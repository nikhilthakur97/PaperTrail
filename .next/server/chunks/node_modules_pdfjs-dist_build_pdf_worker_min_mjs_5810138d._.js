module.exports = [
"[project]/node_modules/pdfjs-dist/build/pdf.worker.min.mjs?url [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */ /**
 * pdfjsVersion = 5.4.149
 * pdfjsBuild = 9e2e9e209
 */ __turbopack_context__.s([
    "WorkerMessageHandler",
    ()=>WorkerMessageHandler
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/pdfjs-dist/build/pdf.worker.min.mjs")}`;
    }
};
const e1 = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type), t = [
    .001,
    0,
    0,
    .001,
    0,
    0
], a = 1.35, r = .35, i = .25925925925925924, n = 1, s = 2, o = 4, c = 8, l = 16, h = 64, u = 128, d = 256, f = "pdfjs_internal_editor_", g = 3, p = 9, m = 13, b = 15, y = 101, w = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
}, x = 0, S = 4, k = 1, C = 2, v = 3, F = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
}, T = "Group", O = "R", M = 1, D = 2, R = 4, N = 16, E = 32, L = 128, j = 512, _ = 1, U = 2, X = 4096, q = 8192, H = 32768, W = 65536, z = 131072, $ = 1048576, G = 2097152, V = 8388608, K = 16777216, J = 1, Y = 2, Z = 3, Q = 4, ee = 5, te = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
}, ae = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
}, re = {
    O: "PageOpen",
    C: "PageClose"
}, ie = 1, ne = 5, se = 1, oe = 2, ce = 3, le = 4, he = 5, ue = 6, de = 7, fe = 8, ge = 9, pe = 10, me = 11, be = 12, ye = 13, we = 14, xe = 15, Se = 16, Ae = 17, ke = 18, Ce = 19, ve = 20, Fe = 21, Ie = 22, Te = 23, Oe = 24, Me = 25, De = 26, Be = 27, Re = 28, Ne = 29, Ee = 30, Pe = 31, Le = 32, je = 33, _e = 34, Ue = 35, Xe = 36, qe = 37, He = 38, We = 39, ze = 40, $e = 41, Ge = 42, Ve = 43, Ke = 44, Je = 45, Ye = 46, Ze = 47, Qe = 48, et = 49, tt = 50, at = 51, rt = 52, it = 53, nt = 54, st = 55, ot = 56, ct = 57, lt = 58, ht = 59, ut = 60, dt = 61, ft = 62, gt = 63, pt = 64, mt = 65, bt = 66, yt = 67, wt = 68, xt = 69, St = 70, At = 71, kt = 72, Ct = 73, vt = 74, Ft = 75, It = 76, Tt = 77, Ot = 80, Mt = 81, Dt = 83, Bt = 84, Rt = 85, Nt = 86, Et = 87, Pt = 88, Lt = 89, jt = 90, _t = 91, Ut = 92, Xt = 93, qt = 94, Ht = 0, Wt = 1, zt = 2, $t = 3, Gt = 1, Vt = 2;
let Kt = ie;
function getVerbosityLevel() {
    return Kt;
}
function info(e1) {
    Kt >= ne && console.log(`Info: ${e1}`);
}
function warn(e1) {
    Kt >= ie && console.log(`Warning: ${e1}`);
}
function unreachable(e1) {
    throw new Error(e1);
}
function assert(e1, t) {
    e1 || unreachable(t);
}
function createValidAbsoluteUrl(e1, t = null, a = null) {
    if (!e1) return null;
    if (a && "string" == typeof e1) {
        if (a.addDefaultProtocol && e1.startsWith("www.")) {
            const t = e1.match(/\./g);
            t?.length >= 2 && (e1 = `http://${e1}`);
        }
        if (a.tryConvertEncoding) try {
            e1 = stringToUTF8String(e1);
        } catch  {}
    }
    const r = t ? URL.parse(e1, t) : URL.parse(e1);
    return function _isValidProtocol(e1) {
        switch(e1?.protocol){
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
                return !0;
            default:
                return !1;
        }
    }(r) ? r : null;
}
function shadow(e1, t, a, r = !1) {
    Object.defineProperty(e1, t, {
        value: a,
        enumerable: !r,
        configurable: !0,
        writable: !1
    });
    return a;
}
const Jt = function BaseExceptionClosure() {
    function BaseException(e1, t) {
        this.message = e1;
        this.name = t;
    }
    BaseException.prototype = new Error;
    BaseException.constructor = BaseException;
    return BaseException;
}();
class PasswordException extends Jt {
    constructor(e1, t){
        super(e1, "PasswordException");
        this.code = t;
    }
}
class UnknownErrorException extends Jt {
    constructor(e1, t){
        super(e1, "UnknownErrorException");
        this.details = t;
    }
}
class InvalidPDFException extends Jt {
    constructor(e1){
        super(e1, "InvalidPDFException");
    }
}
class ResponseException extends Jt {
    constructor(e1, t, a){
        super(e1, "ResponseException");
        this.status = t;
        this.missing = a;
    }
}
class FormatError extends Jt {
    constructor(e1){
        super(e1, "FormatError");
    }
}
class AbortException extends Jt {
    constructor(e1){
        super(e1, "AbortException");
    }
}
function bytesToString(e1) {
    "object" == typeof e1 && void 0 !== e1?.length || unreachable("Invalid argument for bytesToString");
    const t = e1.length, a = 8192;
    if (t < a) return String.fromCharCode.apply(null, e1);
    const r = [];
    for(let i = 0; i < t; i += a){
        const n = Math.min(i + a, t), s = e1.subarray(i, n);
        r.push(String.fromCharCode.apply(null, s));
    }
    return r.join("");
}
function stringToBytes(e1) {
    "string" != typeof e1 && unreachable("Invalid argument for stringToBytes");
    const t = e1.length, a = new Uint8Array(t);
    for(let r = 0; r < t; ++r)a[r] = 255 & e1.charCodeAt(r);
    return a;
}
function string32(e1) {
    return String.fromCharCode(e1 >> 24 & 255, e1 >> 16 & 255, e1 >> 8 & 255, 255 & e1);
}
function objectSize(e1) {
    return Object.keys(e1).length;
}
class FeatureTest {
    static get isLittleEndian() {
        return shadow(this, "isLittleEndian", function isLittleEndian() {
            const e1 = new Uint8Array(4);
            e1[0] = 1;
            return 1 === new Uint32Array(e1.buffer, 0, 1)[0];
        }());
    }
    static get isEvalSupported() {
        return shadow(this, "isEvalSupported", function isEvalSupported() {
            try {
                new Function("");
                return !0;
            } catch  {
                return !1;
            }
        }());
    }
    static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
    }
    static get platform() {
        const { platform: e1, userAgent: t } = navigator;
        return shadow(this, "platform", {
            isAndroid: t.includes("Android"),
            isLinux: e1.includes("Linux"),
            isMac: e1.includes("Mac"),
            isWindows: e1.includes("Win"),
            isFirefox: t.includes("Firefox")
        });
    }
    static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
}
const Yt = Array.from(Array(256).keys(), (e1)=>e1.toString(16).padStart(2, "0"));
class Util {
    static makeHexColor(e1, t, a) {
        return `#${Yt[e1]}${Yt[t]}${Yt[a]}`;
    }
    static domMatrixToTransform(e1) {
        return [
            e1.a,
            e1.b,
            e1.c,
            e1.d,
            e1.e,
            e1.f
        ];
    }
    static scaleMinMax(e1, t) {
        let a;
        if (e1[0]) {
            if (e1[0] < 0) {
                a = t[0];
                t[0] = t[2];
                t[2] = a;
            }
            t[0] *= e1[0];
            t[2] *= e1[0];
            if (e1[3] < 0) {
                a = t[1];
                t[1] = t[3];
                t[3] = a;
            }
            t[1] *= e1[3];
            t[3] *= e1[3];
        } else {
            a = t[0];
            t[0] = t[1];
            t[1] = a;
            a = t[2];
            t[2] = t[3];
            t[3] = a;
            if (e1[1] < 0) {
                a = t[1];
                t[1] = t[3];
                t[3] = a;
            }
            t[1] *= e1[1];
            t[3] *= e1[1];
            if (e1[2] < 0) {
                a = t[0];
                t[0] = t[2];
                t[2] = a;
            }
            t[0] *= e1[2];
            t[2] *= e1[2];
        }
        t[0] += e1[4];
        t[1] += e1[5];
        t[2] += e1[4];
        t[3] += e1[5];
    }
    static transform(e1, t) {
        return [
            e1[0] * t[0] + e1[2] * t[1],
            e1[1] * t[0] + e1[3] * t[1],
            e1[0] * t[2] + e1[2] * t[3],
            e1[1] * t[2] + e1[3] * t[3],
            e1[0] * t[4] + e1[2] * t[5] + e1[4],
            e1[1] * t[4] + e1[3] * t[5] + e1[5]
        ];
    }
    static multiplyByDOMMatrix(e1, t) {
        return [
            e1[0] * t.a + e1[2] * t.b,
            e1[1] * t.a + e1[3] * t.b,
            e1[0] * t.c + e1[2] * t.d,
            e1[1] * t.c + e1[3] * t.d,
            e1[0] * t.e + e1[2] * t.f + e1[4],
            e1[1] * t.e + e1[3] * t.f + e1[5]
        ];
    }
    static applyTransform(e1, t, a = 0) {
        const r = e1[a], i = e1[a + 1];
        e1[a] = r * t[0] + i * t[2] + t[4];
        e1[a + 1] = r * t[1] + i * t[3] + t[5];
    }
    static applyTransformToBezier(e1, t, a = 0) {
        const r = t[0], i = t[1], n = t[2], s = t[3], o = t[4], c = t[5];
        for(let t = 0; t < 6; t += 2){
            const l = e1[a + t], h = e1[a + t + 1];
            e1[a + t] = l * r + h * n + o;
            e1[a + t + 1] = l * i + h * s + c;
        }
    }
    static applyInverseTransform(e1, t) {
        const a = e1[0], r = e1[1], i = t[0] * t[3] - t[1] * t[2];
        e1[0] = (a * t[3] - r * t[2] + t[2] * t[5] - t[4] * t[3]) / i;
        e1[1] = (-a * t[1] + r * t[0] + t[4] * t[1] - t[5] * t[0]) / i;
    }
    static axialAlignedBoundingBox(e1, t, a) {
        const r = t[0], i = t[1], n = t[2], s = t[3], o = t[4], c = t[5], l = e1[0], h = e1[1], u = e1[2], d = e1[3];
        let f = r * l + o, g = f, p = r * u + o, m = p, b = s * h + c, y = b, w = s * d + c, x = w;
        if (0 !== i || 0 !== n) {
            const e1 = i * l, t = i * u, a = n * h, r = n * d;
            f += a;
            m += a;
            p += r;
            g += r;
            b += e1;
            x += e1;
            w += t;
            y += t;
        }
        a[0] = Math.min(a[0], f, p, g, m);
        a[1] = Math.min(a[1], b, w, y, x);
        a[2] = Math.max(a[2], f, p, g, m);
        a[3] = Math.max(a[3], b, w, y, x);
    }
    static inverseTransform(e1) {
        const t = e1[0] * e1[3] - e1[1] * e1[2];
        return [
            e1[3] / t,
            -e1[1] / t,
            -e1[2] / t,
            e1[0] / t,
            (e1[2] * e1[5] - e1[4] * e1[3]) / t,
            (e1[4] * e1[1] - e1[5] * e1[0]) / t
        ];
    }
    static singularValueDecompose2dScale(e1, t) {
        const a = e1[0], r = e1[1], i = e1[2], n = e1[3], s = a ** 2 + r ** 2, o = a * i + r * n, c = i ** 2 + n ** 2, l = (s + c) / 2, h = Math.sqrt(l ** 2 - (s * c - o ** 2));
        t[0] = Math.sqrt(l + h || 1);
        t[1] = Math.sqrt(l - h || 1);
    }
    static normalizeRect(e1) {
        const t = e1.slice(0);
        if (e1[0] > e1[2]) {
            t[0] = e1[2];
            t[2] = e1[0];
        }
        if (e1[1] > e1[3]) {
            t[1] = e1[3];
            t[3] = e1[1];
        }
        return t;
    }
    static intersect(e1, t) {
        const a = Math.max(Math.min(e1[0], e1[2]), Math.min(t[0], t[2])), r = Math.min(Math.max(e1[0], e1[2]), Math.max(t[0], t[2]));
        if (a > r) return null;
        const i = Math.max(Math.min(e1[1], e1[3]), Math.min(t[1], t[3])), n = Math.min(Math.max(e1[1], e1[3]), Math.max(t[1], t[3]));
        return i > n ? null : [
            a,
            i,
            r,
            n
        ];
    }
    static pointBoundingBox(e1, t, a) {
        a[0] = Math.min(a[0], e1);
        a[1] = Math.min(a[1], t);
        a[2] = Math.max(a[2], e1);
        a[3] = Math.max(a[3], t);
    }
    static rectBoundingBox(e1, t, a, r, i) {
        i[0] = Math.min(i[0], e1, a);
        i[1] = Math.min(i[1], t, r);
        i[2] = Math.max(i[2], e1, a);
        i[3] = Math.max(i[3], t, r);
    }
    static #e(e1, t, a, r, i, n, s, o, c, l) {
        if (c <= 0 || c >= 1) return;
        const h = 1 - c, u = c * c, d = u * c, f = h * (h * (h * e1 + 3 * c * t) + 3 * u * a) + d * r, g = h * (h * (h * i + 3 * c * n) + 3 * u * s) + d * o;
        l[0] = Math.min(l[0], f);
        l[1] = Math.min(l[1], g);
        l[2] = Math.max(l[2], f);
        l[3] = Math.max(l[3], g);
    }
    static #t(e1, t, a, r, i, n, s, o, c, l, h, u) {
        if (Math.abs(c) < 1e-12) {
            Math.abs(l) >= 1e-12 && this.#e(e1, t, a, r, i, n, s, o, -h / l, u);
            return;
        }
        const d = l ** 2 - 4 * h * c;
        if (d < 0) return;
        const f = Math.sqrt(d), g = 2 * c;
        this.#e(e1, t, a, r, i, n, s, o, (-l + f) / g, u);
        this.#e(e1, t, a, r, i, n, s, o, (-l - f) / g, u);
    }
    static bezierBoundingBox(e1, t, a, r, i, n, s, o, c) {
        c[0] = Math.min(c[0], e1, s);
        c[1] = Math.min(c[1], t, o);
        c[2] = Math.max(c[2], e1, s);
        c[3] = Math.max(c[3], t, o);
        this.#t(e1, a, i, s, t, r, n, o, 3 * (3 * (a - i) - e1 + s), 6 * (e1 - 2 * a + i), 3 * (a - e1), c);
        this.#t(e1, a, i, s, t, r, n, o, 3 * (3 * (r - n) - t + o), 6 * (t - 2 * r + n), 3 * (r - t), c);
    }
}
const Zt = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    728,
    711,
    710,
    729,
    733,
    731,
    730,
    732,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8226,
    8224,
    8225,
    8230,
    8212,
    8211,
    402,
    8260,
    8249,
    8250,
    8722,
    8240,
    8222,
    8220,
    8221,
    8216,
    8217,
    8218,
    8482,
    64257,
    64258,
    321,
    338,
    352,
    376,
    381,
    305,
    322,
    339,
    353,
    382,
    0,
    8364
];
function stringToPDFString(e1, t = !1) {
    if (e1[0] >= "ï") {
        let a;
        if ("þ" === e1[0] && "ÿ" === e1[1]) {
            a = "utf-16be";
            e1.length % 2 == 1 && (e1 = e1.slice(0, -1));
        } else if ("ÿ" === e1[0] && "þ" === e1[1]) {
            a = "utf-16le";
            e1.length % 2 == 1 && (e1 = e1.slice(0, -1));
        } else "ï" === e1[0] && "»" === e1[1] && "¿" === e1[2] && (a = "utf-8");
        if (a) try {
            const r = new TextDecoder(a, {
                fatal: !0
            }), i = stringToBytes(e1), n = r.decode(i);
            return t || !n.includes("") ? n : n.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
        } catch (e1) {
            warn(`stringToPDFString: "${e1}".`);
        }
    }
    const a = [];
    for(let r = 0, i = e1.length; r < i; r++){
        const n = e1.charCodeAt(r);
        if (!t && 27 === n) {
            for(; ++r < i && 27 !== e1.charCodeAt(r););
            continue;
        }
        const s = Zt[n];
        a.push(s ? String.fromCharCode(s) : e1.charAt(r));
    }
    return a.join("");
}
function stringToUTF8String(e1) {
    return decodeURIComponent(escape(e1));
}
function utf8StringToString(e1) {
    return unescape(encodeURIComponent(e1));
}
function isArrayEqual(e1, t) {
    if (e1.length !== t.length) return !1;
    for(let a = 0, r = e1.length; a < r; a++)if (e1[a] !== t[a]) return !1;
    return !0;
}
function getModificationDate(e1 = new Date) {
    e1 instanceof Date || (e1 = new Date(e1));
    return [
        e1.getUTCFullYear().toString(),
        (e1.getUTCMonth() + 1).toString().padStart(2, "0"),
        e1.getUTCDate().toString().padStart(2, "0"),
        e1.getUTCHours().toString().padStart(2, "0"),
        e1.getUTCMinutes().toString().padStart(2, "0"),
        e1.getUTCSeconds().toString().padStart(2, "0")
    ].join("");
}
let Qt = null, ea = null;
function MathClamp(e1, t, a) {
    return Math.min(Math.max(e1, t), a);
}
function toHexUtil(e1) {
    return Uint8Array.prototype.toHex ? e1.toHex() : Array.from(e1, (e1)=>Yt[e1]).join("");
}
"function" != typeof Promise.try && (Promise.try = function(e1, ...t) {
    return new Promise((a)=>{
        a(e1(...t));
    });
});
"function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e1) {
    return e1.reduce((e1, t)=>e1 + t, 0);
});
const ta = Symbol("CIRCULAR_REF"), aa = Symbol("EOF");
let ra = Object.create(null), ia = Object.create(null), na = Object.create(null);
class Name {
    constructor(e1){
        this.name = e1;
    }
    static get(e1) {
        return ia[e1] ||= new Name(e1);
    }
}
class Cmd {
    constructor(e1){
        this.cmd = e1;
    }
    static get(e1) {
        return ra[e1] ||= new Cmd(e1);
    }
}
const sa = function nonSerializableClosure() {
    return sa;
};
class Dict {
    constructor(e1 = null){
        this._map = new Map;
        this.xref = e1;
        this.objId = null;
        this.suppressEncryption = !1;
        this.__nonSerializable__ = sa;
    }
    assignXref(e1) {
        this.xref = e1;
    }
    get size() {
        return this._map.size;
    }
    get(e1, t, a) {
        let r = this._map.get(e1);
        if (void 0 === r && void 0 !== t) {
            r = this._map.get(t);
            void 0 === r && void 0 !== a && (r = this._map.get(a));
        }
        return r instanceof Ref && this.xref ? this.xref.fetch(r, this.suppressEncryption) : r;
    }
    async getAsync(e1, t, a) {
        let r = this._map.get(e1);
        if (void 0 === r && void 0 !== t) {
            r = this._map.get(t);
            void 0 === r && void 0 !== a && (r = this._map.get(a));
        }
        return r instanceof Ref && this.xref ? this.xref.fetchAsync(r, this.suppressEncryption) : r;
    }
    getArray(e1, t, a) {
        let r = this._map.get(e1);
        if (void 0 === r && void 0 !== t) {
            r = this._map.get(t);
            void 0 === r && void 0 !== a && (r = this._map.get(a));
        }
        r instanceof Ref && this.xref && (r = this.xref.fetch(r, this.suppressEncryption));
        if (Array.isArray(r)) {
            r = r.slice();
            for(let e1 = 0, t = r.length; e1 < t; e1++)r[e1] instanceof Ref && this.xref && (r[e1] = this.xref.fetch(r[e1], this.suppressEncryption));
        }
        return r;
    }
    getRaw(e1) {
        return this._map.get(e1);
    }
    getKeys() {
        return [
            ...this._map.keys()
        ];
    }
    getRawValues() {
        return [
            ...this._map.values()
        ];
    }
    set(e1, t) {
        this._map.set(e1, t);
    }
    setIfNotExists(e1, t) {
        this.has(e1) || this.set(e1, t);
    }
    setIfNumber(e1, t) {
        "number" == typeof t && this.set(e1, t);
    }
    setIfArray(e1, t) {
        (Array.isArray(t) || ArrayBuffer.isView(t)) && this.set(e1, t);
    }
    setIfDefined(e1, t) {
        null != t && this.set(e1, t);
    }
    setIfName(e1, t) {
        "string" == typeof t ? this.set(e1, Name.get(t)) : t instanceof Name && this.set(e1, t);
    }
    has(e1) {
        return this._map.has(e1);
    }
    *[Symbol.iterator]() {
        for (const [e1, t] of this._map)yield [
            e1,
            t instanceof Ref && this.xref ? this.xref.fetch(t, this.suppressEncryption) : t
        ];
    }
    static get empty() {
        const e1 = new Dict(null);
        e1.set = (e1, t)=>{
            unreachable("Should not call `set` on the empty dictionary.");
        };
        return shadow(this, "empty", e1);
    }
    static merge({ xref: e1, dictArray: t, mergeSubDicts: a = !1 }) {
        const r = new Dict(e1), i = new Map;
        for (const e1 of t)if (e1 instanceof Dict) for (const [t, r] of e1._map){
            let e1 = i.get(t);
            if (void 0 === e1) {
                e1 = [];
                i.set(t, e1);
            } else if (!(a && r instanceof Dict)) continue;
            e1.push(r);
        }
        for (const [t, a] of i){
            if (1 === a.length || !(a[0] instanceof Dict)) {
                r._map.set(t, a[0]);
                continue;
            }
            const i = new Dict(e1);
            for (const e1 of a)for (const [t, a] of e1._map)i._map.has(t) || i._map.set(t, a);
            i.size > 0 && r._map.set(t, i);
        }
        i.clear();
        return r.size > 0 ? r : Dict.empty;
    }
    clone() {
        const e1 = new Dict(this.xref);
        for (const t of this.getKeys())e1.set(t, this.getRaw(t));
        return e1;
    }
    delete(e1) {
        delete this._map[e1];
    }
}
class Ref {
    constructor(e1, t){
        this.num = e1;
        this.gen = t;
    }
    toString() {
        return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
    }
    static fromString(e1) {
        const t = na[e1];
        if (t) return t;
        const a = /^(\d+)R(\d*)$/.exec(e1);
        return a && "0" !== a[1] ? na[e1] = new Ref(parseInt(a[1]), a[2] ? parseInt(a[2]) : 0) : null;
    }
    static get(e1, t) {
        const a = 0 === t ? `${e1}R` : `${e1}R${t}`;
        return na[a] ||= new Ref(e1, t);
    }
}
class RefSet {
    constructor(e1 = null){
        this._set = new Set(e1?._set);
    }
    has(e1) {
        return this._set.has(e1.toString());
    }
    put(e1) {
        this._set.add(e1.toString());
    }
    remove(e1) {
        this._set.delete(e1.toString());
    }
    [Symbol.iterator]() {
        return this._set.values();
    }
    clear() {
        this._set.clear();
    }
}
class RefSetCache {
    constructor(){
        this._map = new Map;
    }
    get size() {
        return this._map.size;
    }
    get(e1) {
        return this._map.get(e1.toString());
    }
    has(e1) {
        return this._map.has(e1.toString());
    }
    put(e1, t) {
        this._map.set(e1.toString(), t);
    }
    putAlias(e1, t) {
        this._map.set(e1.toString(), this.get(t));
    }
    [Symbol.iterator]() {
        return this._map.values();
    }
    clear() {
        this._map.clear();
    }
    *values() {
        yield* this._map.values();
    }
    *items() {
        for (const [e1, t] of this._map)yield [
            Ref.fromString(e1),
            t
        ];
    }
}
function isName(e1, t) {
    return e1 instanceof Name && (void 0 === t || e1.name === t);
}
function isCmd(e1, t) {
    return e1 instanceof Cmd && (void 0 === t || e1.cmd === t);
}
function isDict(e1, t) {
    return e1 instanceof Dict && (void 0 === t || isName(e1.get("Type"), t));
}
function isRefsEqual(e1, t) {
    return e1.num === t.num && e1.gen === t.gen;
}
class BaseStream {
    get length() {
        unreachable("Abstract getter `length` accessed");
    }
    get isEmpty() {
        unreachable("Abstract getter `isEmpty` accessed");
    }
    get isDataLoaded() {
        return shadow(this, "isDataLoaded", !0);
    }
    getByte() {
        unreachable("Abstract method `getByte` called");
    }
    getBytes(e1) {
        unreachable("Abstract method `getBytes` called");
    }
    async getImageData(e1, t) {
        return this.getBytes(e1, t);
    }
    async asyncGetBytes() {
        unreachable("Abstract method `asyncGetBytes` called");
    }
    get isAsync() {
        return !1;
    }
    get isAsyncDecoder() {
        return !1;
    }
    get canAsyncDecodeImageFromBuffer() {
        return !1;
    }
    async getTransferableImage() {
        return null;
    }
    peekByte() {
        const e1 = this.getByte();
        -1 !== e1 && this.pos--;
        return e1;
    }
    peekBytes(e1) {
        const t = this.getBytes(e1);
        this.pos -= t.length;
        return t;
    }
    getUint16() {
        const e1 = this.getByte(), t = this.getByte();
        return -1 === e1 || -1 === t ? -1 : (e1 << 8) + t;
    }
    getInt32() {
        return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
    }
    getByteRange(e1, t) {
        unreachable("Abstract method `getByteRange` called");
    }
    getString(e1) {
        return bytesToString(this.getBytes(e1));
    }
    skip(e1) {
        this.pos += e1 || 1;
    }
    reset() {
        unreachable("Abstract method `reset` called");
    }
    moveStart() {
        unreachable("Abstract method `moveStart` called");
    }
    makeSubStream(e1, t, a = null) {
        unreachable("Abstract method `makeSubStream` called");
    }
    getBaseStreams() {
        return null;
    }
}
const oa = /^[1-9]\.\d$/, ca = 2 ** 31 - 1, la = [
    1,
    0,
    0,
    1,
    0,
    0
], ha = [
    "ColorSpace",
    "ExtGState",
    "Font",
    "Pattern",
    "Properties",
    "Shading",
    "XObject"
], ua = [
    "ExtGState",
    "Font",
    "Properties",
    "XObject"
];
function getLookupTableFactory(e1) {
    let t;
    return function() {
        if (e1) {
            t = Object.create(null);
            e1(t);
            e1 = null;
        }
        return t;
    };
}
class MissingDataException extends Jt {
    constructor(e1, t){
        super(`Missing data [${e1}, ${t})`, "MissingDataException");
        this.begin = e1;
        this.end = t;
    }
}
class ParserEOFException extends Jt {
    constructor(e1){
        super(e1, "ParserEOFException");
    }
}
class XRefEntryException extends Jt {
    constructor(e1){
        super(e1, "XRefEntryException");
    }
}
class XRefParseException extends Jt {
    constructor(e1){
        super(e1, "XRefParseException");
    }
}
function arrayBuffersToBytes(e1) {
    const t = e1.length;
    if (0 === t) return new Uint8Array(0);
    if (1 === t) return new Uint8Array(e1[0]);
    let a = 0;
    for(let r = 0; r < t; r++)a += e1[r].byteLength;
    const r = new Uint8Array(a);
    let i = 0;
    for(let a = 0; a < t; a++){
        const t = new Uint8Array(e1[a]);
        r.set(t, i);
        i += t.byteLength;
    }
    return r;
}
async function fetchBinaryData(e1) {
    const t = await fetch(e1);
    if (!t.ok) throw new Error(`Failed to fetch file "${e1}" with "${t.statusText}".`);
    return new Uint8Array(await t.arrayBuffer());
}
function getInheritableProperty({ dict: e1, key: t, getArray: a = !1, stopWhenFound: r = !0 }) {
    let i;
    const n = new RefSet;
    for(; e1 instanceof Dict && (!e1.objId || !n.has(e1.objId));){
        e1.objId && n.put(e1.objId);
        const s = a ? e1.getArray(t) : e1.get(t);
        if (void 0 !== s) {
            if (r) return s;
            (i ||= []).push(s);
        }
        e1 = e1.get("Parent");
    }
    return i;
}
const da = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
];
function toRomanNumerals(e1, t = !1) {
    assert(Number.isInteger(e1) && e1 > 0, "The number should be a positive integer.");
    const a = "M".repeat(e1 / 1e3 | 0) + da[e1 % 1e3 / 100 | 0] + da[10 + (e1 % 100 / 10 | 0)] + da[20 + e1 % 10];
    return t ? a.toLowerCase() : a;
}
function log2(e1) {
    return e1 > 0 ? Math.ceil(Math.log2(e1)) : 0;
}
function readInt8(e1, t) {
    return e1[t] << 24 >> 24;
}
function readInt16(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16) >> 16;
}
function readUint16(e1, t) {
    return e1[t] << 8 | e1[t + 1];
}
function readUint32(e1, t) {
    return (e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3]) >>> 0;
}
function isWhiteSpace(e1) {
    return 32 === e1 || 9 === e1 || 13 === e1 || 10 === e1;
}
function isNumberArray(e1, t) {
    return Array.isArray(e1) ? (null === t || e1.length === t) && e1.every((e1)=>"number" == typeof e1) : ArrayBuffer.isView(e1) && !(e1 instanceof BigInt64Array || e1 instanceof BigUint64Array) && (null === t || e1.length === t);
}
function lookupMatrix(e1, t) {
    return isNumberArray(e1, 6) ? e1 : t;
}
function lookupRect(e1, t) {
    return isNumberArray(e1, 4) ? e1 : t;
}
function lookupNormalRect(e1, t) {
    return isNumberArray(e1, 4) ? Util.normalizeRect(e1) : t;
}
function parseXFAPath(e1) {
    const t = /(.+)\[(\d+)\]$/;
    return e1.split(".").map((e1)=>{
        const a = e1.match(t);
        return a ? {
            name: a[1],
            pos: parseInt(a[2], 10)
        } : {
            name: e1,
            pos: 0
        };
    });
}
function escapePDFName(e1) {
    const t = [];
    let a = 0;
    for(let r = 0, i = e1.length; r < i; r++){
        const i = e1.charCodeAt(r);
        if (i < 33 || i > 126 || 35 === i || 40 === i || 41 === i || 60 === i || 62 === i || 91 === i || 93 === i || 123 === i || 125 === i || 47 === i || 37 === i) {
            a < r && t.push(e1.substring(a, r));
            t.push(`#${i.toString(16)}`);
            a = r + 1;
        }
    }
    if (0 === t.length) return e1;
    a < e1.length && t.push(e1.substring(a, e1.length));
    return t.join("");
}
function escapeString(e1) {
    return e1.replaceAll(/([()\\\n\r])/g, (e1)=>"\n" === e1 ? "\\n" : "\r" === e1 ? "\\r" : `\\${e1}`);
}
function _collectJS(e1, t, a, r) {
    if (!e1) return;
    let i = null;
    if (e1 instanceof Ref) {
        if (r.has(e1)) return;
        i = e1;
        r.put(i);
        e1 = t.fetch(e1);
    }
    if (Array.isArray(e1)) for (const i of e1)_collectJS(i, t, a, r);
    else if (e1 instanceof Dict) {
        if (isName(e1.get("S"), "JavaScript")) {
            const t = e1.get("JS");
            let r;
            t instanceof BaseStream ? r = t.getString() : "string" == typeof t && (r = t);
            r &&= stringToPDFString(r, !0).replaceAll("\0", "");
            r && a.push(r.trim());
        }
        _collectJS(e1.getRaw("Next"), t, a, r);
    }
    i && r.remove(i);
}
function collectActions(e1, t, a) {
    const r = Object.create(null), i = getInheritableProperty({
        dict: t,
        key: "AA",
        stopWhenFound: !1
    });
    if (i) for(let t = i.length - 1; t >= 0; t--){
        const n = i[t];
        if (n instanceof Dict) for (const t of n.getKeys()){
            const i = a[t];
            if (!i) continue;
            const s = [];
            _collectJS(n.getRaw(t), e1, s, new RefSet);
            s.length > 0 && (r[i] = s);
        }
    }
    if (t.has("A")) {
        const a = [];
        _collectJS(t.get("A"), e1, a, new RefSet);
        a.length > 0 && (r.Action = a);
    }
    return objectSize(r) > 0 ? r : null;
}
const fa = {
    60: "&lt;",
    62: "&gt;",
    38: "&amp;",
    34: "&quot;",
    39: "&apos;"
};
function* codePointIter(e1) {
    for(let t = 0, a = e1.length; t < a; t++){
        const a = e1.codePointAt(t);
        a > 55295 && (a < 57344 || a > 65533) && t++;
        yield a;
    }
}
function encodeToXmlString(e1) {
    const t = [];
    let a = 0;
    for(let r = 0, i = e1.length; r < i; r++){
        const i = e1.codePointAt(r);
        if (32 <= i && i <= 126) {
            const n = fa[i];
            if (n) {
                a < r && t.push(e1.substring(a, r));
                t.push(n);
                a = r + 1;
            }
        } else {
            a < r && t.push(e1.substring(a, r));
            t.push(`&#x${i.toString(16).toUpperCase()};`);
            i > 55295 && (i < 57344 || i > 65533) && r++;
            a = r + 1;
        }
    }
    if (0 === t.length) return e1;
    a < e1.length && t.push(e1.substring(a, e1.length));
    return t.join("");
}
function validateFontName(e1, t = !1) {
    const a = /^("|').*("|')$/.exec(e1);
    if (a && a[1] === a[2]) {
        if (new RegExp(`[^\\\\]${a[1]}`).test(e1.slice(1, -1))) {
            t && warn(`FontFamily contains unescaped ${a[1]}: ${e1}.`);
            return !1;
        }
    } else for (const a of e1.split(/[ \t]+/))if (/^(\d|(-(\d|-)))/.test(a) || !/^[\w-\\]+$/.test(a)) {
        t && warn(`FontFamily contains invalid <custom-ident>: ${e1}.`);
        return !1;
    }
    return !0;
}
function validateCSSFont(e1) {
    const t = new Set([
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
        "1000",
        "normal",
        "bold",
        "bolder",
        "lighter"
    ]), { fontFamily: a, fontWeight: r, italicAngle: i } = e1;
    if (!validateFontName(a, !0)) return !1;
    const n = r ? r.toString() : "";
    e1.fontWeight = t.has(n) ? n : "400";
    const s = parseFloat(i);
    e1.italicAngle = isNaN(s) || s < -90 || s > 90 ? "14" : i.toString();
    return !0;
}
function recoverJsURL(e1) {
    const t = new RegExp("^\\s*(" + [
        "app.launchURL",
        "window.open",
        "xfa.host.gotoURL"
    ].join("|").replaceAll(".", "\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i").exec(e1);
    return t?.[2] ? {
        url: t[2],
        newWindow: "app.launchURL" === t[1] && "true" === t[3]
    } : null;
}
function numberToString(e1) {
    if (Number.isInteger(e1)) return e1.toString();
    const t = Math.round(100 * e1);
    return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? e1.toFixed(1) : e1.toFixed(2);
}
function getNewAnnotationsMap(e1) {
    if (!e1) return null;
    const t = new Map;
    for (const [a, r] of e1){
        if (!a.startsWith(f)) continue;
        let e1 = t.get(r.pageIndex);
        if (!e1) {
            e1 = [];
            t.set(r.pageIndex, e1);
        }
        e1.push(r);
    }
    return t.size > 0 ? t : null;
}
function stringToAsciiOrUTF16BE(e1) {
    return null == e1 || function isAscii(e1) {
        if ("string" != typeof e1) return !1;
        return !e1 || /^[\x00-\x7F]*$/.test(e1);
    }(e1) ? e1 : stringToUTF16String(e1, !0);
}
function stringToUTF16HexString(e1) {
    const t = [];
    for(let a = 0, r = e1.length; a < r; a++){
        const r = e1.charCodeAt(a);
        t.push(Yt[r >> 8 & 255], Yt[255 & r]);
    }
    return t.join("");
}
function stringToUTF16String(e1, t = !1) {
    const a = [];
    t && a.push("þÿ");
    for(let t = 0, r = e1.length; t < r; t++){
        const r = e1.charCodeAt(t);
        a.push(String.fromCharCode(r >> 8 & 255), String.fromCharCode(255 & r));
    }
    return a.join("");
}
function getRotationMatrix(e1, t, a) {
    switch(e1){
        case 90:
            return [
                0,
                1,
                -1,
                0,
                t,
                0
            ];
        case 180:
            return [
                -1,
                0,
                0,
                -1,
                t,
                a
            ];
        case 270:
            return [
                0,
                -1,
                1,
                0,
                0,
                a
            ];
        default:
            throw new Error("Invalid rotation");
    }
}
function getSizeInBytes(e1) {
    return Math.ceil(Math.ceil(Math.log2(1 + e1)) / 8);
}
class QCMS {
    static #a = null;
    static _memory = null;
    static _mustAddAlpha = !1;
    static _destBuffer = null;
    static _destOffset = 0;
    static _destLength = 0;
    static _cssColor = "";
    static _makeHexColor = null;
    static get _memoryArray() {
        const e1 = this.#a;
        return e1?.byteLength ? e1 : this.#a = new Uint8Array(this._memory.buffer);
    }
}
let ga;
const pa = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", {
    ignoreBOM: !0,
    fatal: !0
}) : {
    decode: ()=>{
        throw Error("TextDecoder not available");
    }
};
"undefined" != typeof TextDecoder && pa.decode();
let ma = null;
function getUint8ArrayMemory0() {
    null !== ma && 0 !== ma.byteLength || (ma = new Uint8Array(ga.memory.buffer));
    return ma;
}
let ba = 0;
function passArray8ToWasm0(e1, t) {
    const a = t(1 * e1.length, 1) >>> 0;
    getUint8ArrayMemory0().set(e1, a / 1);
    ba = e1.length;
    return a;
}
const ya = Object.freeze({
    RGB8: 0,
    0: "RGB8",
    RGBA8: 1,
    1: "RGBA8",
    BGRA8: 2,
    2: "BGRA8",
    Gray8: 3,
    3: "Gray8",
    GrayA8: 4,
    4: "GrayA8",
    CMYK: 5,
    5: "CMYK"
}), wa = Object.freeze({
    Perceptual: 0,
    0: "Perceptual",
    RelativeColorimetric: 1,
    1: "RelativeColorimetric",
    Saturation: 2,
    2: "Saturation",
    AbsoluteColorimetric: 3,
    3: "AbsoluteColorimetric"
});
function __wbg_get_imports() {
    const e1 = {
        wbg: {}
    };
    e1.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e1, t) {
        !function copy_result(e1, t) {
            const { _mustAddAlpha: a, _destBuffer: r, _destOffset: i, _destLength: n, _memoryArray: s } = QCMS;
            if (t !== n) if (a) for(let a = e1, n = e1 + t, o = i; a < n; a += 3, o += 4){
                r[o] = s[a];
                r[o + 1] = s[a + 1];
                r[o + 2] = s[a + 2];
                r[o + 3] = 255;
            }
            else for(let a = e1, n = e1 + t, o = i; a < n; a += 3, o += 4){
                r[o] = s[a];
                r[o + 1] = s[a + 1];
                r[o + 2] = s[a + 2];
            }
            else r.set(s.subarray(e1, e1 + t), i);
        }(e1 >>> 0, t >>> 0);
    };
    e1.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e1) {
        !function copy_rgb(e1) {
            const { _destBuffer: t, _destOffset: a, _memoryArray: r } = QCMS;
            t[a] = r[e1];
            t[a + 1] = r[e1 + 1];
            t[a + 2] = r[e1 + 2];
        }(e1 >>> 0);
    };
    e1.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e1) {
        !function make_cssRGB(e1) {
            const { _memoryArray: t } = QCMS;
            QCMS._cssColor = QCMS._makeHexColor(t[e1], t[e1 + 1], t[e1 + 2]);
        }(e1 >>> 0);
    };
    e1.wbg.__wbindgen_init_externref_table = function() {
        const e1 = ga.__wbindgen_export_0, t = e1.grow(4);
        e1.set(0, void 0);
        e1.set(t + 0, void 0);
        e1.set(t + 1, null);
        e1.set(t + 2, !0);
        e1.set(t + 3, !1);
    };
    e1.wbg.__wbindgen_throw = function(e1, t) {
        throw new Error(function getStringFromWasm0(e1, t) {
            e1 >>>= 0;
            return pa.decode(getUint8ArrayMemory0().subarray(e1, e1 + t));
        }(e1, t));
    };
    return e1;
}
function __wbg_finalize_init(e1, t) {
    ga = e1.exports;
    __wbg_init.__wbindgen_wasm_module = t;
    ma = null;
    ga.__wbindgen_start();
    return ga;
}
async function __wbg_init(e1) {
    if (void 0 !== ga) return ga;
    void 0 !== e1 && (Object.getPrototypeOf(e1) === Object.prototype ? { module_or_path: e1 } = e1 : console.warn("using deprecated parameters for the initialization function; pass a single object instead"));
    const t = __wbg_get_imports();
    ("string" == typeof e1 || "function" == typeof Request && e1 instanceof Request || "function" == typeof URL && e1 instanceof URL) && (e1 = fetch(e1));
    const { instance: a, module: r } = await async function __wbg_load(e1, t) {
        if ("function" == typeof Response && e1 instanceof Response) {
            if ("function" == typeof WebAssembly.instantiateStreaming) try {
                return await WebAssembly.instantiateStreaming(e1, t);
            } catch (t) {
                if ("application/wasm" == e1.headers.get("Content-Type")) throw t;
                console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t);
            }
            const a = await e1.arrayBuffer();
            return await WebAssembly.instantiate(a, t);
        }
        {
            const a = await WebAssembly.instantiate(e1, t);
            return a instanceof WebAssembly.Instance ? {
                instance: a,
                module: e1
            } : a;
        }
    }(await e1, t);
    return __wbg_finalize_init(a, r);
}
class ColorSpace {
    static #r = new Uint8ClampedArray(3);
    constructor(e1, t){
        this.name = e1;
        this.numComps = t;
    }
    getRgb(e1, t, a = new Uint8ClampedArray(3)) {
        this.getRgbItem(e1, t, a, 0);
        return a;
    }
    getRgbHex(e1, t) {
        const a = this.getRgb(e1, t, ColorSpace.#r);
        return Util.makeHexColor(a[0], a[1], a[2]);
    }
    getRgbItem(e1, t, a, r) {
        unreachable("Should not call ColorSpace.getRgbItem");
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        unreachable("Should not call ColorSpace.getRgbBuffer");
    }
    getOutputLength(e1, t) {
        unreachable("Should not call ColorSpace.getOutputLength");
    }
    isPassthrough(e1) {
        return !1;
    }
    isDefaultDecode(e1, t) {
        return ColorSpace.isDefaultDecode(e1, this.numComps);
    }
    fillRgb(e1, t, a, r, i, n, s, o, c) {
        const l = t * a;
        let h = null;
        const u = 1 << s, d = a !== i || t !== r;
        if (this.isPassthrough(s)) h = o;
        else if (1 === this.numComps && l > u && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
            const t = s <= 8 ? new Uint8Array(u) : new Uint16Array(u);
            for(let e1 = 0; e1 < u; e1++)t[e1] = e1;
            const a = new Uint8ClampedArray(3 * u);
            this.getRgbBuffer(t, 0, u, a, 0, s, 0);
            if (d) {
                h = new Uint8Array(3 * l);
                let e1 = 0;
                for(let t = 0; t < l; ++t){
                    const r = 3 * o[t];
                    h[e1++] = a[r];
                    h[e1++] = a[r + 1];
                    h[e1++] = a[r + 2];
                }
            } else {
                let t = 0;
                for(let r = 0; r < l; ++r){
                    const i = 3 * o[r];
                    e1[t++] = a[i];
                    e1[t++] = a[i + 1];
                    e1[t++] = a[i + 2];
                    t += c;
                }
            }
        } else if (d) {
            h = new Uint8ClampedArray(3 * l);
            this.getRgbBuffer(o, 0, l, h, 0, s, 0);
        } else this.getRgbBuffer(o, 0, r * n, e1, 0, s, c);
        if (h) if (d) !function resizeRgbImage(e1, t, a, r, i, n, s) {
            s = 1 !== s ? 0 : s;
            const o = a / i, c = r / n;
            let l, h = 0;
            const u = new Uint16Array(i), d = 3 * a;
            for(let e1 = 0; e1 < i; e1++)u[e1] = 3 * Math.floor(e1 * o);
            for(let a = 0; a < n; a++){
                const r = Math.floor(a * c) * d;
                for(let a = 0; a < i; a++){
                    l = r + u[a];
                    t[h++] = e1[l++];
                    t[h++] = e1[l++];
                    t[h++] = e1[l++];
                    h += s;
                }
            }
        }(h, e1, t, a, r, i, c);
        else {
            let t = 0, a = 0;
            for(let i = 0, s = r * n; i < s; i++){
                e1[t++] = h[a++];
                e1[t++] = h[a++];
                e1[t++] = h[a++];
                t += c;
            }
        }
    }
    get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", !0);
    }
    static isDefaultDecode(e1, t) {
        if (!Array.isArray(e1)) return !0;
        if (2 * t !== e1.length) {
            warn("The decode map is not the correct length");
            return !0;
        }
        for(let t = 0, a = e1.length; t < a; t += 2)if (0 !== e1[t] || 1 !== e1[t + 1]) return !1;
        return !0;
    }
}
class AlternateCS extends ColorSpace {
    constructor(e1, t, a){
        super("Alternate", e1);
        this.base = t;
        this.tintFn = a;
        this.tmpBuf = new Float32Array(t.numComps);
    }
    getRgbItem(e1, t, a, r) {
        const i = this.tmpBuf;
        this.tintFn(e1, t, i, 0);
        this.base.getRgbItem(i, 0, a, r);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = this.tintFn, c = this.base, l = 1 / ((1 << n) - 1), h = c.numComps, u = c.usesZeroToOneRange, d = (c.isPassthrough(8) || !u) && 0 === s;
        let f = d ? i : 0;
        const g = d ? r : new Uint8ClampedArray(h * a), p = this.numComps, m = new Float32Array(p), b = new Float32Array(h);
        let y, w;
        for(y = 0; y < a; y++){
            for(w = 0; w < p; w++)m[w] = e1[t++] * l;
            o(m, 0, b, 0);
            if (u) for(w = 0; w < h; w++)g[f++] = 255 * b[w];
            else {
                c.getRgbItem(b, 0, g, f);
                f += h;
            }
        }
        d || c.getRgbBuffer(g, 0, a, r, i, 8, s);
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps / this.numComps, t);
    }
}
class PatternCS extends ColorSpace {
    constructor(e1){
        super("Pattern", null);
        this.base = e1;
    }
    isDefaultDecode(e1, t) {
        unreachable("Should not call PatternCS.isDefaultDecode");
    }
}
class IndexedCS extends ColorSpace {
    constructor(e1, t, a){
        super("Indexed", 1);
        this.base = e1;
        this.highVal = t;
        const r = e1.numComps * (t + 1);
        this.lookup = new Uint8Array(r);
        if (a instanceof BaseStream) {
            const e1 = a.getBytes(r);
            this.lookup.set(e1);
        } else {
            if ("string" != typeof a) throw new FormatError(`IndexedCS - unrecognized lookup table: ${a}`);
            for(let e1 = 0; e1 < r; ++e1)this.lookup[e1] = 255 & a.charCodeAt(e1);
        }
    }
    getRgbItem(e1, t, a, r) {
        const { base: i, highVal: n, lookup: s } = this, o = MathClamp(Math.round(e1[t]), 0, n) * i.numComps;
        i.getRgbBuffer(s, o, 1, a, r, 8, 0);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const { base: o, highVal: c, lookup: l } = this, { numComps: h } = o, u = o.getOutputLength(h, s);
        for(let n = 0; n < a; ++n){
            const a = MathClamp(Math.round(e1[t++]), 0, c) * h;
            o.getRgbBuffer(l, a, 1, r, i, 8, s);
            i += u;
        }
    }
    getOutputLength(e1, t) {
        return this.base.getOutputLength(e1 * this.base.numComps, t);
    }
    isDefaultDecode(e1, t) {
        if (!Array.isArray(e1)) return !0;
        if (2 !== e1.length) {
            warn("Decode map length is not correct");
            return !0;
        }
        if (!Number.isInteger(t) || t < 1) {
            warn("Bits per component is not correct");
            return !0;
        }
        return 0 === e1[0] && e1[1] === (1 << t) - 1;
    }
}
class DeviceGrayCS extends ColorSpace {
    constructor(){
        super("DeviceGray", 1);
    }
    getRgbItem(e1, t, a, r) {
        const i = 255 * e1[t];
        a[r] = a[r + 1] = a[r + 2] = i;
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = 255 / ((1 << n) - 1);
        let c = t, l = i;
        for(let t = 0; t < a; ++t){
            const t = o * e1[c++];
            r[l++] = t;
            r[l++] = t;
            r[l++] = t;
            l += s;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class DeviceRgbCS extends ColorSpace {
    constructor(){
        super("DeviceRGB", 3);
    }
    getRgbItem(e1, t, a, r) {
        a[r] = 255 * e1[t];
        a[r + 1] = 255 * e1[t + 1];
        a[r + 2] = 255 * e1[t + 2];
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        if (8 === n && 0 === s) {
            r.set(e1.subarray(t, t + 3 * a), i);
            return;
        }
        const o = 255 / ((1 << n) - 1);
        let c = t, l = i;
        for(let t = 0; t < a; ++t){
            r[l++] = o * e1[c++];
            r[l++] = o * e1[c++];
            r[l++] = o * e1[c++];
            l += s;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
}
class DeviceRgbaCS extends ColorSpace {
    constructor(){
        super("DeviceRGBA", 4);
    }
    getOutputLength(e1, t) {
        return 4 * e1;
    }
    isPassthrough(e1) {
        return 8 === e1;
    }
    fillRgb(e1, t, a, r, i, n, s, o, c) {
        a !== i || t !== r ? function resizeRgbaImage(e1, t, a, r, i, n, s) {
            const o = a / i, c = r / n;
            let l = 0;
            const h = new Uint16Array(i);
            if (1 === s) {
                for(let e1 = 0; e1 < i; e1++)h[e1] = Math.floor(e1 * o);
                const r = new Uint32Array(e1.buffer), s = new Uint32Array(t.buffer), u = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0; e1 < n; e1++){
                    const t = r.subarray(Math.floor(e1 * c) * a);
                    for(let e1 = 0; e1 < i; e1++)s[l++] |= t[h[e1]] & u;
                }
            } else {
                const r = 4, s = a * r;
                for(let e1 = 0; e1 < i; e1++)h[e1] = Math.floor(e1 * o) * r;
                for(let a = 0; a < n; a++){
                    const r = e1.subarray(Math.floor(a * c) * s);
                    for(let e1 = 0; e1 < i; e1++){
                        const a = h[e1];
                        t[l++] = r[a];
                        t[l++] = r[a + 1];
                        t[l++] = r[a + 2];
                    }
                }
            }
        }(o, e1, t, a, r, i, c) : function copyRgbaImage(e1, t, a) {
            if (1 === a) {
                const a = new Uint32Array(e1.buffer), r = new Uint32Array(t.buffer), i = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
                for(let e1 = 0, t = a.length; e1 < t; e1++)r[e1] |= a[e1] & i;
            } else {
                let a = 0;
                for(let r = 0, i = e1.length; r < i; r += 4){
                    t[a++] = e1[r];
                    t[a++] = e1[r + 1];
                    t[a++] = e1[r + 2];
                }
            }
        }(o, e1, c);
    }
}
class DeviceCmykCS extends ColorSpace {
    constructor(){
        super("DeviceCMYK", 4);
    }
    #i(e1, t, a, r, i) {
        const n = e1[t] * a, s = e1[t + 1] * a, o = e1[t + 2] * a, c = e1[t + 3] * a;
        r[i] = 255 + n * (-4.387332384609988 * n + 54.48615194189176 * s + 18.82290502165302 * o + 212.25662451639585 * c - 285.2331026137004) + s * (1.7149763477362134 * s - 5.6096736904047315 * o + -17.873870861415444 * c - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * c + 17.5119270841813) + c * (-21.86122147463605 * c - 189.48180835922747);
        r[i + 1] = 255 + n * (8.841041422036149 * n + 60.118027045597366 * s + 6.871425592049007 * o + 31.159100130055922 * c - 79.2970844816548) + s * (-15.310361306967817 * s + 17.575251261109482 * o + 131.35250912493976 * c - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * c - 24.86741582555878) + c * (-20.737325471181034 * c - 187.80453709719578);
        r[i + 2] = 255 + n * (.8842522430003296 * n + 8.078677503112928 * s + 30.89978309703729 * o - .23883238689178934 * c - 14.183576799673286) + s * (10.49593273432072 * s + 63.02378494754052 * o + 50.606957656360734 * c - 112.23884253719248) + o * (.03296041114873217 * o + 115.60384449646641 * c - 193.58209356861505) + c * (-22.33816807309886 * c - 180.12613974708367);
    }
    getRgbItem(e1, t, a, r) {
        this.#i(e1, t, 1, a, r);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = 1 / ((1 << n) - 1);
        for(let n = 0; n < a; n++){
            this.#i(e1, t, o, r, i);
            t += 4;
            i += 3 + s;
        }
    }
    getOutputLength(e1, t) {
        return e1 / 4 * (3 + t) | 0;
    }
}
class CalGrayCS extends ColorSpace {
    constructor(e1, t, a){
        super("CalGray", 1);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space CalGray");
        [this.XW, this.YW, this.ZW] = e1;
        [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ];
        this.G = a || 1;
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
            info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
            this.XB = this.YB = this.ZB = 0;
        }
        0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
        if (this.G < 1) {
            info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
            this.G = 1;
        }
    }
    #i(e1, t, a, r, i) {
        const n = (e1[t] * i) ** this.G, s = this.YW * n, o = Math.max(295.8 * s ** .3333333333333333 - 40.8, 0);
        a[r] = o;
        a[r + 1] = o;
        a[r + 2] = o;
    }
    getRgbItem(e1, t, a, r) {
        this.#i(e1, t, a, r, 1);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = 1 / ((1 << n) - 1);
        for(let n = 0; n < a; ++n){
            this.#i(e1, t, r, i, o);
            t += 1;
            i += 3 + s;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t);
    }
}
class CalRGBCS extends ColorSpace {
    static #n = new Float32Array([
        .8951,
        .2664,
        -.1614,
        -.7502,
        1.7135,
        .0367,
        .0389,
        -.0685,
        1.0296
    ]);
    static #s = new Float32Array([
        .9869929,
        -.1470543,
        .1599627,
        .4323053,
        .5183603,
        .0492912,
        -.0085287,
        .0400428,
        .9684867
    ]);
    static #o = new Float32Array([
        3.2404542,
        -1.5371385,
        -.4985314,
        -.969266,
        1.8760108,
        .041556,
        .0556434,
        -.2040259,
        1.0572252
    ]);
    static #c = new Float32Array([
        1,
        1,
        1
    ]);
    static #l = new Float32Array(3);
    static #h = new Float32Array(3);
    static #u = new Float32Array(3);
    static #d = (24 / 116) ** 3 / 8;
    constructor(e1, t, a, r){
        super("CalRGB", 3);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space CalRGB");
        const [i, n, s] = this.whitePoint = e1, [o, c, l] = this.blackPoint = t || new Float32Array(3);
        [this.GR, this.GG, this.GB] = a || new Float32Array([
            1,
            1,
            1
        ]);
        [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = r || new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]);
        if (i < 0 || s < 0 || 1 !== n) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
        if (o < 0 || c < 0 || l < 0) {
            info(`Invalid BlackPoint for ${this.name} [${o}, ${c}, ${l}], falling back to default.`);
            this.blackPoint = new Float32Array(3);
        }
        if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
            info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
            this.GR = this.GG = this.GB = 1;
        }
    }
    #f(e1, t, a) {
        a[0] = e1[0] * t[0] + e1[1] * t[1] + e1[2] * t[2];
        a[1] = e1[3] * t[0] + e1[4] * t[1] + e1[5] * t[2];
        a[2] = e1[6] * t[0] + e1[7] * t[1] + e1[8] * t[2];
    }
    #g(e1, t, a) {
        a[0] = 1 * t[0] / e1[0];
        a[1] = 1 * t[1] / e1[1];
        a[2] = 1 * t[2] / e1[2];
    }
    #p(e1, t, a) {
        a[0] = .95047 * t[0] / e1[0];
        a[1] = 1 * t[1] / e1[1];
        a[2] = 1.08883 * t[2] / e1[2];
    }
    #m(e1) {
        return e1 <= .0031308 ? MathClamp(12.92 * e1, 0, 1) : e1 >= .99554525 ? 1 : MathClamp(1.055 * e1 ** (1 / 2.4) - .055, 0, 1);
    }
    #b(e1) {
        return e1 < 0 ? -this.#b(-e1) : e1 > 8 ? ((e1 + 16) / 116) ** 3 : e1 * CalRGBCS.#d;
    }
    #y(e1, t, a) {
        if (0 === e1[0] && 0 === e1[1] && 0 === e1[2]) {
            a[0] = t[0];
            a[1] = t[1];
            a[2] = t[2];
            return;
        }
        const r = this.#b(0), i = (1 - r) / (1 - this.#b(e1[0])), n = 1 - i, s = (1 - r) / (1 - this.#b(e1[1])), o = 1 - s, c = (1 - r) / (1 - this.#b(e1[2])), l = 1 - c;
        a[0] = t[0] * i + n;
        a[1] = t[1] * s + o;
        a[2] = t[2] * c + l;
    }
    #w(e1, t, a) {
        if (1 === e1[0] && 1 === e1[2]) {
            a[0] = t[0];
            a[1] = t[1];
            a[2] = t[2];
            return;
        }
        const r = a;
        this.#f(CalRGBCS.#n, t, r);
        const i = CalRGBCS.#l;
        this.#g(e1, r, i);
        this.#f(CalRGBCS.#s, i, a);
    }
    #x(e1, t, a) {
        const r = a;
        this.#f(CalRGBCS.#n, t, r);
        const i = CalRGBCS.#l;
        this.#p(e1, r, i);
        this.#f(CalRGBCS.#s, i, a);
    }
    #i(e1, t, a, r, i) {
        const n = MathClamp(e1[t] * i, 0, 1), s = MathClamp(e1[t + 1] * i, 0, 1), o = MathClamp(e1[t + 2] * i, 0, 1), c = 1 === n ? 1 : n ** this.GR, l = 1 === s ? 1 : s ** this.GG, h = 1 === o ? 1 : o ** this.GB, u = this.MXA * c + this.MXB * l + this.MXC * h, d = this.MYA * c + this.MYB * l + this.MYC * h, f = this.MZA * c + this.MZB * l + this.MZC * h, g = CalRGBCS.#h;
        g[0] = u;
        g[1] = d;
        g[2] = f;
        const p = CalRGBCS.#u;
        this.#w(this.whitePoint, g, p);
        const m = CalRGBCS.#h;
        this.#y(this.blackPoint, p, m);
        const b = CalRGBCS.#u;
        this.#x(CalRGBCS.#c, m, b);
        const y = CalRGBCS.#h;
        this.#f(CalRGBCS.#o, b, y);
        a[r] = 255 * this.#m(y[0]);
        a[r + 1] = 255 * this.#m(y[1]);
        a[r + 2] = 255 * this.#m(y[2]);
    }
    getRgbItem(e1, t, a, r) {
        this.#i(e1, t, a, r, 1);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = 1 / ((1 << n) - 1);
        for(let n = 0; n < a; ++n){
            this.#i(e1, t, r, i, o);
            t += 3;
            i += 3 + s;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
}
class LabCS extends ColorSpace {
    constructor(e1, t, a){
        super("Lab", 3);
        if (!e1) throw new FormatError("WhitePoint missing - required for color space Lab");
        [this.XW, this.YW, this.ZW] = e1;
        [this.amin, this.amax, this.bmin, this.bmax] = a || [
            -100,
            100,
            -100,
            100
        ];
        [this.XB, this.YB, this.ZB] = t || [
            0,
            0,
            0
        ];
        if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError("Invalid WhitePoint components, no fallback available");
        if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
            info("Invalid BlackPoint, falling back to default");
            this.XB = this.YB = this.ZB = 0;
        }
        if (this.amin > this.amax || this.bmin > this.bmax) {
            info("Invalid Range, falling back to defaults");
            this.amin = -100;
            this.amax = 100;
            this.bmin = -100;
            this.bmax = 100;
        }
    }
    #S(e1) {
        return e1 >= 6 / 29 ? e1 ** 3 : 108 / 841 * (e1 - 4 / 29);
    }
    #A(e1, t, a, r) {
        return a + e1 * (r - a) / t;
    }
    #i(e1, t, a, r, i) {
        let n = e1[t], s = e1[t + 1], o = e1[t + 2];
        if (!1 !== a) {
            n = this.#A(n, a, 0, 100);
            s = this.#A(s, a, this.amin, this.amax);
            o = this.#A(o, a, this.bmin, this.bmax);
        }
        s > this.amax ? s = this.amax : s < this.amin && (s = this.amin);
        o > this.bmax ? o = this.bmax : o < this.bmin && (o = this.bmin);
        const c = (n + 16) / 116, l = c + s / 500, h = c - o / 200, u = this.XW * this.#S(l), d = this.YW * this.#S(c), f = this.ZW * this.#S(h);
        let g, p, m;
        if (this.ZW < 1) {
            g = 3.1339 * u + -1.617 * d + -.4906 * f;
            p = -.9785 * u + 1.916 * d + .0333 * f;
            m = .072 * u + -.229 * d + 1.4057 * f;
        } else {
            g = 3.2406 * u + -1.5372 * d + -.4986 * f;
            p = -.9689 * u + 1.8758 * d + .0415 * f;
            m = .0557 * u + -.204 * d + 1.057 * f;
        }
        r[i] = 255 * Math.sqrt(g);
        r[i + 1] = 255 * Math.sqrt(p);
        r[i + 2] = 255 * Math.sqrt(m);
    }
    getRgbItem(e1, t, a, r) {
        this.#i(e1, t, !1, a, r);
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        const o = (1 << n) - 1;
        for(let n = 0; n < a; n++){
            this.#i(e1, t, o, r, i);
            t += 3;
            i += 3 + s;
        }
    }
    getOutputLength(e1, t) {
        return e1 * (3 + t) / 3 | 0;
    }
    isDefaultDecode(e1, t) {
        return !0;
    }
    get usesZeroToOneRange() {
        return shadow(this, "usesZeroToOneRange", !1);
    }
}
function fetchSync(e1) {
    const t = new XMLHttpRequest;
    t.open("GET", e1, !1);
    t.responseType = "arraybuffer";
    t.send(null);
    return t.response;
}
class IccColorSpace extends ColorSpace {
    #k;
    #C;
    static #v = !0;
    static #F = null;
    static #I = null;
    constructor(e1, t, a){
        if (!IccColorSpace.isUsable) throw new Error("No ICC color space support");
        super(t, a);
        let r;
        switch(a){
            case 1:
                r = ya.Gray8;
                this.#C = (e1, t, a)=>(function qcms_convert_one(e1, t, a) {
                        ga.qcms_convert_one(e1, t, a);
                    })(this.#k, 255 * e1[t], a);
                break;
            case 3:
                r = ya.RGB8;
                this.#C = (e1, t, a)=>(function qcms_convert_three(e1, t, a, r, i) {
                        ga.qcms_convert_three(e1, t, a, r, i);
                    })(this.#k, 255 * e1[t], 255 * e1[t + 1], 255 * e1[t + 2], a);
                break;
            case 4:
                r = ya.CMYK;
                this.#C = (e1, t, a)=>(function qcms_convert_four(e1, t, a, r, i, n) {
                        ga.qcms_convert_four(e1, t, a, r, i, n);
                    })(this.#k, 255 * e1[t], 255 * e1[t + 1], 255 * e1[t + 2], 255 * e1[t + 3], a);
                break;
            default:
                throw new Error(`Unsupported number of components: ${a}`);
        }
        this.#k = function qcms_transformer_from_memory(e1, t, a) {
            const r = passArray8ToWasm0(e1, ga.__wbindgen_malloc), i = ba;
            return ga.qcms_transformer_from_memory(r, i, t, a) >>> 0;
        }(e1, r, wa.Perceptual);
        if (!this.#k) throw new Error("Failed to create ICC color space");
        IccColorSpace.#I ||= new FinalizationRegistry((e1)=>{
            !function qcms_drop_transformer(e1) {
                ga.qcms_drop_transformer(e1);
            }(e1);
        });
        IccColorSpace.#I.register(this, this.#k);
    }
    getRgbHex(e1, t) {
        this.#C(e1, t, !0);
        return QCMS._cssColor;
    }
    getRgbItem(e1, t, a, r) {
        QCMS._destBuffer = a;
        QCMS._destOffset = r;
        QCMS._destLength = 3;
        this.#C(e1, t, !1);
        QCMS._destBuffer = null;
    }
    getRgbBuffer(e1, t, a, r, i, n, s) {
        e1 = e1.subarray(t, t + a * this.numComps);
        if (8 !== n) {
            const t = 255 / ((1 << n) - 1);
            for(let a = 0, r = e1.length; a < r; a++)e1[a] *= t;
        }
        QCMS._mustAddAlpha = s && r.buffer === e1.buffer;
        QCMS._destBuffer = r;
        QCMS._destOffset = i;
        QCMS._destLength = a * (3 + s);
        !function qcms_convert_array(e1, t) {
            const a = passArray8ToWasm0(t, ga.__wbindgen_malloc), r = ba;
            ga.qcms_convert_array(e1, a, r);
        }(this.#k, e1);
        QCMS._mustAddAlpha = !1;
        QCMS._destBuffer = null;
    }
    getOutputLength(e1, t) {
        return e1 / this.numComps * (3 + t) | 0;
    }
    static setOptions({ useWasm: e1, useWorkerFetch: t, wasmUrl: a }) {
        if (t) {
            this.#v = e1;
            this.#F = a;
        } else this.#v = !1;
    }
    static get isUsable() {
        let e1 = !1;
        if (this.#v) if (this.#F) try {
            this._module = function initSync(e1) {
                if (void 0 !== ga) return ga;
                void 0 !== e1 && (Object.getPrototypeOf(e1) === Object.prototype ? { module: e1 } = e1 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
                const t = __wbg_get_imports();
                e1 instanceof WebAssembly.Module || (e1 = new WebAssembly.Module(e1));
                return __wbg_finalize_init(new WebAssembly.Instance(e1, t), e1);
            }({
                module: fetchSync(`${this.#F}qcms_bg.wasm`)
            });
            e1 = !!this._module;
            QCMS._memory = this._module.memory;
            QCMS._makeHexColor = Util.makeHexColor;
        } catch (e1) {
            warn(`ICCBased color space: "${e1}".`);
        }
        else warn("No ICC color space support due to missing `wasmUrl` API option");
        return shadow(this, "isUsable", e1);
    }
}
class CmykICCBasedCS extends IccColorSpace {
    static #T;
    constructor(){
        super(new Uint8Array(fetchSync(`${CmykICCBasedCS.#T}CGATS001Compat-v2-micro.icc`)), "DeviceCMYK", 4);
    }
    static setOptions({ iccUrl: e1 }) {
        this.#T = e1;
    }
    static get isUsable() {
        let e1 = !1;
        IccColorSpace.isUsable && (this.#T ? e1 = !0 : warn("No CMYK ICC profile support due to missing `iccUrl` API option"));
        return shadow(this, "isUsable", e1);
    }
}
class Stream extends BaseStream {
    constructor(e1, t, a, r){
        super();
        this.bytes = e1 instanceof Uint8Array ? e1 : new Uint8Array(e1);
        this.start = t || 0;
        this.pos = this.start;
        this.end = t + a || this.bytes.length;
        this.dict = r;
    }
    get length() {
        return this.end - this.start;
    }
    get isEmpty() {
        return 0 === this.length;
    }
    getByte() {
        return this.pos >= this.end ? -1 : this.bytes[this.pos++];
    }
    getBytes(e1) {
        const t = this.bytes, a = this.pos, r = this.end;
        if (!e1) return t.subarray(a, r);
        let i = a + e1;
        i > r && (i = r);
        this.pos = i;
        return t.subarray(a, i);
    }
    getByteRange(e1, t) {
        e1 < 0 && (e1 = 0);
        t > this.end && (t = this.end);
        return this.bytes.subarray(e1, t);
    }
    reset() {
        this.pos = this.start;
    }
    moveStart() {
        this.start = this.pos;
    }
    makeSubStream(e1, t, a = null) {
        return new Stream(this.bytes.buffer, e1, t, a);
    }
}
class StringStream extends Stream {
    constructor(e1){
        super(stringToBytes(e1));
    }
}
class NullStream extends Stream {
    constructor(){
        super(new Uint8Array(0));
    }
}
class ChunkedStream extends Stream {
    constructor(e1, t, a){
        super(new Uint8Array(e1), 0, e1, null);
        this.chunkSize = t;
        this._loadedChunks = new Set;
        this.numChunks = Math.ceil(e1 / t);
        this.manager = a;
        this.progressiveDataLength = 0;
        this.lastSuccessfulEnsureByteChunk = -1;
    }
    getMissingChunks() {
        const e1 = [];
        for(let t = 0, a = this.numChunks; t < a; ++t)this._loadedChunks.has(t) || e1.push(t);
        return e1;
    }
    get numChunksLoaded() {
        return this._loadedChunks.size;
    }
    get isDataLoaded() {
        return this.numChunksLoaded === this.numChunks;
    }
    onReceiveData(e1, t) {
        const a = this.chunkSize;
        if (e1 % a != 0) throw new Error(`Bad begin offset: ${e1}`);
        const r = e1 + t.byteLength;
        if (r % a != 0 && r !== this.bytes.length) throw new Error(`Bad end offset: ${r}`);
        this.bytes.set(new Uint8Array(t), e1);
        const i = Math.floor(e1 / a), n = Math.floor((r - 1) / a) + 1;
        for(let e1 = i; e1 < n; ++e1)this._loadedChunks.add(e1);
    }
    onReceiveProgressiveData(e1) {
        let t = this.progressiveDataLength;
        const a = Math.floor(t / this.chunkSize);
        this.bytes.set(new Uint8Array(e1), t);
        t += e1.byteLength;
        this.progressiveDataLength = t;
        const r = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);
        for(let e1 = a; e1 < r; ++e1)this._loadedChunks.add(e1);
    }
    ensureByte(e1) {
        if (e1 < this.progressiveDataLength) return;
        const t = Math.floor(e1 / this.chunkSize);
        if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {
            if (!this._loadedChunks.has(t)) throw new MissingDataException(e1, e1 + 1);
            this.lastSuccessfulEnsureByteChunk = t;
        }
    }
    ensureRange(e1, t) {
        if (e1 >= t) return;
        if (t <= this.progressiveDataLength) return;
        const a = Math.floor(e1 / this.chunkSize);
        if (a > this.numChunks) return;
        const r = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);
        for(let i = a; i < r; ++i)if (!this._loadedChunks.has(i)) throw new MissingDataException(e1, t);
    }
    nextEmptyChunk(e1) {
        const t = this.numChunks;
        for(let a = 0; a < t; ++a){
            const r = (e1 + a) % t;
            if (!this._loadedChunks.has(r)) return r;
        }
        return null;
    }
    hasChunk(e1) {
        return this._loadedChunks.has(e1);
    }
    getByte() {
        const e1 = this.pos;
        if (e1 >= this.end) return -1;
        e1 >= this.progressiveDataLength && this.ensureByte(e1);
        return this.bytes[this.pos++];
    }
    getBytes(e1) {
        const t = this.bytes, a = this.pos, r = this.end;
        if (!e1) {
            r > this.progressiveDataLength && this.ensureRange(a, r);
            return t.subarray(a, r);
        }
        let i = a + e1;
        i > r && (i = r);
        i > this.progressiveDataLength && this.ensureRange(a, i);
        this.pos = i;
        return t.subarray(a, i);
    }
    getByteRange(e1, t) {
        e1 < 0 && (e1 = 0);
        t > this.end && (t = this.end);
        t > this.progressiveDataLength && this.ensureRange(e1, t);
        return this.bytes.subarray(e1, t);
    }
    makeSubStream(e1, t, a = null) {
        t ? e1 + t > this.progressiveDataLength && this.ensureRange(e1, e1 + t) : e1 >= this.progressiveDataLength && this.ensureByte(e1);
        function ChunkedStreamSubstream() {}
        ChunkedStreamSubstream.prototype = Object.create(this);
        ChunkedStreamSubstream.prototype.getMissingChunks = function() {
            const e1 = this.chunkSize, t = Math.floor(this.start / e1), a = Math.floor((this.end - 1) / e1) + 1, r = [];
            for(let e1 = t; e1 < a; ++e1)this._loadedChunks.has(e1) || r.push(e1);
            return r;
        };
        Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
            get () {
                return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
            },
            configurable: !0
        });
        const r = new ChunkedStreamSubstream;
        r.pos = r.start = e1;
        r.end = e1 + t || this.end;
        r.dict = a;
        return r;
    }
    getBaseStreams() {
        return [
            this
        ];
    }
}
class ChunkedStreamManager {
    constructor(e1, t){
        this.length = t.length;
        this.chunkSize = t.rangeChunkSize;
        this.stream = new ChunkedStream(this.length, this.chunkSize, this);
        this.pdfNetworkStream = e1;
        this.disableAutoFetch = t.disableAutoFetch;
        this.msgHandler = t.msgHandler;
        this.currRequestId = 0;
        this._chunksNeededByRequest = new Map;
        this._requestsByChunk = new Map;
        this._promisesByRequest = new Map;
        this.progressiveDataLength = 0;
        this.aborted = !1;
        this._loadedStreamCapability = Promise.withResolvers();
    }
    sendRequest(e1, t) {
        const a = this.pdfNetworkStream.getRangeReader(e1, t);
        a.isStreamingSupported || (a.onProgress = this.onProgress.bind(this));
        let r = [], i = 0;
        return new Promise((e1, t)=>{
            const readChunk = ({ value: n, done: s })=>{
                try {
                    if (s) {
                        const t = arrayBuffersToBytes(r);
                        r = null;
                        e1(t);
                        return;
                    }
                    i += n.byteLength;
                    a.isStreamingSupported && this.onProgress({
                        loaded: i
                    });
                    r.push(n);
                    a.read().then(readChunk, t);
                } catch (e1) {
                    t(e1);
                }
            };
            a.read().then(readChunk, t);
        }).then((t)=>{
            this.aborted || this.onReceiveData({
                chunk: t,
                begin: e1
            });
        });
    }
    requestAllChunks(e1 = !1) {
        if (!e1) {
            const e1 = this.stream.getMissingChunks();
            this._requestChunks(e1);
        }
        return this._loadedStreamCapability.promise;
    }
    _requestChunks(e1) {
        const t = this.currRequestId++, a = new Set;
        this._chunksNeededByRequest.set(t, a);
        for (const t of e1)this.stream.hasChunk(t) || a.add(t);
        if (0 === a.size) return Promise.resolve();
        const r = Promise.withResolvers();
        this._promisesByRequest.set(t, r);
        const i = [];
        for (const e1 of a){
            let a = this._requestsByChunk.get(e1);
            if (!a) {
                a = [];
                this._requestsByChunk.set(e1, a);
                i.push(e1);
            }
            a.push(t);
        }
        if (i.length > 0) {
            const e1 = this.groupChunks(i);
            for (const t of e1){
                const e1 = t.beginChunk * this.chunkSize, a = Math.min(t.endChunk * this.chunkSize, this.length);
                this.sendRequest(e1, a).catch(r.reject);
            }
        }
        return r.promise.catch((e1)=>{
            if (!this.aborted) throw e1;
        });
    }
    getStream() {
        return this.stream;
    }
    requestRange(e1, t) {
        t = Math.min(t, this.length);
        const a = this.getBeginChunk(e1), r = this.getEndChunk(t), i = [];
        for(let e1 = a; e1 < r; ++e1)i.push(e1);
        return this._requestChunks(i);
    }
    requestRanges(e1 = []) {
        const t = [];
        for (const a of e1){
            const e1 = this.getBeginChunk(a.begin), r = this.getEndChunk(a.end);
            for(let a = e1; a < r; ++a)t.includes(a) || t.push(a);
        }
        t.sort((e1, t)=>e1 - t);
        return this._requestChunks(t);
    }
    groupChunks(e1) {
        const t = [];
        let a = -1, r = -1;
        for(let i = 0, n = e1.length; i < n; ++i){
            const n = e1[i];
            a < 0 && (a = n);
            if (r >= 0 && r + 1 !== n) {
                t.push({
                    beginChunk: a,
                    endChunk: r + 1
                });
                a = n;
            }
            i + 1 === e1.length && t.push({
                beginChunk: a,
                endChunk: n + 1
            });
            r = n;
        }
        return t;
    }
    onProgress(e1) {
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize + e1.loaded,
            total: this.length
        });
    }
    onReceiveData(e1) {
        const t = e1.chunk, a = void 0 === e1.begin, r = a ? this.progressiveDataLength : e1.begin, i = r + t.byteLength, n = Math.floor(r / this.chunkSize), s = i < this.length ? Math.floor(i / this.chunkSize) : Math.ceil(i / this.chunkSize);
        if (a) {
            this.stream.onReceiveProgressiveData(t);
            this.progressiveDataLength = i;
        } else this.stream.onReceiveData(r, t);
        this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
        const o = [];
        for(let e1 = n; e1 < s; ++e1){
            const t = this._requestsByChunk.get(e1);
            if (t) {
                this._requestsByChunk.delete(e1);
                for (const a of t){
                    const t = this._chunksNeededByRequest.get(a);
                    t.has(e1) && t.delete(e1);
                    t.size > 0 || o.push(a);
                }
            }
        }
        if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
            let e1;
            if (1 === this.stream.numChunksLoaded) {
                const t = this.stream.numChunks - 1;
                this.stream.hasChunk(t) || (e1 = t);
            } else e1 = this.stream.nextEmptyChunk(s);
            Number.isInteger(e1) && this._requestChunks([
                e1
            ]);
        }
        for (const e1 of o){
            const t = this._promisesByRequest.get(e1);
            this._promisesByRequest.delete(e1);
            t.resolve();
        }
        this.msgHandler.send("DocProgress", {
            loaded: this.stream.numChunksLoaded * this.chunkSize,
            total: this.length
        });
    }
    onError(e1) {
        this._loadedStreamCapability.reject(e1);
    }
    getBeginChunk(e1) {
        return Math.floor(e1 / this.chunkSize);
    }
    getEndChunk(e1) {
        return Math.floor((e1 - 1) / this.chunkSize) + 1;
    }
    abort(e1) {
        this.aborted = !0;
        this.pdfNetworkStream?.cancelAllRequests(e1);
        for (const t of this._promisesByRequest.values())t.reject(e1);
    }
}
function convertToRGBA(e1) {
    switch(e1.kind){
        case k:
            return convertBlackAndWhiteToRGBA(e1);
        case C:
            return function convertRGBToRGBA({ src: e1, srcPos: t = 0, dest: a, destPos: r = 0, width: i, height: n }) {
                let s = 0;
                const o = i * n * 3, c = o >> 2, l = new Uint32Array(e1.buffer, t, c);
                if (FeatureTest.isLittleEndian) {
                    for(; s < c - 2; s += 3, r += 4){
                        const e1 = l[s], t = l[s + 1], i = l[s + 2];
                        a[r] = 4278190080 | e1;
                        a[r + 1] = e1 >>> 24 | t << 8 | 4278190080;
                        a[r + 2] = t >>> 16 | i << 16 | 4278190080;
                        a[r + 3] = i >>> 8 | 4278190080;
                    }
                    for(let i = 4 * s, n = t + o; i < n; i += 3)a[r++] = e1[i] | e1[i + 1] << 8 | e1[i + 2] << 16 | 4278190080;
                } else {
                    for(; s < c - 2; s += 3, r += 4){
                        const e1 = l[s], t = l[s + 1], i = l[s + 2];
                        a[r] = 255 | e1;
                        a[r + 1] = e1 << 24 | t >>> 8 | 255;
                        a[r + 2] = t << 16 | i >>> 16 | 255;
                        a[r + 3] = i << 8 | 255;
                    }
                    for(let i = 4 * s, n = t + o; i < n; i += 3)a[r++] = e1[i] << 24 | e1[i + 1] << 16 | e1[i + 2] << 8 | 255;
                }
                return {
                    srcPos: t + o,
                    destPos: r
                };
            }(e1);
    }
    return null;
}
function convertBlackAndWhiteToRGBA({ src: e1, srcPos: t = 0, dest: a, width: r, height: i, nonBlackColor: n = 4294967295, inverseDecode: s = !1 }) {
    const o = FeatureTest.isLittleEndian ? 4278190080 : 255, [c, l] = s ? [
        n,
        o
    ] : [
        o,
        n
    ], h = r >> 3, u = 7 & r, d = e1.length;
    a = new Uint32Array(a.buffer);
    let f = 0;
    for(let r = 0; r < i; r++){
        for(const r = t + h; t < r; t++){
            const r = t < d ? e1[t] : 255;
            a[f++] = 128 & r ? l : c;
            a[f++] = 64 & r ? l : c;
            a[f++] = 32 & r ? l : c;
            a[f++] = 16 & r ? l : c;
            a[f++] = 8 & r ? l : c;
            a[f++] = 4 & r ? l : c;
            a[f++] = 2 & r ? l : c;
            a[f++] = 1 & r ? l : c;
        }
        if (0 === u) continue;
        const r = t < d ? e1[t++] : 255;
        for(let e1 = 0; e1 < u; e1++)a[f++] = r & 1 << 7 - e1 ? l : c;
    }
    return {
        srcPos: t,
        destPos: f
    };
}
class ImageResizer {
    static #O = 2048;
    static #M = FeatureTest.isImageDecoderSupported;
    constructor(e1, t){
        this._imgData = e1;
        this._isMask = t;
    }
    static get canUseImageDecoder() {
        return shadow(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
    }
    static needsToBeResized(e1, t) {
        if (e1 <= this.#O && t <= this.#O) return !1;
        const { MAX_DIM: a } = this;
        if (e1 > a || t > a) return !0;
        const r = e1 * t;
        if (this._hasMaxArea) return r > this.MAX_AREA;
        if (r < this.#O ** 2) return !1;
        if (this._areGoodDims(e1, t)) {
            this.#O = Math.max(this.#O, Math.floor(Math.sqrt(e1 * t)));
            return !1;
        }
        this.#O = this._guessMax(this.#O, a, 128, 0);
        return r > (this.MAX_AREA = this.#O ** 2);
    }
    static getReducePowerForJPX(e1, t, a) {
        const r = e1 * t, i = 2 ** 30 / (4 * a);
        if (!this.needsToBeResized(e1, t)) return r > i ? Math.ceil(Math.log2(r / i)) : 0;
        const { MAX_DIM: n, MAX_AREA: s } = this, o = Math.max(e1 / n, t / n, Math.sqrt(r / Math.min(i, s)));
        return Math.ceil(Math.log2(o));
    }
    static get MAX_DIM() {
        return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
    }
    static get MAX_AREA() {
        this._hasMaxArea = !0;
        return shadow(this, "MAX_AREA", this._guessMax(this.#O, this.MAX_DIM, 128, 0) ** 2);
    }
    static set MAX_AREA(e1) {
        if (e1 >= 0) {
            this._hasMaxArea = !0;
            shadow(this, "MAX_AREA", e1);
        }
    }
    static setOptions({ canvasMaxAreaInBytes: e1 = -1, isImageDecoderSupported: t = !1 }) {
        this._hasMaxArea || (this.MAX_AREA = e1 >> 2);
        this.#M = t;
    }
    static _areGoodDims(e1, t) {
        try {
            const a = new OffscreenCanvas(e1, t), r = a.getContext("2d");
            r.fillRect(0, 0, 1, 1);
            const i = r.getImageData(0, 0, 1, 1).data[3];
            a.width = a.height = 1;
            return 0 !== i;
        } catch  {
            return !1;
        }
    }
    static _guessMax(e1, t, a, r) {
        for(; e1 + a + 1 < t;){
            const a = Math.floor((e1 + t) / 2), i = r || a;
            this._areGoodDims(a, i) ? e1 = a : t = a;
        }
        return e1;
    }
    static async createImage(e1, t = !1) {
        return new ImageResizer(e1, t)._createImage();
    }
    async _createImage() {
        const { _imgData: e1 } = this, { width: t, height: a } = e1;
        if (t * a * 4 > ca) {
            const e1 = this.#D();
            if (e1) return e1;
        }
        const r = this._encodeBMP();
        let i, n;
        if (await ImageResizer.canUseImageDecoder) {
            i = new ImageDecoder({
                data: r,
                type: "image/bmp",
                preferAnimation: !1,
                transfer: [
                    r.buffer
                ]
            });
            n = i.decode().catch((e1)=>{
                warn(`BMP image decoding failed: ${e1}`);
                return createImageBitmap(new Blob([
                    this._encodeBMP().buffer
                ], {
                    type: "image/bmp"
                }));
            }).finally(()=>{
                i.close();
            });
        } else n = createImageBitmap(new Blob([
            r.buffer
        ], {
            type: "image/bmp"
        }));
        const { MAX_AREA: s, MAX_DIM: o } = ImageResizer, c = Math.max(t / o, a / o, Math.sqrt(t * a / s)), l = Math.max(c, 2), h = Math.round(10 * (c + 1.25)) / 10 / l, u = Math.floor(Math.log2(h)), d = new Array(u + 2).fill(2);
        d[0] = l;
        d.splice(-1, 1, h / (1 << u));
        let f = t, g = a;
        const p = await n;
        let m = p.image || p;
        for (const e1 of d){
            const t = f, a = g;
            f = Math.floor(f / e1) - 1;
            g = Math.floor(g / e1) - 1;
            const r = new OffscreenCanvas(f, g);
            r.getContext("2d").drawImage(m, 0, 0, t, a, 0, 0, f, g);
            m.close();
            m = r.transferToImageBitmap();
        }
        e1.data = null;
        e1.bitmap = m;
        e1.width = f;
        e1.height = g;
        return e1;
    }
    #D() {
        const { _imgData: e1 } = this, { data: t, width: a, height: r, kind: i } = e1, n = a * r * 4, s = Math.ceil(Math.log2(n / ca)), o = a >> s, c = r >> s;
        let l, h = r;
        try {
            l = new Uint8Array(n);
        } catch  {
            let e1 = Math.floor(Math.log2(n + 1));
            for(;;)try {
                l = new Uint8Array(2 ** e1 - 1);
                break;
            } catch  {
                e1 -= 1;
            }
            h = Math.floor((2 ** e1 - 1) / (4 * a));
            const t = a * h * 4;
            t < l.length && (l = new Uint8Array(t));
        }
        const u = new Uint32Array(l.buffer), d = new Uint32Array(o * c);
        let f = 0, g = 0;
        const p = Math.ceil(r / h), m = r % h == 0 ? r : r % h;
        for(let e1 = 0; e1 < p; e1++){
            const r = e1 < p - 1 ? h : m;
            ({ srcPos: f } = convertToRGBA({
                kind: i,
                src: t,
                dest: u,
                width: a,
                height: r,
                inverseDecode: this._isMask,
                srcPos: f
            }));
            for(let e1 = 0, t = r >> s; e1 < t; e1++){
                const t = u.subarray((e1 << s) * a);
                for(let e1 = 0; e1 < o; e1++)d[g++] = t[e1 << s];
            }
        }
        if (ImageResizer.needsToBeResized(o, c)) {
            e1.data = d;
            e1.width = o;
            e1.height = c;
            e1.kind = v;
            return null;
        }
        const b = new OffscreenCanvas(o, c);
        b.getContext("2d", {
            willReadFrequently: !0
        }).putImageData(new ImageData(new Uint8ClampedArray(d.buffer), o, c), 0, 0);
        e1.data = null;
        e1.bitmap = b.transferToImageBitmap();
        e1.width = o;
        e1.height = c;
        return e1;
    }
    _encodeBMP() {
        const { width: e1, height: t, kind: a } = this._imgData;
        let r, i = this._imgData.data, n = new Uint8Array(0), s = n, o = 0;
        switch(a){
            case k:
                {
                    r = 1;
                    n = new Uint8Array(this._isMask ? [
                        255,
                        255,
                        255,
                        255,
                        0,
                        0,
                        0,
                        0
                    ] : [
                        0,
                        0,
                        0,
                        0,
                        255,
                        255,
                        255,
                        255
                    ]);
                    const a = e1 + 7 >> 3, s = a + 3 & -4;
                    if (a !== s) {
                        const e1 = new Uint8Array(s * t);
                        let r = 0;
                        for(let n = 0, o = t * a; n < o; n += a, r += s)e1.set(i.subarray(n, n + a), r);
                        i = e1;
                    }
                    break;
                }
            case C:
                r = 24;
                if (3 & e1) {
                    const a = 3 * e1, r = a + 3 & -4, n = r - a, s = new Uint8Array(r * t);
                    let o = 0;
                    for(let e1 = 0, r = t * a; e1 < r; e1 += a){
                        const t = i.subarray(e1, e1 + a);
                        for(let e1 = 0; e1 < a; e1 += 3){
                            s[o++] = t[e1 + 2];
                            s[o++] = t[e1 + 1];
                            s[o++] = t[e1];
                        }
                        o += n;
                    }
                    i = s;
                } else for(let e1 = 0, t = i.length; e1 < t; e1 += 3){
                    const t = i[e1];
                    i[e1] = i[e1 + 2];
                    i[e1 + 2] = t;
                }
                break;
            case v:
                r = 32;
                o = 3;
                s = new Uint8Array(68);
                const a1 = new DataView(s.buffer);
                if (FeatureTest.isLittleEndian) {
                    a1.setUint32(0, 255, !0);
                    a1.setUint32(4, 65280, !0);
                    a1.setUint32(8, 16711680, !0);
                    a1.setUint32(12, 4278190080, !0);
                } else {
                    a1.setUint32(0, 4278190080, !0);
                    a1.setUint32(4, 16711680, !0);
                    a1.setUint32(8, 65280, !0);
                    a1.setUint32(12, 255, !0);
                }
                break;
            default:
                throw new Error("invalid format");
        }
        let c = 0;
        const l = 40 + s.length, h = 14 + l + n.length + i.length, u = new Uint8Array(h), d = new DataView(u.buffer);
        d.setUint16(c, 19778, !0);
        c += 2;
        d.setUint32(c, h, !0);
        c += 4;
        d.setUint32(c, 0, !0);
        c += 4;
        d.setUint32(c, 14 + l + n.length, !0);
        c += 4;
        d.setUint32(c, l, !0);
        c += 4;
        d.setInt32(c, e1, !0);
        c += 4;
        d.setInt32(c, -t, !0);
        c += 4;
        d.setUint16(c, 1, !0);
        c += 2;
        d.setUint16(c, r, !0);
        c += 2;
        d.setUint32(c, o, !0);
        c += 4;
        d.setUint32(c, 0, !0);
        c += 4;
        d.setInt32(c, 0, !0);
        c += 4;
        d.setInt32(c, 0, !0);
        c += 4;
        d.setUint32(c, n.length / 4, !0);
        c += 4;
        d.setUint32(c, 0, !0);
        c += 4;
        u.set(s, c);
        c += s.length;
        u.set(n, c);
        c += n.length;
        u.set(i, c);
        return u;
    }
}
const xa = new Uint8Array(0);
class DecodeStream extends BaseStream {
    constructor(e1){
        super();
        this._rawMinBufferLength = e1 || 0;
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = !1;
        this.buffer = xa;
        this.minBufferLength = 512;
        if (e1) for(; this.minBufferLength < e1;)this.minBufferLength *= 2;
    }
    get isEmpty() {
        for(; !this.eof && 0 === this.bufferLength;)this.readBlock();
        return 0 === this.bufferLength;
    }
    ensureBuffer(e1) {
        const t = this.buffer;
        if (e1 <= t.byteLength) return t;
        let a = this.minBufferLength;
        for(; a < e1;)a *= 2;
        const r = new Uint8Array(a);
        r.set(t);
        return this.buffer = r;
    }
    getByte() {
        const e1 = this.pos;
        for(; this.bufferLength <= e1;){
            if (this.eof) return -1;
            this.readBlock();
        }
        return this.buffer[this.pos++];
    }
    getBytes(e1, t = null) {
        const a = this.pos;
        let r;
        if (e1) {
            this.ensureBuffer(a + e1);
            r = a + e1;
            for(; !this.eof && this.bufferLength < r;)this.readBlock(t);
            const i = this.bufferLength;
            r > i && (r = i);
        } else {
            for(; !this.eof;)this.readBlock(t);
            r = this.bufferLength;
        }
        this.pos = r;
        return this.buffer.subarray(a, r);
    }
    async getImageData(e1, t) {
        if (!this.canAsyncDecodeImageFromBuffer) return this.isAsyncDecoder ? this.decodeImage(null, t) : this.getBytes(e1, t);
        const a = await this.stream.asyncGetBytes();
        return this.decodeImage(a, t);
    }
    reset() {
        this.pos = 0;
    }
    makeSubStream(e1, t, a = null) {
        if (void 0 === t) for(; !this.eof;)this.readBlock();
        else {
            const a = e1 + t;
            for(; this.bufferLength <= a && !this.eof;)this.readBlock();
        }
        return new Stream(this.buffer, e1, t, a);
    }
    getBaseStreams() {
        return this.str ? this.str.getBaseStreams() : null;
    }
}
class StreamsSequenceStream extends DecodeStream {
    constructor(e1, t = null){
        e1 = e1.filter((e1)=>e1 instanceof BaseStream);
        let a = 0;
        for (const t of e1)a += t instanceof DecodeStream ? t._rawMinBufferLength : t.length;
        super(a);
        this.streams = e1;
        this._onError = t;
    }
    readBlock() {
        const e1 = this.streams;
        if (0 === e1.length) {
            this.eof = !0;
            return;
        }
        const t = e1.shift();
        let a;
        try {
            a = t.getBytes();
        } catch (e1) {
            if (this._onError) {
                this._onError(e1, t.dict?.objId);
                return;
            }
            throw e1;
        }
        const r = this.bufferLength, i = r + a.length;
        this.ensureBuffer(i).set(a, r);
        this.bufferLength = i;
    }
    getBaseStreams() {
        const e1 = [];
        for (const t of this.streams){
            const a = t.getBaseStreams();
            a && e1.push(...a);
        }
        return e1.length > 0 ? e1 : null;
    }
}
class ColorSpaceUtils {
    static parse({ cs: e1, xref: t, resources: a = null, pdfFunctionFactory: r, globalColorSpaceCache: i, localColorSpaceCache: n, asyncIfNotCached: s = !1 }) {
        const o = {
            xref: t,
            resources: a,
            pdfFunctionFactory: r,
            globalColorSpaceCache: i,
            localColorSpaceCache: n
        };
        let c, l, h;
        if (e1 instanceof Ref) {
            l = e1;
            const a = i.getByRef(l) || n.getByRef(l);
            if (a) return a;
            e1 = t.fetch(e1);
        }
        if (e1 instanceof Name) {
            c = e1.name;
            const t = n.getByName(c);
            if (t) return t;
        }
        try {
            h = this.#B(e1, o);
        } catch (e1) {
            if (s && !(e1 instanceof MissingDataException)) return Promise.reject(e1);
            throw e1;
        }
        if (c || l) {
            n.set(c, l, h);
            l && i.set(null, l, h);
        }
        return s ? Promise.resolve(h) : h;
    }
    static #R(e1, t) {
        const { globalColorSpaceCache: a } = t;
        let r;
        if (e1 instanceof Ref) {
            r = e1;
            const t = a.getByRef(r);
            if (t) return t;
        }
        const i = this.#B(e1, t);
        r && a.set(null, r, i);
        return i;
    }
    static #B(e1, t) {
        const { xref: a, resources: r, pdfFunctionFactory: i, globalColorSpaceCache: n } = t;
        if ((e1 = a.fetchIfRef(e1)) instanceof Name) switch(e1.name){
            case "G":
            case "DeviceGray":
                return this.gray;
            case "RGB":
            case "DeviceRGB":
                return this.rgb;
            case "DeviceRGBA":
                return this.rgba;
            case "CMYK":
            case "DeviceCMYK":
                return this.cmyk;
            case "Pattern":
                return new PatternCS(null);
            default:
                if (r instanceof Dict) {
                    const a = r.get("ColorSpace");
                    if (a instanceof Dict) {
                        const r = a.get(e1.name);
                        if (r) {
                            if (r instanceof Name) return this.#B(r, t);
                            e1 = r;
                            break;
                        }
                    }
                }
                warn(`Unrecognized ColorSpace: ${e1.name}`);
                return this.gray;
        }
        if (Array.isArray(e1)) {
            const r = a.fetchIfRef(e1[0]).name;
            let s, o, c, l, h, u;
            switch(r){
                case "G":
                case "DeviceGray":
                    return this.gray;
                case "RGB":
                case "DeviceRGB":
                    return this.rgb;
                case "CMYK":
                case "DeviceCMYK":
                    return this.cmyk;
                case "CalGray":
                    s = a.fetchIfRef(e1[1]);
                    l = s.getArray("WhitePoint");
                    h = s.getArray("BlackPoint");
                    u = s.get("Gamma");
                    return new CalGrayCS(l, h, u);
                case "CalRGB":
                    s = a.fetchIfRef(e1[1]);
                    l = s.getArray("WhitePoint");
                    h = s.getArray("BlackPoint");
                    u = s.getArray("Gamma");
                    const d = s.getArray("Matrix");
                    return new CalRGBCS(l, h, u, d);
                case "ICCBased":
                    const f = e1[1] instanceof Ref;
                    if (f) {
                        const t = n.getByRef(e1[1]);
                        if (t) return t;
                    }
                    const g = a.fetchIfRef(e1[1]), p = g.dict;
                    o = p.get("N");
                    if (IccColorSpace.isUsable) try {
                        const t = new IccColorSpace(g.getBytes(), "ICCBased", o);
                        f && n.set(null, e1[1], t);
                        return t;
                    } catch (t) {
                        if (t instanceof MissingDataException) throw t;
                        warn(`ICCBased color space (${e1[1]}): "${t}".`);
                    }
                    const m = p.getRaw("Alternate");
                    if (m) {
                        const e1 = this.#R(m, t);
                        if (e1.numComps === o) return e1;
                        warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (1 === o) return this.gray;
                    if (3 === o) return this.rgb;
                    if (4 === o) return this.cmyk;
                    break;
                case "Pattern":
                    c = e1[1] || null;
                    c && (c = this.#R(c, t));
                    return new PatternCS(c);
                case "I":
                case "Indexed":
                    c = this.#R(e1[1], t);
                    const b = MathClamp(a.fetchIfRef(e1[2]), 0, 255), y = a.fetchIfRef(e1[3]);
                    return new IndexedCS(c, b, y);
                case "Separation":
                case "DeviceN":
                    const w = a.fetchIfRef(e1[1]);
                    o = Array.isArray(w) ? w.length : 1;
                    c = this.#R(e1[2], t);
                    const x = i.create(e1[3]);
                    return new AlternateCS(o, c, x);
                case "Lab":
                    s = a.fetchIfRef(e1[1]);
                    l = s.getArray("WhitePoint");
                    h = s.getArray("BlackPoint");
                    const S = s.getArray("Range");
                    return new LabCS(l, h, S);
                default:
                    warn(`Unimplemented ColorSpace object: ${r}`);
                    return this.gray;
            }
        }
        warn(`Unrecognized ColorSpace object: ${e1}`);
        return this.gray;
    }
    static get gray() {
        return shadow(this, "gray", new DeviceGrayCS);
    }
    static get rgb() {
        return shadow(this, "rgb", new DeviceRgbCS);
    }
    static get rgba() {
        return shadow(this, "rgba", new DeviceRgbaCS);
    }
    static get cmyk() {
        if (CmykICCBasedCS.isUsable) try {
            return shadow(this, "cmyk", new CmykICCBasedCS);
        } catch  {
            warn("CMYK fallback: DeviceCMYK");
        }
        return shadow(this, "cmyk", new DeviceCmykCS);
    }
}
class JpegError extends Jt {
    constructor(e1){
        super(e1, "JpegError");
    }
}
class DNLMarkerError extends Jt {
    constructor(e1, t){
        super(e1, "DNLMarkerError");
        this.scanLines = t;
    }
}
class EOIMarkerError extends Jt {
    constructor(e1){
        super(e1, "EOIMarkerError");
    }
}
const Sa = new Uint8Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
]), Aa = 4017, ka = 799, Ca = 3406, va = 2276, Fa = 1567, Ia = 3784, Ta = 5793, Oa = 2896;
function buildHuffmanTable(e1, t) {
    let a, r, i = 0, n = 16;
    for(; n > 0 && !e1[n - 1];)n--;
    const s = [
        {
            children: [],
            index: 0
        }
    ];
    let o, c = s[0];
    for(a = 0; a < n; a++){
        for(r = 0; r < e1[a]; r++){
            c = s.pop();
            c.children[c.index] = t[i];
            for(; c.index > 0;)c = s.pop();
            c.index++;
            s.push(c);
            for(; s.length <= a;){
                s.push(o = {
                    children: [],
                    index: 0
                });
                c.children[c.index] = o.children;
                c = o;
            }
            i++;
        }
        if (a + 1 < n) {
            s.push(o = {
                children: [],
                index: 0
            });
            c.children[c.index] = o.children;
            c = o;
        }
    }
    return s[0].children;
}
function getBlockBufferOffset(e1, t, a) {
    return 64 * ((e1.blocksPerLine + 1) * t + a);
}
function decodeScan(e1, t, a, r, i, n, s, o, c, l = !1) {
    const h = a.mcusPerLine, u = a.progressive, d = t;
    let f = 0, g = 0;
    function readBit() {
        if (g > 0) {
            g--;
            return f >> g & 1;
        }
        f = e1[t++];
        if (255 === f) {
            const r = e1[t++];
            if (r) {
                if (220 === r && l) {
                    const r = readUint16(e1, t += 2);
                    t += 2;
                    if (r > 0 && r !== a.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", r);
                } else if (217 === r) {
                    if (l) {
                        const e1 = y * (8 === a.precision ? 8 : 0);
                        if (e1 > 0 && Math.round(a.scanLines / e1) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e1);
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                }
                throw new JpegError(`unexpected marker ${(f << 8 | r).toString(16)}`);
            }
        }
        g = 7;
        return f >>> 7;
    }
    function decodeHuffman(e1) {
        let t = e1;
        for(;;){
            t = t[readBit()];
            switch(typeof t){
                case "number":
                    return t;
                case "object":
                    continue;
            }
            throw new JpegError("invalid huffman sequence");
        }
    }
    function receive(e1) {
        let t = 0;
        for(; e1 > 0;){
            t = t << 1 | readBit();
            e1--;
        }
        return t;
    }
    function receiveAndExtend(e1) {
        if (1 === e1) return 1 === readBit() ? 1 : -1;
        const t = receive(e1);
        return t >= 1 << e1 - 1 ? t : t + (-1 << e1) + 1;
    }
    let p = 0;
    let m, b = 0;
    let y = 0;
    function decodeMcu(e1, t, a, r, i) {
        const n = a % h;
        y = (a / h | 0) * e1.v + r;
        const s = n * e1.h + i;
        t(e1, getBlockBufferOffset(e1, y, s));
    }
    function decodeBlock(e1, t, a) {
        y = a / e1.blocksPerLine | 0;
        const r = a % e1.blocksPerLine;
        t(e1, getBlockBufferOffset(e1, y, r));
    }
    const w = r.length;
    let x, S, k, C, v, F;
    F = u ? 0 === n ? 0 === o ? function decodeDCFirst(e1, t) {
        const a = decodeHuffman(e1.huffmanTableDC), r = 0 === a ? 0 : receiveAndExtend(a) << c;
        e1.blockData[t] = e1.pred += r;
    } : function decodeDCSuccessive(e1, t) {
        e1.blockData[t] |= readBit() << c;
    } : 0 === o ? function decodeACFirst(e1, t) {
        if (p > 0) {
            p--;
            return;
        }
        let a = n;
        const r = s;
        for(; a <= r;){
            const r = decodeHuffman(e1.huffmanTableAC), i = 15 & r, n = r >> 4;
            if (0 === i) {
                if (n < 15) {
                    p = receive(n) + (1 << n) - 1;
                    break;
                }
                a += 16;
                continue;
            }
            a += n;
            const s = Sa[a];
            e1.blockData[t + s] = receiveAndExtend(i) * (1 << c);
            a++;
        }
    } : function decodeACSuccessive(e1, t) {
        let a = n;
        const r = s;
        let i, o, l = 0;
        for(; a <= r;){
            const r = t + Sa[a], n = e1.blockData[r] < 0 ? -1 : 1;
            switch(b){
                case 0:
                    o = decodeHuffman(e1.huffmanTableAC);
                    i = 15 & o;
                    l = o >> 4;
                    if (0 === i) if (l < 15) {
                        p = receive(l) + (1 << l);
                        b = 4;
                    } else {
                        l = 16;
                        b = 1;
                    }
                    else {
                        if (1 !== i) throw new JpegError("invalid ACn encoding");
                        m = receiveAndExtend(i);
                        b = l ? 2 : 3;
                    }
                    continue;
                case 1:
                case 2:
                    if (e1.blockData[r]) e1.blockData[r] += n * (readBit() << c);
                    else {
                        l--;
                        0 === l && (b = 2 === b ? 3 : 0);
                    }
                    break;
                case 3:
                    if (e1.blockData[r]) e1.blockData[r] += n * (readBit() << c);
                    else {
                        e1.blockData[r] = m << c;
                        b = 0;
                    }
                    break;
                case 4:
                    e1.blockData[r] && (e1.blockData[r] += n * (readBit() << c));
            }
            a++;
        }
        if (4 === b) {
            p--;
            0 === p && (b = 0);
        }
    } : function decodeBaseline(e1, t) {
        const a = decodeHuffman(e1.huffmanTableDC), r = 0 === a ? 0 : receiveAndExtend(a);
        e1.blockData[t] = e1.pred += r;
        let i = 1;
        for(; i < 64;){
            const a = decodeHuffman(e1.huffmanTableAC), r = 15 & a, n = a >> 4;
            if (0 === r) {
                if (n < 15) break;
                i += 16;
                continue;
            }
            i += n;
            const s = Sa[i];
            e1.blockData[t + s] = receiveAndExtend(r);
            i++;
        }
    };
    let T, O = 0;
    const M = 1 === w ? r[0].blocksPerLine * r[0].blocksPerColumn : h * a.mcusPerColumn;
    let D, R;
    for(; O <= M;){
        const a = i ? Math.min(M - O, i) : M;
        if (a > 0) {
            for(S = 0; S < w; S++)r[S].pred = 0;
            p = 0;
            if (1 === w) {
                x = r[0];
                for(v = 0; v < a; v++){
                    decodeBlock(x, F, O);
                    O++;
                }
            } else for(v = 0; v < a; v++){
                for(S = 0; S < w; S++){
                    x = r[S];
                    D = x.h;
                    R = x.v;
                    for(k = 0; k < R; k++)for(C = 0; C < D; C++)decodeMcu(x, F, O, k, C);
                }
                O++;
            }
        }
        g = 0;
        T = findNextFileMarker(e1, t);
        if (!T) break;
        if (T.invalid) {
            warn(`decodeScan - ${a > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${T.invalid}`);
            t = T.offset;
        }
        if (!(T.marker >= 65488 && T.marker <= 65495)) break;
        t += 2;
    }
    return t - d;
}
function quantizeAndInverse(e1, t, a) {
    const r = e1.quantizationTable, i = e1.blockData;
    let n, s, o, c, l, h, u, d, f, g, p, m, b, y, w, x, S;
    if (!r) throw new JpegError("missing required Quantization Table.");
    for(let e1 = 0; e1 < 64; e1 += 8){
        f = i[t + e1];
        g = i[t + e1 + 1];
        p = i[t + e1 + 2];
        m = i[t + e1 + 3];
        b = i[t + e1 + 4];
        y = i[t + e1 + 5];
        w = i[t + e1 + 6];
        x = i[t + e1 + 7];
        f *= r[e1];
        if (g | p | m | b | y | w | x) {
            g *= r[e1 + 1];
            p *= r[e1 + 2];
            m *= r[e1 + 3];
            b *= r[e1 + 4];
            y *= r[e1 + 5];
            w *= r[e1 + 6];
            x *= r[e1 + 7];
            n = Ta * f + 128 >> 8;
            s = Ta * b + 128 >> 8;
            o = p;
            c = w;
            l = Oa * (g - x) + 128 >> 8;
            d = Oa * (g + x) + 128 >> 8;
            h = m << 4;
            u = y << 4;
            n = n + s + 1 >> 1;
            s = n - s;
            S = o * Ia + c * Fa + 128 >> 8;
            o = o * Fa - c * Ia + 128 >> 8;
            c = S;
            l = l + u + 1 >> 1;
            u = l - u;
            d = d + h + 1 >> 1;
            h = d - h;
            n = n + c + 1 >> 1;
            c = n - c;
            s = s + o + 1 >> 1;
            o = s - o;
            S = l * va + d * Ca + 2048 >> 12;
            l = l * Ca - d * va + 2048 >> 12;
            d = S;
            S = h * ka + u * Aa + 2048 >> 12;
            h = h * Aa - u * ka + 2048 >> 12;
            u = S;
            a[e1] = n + d;
            a[e1 + 7] = n - d;
            a[e1 + 1] = s + u;
            a[e1 + 6] = s - u;
            a[e1 + 2] = o + h;
            a[e1 + 5] = o - h;
            a[e1 + 3] = c + l;
            a[e1 + 4] = c - l;
        } else {
            S = Ta * f + 512 >> 10;
            a[e1] = S;
            a[e1 + 1] = S;
            a[e1 + 2] = S;
            a[e1 + 3] = S;
            a[e1 + 4] = S;
            a[e1 + 5] = S;
            a[e1 + 6] = S;
            a[e1 + 7] = S;
        }
    }
    for(let e1 = 0; e1 < 8; ++e1){
        f = a[e1];
        g = a[e1 + 8];
        p = a[e1 + 16];
        m = a[e1 + 24];
        b = a[e1 + 32];
        y = a[e1 + 40];
        w = a[e1 + 48];
        x = a[e1 + 56];
        if (g | p | m | b | y | w | x) {
            n = Ta * f + 2048 >> 12;
            s = Ta * b + 2048 >> 12;
            o = p;
            c = w;
            l = Oa * (g - x) + 2048 >> 12;
            d = Oa * (g + x) + 2048 >> 12;
            h = m;
            u = y;
            n = 4112 + (n + s + 1 >> 1);
            s = n - s;
            S = o * Ia + c * Fa + 2048 >> 12;
            o = o * Fa - c * Ia + 2048 >> 12;
            c = S;
            l = l + u + 1 >> 1;
            u = l - u;
            d = d + h + 1 >> 1;
            h = d - h;
            n = n + c + 1 >> 1;
            c = n - c;
            s = s + o + 1 >> 1;
            o = s - o;
            S = l * va + d * Ca + 2048 >> 12;
            l = l * Ca - d * va + 2048 >> 12;
            d = S;
            S = h * ka + u * Aa + 2048 >> 12;
            h = h * Aa - u * ka + 2048 >> 12;
            u = S;
            f = n + d;
            x = n - d;
            g = s + u;
            w = s - u;
            p = o + h;
            y = o - h;
            m = c + l;
            b = c - l;
            f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4;
            g < 16 ? g = 0 : g >= 4080 ? g = 255 : g >>= 4;
            p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4;
            m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4;
            b < 16 ? b = 0 : b >= 4080 ? b = 255 : b >>= 4;
            y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4;
            w < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4;
            x < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4;
            i[t + e1] = f;
            i[t + e1 + 8] = g;
            i[t + e1 + 16] = p;
            i[t + e1 + 24] = m;
            i[t + e1 + 32] = b;
            i[t + e1 + 40] = y;
            i[t + e1 + 48] = w;
            i[t + e1 + 56] = x;
        } else {
            S = Ta * f + 8192 >> 14;
            S = S < -2040 ? 0 : S >= 2024 ? 255 : S + 2056 >> 4;
            i[t + e1] = S;
            i[t + e1 + 8] = S;
            i[t + e1 + 16] = S;
            i[t + e1 + 24] = S;
            i[t + e1 + 32] = S;
            i[t + e1 + 40] = S;
            i[t + e1 + 48] = S;
            i[t + e1 + 56] = S;
        }
    }
}
function buildComponentData(e1, t) {
    const a = t.blocksPerLine, r = t.blocksPerColumn, i = new Int16Array(64);
    for(let e1 = 0; e1 < r; e1++)for(let r = 0; r < a; r++){
        quantizeAndInverse(t, getBlockBufferOffset(t, e1, r), i);
    }
    return t.blockData;
}
function findNextFileMarker(e1, t, a = t) {
    const r = e1.length - 1;
    let i = a < t ? a : t;
    if (t >= r) return null;
    const n = readUint16(e1, t);
    if (n >= 65472 && n <= 65534) return {
        invalid: null,
        marker: n,
        offset: t
    };
    let s = readUint16(e1, i);
    for(; !(s >= 65472 && s <= 65534);){
        if (++i >= r) return null;
        s = readUint16(e1, i);
    }
    return {
        invalid: n.toString(16),
        marker: s,
        offset: i
    };
}
function prepareComponents(e1) {
    const t = Math.ceil(e1.samplesPerLine / 8 / e1.maxH), a = Math.ceil(e1.scanLines / 8 / e1.maxV);
    for (const r of e1.components){
        const i = Math.ceil(Math.ceil(e1.samplesPerLine / 8) * r.h / e1.maxH), n = Math.ceil(Math.ceil(e1.scanLines / 8) * r.v / e1.maxV), s = t * r.h, o = 64 * (a * r.v) * (s + 1);
        r.blockData = new Int16Array(o);
        r.blocksPerLine = i;
        r.blocksPerColumn = n;
    }
    e1.mcusPerLine = t;
    e1.mcusPerColumn = a;
}
function readDataBlock(e1, t) {
    const a = readUint16(e1, t);
    let r = (t += 2) + a - 2;
    const i = findNextFileMarker(e1, r, t);
    if (i?.invalid) {
        warn("readDataBlock - incorrect length, current marker is: " + i.invalid);
        r = i.offset;
    }
    const n = e1.subarray(t, r);
    return {
        appData: n,
        oldOffset: t,
        newOffset: t + n.length
    };
}
function skipData(e1, t) {
    const a = readUint16(e1, t), r = (t += 2) + a - 2, i = findNextFileMarker(e1, r, t);
    return i?.invalid ? i.offset : r;
}
class JpegImage {
    constructor({ decodeTransform: e1 = null, colorTransform: t = -1 } = {}){
        this._decodeTransform = e1;
        this._colorTransform = t;
    }
    static canUseImageDecoder(e1, t = -1) {
        let a = null, r = 0, i = null, n = readUint16(e1, r);
        r += 2;
        if (65496 !== n) throw new JpegError("SOI not found");
        n = readUint16(e1, r);
        r += 2;
        e: for(; 65497 !== n;){
            switch(n){
                case 65505:
                    const { appData: t, oldOffset: s, newOffset: o } = readDataBlock(e1, r);
                    r = o;
                    if (69 === t[0] && 120 === t[1] && 105 === t[2] && 102 === t[3] && 0 === t[4] && 0 === t[5]) {
                        if (a) throw new JpegError("Duplicate EXIF-blocks found.");
                        a = {
                            exifStart: s + 6,
                            exifEnd: o
                        };
                    }
                    n = readUint16(e1, r);
                    r += 2;
                    continue;
                case 65472:
                case 65473:
                case 65474:
                    i = e1[r + 7];
                    break e;
                case 65535:
                    255 !== e1[r] && r--;
            }
            r = skipData(e1, r);
            n = readUint16(e1, r);
            r += 2;
        }
        return 4 === i || 3 === i && 0 === t ? null : a || {};
    }
    parse(e1, { dnlScanLines: t = null } = {}) {
        let a, r, i = 0, n = null, s = null, o = 0;
        const c = [], l = [], h = [];
        let u = readUint16(e1, i);
        i += 2;
        if (65496 !== u) throw new JpegError("SOI not found");
        u = readUint16(e1, i);
        i += 2;
        e: for(; 65497 !== u;){
            let d, f, g;
            switch(u){
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                    const { appData: p, newOffset: m } = readDataBlock(e1, i);
                    i = m;
                    65504 === u && 74 === p[0] && 70 === p[1] && 73 === p[2] && 70 === p[3] && 0 === p[4] && (n = {
                        version: {
                            major: p[5],
                            minor: p[6]
                        },
                        densityUnits: p[7],
                        xDensity: p[8] << 8 | p[9],
                        yDensity: p[10] << 8 | p[11],
                        thumbWidth: p[12],
                        thumbHeight: p[13],
                        thumbData: p.subarray(14, 14 + 3 * p[12] * p[13])
                    });
                    65518 === u && 65 === p[0] && 100 === p[1] && 111 === p[2] && 98 === p[3] && 101 === p[4] && (s = {
                        version: p[5] << 8 | p[6],
                        flags0: p[7] << 8 | p[8],
                        flags1: p[9] << 8 | p[10],
                        transformCode: p[11]
                    });
                    break;
                case 65499:
                    const b = readUint16(e1, i);
                    i += 2;
                    const y = b + i - 2;
                    let w;
                    for(; i < y;){
                        const t = e1[i++], a = new Uint16Array(64);
                        if (t >> 4) {
                            if (t >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                            for(f = 0; f < 64; f++){
                                w = Sa[f];
                                a[w] = readUint16(e1, i);
                                i += 2;
                            }
                        } else for(f = 0; f < 64; f++){
                            w = Sa[f];
                            a[w] = e1[i++];
                        }
                        c[15 & t] = a;
                    }
                    break;
                case 65472:
                case 65473:
                case 65474:
                    if (a) throw new JpegError("Only single frame JPEGs supported");
                    i += 2;
                    a = {};
                    a.extended = 65473 === u;
                    a.progressive = 65474 === u;
                    a.precision = e1[i++];
                    const x = readUint16(e1, i);
                    i += 2;
                    a.scanLines = t || x;
                    a.samplesPerLine = readUint16(e1, i);
                    i += 2;
                    a.components = [];
                    a.componentIds = {};
                    const S = e1[i++];
                    let k = 0, C = 0;
                    for(d = 0; d < S; d++){
                        const t = e1[i], r = e1[i + 1] >> 4, n = 15 & e1[i + 1];
                        k < r && (k = r);
                        C < n && (C = n);
                        const s = e1[i + 2];
                        g = a.components.push({
                            h: r,
                            v: n,
                            quantizationId: s,
                            quantizationTable: null
                        });
                        a.componentIds[t] = g - 1;
                        i += 3;
                    }
                    a.maxH = k;
                    a.maxV = C;
                    prepareComponents(a);
                    break;
                case 65476:
                    const v = readUint16(e1, i);
                    i += 2;
                    for(d = 2; d < v;){
                        const t = e1[i++], a = new Uint8Array(16);
                        let r = 0;
                        for(f = 0; f < 16; f++, i++)r += a[f] = e1[i];
                        const n = new Uint8Array(r);
                        for(f = 0; f < r; f++, i++)n[f] = e1[i];
                        d += 17 + r;
                        (t >> 4 ? l : h)[15 & t] = buildHuffmanTable(a, n);
                    }
                    break;
                case 65501:
                    i += 2;
                    r = readUint16(e1, i);
                    i += 2;
                    break;
                case 65498:
                    const F = 1 == ++o && !t;
                    i += 2;
                    const T = e1[i++], O = [];
                    for(d = 0; d < T; d++){
                        const t = e1[i++], r = a.componentIds[t], n = a.components[r];
                        n.index = t;
                        const s = e1[i++];
                        n.huffmanTableDC = h[s >> 4];
                        n.huffmanTableAC = l[15 & s];
                        O.push(n);
                    }
                    const M = e1[i++], D = e1[i++], R = e1[i++];
                    try {
                        i += decodeScan(e1, i, a, O, r, M, D, R >> 4, 15 & R, F);
                    } catch (t) {
                        if (t instanceof DNLMarkerError) {
                            warn(`${t.message} -- attempting to re-parse the JPEG image.`);
                            return this.parse(e1, {
                                dnlScanLines: t.scanLines
                            });
                        }
                        if (t instanceof EOIMarkerError) {
                            warn(`${t.message} -- ignoring the rest of the image data.`);
                            break e;
                        }
                        throw t;
                    }
                    break;
                case 65500:
                    i += 4;
                    break;
                case 65535:
                    255 !== e1[i] && i--;
                    break;
                default:
                    const N = findNextFileMarker(e1, i - 2, i - 3);
                    if (N?.invalid) {
                        warn("JpegImage.parse - unexpected data, current marker is: " + N.invalid);
                        i = N.offset;
                        break;
                    }
                    if (!N || i >= e1.length - 1) {
                        warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e;
                    }
                    throw new JpegError("JpegImage.parse - unknown marker: " + u.toString(16));
            }
            u = readUint16(e1, i);
            i += 2;
        }
        if (!a) throw new JpegError("JpegImage.parse - no frame data found.");
        this.width = a.samplesPerLine;
        this.height = a.scanLines;
        this.jfif = n;
        this.adobe = s;
        this.components = [];
        for (const e1 of a.components){
            const t = c[e1.quantizationId];
            t && (e1.quantizationTable = t);
            this.components.push({
                index: e1.index,
                output: buildComponentData(0, e1),
                scaleX: e1.h / a.maxH,
                scaleY: e1.v / a.maxV,
                blocksPerLine: e1.blocksPerLine,
                blocksPerColumn: e1.blocksPerColumn
            });
        }
        this.numComponents = this.components.length;
    }
    _getLinearizedBlockData(e1, t, a = !1) {
        const r = this.width / e1, i = this.height / t;
        let n, s, o, c, l, h, u, d, f, g, p, m = 0;
        const b = this.components.length, y = e1 * t * b, w = new Uint8ClampedArray(y), x = new Uint32Array(e1), S = 4294967288;
        let k;
        for(u = 0; u < b; u++){
            n = this.components[u];
            s = n.scaleX * r;
            o = n.scaleY * i;
            m = u;
            p = n.output;
            c = n.blocksPerLine + 1 << 3;
            if (s !== k) {
                for(l = 0; l < e1; l++){
                    d = 0 | l * s;
                    x[l] = (d & S) << 3 | 7 & d;
                }
                k = s;
            }
            for(h = 0; h < t; h++){
                d = 0 | h * o;
                g = c * (d & S) | (7 & d) << 3;
                for(l = 0; l < e1; l++){
                    w[m] = p[g + x[l]];
                    m += b;
                }
            }
        }
        let C = this._decodeTransform;
        a || 4 !== b || C || (C = new Int32Array([
            -256,
            255,
            -256,
            255,
            -256,
            255,
            -256,
            255
        ]));
        if (C) for(u = 0; u < y;)for(d = 0, f = 0; d < b; d++, u++, f += 2)w[u] = (w[u] * C[f] >> 8) + C[f + 1];
        return w;
    }
    get _isColorConversionNeeded() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
    }
    _convertYccToRgb(e1) {
        let t, a, r;
        for(let i = 0, n = e1.length; i < n; i += 3){
            t = e1[i];
            a = e1[i + 1];
            r = e1[i + 2];
            e1[i] = t - 179.456 + 1.402 * r;
            e1[i + 1] = t + 135.459 - .344 * a - .714 * r;
            e1[i + 2] = t - 226.816 + 1.772 * a;
        }
        return e1;
    }
    _convertYccToRgba(e1, t) {
        for(let a = 0, r = 0, i = e1.length; a < i; a += 3, r += 4){
            const i = e1[a], n = e1[a + 1], s = e1[a + 2];
            t[r] = i - 179.456 + 1.402 * s;
            t[r + 1] = i + 135.459 - .344 * n - .714 * s;
            t[r + 2] = i - 226.816 + 1.772 * n;
            t[r + 3] = 255;
        }
        return t;
    }
    _convertYcckToRgb(e1) {
        this._convertYcckToCmyk(e1);
        return this._convertCmykToRgb(e1);
    }
    _convertYcckToRgba(e1) {
        this._convertYcckToCmyk(e1);
        return this._convertCmykToRgba(e1);
    }
    _convertYcckToCmyk(e1) {
        let t, a, r;
        for(let i = 0, n = e1.length; i < n; i += 4){
            t = e1[i];
            a = e1[i + 1];
            r = e1[i + 2];
            e1[i] = 434.456 - t - 1.402 * r;
            e1[i + 1] = 119.541 - t + .344 * a + .714 * r;
            e1[i + 2] = 481.816 - t - 1.772 * a;
        }
        return e1;
    }
    _convertCmykToRgb(e1) {
        const t = e1.length / 4;
        ColorSpaceUtils.cmyk.getRgbBuffer(e1, 0, t, e1, 0, 8, 0);
        return e1.subarray(0, 3 * t);
    }
    _convertCmykToRgba(e1) {
        ColorSpaceUtils.cmyk.getRgbBuffer(e1, 0, e1.length / 4, e1, 0, 8, 1);
        if (ColorSpaceUtils.cmyk instanceof DeviceCmykCS) for(let t = 3, a = e1.length; t < a; t += 4)e1[t] = 255;
        return e1;
    }
    getData({ width: e1, height: t, forceRGBA: a = !1, forceRGB: r = !1, isSourcePDF: i = !1 }) {
        if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
        const n = this._getLinearizedBlockData(e1, t, i);
        if (1 === this.numComponents && (a || r)) {
            const e1 = n.length * (a ? 4 : 3), t = new Uint8ClampedArray(e1);
            let r = 0;
            if (a) !function grayToRGBA(e1, t) {
                if (FeatureTest.isLittleEndian) for(let a = 0, r = e1.length; a < r; a++)t[a] = 65793 * e1[a] | 4278190080;
                else for(let a = 0, r = e1.length; a < r; a++)t[a] = 16843008 * e1[a] | 255;
            }(n, new Uint32Array(t.buffer));
            else for (const e1 of n){
                t[r++] = e1;
                t[r++] = e1;
                t[r++] = e1;
            }
            return t;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded) {
            if (a) {
                const e1 = new Uint8ClampedArray(n.length / 3 * 4);
                return this._convertYccToRgba(n, e1);
            }
            return this._convertYccToRgb(n);
        }
        if (4 === this.numComponents) {
            if (this._isColorConversionNeeded) return a ? this._convertYcckToRgba(n) : r ? this._convertYcckToRgb(n) : this._convertYcckToCmyk(n);
            if (a) return this._convertCmykToRgba(n);
            if (r) return this._convertCmykToRgb(n);
        }
        return n;
    }
}
class JpegStream extends DecodeStream {
    static #M = FeatureTest.isImageDecoderSupported;
    constructor(e1, t, a){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = a;
    }
    static get canUseImageDecoder() {
        return shadow(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
    }
    static setOptions({ isImageDecoderSupported: e1 = !1 }) {
        this.#M = e1;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    get jpegOptions() {
        const e1 = {
            decodeTransform: void 0,
            colorTransform: void 0
        }, t = this.dict.getArray("D", "Decode");
        if ((this.forceRGBA || this.forceRGB) && Array.isArray(t)) {
            const a = this.dict.get("BPC", "BitsPerComponent") || 8, r = t.length, i = new Int32Array(r);
            let n = !1;
            const s = (1 << a) - 1;
            for(let e1 = 0; e1 < r; e1 += 2){
                i[e1] = 256 * (t[e1 + 1] - t[e1]) | 0;
                i[e1 + 1] = t[e1] * s | 0;
                256 === i[e1] && 0 === i[e1 + 1] || (n = !0);
            }
            n && (e1.decodeTransform = i);
        }
        if (this.params instanceof Dict) {
            const t = this.params.get("ColorTransform");
            Number.isInteger(t) && (e1.colorTransform = t);
        }
        return shadow(this, "jpegOptions", e1);
    }
    #N(e1) {
        for(let t = 0, a = e1.length - 1; t < a; t++)if (255 === e1[t] && 216 === e1[t + 1]) {
            t > 0 && (e1 = e1.subarray(t));
            break;
        }
        return e1;
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 = this.#N(e1 || this.bytes);
        const t = new JpegImage(this.jpegOptions);
        t.parse(e1);
        const a = t.getData({
            width: this.drawWidth,
            height: this.drawHeight,
            forceRGBA: this.forceRGBA,
            forceRGB: this.forceRGB,
            isSourcePDF: !0
        });
        this.buffer = a;
        this.bufferLength = a.length;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
    async getTransferableImage() {
        if (!await JpegStream.canUseImageDecoder) return null;
        const e1 = this.jpegOptions;
        if (e1.decodeTransform) return null;
        let t;
        try {
            const a = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
            if (!a) return null;
            let r = this.#N(a);
            const i = JpegImage.canUseImageDecoder(r, e1.colorTransform);
            if (!i) return null;
            if (i.exifStart) {
                r = r.slice();
                r.fill(0, i.exifStart, i.exifEnd);
            }
            t = new ImageDecoder({
                data: r,
                type: "image/jpeg",
                preferAnimation: !1
            });
            return (await t.decode()).image;
        } catch (e1) {
            warn(`getTransferableImage - failed: "${e1}".`);
            return null;
        } finally{
            t?.close();
        }
    }
}
var OpenJPEG = async function(e1 = {}) {
    var t, a, r = e1, i = new Promise((e1, r)=>{
        t = e1;
        a = r;
    }), n = "./this.program", quit_ = (e1, t)=>{
        throw t;
    }, s = __TURBOPACK__import$2e$meta__.url;
    try {
        new URL(".", s).href;
    } catch  {}
    var o, c, l, h, u, d, f = console.log.bind(console), g = console.error.bind(console), p = !1;
    function updateMemoryViews() {
        var e1 = o.buffer;
        l = new Int8Array(e1);
        new Int16Array(e1);
        h = new Uint8Array(e1);
        new Uint16Array(e1);
        u = new Int32Array(e1);
        d = new Uint32Array(e1);
        new Float32Array(e1);
        new Float64Array(e1);
        new BigInt64Array(e1);
        new BigUint64Array(e1);
    }
    var m = 0, b = null;
    class ExitStatus {
        name = "ExitStatus";
        constructor(e1){
            this.message = `Program terminated with exit(${e1})`;
            this.status = e1;
        }
    }
    var callRuntimeCallbacks = (e1)=>{
        for(; e1.length > 0;)e1.shift()(r);
    }, y = [], addOnPostRun = (e1)=>y.push(e1), w = [], addOnPreRun = (e1)=>w.push(e1), x = !0, S = 0, k = {}, handleException = (e1)=>{
        if (e1 instanceof ExitStatus || "unwind" == e1) return c;
        quit_(0, e1);
    }, keepRuntimeAlive = ()=>x || S > 0, _proc_exit = (e1)=>{
        c = e1;
        if (!keepRuntimeAlive()) {
            r.onExit?.(e1);
            p = !0;
        }
        quit_(0, new ExitStatus(e1));
    }, _exit = (e1, t)=>{
        c = e1;
        _proc_exit(e1);
    }, callUserCallback = (e1)=>{
        if (!p) try {
            e1();
            (()=>{
                if (!keepRuntimeAlive()) try {
                    _exit(c);
                } catch (e1) {
                    handleException(e1);
                }
            })();
        } catch (e1) {
            handleException(e1);
        }
    }, growMemory = (e1)=>{
        var t = (e1 - o.buffer.byteLength + 65535) / 65536 | 0;
        try {
            o.grow(t);
            updateMemoryViews();
            return 1;
        } catch (e1) {}
    }, C = {}, getEnvStrings = ()=>{
        if (!getEnvStrings.strings) {
            var e1 = {
                USER: "web_user",
                LOGNAME: "web_user",
                PATH: "/",
                PWD: "/",
                HOME: "/home/web_user",
                LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                _: n || "./this.program"
            };
            for(var t in C)void 0 === C[t] ? delete e1[t] : e1[t] = C[t];
            var a = [];
            for(var t in e1)a.push(`${t}=${e1[t]}`);
            getEnvStrings.strings = a;
        }
        return getEnvStrings.strings;
    }, lengthBytesUTF8 = (e1)=>{
        for(var t = 0, a = 0; a < e1.length; ++a){
            var r = e1.charCodeAt(a);
            if (r <= 127) t++;
            else if (r <= 2047) t += 2;
            else if (r >= 55296 && r <= 57343) {
                t += 4;
                ++a;
            } else t += 3;
        }
        return t;
    }, v = [
        null,
        [],
        []
    ], F = "undefined" != typeof TextDecoder ? new TextDecoder : void 0, UTF8ArrayToString = (e1, t = 0, a = NaN)=>{
        for(var r = t + a, i = t; e1[i] && !(i >= r);)++i;
        if (i - t > 16 && e1.buffer && F) return F.decode(e1.subarray(t, i));
        for(var n = ""; t < i;){
            var s = e1[t++];
            if (128 & s) {
                var o = 63 & e1[t++];
                if (192 != (224 & s)) {
                    var c = 63 & e1[t++];
                    if ((s = 224 == (240 & s) ? (15 & s) << 12 | o << 6 | c : (7 & s) << 18 | o << 12 | c << 6 | 63 & e1[t++]) < 65536) n += String.fromCharCode(s);
                    else {
                        var l = s - 65536;
                        n += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);
                    }
                } else n += String.fromCharCode((31 & s) << 6 | o);
            } else n += String.fromCharCode(s);
        }
        return n;
    }, printChar = (e1, t)=>{
        var a = v[e1];
        if (0 === t || 10 === t) {
            (1 === e1 ? f : g)(UTF8ArrayToString(a));
            a.length = 0;
        } else a.push(t);
    }, UTF8ToString = (e1, t)=>e1 ? UTF8ArrayToString(h, e1, t) : "";
    r.noExitRuntime && (x = r.noExitRuntime);
    r.print && (f = r.print);
    r.printErr && (g = r.printErr);
    r.wasmBinary && r.wasmBinary;
    r.arguments && r.arguments;
    r.thisProgram && (n = r.thisProgram);
    r.writeArrayToMemory = (e1, t)=>{
        l.set(e1, t);
    };
    var T = {
        l: ()=>(function abort(e1) {
                r.onAbort?.(e1);
                g(e1 = "Aborted(" + e1 + ")");
                p = !0;
                e1 += ". Build with -sASSERTIONS for more info.";
                var t = new WebAssembly.RuntimeError(e1);
                a(t);
                throw t;
            })(""),
        k: ()=>{
            x = !1;
            S = 0;
        },
        m: (e1, t)=>{
            if (k[e1]) {
                clearTimeout(k[e1].id);
                delete k[e1];
            }
            if (!t) return 0;
            var a = setTimeout(()=>{
                delete k[e1];
                callUserCallback(()=>M(e1, performance.now()));
            }, t);
            k[e1] = {
                id: a,
                timeout_ms: t
            };
            return 0;
        },
        g: function _copy_pixels_1(e1, t) {
            e1 >>= 2;
            const a = r.imageData = new Uint8ClampedArray(t), i = u.subarray(e1, e1 + t);
            a.set(i);
        },
        f: function _copy_pixels_3(e1, t, a, i) {
            e1 >>= 2;
            t >>= 2;
            a >>= 2;
            const n = r.imageData = new Uint8ClampedArray(3 * i), s = u.subarray(e1, e1 + i), o = u.subarray(t, t + i), c = u.subarray(a, a + i);
            for(let e1 = 0; e1 < i; e1++){
                n[3 * e1] = s[e1];
                n[3 * e1 + 1] = o[e1];
                n[3 * e1 + 2] = c[e1];
            }
        },
        e: function _copy_pixels_4(e1, t, a, i, n) {
            e1 >>= 2;
            t >>= 2;
            a >>= 2;
            i >>= 2;
            const s = r.imageData = new Uint8ClampedArray(4 * n), o = u.subarray(e1, e1 + n), c = u.subarray(t, t + n), l = u.subarray(a, a + n), h = u.subarray(i, i + n);
            for(let e1 = 0; e1 < n; e1++){
                s[4 * e1] = o[e1];
                s[4 * e1 + 1] = c[e1];
                s[4 * e1 + 2] = l[e1];
                s[4 * e1 + 3] = h[e1];
            }
        },
        n: (e1)=>{
            var t, a, r = h.length, i = 2147483648;
            if ((e1 >>>= 0) > i) return !1;
            for(var n = 1; n <= 4; n *= 2){
                var s = r * (1 + .2 / n);
                s = Math.min(s, e1 + 100663296);
                var o = Math.min(i, (t = Math.max(e1, s), a = 65536, Math.ceil(t / a) * a));
                if (growMemory(o)) return !0;
            }
            return !1;
        },
        p: (e1, t)=>{
            var a = 0, r = 0;
            for (var i of getEnvStrings()){
                var n = t + a;
                d[e1 + r >> 2] = n;
                a += ((e1, t, a, r)=>{
                    if (!(r > 0)) return 0;
                    for(var i = a, n = a + r - 1, s = 0; s < e1.length; ++s){
                        var o = e1.charCodeAt(s);
                        o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e1.charCodeAt(++s));
                        if (o <= 127) {
                            if (a >= n) break;
                            t[a++] = o;
                        } else if (o <= 2047) {
                            if (a + 1 >= n) break;
                            t[a++] = 192 | o >> 6;
                            t[a++] = 128 | 63 & o;
                        } else if (o <= 65535) {
                            if (a + 2 >= n) break;
                            t[a++] = 224 | o >> 12;
                            t[a++] = 128 | o >> 6 & 63;
                            t[a++] = 128 | 63 & o;
                        } else {
                            if (a + 3 >= n) break;
                            t[a++] = 240 | o >> 18;
                            t[a++] = 128 | o >> 12 & 63;
                            t[a++] = 128 | o >> 6 & 63;
                            t[a++] = 128 | 63 & o;
                        }
                    }
                    t[a] = 0;
                    return a - i;
                })(i, h, n, 1 / 0) + 1;
                r += 4;
            }
            return 0;
        },
        q: (e1, t)=>{
            var a = getEnvStrings();
            d[e1 >> 2] = a.length;
            var r = 0;
            for (var i of a)r += lengthBytesUTF8(i) + 1;
            d[t >> 2] = r;
            return 0;
        },
        b: (e1)=>52,
        o: function _fd_seek(e1, t, a, r) {
            t = (i = t) < -9007199254740992 || i > 9007199254740992 ? NaN : Number(i);
            var i;
            return 70;
        },
        c: (e1, t, a, r)=>{
            for(var i = 0, n = 0; n < a; n++){
                var s = d[t >> 2], o = d[t + 4 >> 2];
                t += 8;
                for(var c = 0; c < o; c++)printChar(e1, h[s + c]);
                i += o;
            }
            d[r >> 2] = i;
            return 0;
        },
        r: function _gray_to_rgba(e1, t) {
            e1 >>= 2;
            const a = r.imageData = new Uint8ClampedArray(4 * t), i = u.subarray(e1, e1 + t);
            for(let e1 = 0; e1 < t; e1++){
                a[4 * e1] = a[4 * e1 + 1] = a[4 * e1 + 2] = i[e1];
                a[4 * e1 + 3] = 255;
            }
        },
        i: function _graya_to_rgba(e1, t, a) {
            e1 >>= 2;
            t >>= 2;
            const i = r.imageData = new Uint8ClampedArray(4 * a), n = u.subarray(e1, e1 + a), s = u.subarray(t, t + a);
            for(let e1 = 0; e1 < a; e1++){
                i[4 * e1] = i[4 * e1 + 1] = i[4 * e1 + 2] = n[e1];
                i[4 * e1 + 3] = s[e1];
            }
        },
        d: function _jsPrintWarning(e1) {
            const t = UTF8ToString(e1);
            (r.warn || console.warn)(`OpenJPEG: ${t}`);
        },
        j: _proc_exit,
        h: function _rgb_to_rgba(e1, t, a, i) {
            e1 >>= 2;
            t >>= 2;
            a >>= 2;
            const n = r.imageData = new Uint8ClampedArray(4 * i), s = u.subarray(e1, e1 + i), o = u.subarray(t, t + i), c = u.subarray(a, a + i);
            for(let e1 = 0; e1 < i; e1++){
                n[4 * e1] = s[e1];
                n[4 * e1 + 1] = o[e1];
                n[4 * e1 + 2] = c[e1];
                n[4 * e1 + 3] = 255;
            }
        },
        a: function _storeErrorMessage(e1) {
            const t = UTF8ToString(e1);
            r.errorMessages ? r.errorMessages += "\n" + t : r.errorMessages = t;
        }
    }, O = await async function createWasm() {
        function receiveInstance(e1, t) {
            O = e1.exports;
            o = O.s;
            updateMemoryViews();
            !function removeRunDependency(e1) {
                m--;
                r.monitorRunDependencies?.(m);
                if (0 == m && b) {
                    var t = b;
                    b = null;
                    t();
                }
            }();
            return O;
        }
        !function addRunDependency(e1) {
            m++;
            r.monitorRunDependencies?.(m);
        }();
        var e1 = function getWasmImports() {
            return {
                a: T
            };
        }();
        return new Promise((t, a)=>{
            r.instantiateWasm(e1, (e1, a)=>{
                t(receiveInstance(e1));
            });
        });
    }(), M = (O.t, r._malloc = O.u, r._free = O.v, r._jp2_decode = O.w, O.x);
    !function preInit() {
        if (r.preInit) {
            "function" == typeof r.preInit && (r.preInit = [
                r.preInit
            ]);
            for(; r.preInit.length > 0;)r.preInit.shift()();
        }
    }();
    !function run() {
        if (m > 0) b = run;
        else {
            !function preRun() {
                if (r.preRun) {
                    "function" == typeof r.preRun && (r.preRun = [
                        r.preRun
                    ]);
                    for(; r.preRun.length;)addOnPreRun(r.preRun.shift());
                }
                callRuntimeCallbacks(w);
            }();
            if (m > 0) b = run;
            else if (r.setStatus) {
                r.setStatus("Running...");
                setTimeout(()=>{
                    setTimeout(()=>r.setStatus(""), 1);
                    doRun();
                }, 1);
            } else doRun();
        }
        function doRun() {
            r.calledRun = !0;
            if (!p) {
                !function initRuntime() {
                    O.t();
                }();
                t(r);
                r.onRuntimeInitialized?.();
                !function postRun() {
                    if (r.postRun) {
                        "function" == typeof r.postRun && (r.postRun = [
                            r.postRun
                        ]);
                        for(; r.postRun.length;)addOnPostRun(r.postRun.shift());
                    }
                    callRuntimeCallbacks(y);
                }();
            }
        }
    }();
    return i;
};
const Ma = OpenJPEG;
class JpxError extends Jt {
    constructor(e1){
        super(e1, "JpxError");
    }
}
class JpxImage {
    static #E = null;
    static #P = null;
    static #L = null;
    static #v = !0;
    static #j = !0;
    static #F = null;
    static setOptions({ handler: e1, useWasm: t, useWorkerFetch: a, wasmUrl: r }) {
        this.#v = t;
        this.#j = a;
        this.#F = r;
        a || (this.#P = e1);
    }
    static async #_(e1) {
        const t = `${this.#F}openjpeg_nowasm_fallback.js`;
        let a = null;
        try {
            a = (await import(/*webpackIgnore: true*/ /*@vite-ignore*/ t)).default();
        } catch (e1) {
            warn(`JpxImage#getJsModule: ${e1}`);
        }
        e1(a);
    }
    static async #U(e1, t, a) {
        const r = "openjpeg.wasm";
        try {
            this.#E || (this.#j ? this.#E = await fetchBinaryData(`${this.#F}${r}`) : this.#E = await this.#P.sendWithPromise("FetchBinaryData", {
                type: "wasmFactory",
                filename: r
            }));
            return a((await WebAssembly.instantiate(this.#E, t)).instance);
        } catch (t) {
            warn(`JpxImage#instantiateWasm: ${t}`);
            this.#_(e1);
            return null;
        } finally{
            this.#P = null;
        }
    }
    static async decode(e1, { numComponents: t = 4, isIndexedColormap: a = !1, smaskInData: r = !1, reducePower: i = 0 } = {}) {
        if (!this.#L) {
            const { promise: e1, resolve: t } = Promise.withResolvers(), a = [
                e1
            ];
            this.#v ? a.push(Ma({
                warn,
                instantiateWasm: this.#U.bind(this, t)
            })) : this.#_(t);
            this.#L = Promise.race(a);
        }
        const n = await this.#L;
        if (!n) throw new JpxError("OpenJPEG failed to initialize");
        let s;
        try {
            const o = e1.length;
            s = n._malloc(o);
            n.writeArrayToMemory(e1, s);
            if (n._jp2_decode(s, o, t > 0 ? t : 0, !!a, !!r, i)) {
                const { errorMessages: e1 } = n;
                if (e1) {
                    delete n.errorMessages;
                    throw new JpxError(e1);
                }
                throw new JpxError("Unknown error");
            }
            const { imageData: c } = n;
            n.imageData = null;
            return c;
        } finally{
            s && n._free(s);
        }
    }
    static cleanup() {
        this.#L = null;
    }
    static parseImageProperties(e1) {
        let t = e1.getByte();
        for(; t >= 0;){
            const a = t;
            t = e1.getByte();
            if (65361 === (a << 8 | t)) {
                e1.skip(4);
                const t = e1.getInt32() >>> 0, a = e1.getInt32() >>> 0, r = e1.getInt32() >>> 0, i = e1.getInt32() >>> 0;
                e1.skip(16);
                return {
                    width: t - r,
                    height: a - i,
                    bitsPerComponent: 8,
                    componentsCount: e1.getUint16()
                };
            }
        }
        throw new JpxError("No size marker found in JPX stream");
    }
}
function addState(e1, t, a, r, i) {
    let n = e1;
    for(let e1 = 0, a = t.length - 1; e1 < a; e1++){
        const a = t[e1];
        n = n[a] ||= [];
    }
    n[t.at(-1)] = {
        checkFn: a,
        iterateFn: r,
        processFn: i
    };
}
const Da = [];
addState(Da, [
    pe,
    be,
    Nt,
    me
], null, function iterateInlineImageGroup(e1, t) {
    const a = e1.fnArray, r = (t - (e1.iCurr - 3)) % 4;
    switch(r){
        case 0:
            return a[t] === pe;
        case 1:
            return a[t] === be;
        case 2:
            return a[t] === Nt;
        case 3:
            return a[t] === me;
    }
    throw new Error(`iterateInlineImageGroup - invalid pos: ${r}`);
}, function foundInlineImageGroup(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = e1.iCurr, n = i - 3, s = i - 2, o = i - 1, c = Math.min(Math.floor((t - n) / 4), 200);
    if (c < 10) return t - (t - n) % 4;
    let l = 0;
    const h = [];
    let u = 0, d = 1, f = 1;
    for(let e1 = 0; e1 < c; e1++){
        const t = r[s + (e1 << 2)], a = r[o + (e1 << 2)][0];
        if (d + a.width > 1e3) {
            l = Math.max(l, d);
            f += u + 2;
            d = 0;
            u = 0;
        }
        h.push({
            transform: t,
            x: d,
            y: f,
            w: a.width,
            h: a.height
        });
        d += a.width + 2;
        u = Math.max(u, a.height);
    }
    const g = Math.max(l, d) + 1, p = f + u + 1, m = new Uint8Array(g * p * 4), b = g << 2;
    for(let e1 = 0; e1 < c; e1++){
        const t = r[o + (e1 << 2)][0].data, a = h[e1].w << 2;
        let i = 0, n = h[e1].x + h[e1].y * g << 2;
        m.set(t.subarray(0, a), n - b);
        for(let r = 0, s = h[e1].h; r < s; r++){
            m.set(t.subarray(i, i + a), n);
            i += a;
            n += b;
        }
        m.set(t.subarray(i - a, i), n);
        for(; n >= 0;){
            t[n - 4] = t[n];
            t[n - 3] = t[n + 1];
            t[n - 2] = t[n + 2];
            t[n - 1] = t[n + 3];
            t[n + a] = t[n + a - 4];
            t[n + a + 1] = t[n + a - 3];
            t[n + a + 2] = t[n + a - 2];
            t[n + a + 3] = t[n + a - 1];
            n -= b;
        }
    }
    const y = {
        width: g,
        height: p
    };
    if (e1.isOffscreenCanvasSupported) {
        const e1 = new OffscreenCanvas(g, p);
        e1.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(m.buffer), g, p), 0, 0);
        y.bitmap = e1.transferToImageBitmap();
        y.data = null;
    } else {
        y.kind = v;
        y.data = m;
    }
    a.splice(n, 4 * c, Et);
    r.splice(n, 4 * c, [
        y,
        h
    ]);
    return n + 1;
});
addState(Da, [
    pe,
    be,
    Dt,
    me
], null, function iterateImageMaskGroup(e1, t) {
    const a = e1.fnArray, r = (t - (e1.iCurr - 3)) % 4;
    switch(r){
        case 0:
            return a[t] === pe;
        case 1:
            return a[t] === be;
        case 2:
            return a[t] === Dt;
        case 3:
            return a[t] === me;
    }
    throw new Error(`iterateImageMaskGroup - invalid pos: ${r}`);
}, function foundImageMaskGroup(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = e1.iCurr, n = i - 3, s = i - 2, o = i - 1;
    let c = Math.floor((t - n) / 4);
    if (c < 10) return t - (t - n) % 4;
    let l, h, u = !1;
    const d = r[o][0], f = r[s][0], g = r[s][1], p = r[s][2], m = r[s][3];
    if (g === p) {
        u = !0;
        l = s + 4;
        let e1 = o + 4;
        for(let t = 1; t < c; t++, l += 4, e1 += 4){
            h = r[l];
            if (r[e1][0] !== d || h[0] !== f || h[1] !== g || h[2] !== p || h[3] !== m) {
                t < 10 ? u = !1 : c = t;
                break;
            }
        }
    }
    if (u) {
        c = Math.min(c, 1e3);
        const e1 = new Float32Array(2 * c);
        l = s;
        for(let t = 0; t < c; t++, l += 4){
            h = r[l];
            e1[t << 1] = h[4];
            e1[1 + (t << 1)] = h[5];
        }
        a.splice(n, 4 * c, Lt);
        r.splice(n, 4 * c, [
            d,
            f,
            g,
            p,
            m,
            e1
        ]);
    } else {
        c = Math.min(c, 100);
        const e1 = [];
        for(let t = 0; t < c; t++){
            h = r[s + (t << 2)];
            const a = r[o + (t << 2)][0];
            e1.push({
                data: a.data,
                width: a.width,
                height: a.height,
                interpolate: a.interpolate,
                count: a.count,
                transform: h
            });
        }
        a.splice(n, 4 * c, Bt);
        r.splice(n, 4 * c, [
            e1
        ]);
    }
    return n + 1;
});
addState(Da, [
    pe,
    be,
    Rt,
    me
], function(e1) {
    const t = e1.argsArray, a = e1.iCurr - 2;
    return 0 === t[a][1] && 0 === t[a][2];
}, function iterateImageGroup(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = (t - (e1.iCurr - 3)) % 4;
    switch(i){
        case 0:
            return a[t] === pe;
        case 1:
            if (a[t] !== be) return !1;
            const i1 = e1.iCurr - 2, n = r[i1][0], s = r[i1][3];
            return r[t][0] === n && 0 === r[t][1] && 0 === r[t][2] && r[t][3] === s;
        case 2:
            if (a[t] !== Rt) return !1;
            const o = r[e1.iCurr - 1][0];
            return r[t][0] === o;
        case 3:
            return a[t] === me;
    }
    throw new Error(`iterateImageGroup - invalid pos: ${i}`);
}, function(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = e1.iCurr, n = i - 3, s = i - 2, o = r[i - 1][0], c = r[s][0], l = r[s][3], h = Math.min(Math.floor((t - n) / 4), 1e3);
    if (h < 3) return t - (t - n) % 4;
    const u = new Float32Array(2 * h);
    let d = s;
    for(let e1 = 0; e1 < h; e1++, d += 4){
        const t = r[d];
        u[e1 << 1] = t[4];
        u[1 + (e1 << 1)] = t[5];
    }
    const f = [
        o,
        c,
        l,
        u
    ];
    a.splice(n, 4 * h, Pt);
    r.splice(n, 4 * h, f);
    return n + 1;
});
addState(Da, [
    Pe,
    qe,
    Ge,
    Ke,
    Le
], null, function iterateShowTextGroup(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = (t - (e1.iCurr - 4)) % 5;
    switch(i){
        case 0:
            return a[t] === Pe;
        case 1:
            return a[t] === qe;
        case 2:
            return a[t] === Ge;
        case 3:
            if (a[t] !== Ke) return !1;
            const i1 = e1.iCurr - 3, n = r[i1][0], s = r[i1][1];
            return r[t][0] === n && r[t][1] === s;
        case 4:
            return a[t] === Le;
    }
    throw new Error(`iterateShowTextGroup - invalid pos: ${i}`);
}, function(e1, t) {
    const a = e1.fnArray, r = e1.argsArray, i = e1.iCurr, n = i - 4, s = i - 3, o = i - 2, c = i - 1, l = i, h = r[s][0], u = r[s][1];
    let d = Math.min(Math.floor((t - n) / 5), 1e3);
    if (d < 3) return t - (t - n) % 5;
    let f = n;
    if (n >= 4 && a[n - 4] === a[s] && a[n - 3] === a[o] && a[n - 2] === a[c] && a[n - 1] === a[l] && r[n - 4][0] === h && r[n - 4][1] === u) {
        d++;
        f -= 5;
    }
    let g = f + 4;
    for(let e1 = 1; e1 < d; e1++){
        a.splice(g, 3);
        r.splice(g, 3);
        g += 2;
    }
    return g + 1;
});
addState(Da, [
    pe,
    be,
    _t,
    me
], (e1)=>{
    const t = e1.argsArray, a = t[e1.iCurr - 1][0];
    if (a !== ve && a !== Fe && a !== Oe && a !== Me && a !== De && a !== Be) return !0;
    const r = t[e1.iCurr - 2];
    return 1 === r[0] && 0 === r[1] && 0 === r[2] && 1 === r[3];
}, ()=>!1, (e1, t)=>{
    const { fnArray: a, argsArray: r } = e1, i = e1.iCurr, n = i - 3, s = i - 2, o = r[i - 1], c = r[s], [, [l], h] = o;
    if (h) {
        Util.scaleMinMax(c, h);
        for(let e1 = 0, t = l.length; e1 < t;)switch(l[e1++]){
            case Ht:
            case Wt:
                Util.applyTransform(l, c, e1);
                e1 += 2;
                break;
            case zt:
                Util.applyTransformToBezier(l, c, e1);
                e1 += 6;
        }
    }
    a.splice(n, 4, _t);
    r.splice(n, 4, o);
    return n + 1;
});
class NullOptimizer {
    constructor(e1){
        this.queue = e1;
    }
    _optimize() {}
    push(e1, t) {
        this.queue.fnArray.push(e1);
        this.queue.argsArray.push(t);
        this._optimize();
    }
    flush() {}
    reset() {}
}
class QueueOptimizer extends NullOptimizer {
    constructor(e1){
        super(e1);
        this.state = null;
        this.context = {
            iCurr: 0,
            fnArray: e1.fnArray,
            argsArray: e1.argsArray,
            isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported
        };
        this.match = null;
        this.lastProcessed = 0;
    }
    _optimize() {
        const e1 = this.queue.fnArray;
        let t = this.lastProcessed, a = e1.length, r = this.state, i = this.match;
        if (!r && !i && t + 1 === a && !Da[e1[t]]) {
            this.lastProcessed = a;
            return;
        }
        const n = this.context;
        for(; t < a;){
            if (i) {
                if ((0, i.iterateFn)(n, t)) {
                    t++;
                    continue;
                }
                t = (0, i.processFn)(n, t + 1);
                a = e1.length;
                i = null;
                r = null;
                if (t >= a) break;
            }
            r = (r || Da)[e1[t]];
            if (r && !Array.isArray(r)) {
                n.iCurr = t;
                t++;
                if (!r.checkFn || (0, r.checkFn)(n)) {
                    i = r;
                    r = null;
                } else r = null;
            } else t++;
        }
        this.state = r;
        this.match = i;
        this.lastProcessed = t;
    }
    flush() {
        for(; this.match;){
            const e1 = this.queue.fnArray.length;
            this.lastProcessed = (0, this.match.processFn)(this.context, e1);
            this.match = null;
            this.state = null;
            this._optimize();
        }
    }
    reset() {
        this.state = null;
        this.match = null;
        this.lastProcessed = 0;
    }
}
class OperatorList {
    static CHUNK_SIZE = 1e3;
    static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
    static isOffscreenCanvasSupported = !1;
    constructor(e1 = 0, t){
        this._streamSink = t;
        this.fnArray = [];
        this.argsArray = [];
        this.optimizer = !t || e1 & d ? new NullOptimizer(this) : new QueueOptimizer(this);
        this.dependencies = new Set;
        this._totalLength = 0;
        this.weight = 0;
        this._resolved = t ? null : Promise.resolve();
    }
    static setOptions({ isOffscreenCanvasSupported: e1 }) {
        this.isOffscreenCanvasSupported = e1;
    }
    get length() {
        return this.argsArray.length;
    }
    get ready() {
        return this._resolved || this._streamSink.ready;
    }
    get totalLength() {
        return this._totalLength + this.length;
    }
    addOp(e1, t) {
        this.optimizer.push(e1, t);
        this.weight++;
        this._streamSink && (this.weight >= OperatorList.CHUNK_SIZE || this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (e1 === me || e1 === Le)) && this.flush();
    }
    addImageOps(e1, t, a, r = !1) {
        if (r) {
            this.addOp(pe);
            this.addOp(ge, [
                [
                    [
                        "SMask",
                        !1
                    ]
                ]
            ]);
        }
        void 0 !== a && this.addOp(St, [
            "OC",
            a
        ]);
        this.addOp(e1, t);
        void 0 !== a && this.addOp(At, []);
        r && this.addOp(me);
    }
    addDependency(e1) {
        if (!this.dependencies.has(e1)) {
            this.dependencies.add(e1);
            this.addOp(se, [
                e1
            ]);
        }
    }
    addDependencies(e1) {
        for (const t of e1)this.addDependency(t);
    }
    addOpList(e1) {
        if (e1 instanceof OperatorList) {
            for (const t of e1.dependencies)this.dependencies.add(t);
            for(let t = 0, a = e1.length; t < a; t++)this.addOp(e1.fnArray[t], e1.argsArray[t]);
        } else warn('addOpList - ignoring invalid "opList" parameter.');
    }
    getIR() {
        return {
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            length: this.length
        };
    }
    get _transfers() {
        const e1 = [], { fnArray: t, argsArray: a, length: r } = this;
        for(let i = 0; i < r; i++)switch(t[i]){
            case Nt:
            case Et:
            case Dt:
                {
                    const { bitmap: t, data: r } = a[i][0];
                    (t || r?.buffer) && e1.push(t || r.buffer);
                    break;
                }
            case _t:
                {
                    const [, [t], r] = a[i];
                    t && e1.push(t.buffer, r.buffer);
                    break;
                }
            case vt:
                const [t1, r] = a[i];
                t1 && e1.push(t1.buffer);
                r && e1.push(r.buffer);
                break;
            case Ge:
                e1.push(a[i][0].buffer);
        }
        return e1;
    }
    flush(e1 = !1, t = null) {
        this.optimizer.flush();
        const a = this.length;
        this._totalLength += a;
        this._streamSink.enqueue({
            fnArray: this.fnArray,
            argsArray: this.argsArray,
            lastChunk: e1,
            separateAnnots: t,
            length: a
        }, 1, this._transfers);
        this.dependencies.clear();
        this.fnArray.length = 0;
        this.argsArray.length = 0;
        this.weight = 0;
        this.optimizer.reset();
    }
}
function hexToInt(e1, t) {
    let a = 0;
    for(let r = 0; r <= t; r++)a = a << 8 | e1[r];
    return a >>> 0;
}
function hexToStr(e1, t) {
    return 1 === t ? String.fromCharCode(e1[0], e1[1]) : 3 === t ? String.fromCharCode(e1[0], e1[1], e1[2], e1[3]) : String.fromCharCode(...e1.subarray(0, t + 1));
}
function addHex(e1, t, a) {
    let r = 0;
    for(let i = a; i >= 0; i--){
        r += e1[i] + t[i];
        e1[i] = 255 & r;
        r >>= 8;
    }
}
function incHex(e1, t) {
    let a = 1;
    for(let r = t; r >= 0 && a > 0; r--){
        a += e1[r];
        e1[r] = 255 & a;
        a >>= 8;
    }
}
const Ba = 16;
class BinaryCMapStream {
    constructor(e1){
        this.buffer = e1;
        this.pos = 0;
        this.end = e1.length;
        this.tmpBuf = new Uint8Array(19);
    }
    readByte() {
        return this.pos >= this.end ? -1 : this.buffer[this.pos++];
    }
    readNumber() {
        let e1, t = 0;
        do {
            const a = this.readByte();
            if (a < 0) throw new FormatError("unexpected EOF in bcmap");
            e1 = !(128 & a);
            t = t << 7 | 127 & a;
        }while (!e1)
        return t;
    }
    readSigned() {
        const e1 = this.readNumber();
        return 1 & e1 ? ~(e1 >>> 1) : e1 >>> 1;
    }
    readHex(e1, t) {
        e1.set(this.buffer.subarray(this.pos, this.pos + t + 1));
        this.pos += t + 1;
    }
    readHexNumber(e1, t) {
        let a;
        const r = this.tmpBuf;
        let i = 0;
        do {
            const e1 = this.readByte();
            if (e1 < 0) throw new FormatError("unexpected EOF in bcmap");
            a = !(128 & e1);
            r[i++] = 127 & e1;
        }while (!a)
        let n = t, s = 0, o = 0;
        for(; n >= 0;){
            for(; o < 8 && r.length > 0;){
                s |= r[--i] << o;
                o += 7;
            }
            e1[n] = 255 & s;
            n--;
            s >>= 8;
            o -= 8;
        }
    }
    readHexSigned(e1, t) {
        this.readHexNumber(e1, t);
        const a = 1 & e1[t] ? 255 : 0;
        let r = 0;
        for(let i = 0; i <= t; i++){
            r = (1 & r) << 8 | e1[i];
            e1[i] = r >> 1 ^ a;
        }
    }
    readString() {
        const e1 = this.readNumber(), t = new Array(e1);
        for(let a = 0; a < e1; a++)t[a] = this.readNumber();
        return String.fromCharCode(...t);
    }
}
class BinaryCMapReader {
    async process(e1, t, a) {
        const r = new BinaryCMapStream(e1), i = r.readByte();
        t.vertical = !!(1 & i);
        let n = null;
        const s = new Uint8Array(Ba), o = new Uint8Array(Ba), c = new Uint8Array(Ba), l = new Uint8Array(Ba), h = new Uint8Array(Ba);
        let u, d;
        for(; (d = r.readByte()) >= 0;){
            const e1 = d >> 5;
            if (7 === e1) {
                switch(31 & d){
                    case 0:
                        r.readString();
                        break;
                    case 1:
                        n = r.readString();
                }
                continue;
            }
            const a = !!(16 & d), i = 15 & d;
            if (i + 1 > Ba) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
            const f = 1, g = r.readNumber();
            switch(e1){
                case 0:
                    r.readHex(s, i);
                    r.readHexNumber(o, i);
                    addHex(o, s, i);
                    t.addCodespaceRange(i + 1, hexToInt(s, i), hexToInt(o, i));
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(o, i);
                        r.readHexNumber(s, i);
                        addHex(s, o, i);
                        r.readHexNumber(o, i);
                        addHex(o, s, i);
                        t.addCodespaceRange(i + 1, hexToInt(s, i), hexToInt(o, i));
                    }
                    break;
                case 1:
                    r.readHex(s, i);
                    r.readHexNumber(o, i);
                    addHex(o, s, i);
                    r.readNumber();
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(o, i);
                        r.readHexNumber(s, i);
                        addHex(s, o, i);
                        r.readHexNumber(o, i);
                        addHex(o, s, i);
                        r.readNumber();
                    }
                    break;
                case 2:
                    r.readHex(c, i);
                    u = r.readNumber();
                    t.mapOne(hexToInt(c, i), u);
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(c, i);
                        if (!a) {
                            r.readHexNumber(h, i);
                            addHex(c, h, i);
                        }
                        u = r.readSigned() + (u + 1);
                        t.mapOne(hexToInt(c, i), u);
                    }
                    break;
                case 3:
                    r.readHex(s, i);
                    r.readHexNumber(o, i);
                    addHex(o, s, i);
                    u = r.readNumber();
                    t.mapCidRange(hexToInt(s, i), hexToInt(o, i), u);
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(o, i);
                        if (a) s.set(o);
                        else {
                            r.readHexNumber(s, i);
                            addHex(s, o, i);
                        }
                        r.readHexNumber(o, i);
                        addHex(o, s, i);
                        u = r.readNumber();
                        t.mapCidRange(hexToInt(s, i), hexToInt(o, i), u);
                    }
                    break;
                case 4:
                    r.readHex(c, f);
                    r.readHex(l, i);
                    t.mapOne(hexToInt(c, f), hexToStr(l, i));
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(c, f);
                        if (!a) {
                            r.readHexNumber(h, f);
                            addHex(c, h, f);
                        }
                        incHex(l, i);
                        r.readHexSigned(h, i);
                        addHex(l, h, i);
                        t.mapOne(hexToInt(c, f), hexToStr(l, i));
                    }
                    break;
                case 5:
                    r.readHex(s, f);
                    r.readHexNumber(o, f);
                    addHex(o, s, f);
                    r.readHex(l, i);
                    t.mapBfRange(hexToInt(s, f), hexToInt(o, f), hexToStr(l, i));
                    for(let e1 = 1; e1 < g; e1++){
                        incHex(o, f);
                        if (a) s.set(o);
                        else {
                            r.readHexNumber(s, f);
                            addHex(s, o, f);
                        }
                        r.readHexNumber(o, f);
                        addHex(o, s, f);
                        r.readHex(l, i);
                        t.mapBfRange(hexToInt(s, f), hexToInt(o, f), hexToStr(l, i));
                    }
                    break;
                default:
                    throw new Error(`BinaryCMapReader.process - unknown type: ${e1}`);
            }
        }
        return n ? a(n) : t;
    }
}
class Ascii85Stream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .8);
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.input = new Uint8Array(5);
    }
    readBlock() {
        const e1 = this.str;
        let t = e1.getByte();
        for(; isWhiteSpace(t);)t = e1.getByte();
        if (-1 === t || 126 === t) {
            this.eof = !0;
            return;
        }
        const a = this.bufferLength;
        let r, i;
        if (122 === t) {
            r = this.ensureBuffer(a + 4);
            for(i = 0; i < 4; ++i)r[a + i] = 0;
            this.bufferLength += 4;
        } else {
            const n = this.input;
            n[0] = t;
            for(i = 1; i < 5; ++i){
                t = e1.getByte();
                for(; isWhiteSpace(t);)t = e1.getByte();
                n[i] = t;
                if (-1 === t || 126 === t) break;
            }
            r = this.ensureBuffer(a + i - 1);
            this.bufferLength += i - 1;
            if (i < 5) {
                for(; i < 5; ++i)n[i] = 117;
                this.eof = !0;
            }
            let s = 0;
            for(i = 0; i < 5; ++i)s = 85 * s + (n[i] - 33);
            for(i = 3; i >= 0; --i){
                r[a + i] = 255 & s;
                s >>= 8;
            }
        }
    }
}
class AsciiHexStream extends DecodeStream {
    constructor(e1, t){
        t && (t *= .5);
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.firstDigit = -1;
    }
    readBlock() {
        const e1 = this.str.getBytes(8e3);
        if (!e1.length) {
            this.eof = !0;
            return;
        }
        const t = e1.length + 1 >> 1, a = this.ensureBuffer(this.bufferLength + t);
        let r = this.bufferLength, i = this.firstDigit;
        for (const t of e1){
            let e1;
            if (t >= 48 && t <= 57) e1 = 15 & t;
            else {
                if (!(t >= 65 && t <= 70 || t >= 97 && t <= 102)) {
                    if (62 === t) {
                        this.eof = !0;
                        break;
                    }
                    continue;
                }
                e1 = 9 + (15 & t);
            }
            if (i < 0) i = e1;
            else {
                a[r++] = i << 4 | e1;
                i = -1;
            }
        }
        if (i >= 0 && this.eof) {
            a[r++] = i << 4;
            i = -1;
        }
        this.firstDigit = i;
        this.bufferLength = r;
    }
}
const Ra = -1, Na = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        7,
        8
    ],
    [
        7,
        7
    ],
    [
        6,
        6
    ],
    [
        6,
        6
    ],
    [
        6,
        5
    ],
    [
        6,
        5
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        4,
        0
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        3,
        3
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ],
    [
        1,
        2
    ]
], Ea = [
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ]
], Pa = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        8,
        29
    ],
    [
        8,
        29
    ],
    [
        8,
        30
    ],
    [
        8,
        30
    ],
    [
        8,
        45
    ],
    [
        8,
        45
    ],
    [
        8,
        46
    ],
    [
        8,
        46
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        22
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        7,
        23
    ],
    [
        8,
        47
    ],
    [
        8,
        47
    ],
    [
        8,
        48
    ],
    [
        8,
        48
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        6,
        13
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        7,
        20
    ],
    [
        8,
        33
    ],
    [
        8,
        33
    ],
    [
        8,
        34
    ],
    [
        8,
        34
    ],
    [
        8,
        35
    ],
    [
        8,
        35
    ],
    [
        8,
        36
    ],
    [
        8,
        36
    ],
    [
        8,
        37
    ],
    [
        8,
        37
    ],
    [
        8,
        38
    ],
    [
        8,
        38
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        7,
        19
    ],
    [
        8,
        31
    ],
    [
        8,
        31
    ],
    [
        8,
        32
    ],
    [
        8,
        32
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        1
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        6,
        12
    ],
    [
        8,
        53
    ],
    [
        8,
        53
    ],
    [
        8,
        54
    ],
    [
        8,
        54
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        7,
        26
    ],
    [
        8,
        39
    ],
    [
        8,
        39
    ],
    [
        8,
        40
    ],
    [
        8,
        40
    ],
    [
        8,
        41
    ],
    [
        8,
        41
    ],
    [
        8,
        42
    ],
    [
        8,
        42
    ],
    [
        8,
        43
    ],
    [
        8,
        43
    ],
    [
        8,
        44
    ],
    [
        8,
        44
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        21
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        7,
        28
    ],
    [
        8,
        61
    ],
    [
        8,
        61
    ],
    [
        8,
        62
    ],
    [
        8,
        62
    ],
    [
        8,
        63
    ],
    [
        8,
        63
    ],
    [
        8,
        0
    ],
    [
        8,
        0
    ],
    [
        8,
        320
    ],
    [
        8,
        320
    ],
    [
        8,
        384
    ],
    [
        8,
        384
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        10
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        5,
        11
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        7,
        27
    ],
    [
        8,
        59
    ],
    [
        8,
        59
    ],
    [
        8,
        60
    ],
    [
        8,
        60
    ],
    [
        9,
        1472
    ],
    [
        9,
        1536
    ],
    [
        9,
        1600
    ],
    [
        9,
        1728
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        18
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        7,
        24
    ],
    [
        8,
        49
    ],
    [
        8,
        49
    ],
    [
        8,
        50
    ],
    [
        8,
        50
    ],
    [
        8,
        51
    ],
    [
        8,
        51
    ],
    [
        8,
        52
    ],
    [
        8,
        52
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        7,
        25
    ],
    [
        8,
        55
    ],
    [
        8,
        55
    ],
    [
        8,
        56
    ],
    [
        8,
        56
    ],
    [
        8,
        57
    ],
    [
        8,
        57
    ],
    [
        8,
        58
    ],
    [
        8,
        58
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        192
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        6,
        1664
    ],
    [
        8,
        448
    ],
    [
        8,
        448
    ],
    [
        8,
        512
    ],
    [
        8,
        512
    ],
    [
        9,
        704
    ],
    [
        9,
        768
    ],
    [
        8,
        640
    ],
    [
        8,
        640
    ],
    [
        8,
        576
    ],
    [
        8,
        576
    ],
    [
        9,
        832
    ],
    [
        9,
        896
    ],
    [
        9,
        960
    ],
    [
        9,
        1024
    ],
    [
        9,
        1088
    ],
    [
        9,
        1152
    ],
    [
        9,
        1216
    ],
    [
        9,
        1280
    ],
    [
        9,
        1344
    ],
    [
        9,
        1408
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        7,
        256
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        2
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        4,
        3
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        128
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        8
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        5,
        9
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        16
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        6,
        17
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        4
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        14
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        6,
        15
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        5,
        64
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ],
    [
        4,
        7
    ]
], La = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        12,
        -2
    ],
    [
        12,
        -2
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        11,
        1792
    ],
    [
        12,
        1984
    ],
    [
        12,
        1984
    ],
    [
        12,
        2048
    ],
    [
        12,
        2048
    ],
    [
        12,
        2112
    ],
    [
        12,
        2112
    ],
    [
        12,
        2176
    ],
    [
        12,
        2176
    ],
    [
        12,
        2240
    ],
    [
        12,
        2240
    ],
    [
        12,
        2304
    ],
    [
        12,
        2304
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1856
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        11,
        1920
    ],
    [
        12,
        2368
    ],
    [
        12,
        2368
    ],
    [
        12,
        2432
    ],
    [
        12,
        2432
    ],
    [
        12,
        2496
    ],
    [
        12,
        2496
    ],
    [
        12,
        2560
    ],
    [
        12,
        2560
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        10,
        18
    ],
    [
        12,
        52
    ],
    [
        12,
        52
    ],
    [
        13,
        640
    ],
    [
        13,
        704
    ],
    [
        13,
        768
    ],
    [
        13,
        832
    ],
    [
        12,
        55
    ],
    [
        12,
        55
    ],
    [
        12,
        56
    ],
    [
        12,
        56
    ],
    [
        13,
        1280
    ],
    [
        13,
        1344
    ],
    [
        13,
        1408
    ],
    [
        13,
        1472
    ],
    [
        12,
        59
    ],
    [
        12,
        59
    ],
    [
        12,
        60
    ],
    [
        12,
        60
    ],
    [
        13,
        1536
    ],
    [
        13,
        1600
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        24
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        11,
        25
    ],
    [
        13,
        1664
    ],
    [
        13,
        1728
    ],
    [
        12,
        320
    ],
    [
        12,
        320
    ],
    [
        12,
        384
    ],
    [
        12,
        384
    ],
    [
        12,
        448
    ],
    [
        12,
        448
    ],
    [
        13,
        512
    ],
    [
        13,
        576
    ],
    [
        12,
        53
    ],
    [
        12,
        53
    ],
    [
        12,
        54
    ],
    [
        12,
        54
    ],
    [
        13,
        896
    ],
    [
        13,
        960
    ],
    [
        13,
        1024
    ],
    [
        13,
        1088
    ],
    [
        13,
        1152
    ],
    [
        13,
        1216
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ],
    [
        10,
        64
    ]
], ja = [
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        8,
        13
    ],
    [
        11,
        23
    ],
    [
        11,
        23
    ],
    [
        12,
        50
    ],
    [
        12,
        51
    ],
    [
        12,
        44
    ],
    [
        12,
        45
    ],
    [
        12,
        46
    ],
    [
        12,
        47
    ],
    [
        12,
        57
    ],
    [
        12,
        58
    ],
    [
        12,
        61
    ],
    [
        12,
        256
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        16
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        10,
        17
    ],
    [
        12,
        48
    ],
    [
        12,
        49
    ],
    [
        12,
        62
    ],
    [
        12,
        63
    ],
    [
        12,
        30
    ],
    [
        12,
        31
    ],
    [
        12,
        32
    ],
    [
        12,
        33
    ],
    [
        12,
        40
    ],
    [
        12,
        41
    ],
    [
        11,
        22
    ],
    [
        11,
        22
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        8,
        14
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        10
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        7,
        11
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        9,
        15
    ],
    [
        12,
        128
    ],
    [
        12,
        192
    ],
    [
        12,
        26
    ],
    [
        12,
        27
    ],
    [
        12,
        28
    ],
    [
        12,
        29
    ],
    [
        11,
        19
    ],
    [
        11,
        19
    ],
    [
        11,
        20
    ],
    [
        11,
        20
    ],
    [
        12,
        34
    ],
    [
        12,
        35
    ],
    [
        12,
        36
    ],
    [
        12,
        37
    ],
    [
        12,
        38
    ],
    [
        12,
        39
    ],
    [
        11,
        21
    ],
    [
        11,
        21
    ],
    [
        12,
        42
    ],
    [
        12,
        43
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        10,
        0
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ],
    [
        7,
        12
    ]
], _a = [
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        -1,
        -1
    ],
    [
        6,
        9
    ],
    [
        6,
        8
    ],
    [
        5,
        7
    ],
    [
        5,
        7
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        6
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        4,
        5
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        1
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        3,
        4
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        3
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ],
    [
        2,
        2
    ]
];
class CCITTFaxDecoder {
    constructor(e1, t = {}){
        if ("function" != typeof e1?.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
        this.source = e1;
        this.eof = !1;
        this.encoding = t.K || 0;
        this.eoline = t.EndOfLine || !1;
        this.byteAlign = t.EncodedByteAlign || !1;
        this.columns = t.Columns || 1728;
        this.rows = t.Rows || 0;
        this.eoblock = t.EndOfBlock ?? !0;
        this.black = t.BlackIs1 || !1;
        this.codingLine = new Uint32Array(this.columns + 1);
        this.refLine = new Uint32Array(this.columns + 2);
        this.codingLine[0] = this.columns;
        this.codingPos = 0;
        this.row = 0;
        this.nextLine2D = this.encoding < 0;
        this.inputBits = 0;
        this.inputBuf = 0;
        this.outputBits = 0;
        this.rowsDone = !1;
        let a;
        for(; 0 === (a = this._lookBits(12));)this._eatBits(1);
        1 === a && this._eatBits(12);
        if (this.encoding > 0) {
            this.nextLine2D = !this._lookBits(1);
            this._eatBits(1);
        }
    }
    readNextChar() {
        if (this.eof) return -1;
        const e1 = this.refLine, t = this.codingLine, a = this.columns;
        let r, i, n, s, o;
        if (0 === this.outputBits) {
            this.rowsDone && (this.eof = !0);
            if (this.eof) return -1;
            this.err = !1;
            let n, o, c;
            if (this.nextLine2D) {
                for(s = 0; t[s] < a; ++s)e1[s] = t[s];
                e1[s++] = a;
                e1[s] = a;
                t[0] = 0;
                this.codingPos = 0;
                r = 0;
                i = 0;
                for(; t[this.codingPos] < a;){
                    n = this._getTwoDimCode();
                    switch(n){
                        case 0:
                            this._addPixels(e1[r + 1], i);
                            e1[r + 1] < a && (r += 2);
                            break;
                        case 1:
                            n = o = 0;
                            if (i) {
                                do {
                                    n += c = this._getBlackCode();
                                }while (c >= 64)
                                do {
                                    o += c = this._getWhiteCode();
                                }while (c >= 64)
                            } else {
                                do {
                                    n += c = this._getWhiteCode();
                                }while (c >= 64)
                                do {
                                    o += c = this._getBlackCode();
                                }while (c >= 64)
                            }
                            this._addPixels(t[this.codingPos] + n, i);
                            t[this.codingPos] < a && this._addPixels(t[this.codingPos] + o, 1 ^ i);
                            for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            break;
                        case 7:
                            this._addPixels(e1[r] + 3, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 5:
                            this._addPixels(e1[r] + 2, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 3:
                            this._addPixels(e1[r] + 1, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 2:
                            this._addPixels(e1[r], i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 8:
                            this._addPixelsNeg(e1[r] - 3, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                r > 0 ? --r : ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 6:
                            this._addPixelsNeg(e1[r] - 2, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                r > 0 ? --r : ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case 4:
                            this._addPixelsNeg(e1[r] - 1, i);
                            i ^= 1;
                            if (t[this.codingPos] < a) {
                                r > 0 ? --r : ++r;
                                for(; e1[r] <= t[this.codingPos] && e1[r] < a;)r += 2;
                            }
                            break;
                        case Ra:
                            this._addPixels(a, 0);
                            this.eof = !0;
                            break;
                        default:
                            info("bad 2d code");
                            this._addPixels(a, 0);
                            this.err = !0;
                    }
                }
            } else {
                t[0] = 0;
                this.codingPos = 0;
                i = 0;
                for(; t[this.codingPos] < a;){
                    n = 0;
                    if (i) do {
                        n += c = this._getBlackCode();
                    }while (c >= 64)
                    else do {
                        n += c = this._getWhiteCode();
                    }while (c >= 64)
                    this._addPixels(t[this.codingPos] + n, i);
                    i ^= 1;
                }
            }
            let l = !1;
            this.byteAlign && (this.inputBits &= -8);
            if (this.eoblock || this.row !== this.rows - 1) {
                n = this._lookBits(12);
                if (this.eoline) for(; n !== Ra && 1 !== n;){
                    this._eatBits(1);
                    n = this._lookBits(12);
                }
                else for(; 0 === n;){
                    this._eatBits(1);
                    n = this._lookBits(12);
                }
                if (1 === n) {
                    this._eatBits(12);
                    l = !0;
                } else n === Ra && (this.eof = !0);
            } else this.rowsDone = !0;
            if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                this.nextLine2D = !this._lookBits(1);
                this._eatBits(1);
            }
            if (this.eoblock && l && this.byteAlign) {
                n = this._lookBits(12);
                if (1 === n) {
                    this._eatBits(12);
                    if (this.encoding > 0) {
                        this._lookBits(1);
                        this._eatBits(1);
                    }
                    if (this.encoding >= 0) for(s = 0; s < 4; ++s){
                        n = this._lookBits(12);
                        1 !== n && info("bad rtc code: " + n);
                        this._eatBits(12);
                        if (this.encoding > 0) {
                            this._lookBits(1);
                            this._eatBits(1);
                        }
                    }
                    this.eof = !0;
                }
            } else if (this.err && this.eoline) {
                for(;;){
                    n = this._lookBits(13);
                    if (n === Ra) {
                        this.eof = !0;
                        return -1;
                    }
                    if (n >> 1 == 1) break;
                    this._eatBits(1);
                }
                this._eatBits(12);
                if (this.encoding > 0) {
                    this._eatBits(1);
                    this.nextLine2D = !(1 & n);
                }
            }
            this.outputBits = t[0] > 0 ? t[this.codingPos = 0] : t[this.codingPos = 1];
            this.row++;
        }
        if (this.outputBits >= 8) {
            o = 1 & this.codingPos ? 0 : 255;
            this.outputBits -= 8;
            if (0 === this.outputBits && t[this.codingPos] < a) {
                this.codingPos++;
                this.outputBits = t[this.codingPos] - t[this.codingPos - 1];
            }
        } else {
            n = 8;
            o = 0;
            do {
                if ("number" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                if (this.outputBits > n) {
                    o <<= n;
                    1 & this.codingPos || (o |= 255 >> 8 - n);
                    this.outputBits -= n;
                    n = 0;
                } else {
                    o <<= this.outputBits;
                    1 & this.codingPos || (o |= 255 >> 8 - this.outputBits);
                    n -= this.outputBits;
                    this.outputBits = 0;
                    if (t[this.codingPos] < a) {
                        this.codingPos++;
                        this.outputBits = t[this.codingPos] - t[this.codingPos - 1];
                    } else if (n > 0) {
                        o <<= n;
                        n = 0;
                    }
                }
            }while (n)
        }
        this.black && (o ^= 255);
        return o;
    }
    _addPixels(e1, t) {
        const a = this.codingLine;
        let r = this.codingPos;
        if (e1 > a[r]) {
            if (e1 > this.columns) {
                info("row is wrong length");
                this.err = !0;
                e1 = this.columns;
            }
            1 & r ^ t && ++r;
            a[r] = e1;
        }
        this.codingPos = r;
    }
    _addPixelsNeg(e1, t) {
        const a = this.codingLine;
        let r = this.codingPos;
        if (e1 > a[r]) {
            if (e1 > this.columns) {
                info("row is wrong length");
                this.err = !0;
                e1 = this.columns;
            }
            1 & r ^ t && ++r;
            a[r] = e1;
        } else if (e1 < a[r]) {
            if (e1 < 0) {
                info("invalid code");
                this.err = !0;
                e1 = 0;
            }
            for(; r > 0 && e1 < a[r - 1];)--r;
            a[r] = e1;
        }
        this.codingPos = r;
    }
    _findTableCode(e1, t, a, r) {
        const i = r || 0;
        for(let r = e1; r <= t; ++r){
            let e1 = this._lookBits(r);
            if (e1 === Ra) return [
                !0,
                1,
                !1
            ];
            r < t && (e1 <<= t - r);
            if (!i || e1 >= i) {
                const t = a[e1 - i];
                if (t[0] === r) {
                    this._eatBits(r);
                    return [
                        !0,
                        t[1],
                        !0
                    ];
                }
            }
        }
        return [
            !1,
            0,
            !1
        ];
    }
    _getTwoDimCode() {
        let e1, t = 0;
        if (this.eoblock) {
            t = this._lookBits(7);
            e1 = Na[t];
            if (e1?.[0] > 0) {
                this._eatBits(e1[0]);
                return e1[1];
            }
        } else {
            const e1 = this._findTableCode(1, 7, Na);
            if (e1[0] && e1[2]) return e1[1];
        }
        info("Bad two dim code");
        return Ra;
    }
    _getWhiteCode() {
        let e1, t = 0;
        if (this.eoblock) {
            t = this._lookBits(12);
            if (t === Ra) return 1;
            e1 = t >> 5 ? Pa[t >> 3] : Ea[t];
            if (e1[0] > 0) {
                this._eatBits(e1[0]);
                return e1[1];
            }
        } else {
            let e1 = this._findTableCode(1, 9, Pa);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(11, 12, Ea);
            if (e1[0]) return e1[1];
        }
        info("bad white code");
        this._eatBits(1);
        return 1;
    }
    _getBlackCode() {
        let e1, t;
        if (this.eoblock) {
            e1 = this._lookBits(13);
            if (e1 === Ra) return 1;
            t = e1 >> 7 ? !(e1 >> 9) && e1 >> 7 ? ja[(e1 >> 1) - 64] : _a[e1 >> 7] : La[e1];
            if (t[0] > 0) {
                this._eatBits(t[0]);
                return t[1];
            }
        } else {
            let e1 = this._findTableCode(2, 6, _a);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(7, 12, ja, 64);
            if (e1[0]) return e1[1];
            e1 = this._findTableCode(10, 13, La);
            if (e1[0]) return e1[1];
        }
        info("bad black code");
        this._eatBits(1);
        return 1;
    }
    _lookBits(e1) {
        let t;
        for(; this.inputBits < e1;){
            if (-1 === (t = this.source.next())) return 0 === this.inputBits ? Ra : this.inputBuf << e1 - this.inputBits & 65535 >> 16 - e1;
            this.inputBuf = this.inputBuf << 8 | t;
            this.inputBits += 8;
        }
        return this.inputBuf >> this.inputBits - e1 & 65535 >> 16 - e1;
    }
    _eatBits(e1) {
        (this.inputBits -= e1) < 0 && (this.inputBits = 0);
    }
}
class CCITTFaxStream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        a instanceof Dict || (a = Dict.empty);
        const r = {
            next: ()=>e1.getByte()
        };
        this.ccittFaxDecoder = new CCITTFaxDecoder(r, {
            K: a.get("K"),
            EndOfLine: a.get("EndOfLine"),
            EncodedByteAlign: a.get("EncodedByteAlign"),
            Columns: a.get("Columns"),
            Rows: a.get("Rows"),
            EndOfBlock: a.get("EndOfBlock"),
            BlackIs1: a.get("BlackIs1")
        });
    }
    readBlock() {
        for(; !this.eof;){
            const e1 = this.ccittFaxDecoder.readNextChar();
            if (-1 === e1) {
                this.eof = !0;
                return;
            }
            this.ensureBuffer(this.bufferLength + 1);
            this.buffer[this.bufferLength++] = e1;
        }
    }
}
const Ua = new Int32Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), Xa = new Int32Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    65547,
    65549,
    65551,
    65553,
    131091,
    131095,
    131099,
    131103,
    196643,
    196651,
    196659,
    196667,
    262211,
    262227,
    262243,
    262259,
    327811,
    327843,
    327875,
    327907,
    258,
    258,
    258
]), qa = new Int32Array([
    1,
    2,
    3,
    4,
    65541,
    65543,
    131081,
    131085,
    196625,
    196633,
    262177,
    262193,
    327745,
    327777,
    393345,
    393409,
    459009,
    459137,
    524801,
    525057,
    590849,
    591361,
    657409,
    658433,
    724993,
    727041,
    794625,
    798721,
    868353,
    876545
]), Ha = [
    new Int32Array([
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590016,
        459016,
        524384,
        524320,
        589984,
        524288,
        524416,
        524352,
        590048,
        459012,
        524376,
        524312,
        589968,
        459028,
        524408,
        524344,
        590032,
        459020,
        524392,
        524328,
        59e4,
        524296,
        524424,
        524360,
        590064,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590024,
        459018,
        524388,
        524324,
        589992,
        524292,
        524420,
        524356,
        590056,
        459014,
        524380,
        524316,
        589976,
        459030,
        524412,
        524348,
        590040,
        459022,
        524396,
        524332,
        590008,
        524300,
        524428,
        524364,
        590072,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590020,
        459017,
        524386,
        524322,
        589988,
        524290,
        524418,
        524354,
        590052,
        459013,
        524378,
        524314,
        589972,
        459029,
        524410,
        524346,
        590036,
        459021,
        524394,
        524330,
        590004,
        524298,
        524426,
        524362,
        590068,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590028,
        459019,
        524390,
        524326,
        589996,
        524294,
        524422,
        524358,
        590060,
        459015,
        524382,
        524318,
        589980,
        459031,
        524414,
        524350,
        590044,
        459023,
        524398,
        524334,
        590012,
        524302,
        524430,
        524366,
        590076,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590018,
        459016,
        524385,
        524321,
        589986,
        524289,
        524417,
        524353,
        590050,
        459012,
        524377,
        524313,
        589970,
        459028,
        524409,
        524345,
        590034,
        459020,
        524393,
        524329,
        590002,
        524297,
        524425,
        524361,
        590066,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590026,
        459018,
        524389,
        524325,
        589994,
        524293,
        524421,
        524357,
        590058,
        459014,
        524381,
        524317,
        589978,
        459030,
        524413,
        524349,
        590042,
        459022,
        524397,
        524333,
        590010,
        524301,
        524429,
        524365,
        590074,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590022,
        459017,
        524387,
        524323,
        589990,
        524291,
        524419,
        524355,
        590054,
        459013,
        524379,
        524315,
        589974,
        459029,
        524411,
        524347,
        590038,
        459021,
        524395,
        524331,
        590006,
        524299,
        524427,
        524363,
        590070,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590030,
        459019,
        524391,
        524327,
        589998,
        524295,
        524423,
        524359,
        590062,
        459015,
        524383,
        524319,
        589982,
        459031,
        524415,
        524351,
        590046,
        459023,
        524399,
        524335,
        590014,
        524303,
        524431,
        524367,
        590078,
        459008,
        524368,
        524304,
        524568,
        459024,
        524400,
        524336,
        590017,
        459016,
        524384,
        524320,
        589985,
        524288,
        524416,
        524352,
        590049,
        459012,
        524376,
        524312,
        589969,
        459028,
        524408,
        524344,
        590033,
        459020,
        524392,
        524328,
        590001,
        524296,
        524424,
        524360,
        590065,
        459010,
        524372,
        524308,
        524572,
        459026,
        524404,
        524340,
        590025,
        459018,
        524388,
        524324,
        589993,
        524292,
        524420,
        524356,
        590057,
        459014,
        524380,
        524316,
        589977,
        459030,
        524412,
        524348,
        590041,
        459022,
        524396,
        524332,
        590009,
        524300,
        524428,
        524364,
        590073,
        459009,
        524370,
        524306,
        524570,
        459025,
        524402,
        524338,
        590021,
        459017,
        524386,
        524322,
        589989,
        524290,
        524418,
        524354,
        590053,
        459013,
        524378,
        524314,
        589973,
        459029,
        524410,
        524346,
        590037,
        459021,
        524394,
        524330,
        590005,
        524298,
        524426,
        524362,
        590069,
        459011,
        524374,
        524310,
        524574,
        459027,
        524406,
        524342,
        590029,
        459019,
        524390,
        524326,
        589997,
        524294,
        524422,
        524358,
        590061,
        459015,
        524382,
        524318,
        589981,
        459031,
        524414,
        524350,
        590045,
        459023,
        524398,
        524334,
        590013,
        524302,
        524430,
        524366,
        590077,
        459008,
        524369,
        524305,
        524569,
        459024,
        524401,
        524337,
        590019,
        459016,
        524385,
        524321,
        589987,
        524289,
        524417,
        524353,
        590051,
        459012,
        524377,
        524313,
        589971,
        459028,
        524409,
        524345,
        590035,
        459020,
        524393,
        524329,
        590003,
        524297,
        524425,
        524361,
        590067,
        459010,
        524373,
        524309,
        524573,
        459026,
        524405,
        524341,
        590027,
        459018,
        524389,
        524325,
        589995,
        524293,
        524421,
        524357,
        590059,
        459014,
        524381,
        524317,
        589979,
        459030,
        524413,
        524349,
        590043,
        459022,
        524397,
        524333,
        590011,
        524301,
        524429,
        524365,
        590075,
        459009,
        524371,
        524307,
        524571,
        459025,
        524403,
        524339,
        590023,
        459017,
        524387,
        524323,
        589991,
        524291,
        524419,
        524355,
        590055,
        459013,
        524379,
        524315,
        589975,
        459029,
        524411,
        524347,
        590039,
        459021,
        524395,
        524331,
        590007,
        524299,
        524427,
        524363,
        590071,
        459011,
        524375,
        524311,
        524575,
        459027,
        524407,
        524343,
        590031,
        459019,
        524391,
        524327,
        589999,
        524295,
        524423,
        524359,
        590063,
        459015,
        524383,
        524319,
        589983,
        459031,
        524415,
        524351,
        590047,
        459023,
        524399,
        524335,
        590015,
        524303,
        524431,
        524367,
        590079
    ]),
    9
], Wa = [
    new Int32Array([
        327680,
        327696,
        327688,
        327704,
        327684,
        327700,
        327692,
        327708,
        327682,
        327698,
        327690,
        327706,
        327686,
        327702,
        327694,
        0,
        327681,
        327697,
        327689,
        327705,
        327685,
        327701,
        327693,
        327709,
        327683,
        327699,
        327691,
        327707,
        327687,
        327703,
        327695,
        0
    ]),
    5
];
class FlateStream extends DecodeStream {
    constructor(e1, t){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        const a = e1.getByte(), r = e1.getByte();
        if (-1 === a || -1 === r) throw new FormatError(`Invalid header in flate stream: ${a}, ${r}`);
        if (8 != (15 & a)) throw new FormatError(`Unknown compression method in flate stream: ${a}, ${r}`);
        if (((a << 8) + r) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${a}, ${r}`);
        if (32 & r) throw new FormatError(`FDICT bit set in flate stream: ${a}, ${r}`);
        this.codeSize = 0;
        this.codeBuf = 0;
    }
    async getImageData(e1, t) {
        const a = await this.asyncGetBytes();
        return a ? a.length <= e1 ? a : a.subarray(0, e1) : this.getBytes(e1);
    }
    async asyncGetBytes() {
        this.str.reset();
        const e1 = this.str.getBytes();
        try {
            const { readable: t, writable: a } = new DecompressionStream("deflate"), r = a.getWriter();
            await r.ready;
            r.write(e1).then(async ()=>{
                await r.ready;
                await r.close();
            }).catch(()=>{});
            const i = [];
            let n = 0;
            for await (const e1 of t){
                i.push(e1);
                n += e1.byteLength;
            }
            const s = new Uint8Array(n);
            let o = 0;
            for (const e1 of i){
                s.set(e1, o);
                o += e1.byteLength;
            }
            return s;
        } catch  {
            this.str = new Stream(e1, 2, e1.length, this.str.dict);
            this.reset();
            return null;
        }
    }
    get isAsync() {
        return !0;
    }
    getBits(e1) {
        const t = this.str;
        let a, r = this.codeSize, i = this.codeBuf;
        for(; r < e1;){
            if (-1 === (a = t.getByte())) throw new FormatError("Bad encoding in flate stream");
            i |= a << r;
            r += 8;
        }
        a = i & (1 << e1) - 1;
        this.codeBuf = i >> e1;
        this.codeSize = r -= e1;
        return a;
    }
    getCode(e1) {
        const t = this.str, a = e1[0], r = e1[1];
        let i, n = this.codeSize, s = this.codeBuf;
        for(; n < r && -1 !== (i = t.getByte());){
            s |= i << n;
            n += 8;
        }
        const o = a[s & (1 << r) - 1], c = o >> 16, l = 65535 & o;
        if (c < 1 || n < c) throw new FormatError("Bad encoding in flate stream");
        this.codeBuf = s >> c;
        this.codeSize = n - c;
        return l;
    }
    generateHuffmanTable(e1) {
        const t = e1.length;
        let a, r = 0;
        for(a = 0; a < t; ++a)e1[a] > r && (r = e1[a]);
        const i = 1 << r, n = new Int32Array(i);
        for(let s = 1, o = 0, c = 2; s <= r; ++s, o <<= 1, c <<= 1)for(let r = 0; r < t; ++r)if (e1[r] === s) {
            let e1 = 0, t = o;
            for(a = 0; a < s; ++a){
                e1 = e1 << 1 | 1 & t;
                t >>= 1;
            }
            for(a = e1; a < i; a += c)n[a] = s << 16 | r;
            ++o;
        }
        return [
            n,
            r
        ];
    }
    #X(e1) {
        info(e1);
        this.eof = !0;
    }
    readBlock() {
        let e1, t, a;
        const r = this.str;
        try {
            t = this.getBits(3);
        } catch (e1) {
            this.#X(e1.message);
            return;
        }
        1 & t && (this.eof = !0);
        t >>= 1;
        if (0 === t) {
            let t;
            if (-1 === (t = r.getByte())) {
                this.#X("Bad block header in flate stream");
                return;
            }
            let a = t;
            if (-1 === (t = r.getByte())) {
                this.#X("Bad block header in flate stream");
                return;
            }
            a |= t << 8;
            if (-1 === (t = r.getByte())) {
                this.#X("Bad block header in flate stream");
                return;
            }
            let i = t;
            if (-1 === (t = r.getByte())) {
                this.#X("Bad block header in flate stream");
                return;
            }
            i |= t << 8;
            if (i !== (65535 & ~a) && (0 !== a || 0 !== i)) throw new FormatError("Bad uncompressed block length in flate stream");
            this.codeBuf = 0;
            this.codeSize = 0;
            const n = this.bufferLength, s = n + a;
            e1 = this.ensureBuffer(s);
            this.bufferLength = s;
            if (0 === a) -1 === r.peekByte() && (this.eof = !0);
            else {
                const t = r.getBytes(a);
                e1.set(t, n);
                t.length < a && (this.eof = !0);
            }
            return;
        }
        let i, n;
        if (1 === t) {
            i = Ha;
            n = Wa;
        } else {
            if (2 !== t) throw new FormatError("Unknown block type in flate stream");
            {
                const e1 = this.getBits(5) + 257, t = this.getBits(5) + 1, r = this.getBits(4) + 4, s = new Uint8Array(Ua.length);
                let o;
                for(o = 0; o < r; ++o)s[Ua[o]] = this.getBits(3);
                const c = this.generateHuffmanTable(s);
                a = 0;
                o = 0;
                const l = e1 + t, h = new Uint8Array(l);
                let u, d, f;
                for(; o < l;){
                    const e1 = this.getCode(c);
                    if (16 === e1) {
                        u = 2;
                        d = 3;
                        f = a;
                    } else if (17 === e1) {
                        u = 3;
                        d = 3;
                        f = a = 0;
                    } else {
                        if (18 !== e1) {
                            h[o++] = a = e1;
                            continue;
                        }
                        u = 7;
                        d = 11;
                        f = a = 0;
                    }
                    let t = this.getBits(u) + d;
                    for(; t-- > 0;)h[o++] = f;
                }
                i = this.generateHuffmanTable(h.subarray(0, e1));
                n = this.generateHuffmanTable(h.subarray(e1, l));
            }
        }
        e1 = this.buffer;
        let s = e1 ? e1.length : 0, o = this.bufferLength;
        for(;;){
            let t = this.getCode(i);
            if (t < 256) {
                if (o + 1 >= s) {
                    e1 = this.ensureBuffer(o + 1);
                    s = e1.length;
                }
                e1[o++] = t;
                continue;
            }
            if (256 === t) {
                this.bufferLength = o;
                return;
            }
            t -= 257;
            t = Xa[t];
            let r = t >> 16;
            r > 0 && (r = this.getBits(r));
            a = (65535 & t) + r;
            t = this.getCode(n);
            t = qa[t];
            r = t >> 16;
            r > 0 && (r = this.getBits(r));
            const c = (65535 & t) + r;
            if (o + a >= s) {
                e1 = this.ensureBuffer(o + a);
                s = e1.length;
            }
            for(let t = 0; t < a; ++t, ++o)e1[o] = e1[o - c];
        }
    }
}
const za = [
    {
        qe: 22017,
        nmps: 1,
        nlps: 1,
        switchFlag: 1
    },
    {
        qe: 13313,
        nmps: 2,
        nlps: 6,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 3,
        nlps: 9,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 4,
        nlps: 12,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 5,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 38,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 7,
        nlps: 6,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 8,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 9,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 10,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 11,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 12,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 13,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 29,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 15,
        nlps: 14,
        switchFlag: 1
    },
    {
        qe: 21505,
        nmps: 16,
        nlps: 14,
        switchFlag: 0
    },
    {
        qe: 20737,
        nmps: 17,
        nlps: 15,
        switchFlag: 0
    },
    {
        qe: 18433,
        nmps: 18,
        nlps: 16,
        switchFlag: 0
    },
    {
        qe: 14337,
        nmps: 19,
        nlps: 17,
        switchFlag: 0
    },
    {
        qe: 13313,
        nmps: 20,
        nlps: 18,
        switchFlag: 0
    },
    {
        qe: 12289,
        nmps: 21,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 10241,
        nmps: 22,
        nlps: 19,
        switchFlag: 0
    },
    {
        qe: 9217,
        nmps: 23,
        nlps: 20,
        switchFlag: 0
    },
    {
        qe: 8705,
        nmps: 24,
        nlps: 21,
        switchFlag: 0
    },
    {
        qe: 7169,
        nmps: 25,
        nlps: 22,
        switchFlag: 0
    },
    {
        qe: 6145,
        nmps: 26,
        nlps: 23,
        switchFlag: 0
    },
    {
        qe: 5633,
        nmps: 27,
        nlps: 24,
        switchFlag: 0
    },
    {
        qe: 5121,
        nmps: 28,
        nlps: 25,
        switchFlag: 0
    },
    {
        qe: 4609,
        nmps: 29,
        nlps: 26,
        switchFlag: 0
    },
    {
        qe: 4353,
        nmps: 30,
        nlps: 27,
        switchFlag: 0
    },
    {
        qe: 2753,
        nmps: 31,
        nlps: 28,
        switchFlag: 0
    },
    {
        qe: 2497,
        nmps: 32,
        nlps: 29,
        switchFlag: 0
    },
    {
        qe: 2209,
        nmps: 33,
        nlps: 30,
        switchFlag: 0
    },
    {
        qe: 1313,
        nmps: 34,
        nlps: 31,
        switchFlag: 0
    },
    {
        qe: 1089,
        nmps: 35,
        nlps: 32,
        switchFlag: 0
    },
    {
        qe: 673,
        nmps: 36,
        nlps: 33,
        switchFlag: 0
    },
    {
        qe: 545,
        nmps: 37,
        nlps: 34,
        switchFlag: 0
    },
    {
        qe: 321,
        nmps: 38,
        nlps: 35,
        switchFlag: 0
    },
    {
        qe: 273,
        nmps: 39,
        nlps: 36,
        switchFlag: 0
    },
    {
        qe: 133,
        nmps: 40,
        nlps: 37,
        switchFlag: 0
    },
    {
        qe: 73,
        nmps: 41,
        nlps: 38,
        switchFlag: 0
    },
    {
        qe: 37,
        nmps: 42,
        nlps: 39,
        switchFlag: 0
    },
    {
        qe: 21,
        nmps: 43,
        nlps: 40,
        switchFlag: 0
    },
    {
        qe: 9,
        nmps: 44,
        nlps: 41,
        switchFlag: 0
    },
    {
        qe: 5,
        nmps: 45,
        nlps: 42,
        switchFlag: 0
    },
    {
        qe: 1,
        nmps: 45,
        nlps: 43,
        switchFlag: 0
    },
    {
        qe: 22017,
        nmps: 46,
        nlps: 46,
        switchFlag: 0
    }
];
class ArithmeticDecoder {
    constructor(e1, t, a){
        this.data = e1;
        this.bp = t;
        this.dataEnd = a;
        this.chigh = e1[t];
        this.clow = 0;
        this.byteIn();
        this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
        this.clow = this.clow << 7 & 65535;
        this.ct -= 7;
        this.a = 32768;
    }
    byteIn() {
        const e1 = this.data;
        let t = this.bp;
        if (255 === e1[t]) if (e1[t + 1] > 143) {
            this.clow += 65280;
            this.ct = 8;
        } else {
            t++;
            this.clow += e1[t] << 9;
            this.ct = 7;
            this.bp = t;
        }
        else {
            t++;
            this.clow += t < this.dataEnd ? e1[t] << 8 : 65280;
            this.ct = 8;
            this.bp = t;
        }
        if (this.clow > 65535) {
            this.chigh += this.clow >> 16;
            this.clow &= 65535;
        }
    }
    readBit(e1, t) {
        let a = e1[t] >> 1, r = 1 & e1[t];
        const i = za[a], n = i.qe;
        let s, o = this.a - n;
        if (this.chigh < n) if (o < n) {
            o = n;
            s = r;
            a = i.nmps;
        } else {
            o = n;
            s = 1 ^ r;
            1 === i.switchFlag && (r = s);
            a = i.nlps;
        }
        else {
            this.chigh -= n;
            if (32768 & o) {
                this.a = o;
                return r;
            }
            if (o < n) {
                s = 1 ^ r;
                1 === i.switchFlag && (r = s);
                a = i.nlps;
            } else {
                s = r;
                a = i.nmps;
            }
        }
        do {
            0 === this.ct && this.byteIn();
            o <<= 1;
            this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
            this.clow = this.clow << 1 & 65535;
            this.ct--;
        }while (!(32768 & o))
        this.a = o;
        e1[t] = a << 1 | r;
        return s;
    }
}
class Jbig2Error extends Jt {
    constructor(e1){
        super(e1, "Jbig2Error");
    }
}
class ContextCache {
    getContexts(e1) {
        return e1 in this ? this[e1] : this[e1] = new Int8Array(65536);
    }
}
class DecodingContext {
    constructor(e1, t, a){
        this.data = e1;
        this.start = t;
        this.end = a;
    }
    get decoder() {
        return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
    }
    get contextCache() {
        return shadow(this, "contextCache", new ContextCache);
    }
}
function decodeInteger(e1, t, a) {
    const r = e1.getContexts(t);
    let i = 1;
    function readBits(e1) {
        let t = 0;
        for(let n = 0; n < e1; n++){
            const e1 = a.readBit(r, i);
            i = i < 256 ? i << 1 | e1 : 511 & (i << 1 | e1) | 256;
            t = t << 1 | e1;
        }
        return t >>> 0;
    }
    const n = readBits(1), s = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
    let o;
    0 === n ? o = s : s > 0 && (o = -s);
    return o >= -2147483648 && o <= ca ? o : null;
}
function decodeIAID(e1, t, a) {
    const r = e1.getContexts("IAID");
    let i = 1;
    for(let e1 = 0; e1 < a; e1++){
        i = i << 1 | t.readBit(r, i);
    }
    return a < 31 ? i & (1 << a) - 1 : 2147483647 & i;
}
const $a = [
    "SymbolDictionary",
    null,
    null,
    null,
    "IntermediateTextRegion",
    null,
    "ImmediateTextRegion",
    "ImmediateLosslessTextRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PatternDictionary",
    null,
    null,
    null,
    "IntermediateHalftoneRegion",
    null,
    "ImmediateHalftoneRegion",
    "ImmediateLosslessHalftoneRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "IntermediateGenericRegion",
    null,
    "ImmediateGenericRegion",
    "ImmediateLosslessGenericRegion",
    "IntermediateGenericRefinementRegion",
    null,
    "ImmediateGenericRefinementRegion",
    "ImmediateLosslessGenericRefinementRegion",
    null,
    null,
    null,
    null,
    "PageInformation",
    "EndOfPage",
    "EndOfStripe",
    "EndOfFile",
    "Profiles",
    "Tables",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Extension"
], Ga = [
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: 2,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: 2,
            y: -1
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -1,
            y: -2
        },
        {
            x: 0,
            y: -2
        },
        {
            x: 1,
            y: -2
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ],
    [
        {
            x: -3,
            y: -1
        },
        {
            x: -2,
            y: -1
        },
        {
            x: -1,
            y: -1
        },
        {
            x: 0,
            y: -1
        },
        {
            x: 1,
            y: -1
        },
        {
            x: -4,
            y: 0
        },
        {
            x: -3,
            y: 0
        },
        {
            x: -2,
            y: 0
        },
        {
            x: -1,
            y: 0
        }
    ]
], Va = [
    {
        coding: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: -1,
                y: 1
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    },
    {
        coding: [
            {
                x: -1,
                y: -1
            },
            {
                x: 0,
                y: -1
            },
            {
                x: 1,
                y: -1
            },
            {
                x: -1,
                y: 0
            }
        ],
        reference: [
            {
                x: 0,
                y: -1
            },
            {
                x: -1,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: 0
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 1,
                y: 1
            }
        ]
    }
], Ka = [
    39717,
    1941,
    229,
    405
], Ja = [
    32,
    8
];
function decodeBitmap(e1, t, a, r, i, n, s, o) {
    if (e1) {
        return decodeMMRBitmap(new Reader(o.data, o.start, o.end), t, a, !1);
    }
    if (0 === r && !n && !i && 4 === s.length && 3 === s[0].x && -1 === s[0].y && -3 === s[1].x && -1 === s[1].y && 2 === s[2].x && -2 === s[2].y && -2 === s[3].x && -2 === s[3].y) return function decodeBitmapTemplate0(e1, t, a) {
        const r = a.decoder, i = a.contextCache.getContexts("GB"), n = [];
        let s, o, c, l, h, u, d;
        for(o = 0; o < t; o++){
            h = n[o] = new Uint8Array(e1);
            u = o < 1 ? h : n[o - 1];
            d = o < 2 ? h : n[o - 2];
            s = d[0] << 13 | d[1] << 12 | d[2] << 11 | u[0] << 7 | u[1] << 6 | u[2] << 5 | u[3] << 4;
            for(c = 0; c < e1; c++){
                h[c] = l = r.readBit(i, s);
                s = (31735 & s) << 1 | (c + 3 < e1 ? d[c + 3] << 11 : 0) | (c + 4 < e1 ? u[c + 4] << 4 : 0) | l;
            }
        }
        return n;
    }(t, a, o);
    const c = !!n, l = Ga[r].concat(s);
    l.sort((e1, t)=>e1.y - t.y || e1.x - t.x);
    const h = l.length, u = new Int8Array(h), d = new Int8Array(h), f = [];
    let g, p, m = 0, b = 0, y = 0, w = 0;
    for(p = 0; p < h; p++){
        u[p] = l[p].x;
        d[p] = l[p].y;
        b = Math.min(b, l[p].x);
        y = Math.max(y, l[p].x);
        w = Math.min(w, l[p].y);
        p < h - 1 && l[p].y === l[p + 1].y && l[p].x === l[p + 1].x - 1 ? m |= 1 << h - 1 - p : f.push(p);
    }
    const x = f.length, S = new Int8Array(x), k = new Int8Array(x), C = new Uint16Array(x);
    for(g = 0; g < x; g++){
        p = f[g];
        S[g] = l[p].x;
        k[g] = l[p].y;
        C[g] = 1 << h - 1 - p;
    }
    const v = -b, F = -w, T = t - y, O = Ka[r];
    let M = new Uint8Array(t);
    const D = [], R = o.decoder, N = o.contextCache.getContexts("GB");
    let E, L, j, _, U, X = 0, q = 0;
    for(let e1 = 0; e1 < a; e1++){
        if (i) {
            X ^= R.readBit(N, O);
            if (X) {
                D.push(M);
                continue;
            }
        }
        M = new Uint8Array(M);
        D.push(M);
        for(E = 0; E < t; E++){
            if (c && n[e1][E]) {
                M[E] = 0;
                continue;
            }
            if (E >= v && E < T && e1 >= F) {
                q = q << 1 & m;
                for(p = 0; p < x; p++){
                    L = e1 + k[p];
                    j = E + S[p];
                    _ = D[L][j];
                    if (_) {
                        _ = C[p];
                        q |= _;
                    }
                }
            } else {
                q = 0;
                U = h - 1;
                for(p = 0; p < h; p++, U--){
                    j = E + u[p];
                    if (j >= 0 && j < t) {
                        L = e1 + d[p];
                        if (L >= 0) {
                            _ = D[L][j];
                            _ && (q |= _ << U);
                        }
                    }
                }
            }
            const a = R.readBit(N, q);
            M[E] = a;
        }
    }
    return D;
}
function decodeRefinement(e1, t, a, r, i, n, s, o, c) {
    let l = Va[a].coding;
    0 === a && (l = l.concat([
        o[0]
    ]));
    const h = l.length, u = new Int32Array(h), d = new Int32Array(h);
    let f;
    for(f = 0; f < h; f++){
        u[f] = l[f].x;
        d[f] = l[f].y;
    }
    let g = Va[a].reference;
    0 === a && (g = g.concat([
        o[1]
    ]));
    const p = g.length, m = new Int32Array(p), b = new Int32Array(p);
    for(f = 0; f < p; f++){
        m[f] = g[f].x;
        b[f] = g[f].y;
    }
    const y = r[0].length, w = r.length, x = Ja[a], S = [], k = c.decoder, C = c.contextCache.getContexts("GR");
    let v = 0;
    for(let a = 0; a < t; a++){
        if (s) {
            v ^= k.readBit(C, x);
            if (v) throw new Jbig2Error("prediction is not supported");
        }
        const t = new Uint8Array(e1);
        S.push(t);
        for(let s = 0; s < e1; s++){
            let o, c, l = 0;
            for(f = 0; f < h; f++){
                o = a + d[f];
                c = s + u[f];
                o < 0 || c < 0 || c >= e1 ? l <<= 1 : l = l << 1 | S[o][c];
            }
            for(f = 0; f < p; f++){
                o = a + b[f] - n;
                c = s + m[f] - i;
                o < 0 || o >= w || c < 0 || c >= y ? l <<= 1 : l = l << 1 | r[o][c];
            }
            const g = k.readBit(C, l);
            t[s] = g;
        }
    }
    return S;
}
function decodeTextRegion(e1, t, a, r, i, n, s, o, c, l, h, u, d, f, g, p, m, b, y) {
    if (e1 && t) throw new Jbig2Error("refinement with Huffman is not supported");
    const w = [];
    let x, S;
    for(x = 0; x < r; x++){
        S = new Uint8Array(a);
        i && S.fill(i);
        w.push(S);
    }
    const k = m.decoder, C = m.contextCache;
    let v = e1 ? -f.tableDeltaT.decode(y) : -decodeInteger(C, "IADT", k), F = 0;
    x = 0;
    for(; x < n;){
        v += e1 ? f.tableDeltaT.decode(y) : decodeInteger(C, "IADT", k);
        F += e1 ? f.tableFirstS.decode(y) : decodeInteger(C, "IAFS", k);
        let r = F;
        for(;;){
            let i = 0;
            s > 1 && (i = e1 ? y.readBits(b) : decodeInteger(C, "IAIT", k));
            const n = s * v + i, F = e1 ? f.symbolIDTable.decode(y) : decodeIAID(C, k, c), T = t && (e1 ? y.readBit() : decodeInteger(C, "IARI", k));
            let O = o[F], M = O[0].length, D = O.length;
            if (T) {
                const e1 = decodeInteger(C, "IARDW", k), t = decodeInteger(C, "IARDH", k);
                M += e1;
                D += t;
                O = decodeRefinement(M, D, g, O, (e1 >> 1) + decodeInteger(C, "IARDX", k), (t >> 1) + decodeInteger(C, "IARDY", k), !1, p, m);
            }
            let R = 0;
            l ? 1 & u ? R = D - 1 : r += D - 1 : u > 1 ? r += M - 1 : R = M - 1;
            const N = n - (1 & u ? 0 : D - 1), E = r - (2 & u ? M - 1 : 0);
            let L, j, _;
            if (l) for(L = 0; L < D; L++){
                S = w[E + L];
                if (!S) continue;
                _ = O[L];
                const e1 = Math.min(a - N, M);
                switch(d){
                    case 0:
                        for(j = 0; j < e1; j++)S[N + j] |= _[j];
                        break;
                    case 2:
                        for(j = 0; j < e1; j++)S[N + j] ^= _[j];
                        break;
                    default:
                        throw new Jbig2Error(`operator ${d} is not supported`);
                }
            }
            else for(j = 0; j < D; j++){
                S = w[N + j];
                if (S) {
                    _ = O[j];
                    switch(d){
                        case 0:
                            for(L = 0; L < M; L++)S[E + L] |= _[L];
                            break;
                        case 2:
                            for(L = 0; L < M; L++)S[E + L] ^= _[L];
                            break;
                        default:
                            throw new Jbig2Error(`operator ${d} is not supported`);
                    }
                }
            }
            x++;
            const U = e1 ? f.tableDeltaS.decode(y) : decodeInteger(C, "IADS", k);
            if (null === U) break;
            r += R + U + h;
        }
    }
    return w;
}
function readSegmentHeader(e1, t) {
    const a = {};
    a.number = readUint32(e1, t);
    const r = e1[t + 4], i = 63 & r;
    if (!$a[i]) throw new Jbig2Error("invalid segment type: " + i);
    a.type = i;
    a.typeName = $a[i];
    a.deferredNonRetain = !!(128 & r);
    const n = !!(64 & r), s = e1[t + 5];
    let o = s >> 5 & 7;
    const c = [
        31 & s
    ];
    let l = t + 6;
    if (7 === s) {
        o = 536870911 & readUint32(e1, l - 1);
        l += 3;
        let t = o + 7 >> 3;
        c[0] = e1[l++];
        for(; --t > 0;)c.push(e1[l++]);
    } else if (5 === s || 6 === s) throw new Jbig2Error("invalid referred-to flags");
    a.retainBits = c;
    let h = 4;
    a.number <= 256 ? h = 1 : a.number <= 65536 && (h = 2);
    const u = [];
    let d, f;
    for(d = 0; d < o; d++){
        let t;
        t = 1 === h ? e1[l] : 2 === h ? readUint16(e1, l) : readUint32(e1, l);
        u.push(t);
        l += h;
    }
    a.referredTo = u;
    if (n) {
        a.pageAssociation = readUint32(e1, l);
        l += 4;
    } else a.pageAssociation = e1[l++];
    a.length = readUint32(e1, l);
    l += 4;
    if (4294967295 === a.length) {
        if (38 !== i) throw new Jbig2Error("invalid unknown segment length");
        {
            const t = readRegionSegmentInformation(e1, l), r = !!(1 & e1[l + Ya]), i = 6, n = new Uint8Array(i);
            if (!r) {
                n[0] = 255;
                n[1] = 172;
            }
            n[2] = t.height >>> 24 & 255;
            n[3] = t.height >> 16 & 255;
            n[4] = t.height >> 8 & 255;
            n[5] = 255 & t.height;
            for(d = l, f = e1.length; d < f; d++){
                let t = 0;
                for(; t < i && n[t] === e1[d + t];)t++;
                if (t === i) {
                    a.length = d + i;
                    break;
                }
            }
            if (4294967295 === a.length) throw new Jbig2Error("segment end was not found");
        }
    }
    a.headerEnd = l;
    return a;
}
function readSegments(e1, t, a, r) {
    const i = [];
    let n = a;
    for(; n < r;){
        const a = readSegmentHeader(t, n);
        n = a.headerEnd;
        const r = {
            header: a,
            data: t
        };
        if (!e1.randomAccess) {
            r.start = n;
            n += a.length;
            r.end = n;
        }
        i.push(r);
        if (51 === a.type) break;
    }
    if (e1.randomAccess) for(let e1 = 0, t = i.length; e1 < t; e1++){
        i[e1].start = n;
        n += i[e1].header.length;
        i[e1].end = n;
    }
    return i;
}
function readRegionSegmentInformation(e1, t) {
    return {
        width: readUint32(e1, t),
        height: readUint32(e1, t + 4),
        x: readUint32(e1, t + 8),
        y: readUint32(e1, t + 12),
        combinationOperator: 7 & e1[t + 16]
    };
}
const Ya = 17;
function processSegment(e1, t) {
    const a = e1.header, r = e1.data, i = e1.end;
    let n, s, o, c, l = e1.start;
    switch(a.type){
        case 0:
            const e2 = {}, t1 = readUint16(r, l);
            e2.huffman = !!(1 & t1);
            e2.refinement = !!(2 & t1);
            e2.huffmanDHSelector = t1 >> 2 & 3;
            e2.huffmanDWSelector = t1 >> 4 & 3;
            e2.bitmapSizeSelector = t1 >> 6 & 1;
            e2.aggregationInstancesSelector = t1 >> 7 & 1;
            e2.bitmapCodingContextUsed = !!(256 & t1);
            e2.bitmapCodingContextRetained = !!(512 & t1);
            e2.template = t1 >> 10 & 3;
            e2.refinementTemplate = t1 >> 12 & 1;
            l += 2;
            if (!e2.huffman) {
                c = 0 === e2.template ? 4 : 1;
                s = [];
                for(o = 0; o < c; o++){
                    s.push({
                        x: readInt8(r, l),
                        y: readInt8(r, l + 1)
                    });
                    l += 2;
                }
                e2.at = s;
            }
            if (e2.refinement && !e2.refinementTemplate) {
                s = [];
                for(o = 0; o < 2; o++){
                    s.push({
                        x: readInt8(r, l),
                        y: readInt8(r, l + 1)
                    });
                    l += 2;
                }
                e2.refinementAt = s;
            }
            e2.numberOfExportedSymbols = readUint32(r, l);
            l += 4;
            e2.numberOfNewSymbols = readUint32(r, l);
            l += 4;
            n = [
                e2,
                a.number,
                a.referredTo,
                r,
                l,
                i
            ];
            break;
        case 6:
        case 7:
            const h = {};
            h.info = readRegionSegmentInformation(r, l);
            l += Ya;
            const u = readUint16(r, l);
            l += 2;
            h.huffman = !!(1 & u);
            h.refinement = !!(2 & u);
            h.logStripSize = u >> 2 & 3;
            h.stripSize = 1 << h.logStripSize;
            h.referenceCorner = u >> 4 & 3;
            h.transposed = !!(64 & u);
            h.combinationOperator = u >> 7 & 3;
            h.defaultPixelValue = u >> 9 & 1;
            h.dsOffset = u << 17 >> 27;
            h.refinementTemplate = u >> 15 & 1;
            if (h.huffman) {
                const e1 = readUint16(r, l);
                l += 2;
                h.huffmanFS = 3 & e1;
                h.huffmanDS = e1 >> 2 & 3;
                h.huffmanDT = e1 >> 4 & 3;
                h.huffmanRefinementDW = e1 >> 6 & 3;
                h.huffmanRefinementDH = e1 >> 8 & 3;
                h.huffmanRefinementDX = e1 >> 10 & 3;
                h.huffmanRefinementDY = e1 >> 12 & 3;
                h.huffmanRefinementSizeSelector = !!(16384 & e1);
            }
            if (h.refinement && !h.refinementTemplate) {
                s = [];
                for(o = 0; o < 2; o++){
                    s.push({
                        x: readInt8(r, l),
                        y: readInt8(r, l + 1)
                    });
                    l += 2;
                }
                h.refinementAt = s;
            }
            h.numberOfSymbolInstances = readUint32(r, l);
            l += 4;
            n = [
                h,
                a.referredTo,
                r,
                l,
                i
            ];
            break;
        case 16:
            const d = {}, f = r[l++];
            d.mmr = !!(1 & f);
            d.template = f >> 1 & 3;
            d.patternWidth = r[l++];
            d.patternHeight = r[l++];
            d.maxPatternIndex = readUint32(r, l);
            l += 4;
            n = [
                d,
                a.number,
                r,
                l,
                i
            ];
            break;
        case 22:
        case 23:
            const g = {};
            g.info = readRegionSegmentInformation(r, l);
            l += Ya;
            const p = r[l++];
            g.mmr = !!(1 & p);
            g.template = p >> 1 & 3;
            g.enableSkip = !!(8 & p);
            g.combinationOperator = p >> 4 & 7;
            g.defaultPixelValue = p >> 7 & 1;
            g.gridWidth = readUint32(r, l);
            l += 4;
            g.gridHeight = readUint32(r, l);
            l += 4;
            g.gridOffsetX = 4294967295 & readUint32(r, l);
            l += 4;
            g.gridOffsetY = 4294967295 & readUint32(r, l);
            l += 4;
            g.gridVectorX = readUint16(r, l);
            l += 2;
            g.gridVectorY = readUint16(r, l);
            l += 2;
            n = [
                g,
                a.referredTo,
                r,
                l,
                i
            ];
            break;
        case 38:
        case 39:
            const m = {};
            m.info = readRegionSegmentInformation(r, l);
            l += Ya;
            const b = r[l++];
            m.mmr = !!(1 & b);
            m.template = b >> 1 & 3;
            m.prediction = !!(8 & b);
            if (!m.mmr) {
                c = 0 === m.template ? 4 : 1;
                s = [];
                for(o = 0; o < c; o++){
                    s.push({
                        x: readInt8(r, l),
                        y: readInt8(r, l + 1)
                    });
                    l += 2;
                }
                m.at = s;
            }
            n = [
                m,
                r,
                l,
                i
            ];
            break;
        case 48:
            const y = {
                width: readUint32(r, l),
                height: readUint32(r, l + 4),
                resolutionX: readUint32(r, l + 8),
                resolutionY: readUint32(r, l + 12)
            };
            4294967295 === y.height && delete y.height;
            const w = r[l + 16];
            readUint16(r, l + 17);
            y.lossless = !!(1 & w);
            y.refinement = !!(2 & w);
            y.defaultPixelValue = w >> 2 & 1;
            y.combinationOperator = w >> 3 & 3;
            y.requiresBuffer = !!(32 & w);
            y.combinationOperatorOverride = !!(64 & w);
            n = [
                y
            ];
            break;
        case 49:
        case 50:
        case 51:
        case 62:
            break;
        case 53:
            n = [
                a.number,
                r,
                l,
                i
            ];
            break;
        default:
            throw new Jbig2Error(`segment type ${a.typeName}(${a.type}) is not implemented`);
    }
    const h1 = "on" + a.typeName;
    h1 in t && t[h1].apply(t, n);
}
function processSegments(e1, t) {
    for(let a = 0, r = e1.length; a < r; a++)processSegment(e1[a], t);
}
class SimpleSegmentVisitor {
    onPageInformation(e1) {
        this.currentPageInfo = e1;
        const t = e1.width + 7 >> 3, a = new Uint8ClampedArray(t * e1.height);
        e1.defaultPixelValue && a.fill(255);
        this.buffer = a;
    }
    drawBitmap(e1, t) {
        const a = this.currentPageInfo, r = e1.width, i = e1.height, n = a.width + 7 >> 3, s = a.combinationOperatorOverride ? e1.combinationOperator : a.combinationOperator, o = this.buffer, c = 128 >> (7 & e1.x);
        let l, h, u, d, f = e1.y * n + (e1.x >> 3);
        switch(s){
            case 0:
                for(l = 0; l < i; l++){
                    u = c;
                    d = f;
                    for(h = 0; h < r; h++){
                        t[l][h] && (o[d] |= u);
                        u >>= 1;
                        if (!u) {
                            u = 128;
                            d++;
                        }
                    }
                    f += n;
                }
                break;
            case 2:
                for(l = 0; l < i; l++){
                    u = c;
                    d = f;
                    for(h = 0; h < r; h++){
                        t[l][h] && (o[d] ^= u);
                        u >>= 1;
                        if (!u) {
                            u = 128;
                            d++;
                        }
                    }
                    f += n;
                }
                break;
            default:
                throw new Jbig2Error(`operator ${s} is not supported`);
        }
    }
    onImmediateGenericRegion(e1, t, a, r) {
        const i = e1.info, n = new DecodingContext(t, a, r), s = decodeBitmap(e1.mmr, i.width, i.height, e1.template, e1.prediction, null, e1.at, n);
        this.drawBitmap(i, s);
    }
    onImmediateLosslessGenericRegion() {
        this.onImmediateGenericRegion(...arguments);
    }
    onSymbolDictionary(e1, t, a, r, i, n) {
        let s, o;
        if (e1.huffman) {
            s = function getSymbolDictionaryHuffmanTables(e1, t, a) {
                let r, i, n, s, o = 0;
                switch(e1.huffmanDHSelector){
                    case 0:
                    case 1:
                        r = getStandardTable(e1.huffmanDHSelector + 4);
                        break;
                    case 3:
                        r = getCustomHuffmanTable(o, t, a);
                        o++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch(e1.huffmanDWSelector){
                    case 0:
                    case 1:
                        i = getStandardTable(e1.huffmanDWSelector + 2);
                        break;
                    case 3:
                        i = getCustomHuffmanTable(o, t, a);
                        o++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DW selector");
                }
                if (e1.bitmapSizeSelector) {
                    n = getCustomHuffmanTable(o, t, a);
                    o++;
                } else n = getStandardTable(1);
                s = e1.aggregationInstancesSelector ? getCustomHuffmanTable(o, t, a) : getStandardTable(1);
                return {
                    tableDeltaHeight: r,
                    tableDeltaWidth: i,
                    tableBitmapSize: n,
                    tableAggregateInstances: s
                };
            }(e1, a, this.customTables);
            o = new Reader(r, i, n);
        }
        let c = this.symbols;
        c || (this.symbols = c = {});
        const l = [];
        for (const e1 of a){
            const t = c[e1];
            t && l.push(...t);
        }
        const h = new DecodingContext(r, i, n);
        c[t] = function decodeSymbolDictionary(e1, t, a, r, i, n, s, o, c, l, h, u) {
            if (e1 && t) throw new Jbig2Error("symbol refinement with Huffman is not supported");
            const d = [];
            let f = 0, g = log2(a.length + r);
            const p = h.decoder, m = h.contextCache;
            let b, y;
            if (e1) {
                b = getStandardTable(1);
                y = [];
                g = Math.max(g, 1);
            }
            for(; d.length < r;){
                f += e1 ? n.tableDeltaHeight.decode(u) : decodeInteger(m, "IADH", p);
                let r = 0, i = 0;
                const b = e1 ? y.length : 0;
                for(;;){
                    const b = e1 ? n.tableDeltaWidth.decode(u) : decodeInteger(m, "IADW", p);
                    if (null === b) break;
                    r += b;
                    i += r;
                    let w;
                    if (t) {
                        const i = decodeInteger(m, "IAAI", p);
                        if (i > 1) w = decodeTextRegion(e1, t, r, f, 0, i, 1, a.concat(d), g, 0, 0, 1, 0, n, c, l, h, 0, u);
                        else {
                            const e1 = decodeIAID(m, p, g), t = decodeInteger(m, "IARDX", p), i = decodeInteger(m, "IARDY", p);
                            w = decodeRefinement(r, f, c, e1 < a.length ? a[e1] : d[e1 - a.length], t, i, !1, l, h);
                        }
                        d.push(w);
                    } else if (e1) y.push(r);
                    else {
                        w = decodeBitmap(!1, r, f, s, !1, null, o, h);
                        d.push(w);
                    }
                }
                if (e1 && !t) {
                    const e1 = n.tableBitmapSize.decode(u);
                    u.byteAlign();
                    let t;
                    if (0 === e1) t = readUncompressedBitmap(u, i, f);
                    else {
                        const a = u.end, r = u.position + e1;
                        u.end = r;
                        t = decodeMMRBitmap(u, i, f, !1);
                        u.end = a;
                        u.position = r;
                    }
                    const a = y.length;
                    if (b === a - 1) d.push(t);
                    else {
                        let e1, r, i, n, s, o = 0;
                        for(e1 = b; e1 < a; e1++){
                            n = y[e1];
                            i = o + n;
                            s = [];
                            for(r = 0; r < f; r++)s.push(t[r].subarray(o, i));
                            d.push(s);
                            o = i;
                        }
                    }
                }
            }
            const w = [], x = [];
            let S, k, C = !1;
            const v = a.length + r;
            for(; x.length < v;){
                let t = e1 ? b.decode(u) : decodeInteger(m, "IAEX", p);
                for(; t--;)x.push(C);
                C = !C;
            }
            for(S = 0, k = a.length; S < k; S++)x[S] && w.push(a[S]);
            for(let e1 = 0; e1 < r; S++, e1++)x[S] && w.push(d[e1]);
            return w;
        }(e1.huffman, e1.refinement, l, e1.numberOfNewSymbols, e1.numberOfExportedSymbols, s, e1.template, e1.at, e1.refinementTemplate, e1.refinementAt, h, o);
    }
    onImmediateTextRegion(e1, t, a, r, i) {
        const n = e1.info;
        let s, o;
        const c = this.symbols, l = [];
        for (const e1 of t){
            const t = c[e1];
            t && l.push(...t);
        }
        const h = log2(l.length);
        if (e1.huffman) {
            o = new Reader(a, r, i);
            s = function getTextRegionHuffmanTables(e1, t, a, r, i) {
                const n = [];
                for(let e1 = 0; e1 <= 34; e1++){
                    const t = i.readBits(4);
                    n.push(new HuffmanLine([
                        e1,
                        t,
                        0,
                        0
                    ]));
                }
                const s = new HuffmanTable(n, !1);
                n.length = 0;
                for(let e1 = 0; e1 < r;){
                    const t = s.decode(i);
                    if (t >= 32) {
                        let a, r, s;
                        switch(t){
                            case 32:
                                if (0 === e1) throw new Jbig2Error("no previous value in symbol ID table");
                                r = i.readBits(2) + 3;
                                a = n[e1 - 1].prefixLength;
                                break;
                            case 33:
                                r = i.readBits(3) + 3;
                                a = 0;
                                break;
                            case 34:
                                r = i.readBits(7) + 11;
                                a = 0;
                                break;
                            default:
                                throw new Jbig2Error("invalid code length in symbol ID table");
                        }
                        for(s = 0; s < r; s++){
                            n.push(new HuffmanLine([
                                e1,
                                a,
                                0,
                                0
                            ]));
                            e1++;
                        }
                    } else {
                        n.push(new HuffmanLine([
                            e1,
                            t,
                            0,
                            0
                        ]));
                        e1++;
                    }
                }
                i.byteAlign();
                const o = new HuffmanTable(n, !1);
                let c, l, h, u = 0;
                switch(e1.huffmanFS){
                    case 0:
                    case 1:
                        c = getStandardTable(e1.huffmanFS + 6);
                        break;
                    case 3:
                        c = getCustomHuffmanTable(u, t, a);
                        u++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch(e1.huffmanDS){
                    case 0:
                    case 1:
                    case 2:
                        l = getStandardTable(e1.huffmanDS + 8);
                        break;
                    case 3:
                        l = getCustomHuffmanTable(u, t, a);
                        u++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch(e1.huffmanDT){
                    case 0:
                    case 1:
                    case 2:
                        h = getStandardTable(e1.huffmanDT + 11);
                        break;
                    case 3:
                        h = getCustomHuffmanTable(u, t, a);
                        u++;
                        break;
                    default:
                        throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (e1.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
                return {
                    symbolIDTable: o,
                    tableFirstS: c,
                    tableDeltaS: l,
                    tableDeltaT: h
                };
            }(e1, t, this.customTables, l.length, o);
        }
        const u = new DecodingContext(a, r, i), d = decodeTextRegion(e1.huffman, e1.refinement, n.width, n.height, e1.defaultPixelValue, e1.numberOfSymbolInstances, e1.stripSize, l, h, e1.transposed, e1.dsOffset, e1.referenceCorner, e1.combinationOperator, s, e1.refinementTemplate, e1.refinementAt, u, e1.logStripSize, o);
        this.drawBitmap(n, d);
    }
    onImmediateLosslessTextRegion() {
        this.onImmediateTextRegion(...arguments);
    }
    onPatternDictionary(e1, t, a, r, i) {
        let n = this.patterns;
        n || (this.patterns = n = {});
        const s = new DecodingContext(a, r, i);
        n[t] = function decodePatternDictionary(e1, t, a, r, i, n) {
            const s = [];
            if (!e1) {
                s.push({
                    x: -t,
                    y: 0
                });
                0 === i && s.push({
                    x: -3,
                    y: -1
                }, {
                    x: 2,
                    y: -2
                }, {
                    x: -2,
                    y: -2
                });
            }
            const o = decodeBitmap(e1, (r + 1) * t, a, i, !1, null, s, n), c = [];
            for(let e1 = 0; e1 <= r; e1++){
                const r = [], i = t * e1, n = i + t;
                for(let e1 = 0; e1 < a; e1++)r.push(o[e1].subarray(i, n));
                c.push(r);
            }
            return c;
        }(e1.mmr, e1.patternWidth, e1.patternHeight, e1.maxPatternIndex, e1.template, s);
    }
    onImmediateHalftoneRegion(e1, t, a, r, i) {
        const n = this.patterns[t[0]], s = e1.info, o = new DecodingContext(a, r, i), c = function decodeHalftoneRegion(e1, t, a, r, i, n, s, o, c, l, h, u, d, f, g) {
            if (s) throw new Jbig2Error("skip is not supported");
            if (0 !== o) throw new Jbig2Error(`operator "${o}" is not supported in halftone region`);
            const p = [];
            let m, b, y;
            for(m = 0; m < i; m++){
                y = new Uint8Array(r);
                n && y.fill(n);
                p.push(y);
            }
            const w = t.length, x = t[0], S = x[0].length, k = x.length, C = log2(w), v = [];
            if (!e1) {
                v.push({
                    x: a <= 1 ? 3 : 2,
                    y: -1
                });
                0 === a && v.push({
                    x: -3,
                    y: -1
                }, {
                    x: 2,
                    y: -2
                }, {
                    x: -2,
                    y: -2
                });
            }
            const F = [];
            let T, O, M, D, R, N, E, L, j, _, U;
            e1 && (T = new Reader(g.data, g.start, g.end));
            for(m = C - 1; m >= 0; m--){
                O = e1 ? decodeMMRBitmap(T, c, l, !0) : decodeBitmap(!1, c, l, a, !1, null, v, g);
                F[m] = O;
            }
            for(M = 0; M < l; M++)for(D = 0; D < c; D++){
                R = 0;
                N = 0;
                for(b = C - 1; b >= 0; b--){
                    R ^= F[b][M][D];
                    N |= R << b;
                }
                E = t[N];
                L = h + M * f + D * d >> 8;
                j = u + M * d - D * f >> 8;
                if (L >= 0 && L + S <= r && j >= 0 && j + k <= i) for(m = 0; m < k; m++){
                    U = p[j + m];
                    _ = E[m];
                    for(b = 0; b < S; b++)U[L + b] |= _[b];
                }
                else {
                    let e1, t;
                    for(m = 0; m < k; m++){
                        t = j + m;
                        if (!(t < 0 || t >= i)) {
                            U = p[t];
                            _ = E[m];
                            for(b = 0; b < S; b++){
                                e1 = L + b;
                                e1 >= 0 && e1 < r && (U[e1] |= _[b]);
                            }
                        }
                    }
                }
            }
            return p;
        }(e1.mmr, n, e1.template, s.width, s.height, e1.defaultPixelValue, e1.enableSkip, e1.combinationOperator, e1.gridWidth, e1.gridHeight, e1.gridOffsetX, e1.gridOffsetY, e1.gridVectorX, e1.gridVectorY, o);
        this.drawBitmap(s, c);
    }
    onImmediateLosslessHalftoneRegion() {
        this.onImmediateHalftoneRegion(...arguments);
    }
    onTables(e1, t, a, r) {
        let i = this.customTables;
        i || (this.customTables = i = {});
        i[e1] = function decodeTablesSegment(e1, t, a) {
            const r = e1[t], i = 4294967295 & readUint32(e1, t + 1), n = 4294967295 & readUint32(e1, t + 5), s = new Reader(e1, t + 9, a), o = 1 + (r >> 1 & 7), c = 1 + (r >> 4 & 7), l = [];
            let h, u, d = i;
            do {
                h = s.readBits(o);
                u = s.readBits(c);
                l.push(new HuffmanLine([
                    d,
                    h,
                    u,
                    0
                ]));
                d += 1 << u;
            }while (d < n)
            h = s.readBits(o);
            l.push(new HuffmanLine([
                i - 1,
                h,
                32,
                0,
                "lower"
            ]));
            h = s.readBits(o);
            l.push(new HuffmanLine([
                n,
                h,
                32,
                0
            ]));
            if (1 & r) {
                h = s.readBits(o);
                l.push(new HuffmanLine([
                    h,
                    0
                ]));
            }
            return new HuffmanTable(l, !1);
        }(t, a, r);
    }
}
class HuffmanLine {
    constructor(e1){
        if (2 === e1.length) {
            this.isOOB = !0;
            this.rangeLow = 0;
            this.prefixLength = e1[0];
            this.rangeLength = 0;
            this.prefixCode = e1[1];
            this.isLowerRange = !1;
        } else {
            this.isOOB = !1;
            this.rangeLow = e1[0];
            this.prefixLength = e1[1];
            this.rangeLength = e1[2];
            this.prefixCode = e1[3];
            this.isLowerRange = "lower" === e1[4];
        }
    }
}
class HuffmanTreeNode {
    constructor(e1){
        this.children = [];
        if (e1) {
            this.isLeaf = !0;
            this.rangeLength = e1.rangeLength;
            this.rangeLow = e1.rangeLow;
            this.isLowerRange = e1.isLowerRange;
            this.isOOB = e1.isOOB;
        } else this.isLeaf = !1;
    }
    buildTree(e1, t) {
        const a = e1.prefixCode >> t & 1;
        if (t <= 0) this.children[a] = new HuffmanTreeNode(e1);
        else {
            let r = this.children[a];
            r || (this.children[a] = r = new HuffmanTreeNode(null));
            r.buildTree(e1, t - 1);
        }
    }
    decodeNode(e1) {
        if (this.isLeaf) {
            if (this.isOOB) return null;
            const t = e1.readBits(this.rangeLength);
            return this.rangeLow + (this.isLowerRange ? -t : t);
        }
        const t = this.children[e1.readBit()];
        if (!t) throw new Jbig2Error("invalid Huffman data");
        return t.decodeNode(e1);
    }
}
class HuffmanTable {
    constructor(e1, t){
        t || this.assignPrefixCodes(e1);
        this.rootNode = new HuffmanTreeNode(null);
        for(let t = 0, a = e1.length; t < a; t++){
            const a = e1[t];
            a.prefixLength > 0 && this.rootNode.buildTree(a, a.prefixLength - 1);
        }
    }
    decode(e1) {
        return this.rootNode.decodeNode(e1);
    }
    assignPrefixCodes(e1) {
        const t = e1.length;
        let a = 0;
        for(let r = 0; r < t; r++)a = Math.max(a, e1[r].prefixLength);
        const r = new Uint32Array(a + 1);
        for(let a = 0; a < t; a++)r[e1[a].prefixLength]++;
        let i, n, s, o = 1, c = 0;
        r[0] = 0;
        for(; o <= a;){
            c = c + r[o - 1] << 1;
            i = c;
            n = 0;
            for(; n < t;){
                s = e1[n];
                if (s.prefixLength === o) {
                    s.prefixCode = i;
                    i++;
                }
                n++;
            }
            o++;
        }
    }
}
const Za = {};
function getStandardTable(e1) {
    let t, a = Za[e1];
    if (a) return a;
    switch(e1){
        case 1:
            t = [
                [
                    0,
                    1,
                    4,
                    0
                ],
                [
                    16,
                    2,
                    8,
                    2
                ],
                [
                    272,
                    3,
                    16,
                    6
                ],
                [
                    65808,
                    3,
                    32,
                    7
                ]
            ];
            break;
        case 2:
            t = [
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    75,
                    6,
                    32,
                    62
                ],
                [
                    6,
                    63
                ]
            ];
            break;
        case 3:
            t = [
                [
                    -256,
                    8,
                    8,
                    254
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    2
                ],
                [
                    2,
                    3,
                    0,
                    6
                ],
                [
                    3,
                    4,
                    3,
                    14
                ],
                [
                    11,
                    5,
                    6,
                    30
                ],
                [
                    -257,
                    8,
                    32,
                    255,
                    "lower"
                ],
                [
                    75,
                    7,
                    32,
                    126
                ],
                [
                    6,
                    62
                ]
            ];
            break;
        case 4:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    76,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 5:
            t = [
                [
                    -255,
                    7,
                    8,
                    126
                ],
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    0,
                    6
                ],
                [
                    4,
                    4,
                    3,
                    14
                ],
                [
                    12,
                    5,
                    6,
                    30
                ],
                [
                    -256,
                    7,
                    32,
                    127,
                    "lower"
                ],
                [
                    76,
                    6,
                    32,
                    62
                ]
            ];
            break;
        case 6:
            t = [
                [
                    -2048,
                    5,
                    10,
                    28
                ],
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    4,
                    8,
                    9
                ],
                [
                    -256,
                    4,
                    7,
                    10
                ],
                [
                    -128,
                    5,
                    6,
                    29
                ],
                [
                    -64,
                    5,
                    5,
                    30
                ],
                [
                    -32,
                    4,
                    5,
                    11
                ],
                [
                    0,
                    2,
                    7,
                    0
                ],
                [
                    128,
                    3,
                    7,
                    2
                ],
                [
                    256,
                    3,
                    8,
                    3
                ],
                [
                    512,
                    4,
                    9,
                    12
                ],
                [
                    1024,
                    4,
                    10,
                    13
                ],
                [
                    -2049,
                    6,
                    32,
                    62,
                    "lower"
                ],
                [
                    2048,
                    6,
                    32,
                    63
                ]
            ];
            break;
        case 7:
            t = [
                [
                    -1024,
                    4,
                    9,
                    8
                ],
                [
                    -512,
                    3,
                    8,
                    0
                ],
                [
                    -256,
                    4,
                    7,
                    9
                ],
                [
                    -128,
                    5,
                    6,
                    26
                ],
                [
                    -64,
                    5,
                    5,
                    27
                ],
                [
                    -32,
                    4,
                    5,
                    10
                ],
                [
                    0,
                    4,
                    5,
                    11
                ],
                [
                    32,
                    5,
                    5,
                    28
                ],
                [
                    64,
                    5,
                    6,
                    29
                ],
                [
                    128,
                    4,
                    7,
                    12
                ],
                [
                    256,
                    3,
                    8,
                    1
                ],
                [
                    512,
                    3,
                    9,
                    2
                ],
                [
                    1024,
                    3,
                    10,
                    3
                ],
                [
                    -1025,
                    5,
                    32,
                    30,
                    "lower"
                ],
                [
                    2048,
                    5,
                    32,
                    31
                ]
            ];
            break;
        case 8:
            t = [
                [
                    -15,
                    8,
                    3,
                    252
                ],
                [
                    -7,
                    9,
                    1,
                    508
                ],
                [
                    -5,
                    8,
                    1,
                    253
                ],
                [
                    -3,
                    9,
                    0,
                    509
                ],
                [
                    -2,
                    7,
                    0,
                    124
                ],
                [
                    -1,
                    4,
                    0,
                    10
                ],
                [
                    0,
                    2,
                    1,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    26
                ],
                [
                    3,
                    6,
                    0,
                    58
                ],
                [
                    4,
                    3,
                    4,
                    4
                ],
                [
                    20,
                    6,
                    1,
                    59
                ],
                [
                    22,
                    4,
                    4,
                    11
                ],
                [
                    38,
                    4,
                    5,
                    12
                ],
                [
                    70,
                    5,
                    6,
                    27
                ],
                [
                    134,
                    5,
                    7,
                    28
                ],
                [
                    262,
                    6,
                    7,
                    60
                ],
                [
                    390,
                    7,
                    8,
                    125
                ],
                [
                    646,
                    6,
                    10,
                    61
                ],
                [
                    -16,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    1670,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    1
                ]
            ];
            break;
        case 9:
            t = [
                [
                    -31,
                    8,
                    4,
                    252
                ],
                [
                    -15,
                    9,
                    2,
                    508
                ],
                [
                    -11,
                    8,
                    2,
                    253
                ],
                [
                    -7,
                    9,
                    1,
                    509
                ],
                [
                    -5,
                    7,
                    1,
                    124
                ],
                [
                    -3,
                    4,
                    1,
                    10
                ],
                [
                    -1,
                    3,
                    1,
                    2
                ],
                [
                    1,
                    3,
                    1,
                    3
                ],
                [
                    3,
                    5,
                    1,
                    26
                ],
                [
                    5,
                    6,
                    1,
                    58
                ],
                [
                    7,
                    3,
                    5,
                    4
                ],
                [
                    39,
                    6,
                    2,
                    59
                ],
                [
                    43,
                    4,
                    5,
                    11
                ],
                [
                    75,
                    4,
                    6,
                    12
                ],
                [
                    139,
                    5,
                    7,
                    27
                ],
                [
                    267,
                    5,
                    8,
                    28
                ],
                [
                    523,
                    6,
                    8,
                    60
                ],
                [
                    779,
                    7,
                    9,
                    125
                ],
                [
                    1291,
                    6,
                    11,
                    61
                ],
                [
                    -32,
                    9,
                    32,
                    510,
                    "lower"
                ],
                [
                    3339,
                    9,
                    32,
                    511
                ],
                [
                    2,
                    0
                ]
            ];
            break;
        case 10:
            t = [
                [
                    -21,
                    7,
                    4,
                    122
                ],
                [
                    -5,
                    8,
                    0,
                    252
                ],
                [
                    -4,
                    7,
                    0,
                    123
                ],
                [
                    -3,
                    5,
                    0,
                    24
                ],
                [
                    -2,
                    2,
                    2,
                    0
                ],
                [
                    2,
                    5,
                    0,
                    25
                ],
                [
                    3,
                    6,
                    0,
                    54
                ],
                [
                    4,
                    7,
                    0,
                    124
                ],
                [
                    5,
                    8,
                    0,
                    253
                ],
                [
                    6,
                    2,
                    6,
                    1
                ],
                [
                    70,
                    5,
                    5,
                    26
                ],
                [
                    102,
                    6,
                    5,
                    55
                ],
                [
                    134,
                    6,
                    6,
                    56
                ],
                [
                    198,
                    6,
                    7,
                    57
                ],
                [
                    326,
                    6,
                    8,
                    58
                ],
                [
                    582,
                    6,
                    9,
                    59
                ],
                [
                    1094,
                    6,
                    10,
                    60
                ],
                [
                    2118,
                    7,
                    11,
                    125
                ],
                [
                    -22,
                    8,
                    32,
                    254,
                    "lower"
                ],
                [
                    4166,
                    8,
                    32,
                    255
                ],
                [
                    2,
                    2
                ]
            ];
            break;
        case 11:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    1,
                    2
                ],
                [
                    4,
                    4,
                    0,
                    12
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    5,
                    1,
                    28
                ],
                [
                    9,
                    5,
                    2,
                    29
                ],
                [
                    13,
                    6,
                    2,
                    60
                ],
                [
                    17,
                    7,
                    2,
                    122
                ],
                [
                    21,
                    7,
                    3,
                    123
                ],
                [
                    29,
                    7,
                    4,
                    124
                ],
                [
                    45,
                    7,
                    5,
                    125
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 12:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    2,
                    0,
                    2
                ],
                [
                    3,
                    3,
                    1,
                    6
                ],
                [
                    5,
                    5,
                    0,
                    28
                ],
                [
                    6,
                    5,
                    1,
                    29
                ],
                [
                    8,
                    6,
                    1,
                    60
                ],
                [
                    10,
                    7,
                    0,
                    122
                ],
                [
                    11,
                    7,
                    1,
                    123
                ],
                [
                    13,
                    7,
                    2,
                    124
                ],
                [
                    17,
                    7,
                    3,
                    125
                ],
                [
                    25,
                    7,
                    4,
                    126
                ],
                [
                    41,
                    8,
                    5,
                    254
                ],
                [
                    73,
                    8,
                    32,
                    255
                ]
            ];
            break;
        case 13:
            t = [
                [
                    1,
                    1,
                    0,
                    0
                ],
                [
                    2,
                    3,
                    0,
                    4
                ],
                [
                    3,
                    4,
                    0,
                    12
                ],
                [
                    4,
                    5,
                    0,
                    28
                ],
                [
                    5,
                    4,
                    1,
                    13
                ],
                [
                    7,
                    3,
                    3,
                    5
                ],
                [
                    15,
                    6,
                    1,
                    58
                ],
                [
                    17,
                    6,
                    2,
                    59
                ],
                [
                    21,
                    6,
                    3,
                    60
                ],
                [
                    29,
                    6,
                    4,
                    61
                ],
                [
                    45,
                    6,
                    5,
                    62
                ],
                [
                    77,
                    7,
                    6,
                    126
                ],
                [
                    141,
                    7,
                    32,
                    127
                ]
            ];
            break;
        case 14:
            t = [
                [
                    -2,
                    3,
                    0,
                    4
                ],
                [
                    -1,
                    3,
                    0,
                    5
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    6
                ],
                [
                    2,
                    3,
                    0,
                    7
                ]
            ];
            break;
        case 15:
            t = [
                [
                    -24,
                    7,
                    4,
                    124
                ],
                [
                    -8,
                    6,
                    2,
                    60
                ],
                [
                    -4,
                    5,
                    1,
                    28
                ],
                [
                    -2,
                    4,
                    0,
                    12
                ],
                [
                    -1,
                    3,
                    0,
                    4
                ],
                [
                    0,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    0,
                    5
                ],
                [
                    2,
                    4,
                    0,
                    13
                ],
                [
                    3,
                    5,
                    1,
                    29
                ],
                [
                    5,
                    6,
                    2,
                    61
                ],
                [
                    9,
                    7,
                    4,
                    125
                ],
                [
                    -25,
                    7,
                    32,
                    126,
                    "lower"
                ],
                [
                    25,
                    7,
                    32,
                    127
                ]
            ];
            break;
        default:
            throw new Jbig2Error(`standard table B.${e1} does not exist`);
    }
    for(let e1 = 0, a = t.length; e1 < a; e1++)t[e1] = new HuffmanLine(t[e1]);
    a = new HuffmanTable(t, !0);
    Za[e1] = a;
    return a;
}
class Reader {
    constructor(e1, t, a){
        this.data = e1;
        this.start = t;
        this.end = a;
        this.position = t;
        this.shift = -1;
        this.currentByte = 0;
    }
    readBit() {
        if (this.shift < 0) {
            if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
            this.currentByte = this.data[this.position++];
            this.shift = 7;
        }
        const e1 = this.currentByte >> this.shift & 1;
        this.shift--;
        return e1;
    }
    readBits(e1) {
        let t, a = 0;
        for(t = e1 - 1; t >= 0; t--)a |= this.readBit() << t;
        return a;
    }
    byteAlign() {
        this.shift = -1;
    }
    next() {
        return this.position >= this.end ? -1 : this.data[this.position++];
    }
}
function getCustomHuffmanTable(e1, t, a) {
    let r = 0;
    for(let i = 0, n = t.length; i < n; i++){
        const n = a[t[i]];
        if (n) {
            if (e1 === r) return n;
            r++;
        }
    }
    throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e1, t, a) {
    const r = [];
    for(let i = 0; i < a; i++){
        const a = new Uint8Array(t);
        r.push(a);
        for(let r = 0; r < t; r++)a[r] = e1.readBit();
        e1.byteAlign();
    }
    return r;
}
function decodeMMRBitmap(e1, t, a, r) {
    const i = new CCITTFaxDecoder(e1, {
        K: -1,
        Columns: t,
        Rows: a,
        BlackIs1: !0,
        EndOfBlock: r
    }), n = [];
    let s, o = !1;
    for(let e1 = 0; e1 < a; e1++){
        const e1 = new Uint8Array(t);
        n.push(e1);
        let a = -1;
        for(let r = 0; r < t; r++){
            if (a < 0) {
                s = i.readNextChar();
                if (-1 === s) {
                    s = 0;
                    o = !0;
                }
                a = 7;
            }
            e1[r] = s >> a & 1;
            a--;
        }
    }
    if (r && !o) {
        const e1 = 5;
        for(let t = 0; t < e1 && -1 !== i.readNextChar(); t++);
    }
    return n;
}
class Jbig2Image {
    parseChunks(e1) {
        return function parseJbig2Chunks(e1) {
            const t = new SimpleSegmentVisitor;
            for(let a = 0, r = e1.length; a < r; a++){
                const r = e1[a];
                processSegments(readSegments({}, r.data, r.start, r.end), t);
            }
            return t.buffer;
        }(e1);
    }
    parse(e1) {
        throw new Error("Not implemented: Jbig2Image.parse");
    }
}
class Jbig2Stream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = a;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock() {
        this.decodeImage();
    }
    decodeImage(e1) {
        if (this.eof) return this.buffer;
        e1 ||= this.bytes;
        const t = new Jbig2Image, a = [];
        if (this.params instanceof Dict) {
            const e1 = this.params.get("JBIG2Globals");
            if (e1 instanceof BaseStream) {
                const t = e1.getBytes();
                a.push({
                    data: t,
                    start: 0,
                    end: t.length
                });
            }
        }
        a.push({
            data: e1,
            start: 0,
            end: e1.length
        });
        const r = t.parseChunks(a), i = r.length;
        for(let e1 = 0; e1 < i; e1++)r[e1] ^= 255;
        this.buffer = r;
        this.bufferLength = i;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
class JpxStream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        this.stream = e1;
        this.dict = e1.dict;
        this.maybeLength = t;
        this.params = a;
    }
    get bytes() {
        return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e1) {}
    readBlock(e1) {
        unreachable("JpxStream.readBlock");
    }
    get isAsyncDecoder() {
        return !0;
    }
    async decodeImage(e1, t) {
        if (this.eof) return this.buffer;
        e1 ||= this.bytes;
        this.buffer = await JpxImage.decode(e1, t);
        this.bufferLength = this.buffer.length;
        this.eof = !0;
        return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
        return this.stream.isAsync;
    }
}
class LZWStream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.cachedData = 0;
        this.bitsCached = 0;
        const r = 4096, i = {
            earlyChange: a,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(r),
            dictionaryLengths: new Uint16Array(r),
            dictionaryPrevCodes: new Uint16Array(r),
            currentSequence: new Uint8Array(r),
            currentSequenceLength: 0
        };
        for(let e1 = 0; e1 < 256; ++e1){
            i.dictionaryValues[e1] = e1;
            i.dictionaryLengths[e1] = 1;
        }
        this.lzwState = i;
    }
    readBits(e1) {
        let t = this.bitsCached, a = this.cachedData;
        for(; t < e1;){
            const e1 = this.str.getByte();
            if (-1 === e1) {
                this.eof = !0;
                return null;
            }
            a = a << 8 | e1;
            t += 8;
        }
        this.bitsCached = t -= e1;
        this.cachedData = a;
        this.lastCode = null;
        return a >>> t & (1 << e1) - 1;
    }
    readBlock() {
        let e1, t, a, r = 1024;
        const i = this.lzwState;
        if (!i) return;
        const n = i.earlyChange;
        let s = i.nextCode;
        const o = i.dictionaryValues, c = i.dictionaryLengths, l = i.dictionaryPrevCodes;
        let h = i.codeLength, u = i.prevCode;
        const d = i.currentSequence;
        let f = i.currentSequenceLength, g = 0, p = this.bufferLength, m = this.ensureBuffer(this.bufferLength + r);
        for(e1 = 0; e1 < 512; e1++){
            const e1 = this.readBits(h), i = f > 0;
            if (e1 < 256) {
                d[0] = e1;
                f = 1;
            } else {
                if (!(e1 >= 258)) {
                    if (256 === e1) {
                        h = 9;
                        s = 258;
                        f = 0;
                        continue;
                    }
                    this.eof = !0;
                    delete this.lzwState;
                    break;
                }
                if (e1 < s) {
                    f = c[e1];
                    for(t = f - 1, a = e1; t >= 0; t--){
                        d[t] = o[a];
                        a = l[a];
                    }
                } else d[f++] = d[0];
            }
            if (i) {
                l[s] = u;
                c[s] = c[u] + 1;
                o[s] = d[0];
                s++;
                h = s + n & s + n - 1 ? h : 0 | Math.min(Math.log(s + n) / .6931471805599453 + 1, 12);
            }
            u = e1;
            g += f;
            if (r < g) {
                do {
                    r += 512;
                }while (r < g)
                m = this.ensureBuffer(this.bufferLength + r);
            }
            for(t = 0; t < f; t++)m[p++] = d[t];
        }
        i.nextCode = s;
        i.codeLength = h;
        i.prevCode = u;
        i.currentSequenceLength = f;
        this.bufferLength = p;
    }
}
class PredictorStream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        if (!(a instanceof Dict)) return e1;
        const r = this.predictor = a.get("Predictor") || 1;
        if (r <= 1) return e1;
        if (2 !== r && (r < 10 || r > 15)) throw new FormatError(`Unsupported predictor: ${r}`);
        this.readBlock = 2 === r ? this.readBlockTiff : this.readBlockPng;
        this.str = e1;
        this.dict = e1.dict;
        const i = this.colors = a.get("Colors") || 1, n = this.bits = a.get("BPC", "BitsPerComponent") || 8, s = this.columns = a.get("Columns") || 1;
        this.pixBytes = i * n + 7 >> 3;
        this.rowBytes = s * i * n + 7 >> 3;
        return this;
    }
    readBlockTiff() {
        const e1 = this.rowBytes, t = this.bufferLength, a = this.ensureBuffer(t + e1), r = this.bits, i = this.colors, n = this.str.getBytes(e1);
        this.eof = !n.length;
        if (this.eof) return;
        let s, o = 0, c = 0, l = 0, h = 0, u = t;
        if (1 === r && 1 === i) for(s = 0; s < e1; ++s){
            let e1 = n[s] ^ o;
            e1 ^= e1 >> 1;
            e1 ^= e1 >> 2;
            e1 ^= e1 >> 4;
            o = (1 & e1) << 7;
            a[u++] = e1;
        }
        else if (8 === r) {
            for(s = 0; s < i; ++s)a[u++] = n[s];
            for(; s < e1; ++s){
                a[u] = a[u - i] + n[s];
                u++;
            }
        } else if (16 === r) {
            const t = 2 * i;
            for(s = 0; s < t; ++s)a[u++] = n[s];
            for(; s < e1; s += 2){
                const e1 = ((255 & n[s]) << 8) + (255 & n[s + 1]) + ((255 & a[u - t]) << 8) + (255 & a[u - t + 1]);
                a[u++] = e1 >> 8 & 255;
                a[u++] = 255 & e1;
            }
        } else {
            const e1 = new Uint8Array(i + 1), u = (1 << r) - 1;
            let d = 0, f = t;
            const g = this.columns;
            for(s = 0; s < g; ++s)for(let t = 0; t < i; ++t){
                if (l < r) {
                    o = o << 8 | 255 & n[d++];
                    l += 8;
                }
                e1[t] = e1[t] + (o >> l - r) & u;
                l -= r;
                c = c << r | e1[t];
                h += r;
                if (h >= 8) {
                    a[f++] = c >> h - 8 & 255;
                    h -= 8;
                }
            }
            h > 0 && (a[f++] = (c << 8 - h) + (o & (1 << 8 - h) - 1));
        }
        this.bufferLength += e1;
    }
    readBlockPng() {
        const e1 = this.rowBytes, t = this.pixBytes, a = this.str.getByte(), r = this.str.getBytes(e1);
        this.eof = !r.length;
        if (this.eof) return;
        const i = this.bufferLength, n = this.ensureBuffer(i + e1);
        let s = n.subarray(i - e1, i);
        0 === s.length && (s = new Uint8Array(e1));
        let o, c, l, h = i;
        switch(a){
            case 0:
                for(o = 0; o < e1; ++o)n[h++] = r[o];
                break;
            case 1:
                for(o = 0; o < t; ++o)n[h++] = r[o];
                for(; o < e1; ++o){
                    n[h] = n[h - t] + r[o] & 255;
                    h++;
                }
                break;
            case 2:
                for(o = 0; o < e1; ++o)n[h++] = s[o] + r[o] & 255;
                break;
            case 3:
                for(o = 0; o < t; ++o)n[h++] = (s[o] >> 1) + r[o];
                for(; o < e1; ++o){
                    n[h] = (s[o] + n[h - t] >> 1) + r[o] & 255;
                    h++;
                }
                break;
            case 4:
                for(o = 0; o < t; ++o){
                    c = s[o];
                    l = r[o];
                    n[h++] = c + l;
                }
                for(; o < e1; ++o){
                    c = s[o];
                    const e1 = s[o - t], a = n[h - t], i = a + c - e1;
                    let u = i - a;
                    u < 0 && (u = -u);
                    let d = i - c;
                    d < 0 && (d = -d);
                    let f = i - e1;
                    f < 0 && (f = -f);
                    l = r[o];
                    n[h++] = u <= d && u <= f ? a + l : d <= f ? c + l : e1 + l;
                }
                break;
            default:
                throw new FormatError(`Unsupported predictor: ${a}`);
        }
        this.bufferLength += e1;
    }
}
class RunLengthStream extends DecodeStream {
    constructor(e1, t){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
    }
    readBlock() {
        const e1 = this.str.getBytes(2);
        if (!e1 || e1.length < 2 || 128 === e1[0]) {
            this.eof = !0;
            return;
        }
        let t, a = this.bufferLength, r = e1[0];
        if (r < 128) {
            t = this.ensureBuffer(a + r + 1);
            t[a++] = e1[1];
            if (r > 0) {
                const e1 = this.str.getBytes(r);
                t.set(e1, a);
                a += r;
            }
        } else {
            r = 257 - r;
            t = this.ensureBuffer(a + r + 1);
            t.fill(e1[1], a, a + r);
            a += r;
        }
        this.bufferLength = a;
    }
}
class Parser {
    constructor({ lexer: e1, xref: t, allowStreams: a = !1, recoveryMode: r = !1 }){
        this.lexer = e1;
        this.xref = t;
        this.allowStreams = a;
        this.recoveryMode = r;
        this.imageCache = Object.create(null);
        this._imageId = 0;
        this.refill();
    }
    refill() {
        this.buf1 = this.lexer.getObj();
        this.buf2 = this.lexer.getObj();
    }
    shift() {
        if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
            this.buf1 = this.buf2;
            this.buf2 = null;
        } else {
            this.buf1 = this.buf2;
            this.buf2 = this.lexer.getObj();
        }
    }
    tryShift() {
        try {
            this.shift();
            return !0;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            return !1;
        }
    }
    getObj(e1 = null) {
        const t = this.buf1;
        this.shift();
        if (t instanceof Cmd) switch(t.cmd){
            case "BI":
                return this.makeInlineImage(e1);
            case "[":
                const a = [];
                for(; !isCmd(this.buf1, "]") && this.buf1 !== aa;)a.push(this.getObj(e1));
                if (this.buf1 === aa) {
                    if (this.recoveryMode) return a;
                    throw new ParserEOFException("End of file inside array.");
                }
                this.shift();
                return a;
            case "<<":
                const r = new Dict(this.xref);
                for(; !isCmd(this.buf1, ">>") && this.buf1 !== aa;){
                    if (!(this.buf1 instanceof Name)) {
                        info("Malformed dictionary: key must be a name object");
                        this.shift();
                        continue;
                    }
                    const t = this.buf1.name;
                    this.shift();
                    if (this.buf1 === aa) break;
                    r.set(t, this.getObj(e1));
                }
                if (this.buf1 === aa) {
                    if (this.recoveryMode) return r;
                    throw new ParserEOFException("End of file inside dictionary.");
                }
                if (isCmd(this.buf2, "stream")) return this.allowStreams ? this.makeStream(r, e1) : r;
                this.shift();
                return r;
            default:
                return t;
        }
        if (Number.isInteger(t)) {
            if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
                const e1 = Ref.get(t, this.buf1);
                this.shift();
                this.shift();
                return e1;
            }
            return t;
        }
        return "string" == typeof t && e1 ? e1.decryptString(t) : t;
    }
    findDefaultInlineStreamEnd(e1) {
        const { knownCommands: t } = this.lexer, a = e1.pos;
        let r, i, n = 0;
        for(; -1 !== (r = e1.getByte());)if (0 === n) n = 69 === r ? 1 : 0;
        else if (1 === n) n = 73 === r ? 2 : 0;
        else if (32 === r || 10 === r || 13 === r) {
            i = e1.pos;
            const a = e1.peekBytes(15), s = a.length;
            if (0 === s) break;
            for(let e1 = 0; e1 < s; e1++){
                r = a[e1];
                if ((0 !== r || 0 === a[e1 + 1]) && 10 !== r && 13 !== r && (r < 32 || r > 127)) {
                    n = 0;
                    break;
                }
            }
            if (2 !== n) continue;
            if (!t) {
                warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                continue;
            }
            const o = new Lexer(new Stream(e1.peekBytes(75)), t);
            o._hexStringWarn = ()=>{};
            let c = 0;
            for(;;){
                const e1 = o.getObj();
                if (e1 === aa) {
                    n = 0;
                    break;
                }
                if (e1 instanceof Cmd) {
                    const a = t[e1.cmd];
                    if (!a) {
                        n = 0;
                        break;
                    }
                    if (a.variableArgs ? c <= a.numArgs : c === a.numArgs) break;
                    c = 0;
                } else c++;
            }
            if (2 === n) break;
        } else n = 0;
        if (-1 === r) {
            warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
            if (i) {
                warn('... trying to recover by using the last "EI" occurrence.');
                e1.skip(-(e1.pos - i));
            }
        }
        let s = 4;
        e1.skip(-s);
        r = e1.peekByte();
        e1.skip(s);
        isWhiteSpace(r) || s--;
        return e1.pos - s - a;
    }
    findDCTDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let a, r, i = !1;
        for(; -1 !== (a = e1.getByte());)if (255 === a) {
            switch(e1.getByte()){
                case 0:
                    break;
                case 255:
                    e1.skip(-1);
                    break;
                case 217:
                    i = !0;
                    break;
                case 192:
                case 193:
                case 194:
                case 195:
                case 197:
                case 198:
                case 199:
                case 201:
                case 202:
                case 203:
                case 205:
                case 206:
                case 207:
                case 196:
                case 204:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 254:
                    r = e1.getUint16();
                    r > 2 ? e1.skip(r - 2) : e1.skip(-2);
            }
            if (i) break;
        }
        const n = e1.pos - t;
        if (-1 === a) {
            warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
            e1.skip(-n);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return n;
    }
    findASCII85DecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let a;
        for(; -1 !== (a = e1.getByte());)if (126 === a) {
            const t = e1.pos;
            a = e1.peekByte();
            for(; isWhiteSpace(a);){
                e1.skip();
                a = e1.peekByte();
            }
            if (62 === a) {
                e1.skip();
                break;
            }
            if (e1.pos > t) {
                const t = e1.peekBytes(2);
                if (69 === t[0] && 73 === t[1]) break;
            }
        }
        const r = e1.pos - t;
        if (-1 === a) {
            warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
            e1.skip(-r);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return r;
    }
    findASCIIHexDecodeInlineStreamEnd(e1) {
        const t = e1.pos;
        let a;
        for(; -1 !== (a = e1.getByte()) && 62 !== a;);
        const r = e1.pos - t;
        if (-1 === a) {
            warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
            e1.skip(-r);
            return this.findDefaultInlineStreamEnd(e1);
        }
        this.inlineStreamSkipEI(e1);
        return r;
    }
    inlineStreamSkipEI(e1) {
        let t, a = 0;
        for(; -1 !== (t = e1.getByte());)if (0 === a) a = 69 === t ? 1 : 0;
        else if (1 === a) a = 73 === t ? 2 : 0;
        else if (2 === a) break;
    }
    makeInlineImage(e1) {
        const t = this.lexer, a = t.stream, r = Object.create(null);
        let i;
        for(; !isCmd(this.buf1, "ID") && this.buf1 !== aa;){
            if (!(this.buf1 instanceof Name)) throw new FormatError("Dictionary key must be a name object");
            const t = this.buf1.name;
            this.shift();
            if (this.buf1 === aa) break;
            r[t] = this.getObj(e1);
        }
        -1 !== t.beginInlineImagePos && (i = a.pos - t.beginInlineImagePos);
        const n = this.xref.fetchIfRef(r.F || r.Filter);
        let s;
        if (n instanceof Name) s = n.name;
        else if (Array.isArray(n)) {
            const e1 = this.xref.fetchIfRef(n[0]);
            e1 instanceof Name && (s = e1.name);
        }
        const o = a.pos;
        let c, l;
        switch(s){
            case "DCT":
            case "DCTDecode":
                c = this.findDCTDecodeInlineStreamEnd(a);
                break;
            case "A85":
            case "ASCII85Decode":
                c = this.findASCII85DecodeInlineStreamEnd(a);
                break;
            case "AHx":
            case "ASCIIHexDecode":
                c = this.findASCIIHexDecodeInlineStreamEnd(a);
                break;
            default:
                c = this.findDefaultInlineStreamEnd(a);
        }
        if (c < 1e3 && i > 0) {
            const e1 = a.pos;
            a.pos = t.beginInlineImagePos;
            l = function getInlineImageCacheKey(e1) {
                const t = [], a = e1.length;
                let r = 0;
                for(; r < a - 1;)t.push(e1[r++] << 8 | e1[r++]);
                r < a && t.push(e1[r]);
                return a + "_" + String.fromCharCode.apply(null, t);
            }(a.getBytes(i + c));
            a.pos = e1;
            const r = this.imageCache[l];
            if (void 0 !== r) {
                this.buf2 = Cmd.get("EI");
                this.shift();
                r.reset();
                return r;
            }
        }
        const h = new Dict(this.xref);
        for(const e1 in r)h.set(e1, r[e1]);
        let u = a.makeSubStream(o, c, h);
        e1 && (u = e1.createStream(u, c));
        u = this.filter(u, h, c);
        u.dict = h;
        if (void 0 !== l) {
            u.cacheKey = "inline_img_" + ++this._imageId;
            this.imageCache[l] = u;
        }
        this.buf2 = Cmd.get("EI");
        this.shift();
        return u;
    }
    #q(e1) {
        const { stream: t } = this.lexer;
        t.pos = e1;
        const a = new Uint8Array([
            101,
            110,
            100
        ]), r = a.length, i = [
            new Uint8Array([
                115,
                116,
                114,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                101,
                97,
                109
            ]),
            new Uint8Array([
                115,
                116,
                114,
                101,
                97
            ])
        ], n = 9 - r;
        for(; t.pos < t.end;){
            const s = t.peekBytes(2048), o = s.length - 9;
            if (o <= 0) break;
            let c = 0;
            for(; c < o;){
                let o = 0;
                for(; o < r && s[c + o] === a[o];)o++;
                if (o >= r) {
                    let r = !1;
                    for (const e1 of i){
                        const t = e1.length;
                        let i = 0;
                        for(; i < t && s[c + o + i] === e1[i];)i++;
                        if (i >= n) {
                            r = !0;
                            break;
                        }
                        if (i >= t) {
                            if (isWhiteSpace(s[c + o + i])) {
                                info(`Found "${bytesToString([
                                    ...a,
                                    ...e1
                                ])}" when searching for endstream command.`);
                                r = !0;
                            }
                            break;
                        }
                    }
                    if (r) {
                        t.pos += c;
                        return t.pos - e1;
                    }
                }
                c++;
            }
            t.pos += o;
        }
        return -1;
    }
    makeStream(e1, t) {
        const a = this.lexer;
        let r = a.stream;
        a.skipToNextLine();
        const i = r.pos - 1;
        let n = e1.get("Length");
        if (!Number.isInteger(n)) {
            info(`Bad length "${n && n.toString()}" in stream.`);
            n = 0;
        }
        r.pos = i + n;
        a.nextChar();
        if (this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
        else {
            n = this.#q(i);
            if (n < 0) throw new FormatError("Missing endstream command.");
            a.nextChar();
            this.shift();
            this.shift();
        }
        this.shift();
        r = r.makeSubStream(i, n, e1);
        t && (r = t.createStream(r, n));
        r = this.filter(r, e1, n);
        r.dict = e1;
        return r;
    }
    filter(e1, t, a) {
        let r = t.get("F", "Filter"), i = t.get("DP", "DecodeParms");
        if (r instanceof Name) {
            Array.isArray(i) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
            return this.makeFilter(e1, r.name, a, i);
        }
        let n = a;
        if (Array.isArray(r)) {
            const t = r, a = i;
            for(let s = 0, o = t.length; s < o; ++s){
                r = this.xref.fetchIfRef(t[s]);
                if (!(r instanceof Name)) throw new FormatError(`Bad filter name "${r}"`);
                i = null;
                Array.isArray(a) && s in a && (i = this.xref.fetchIfRef(a[s]));
                e1 = this.makeFilter(e1, r.name, n, i);
                n = null;
            }
        }
        return e1;
    }
    makeFilter(e1, t, a, r) {
        if (0 === a) {
            warn(`Empty "${t}" stream.`);
            return new NullStream;
        }
        try {
            switch(t){
                case "Fl":
                case "FlateDecode":
                    return r ? new PredictorStream(new FlateStream(e1, a), a, r) : new FlateStream(e1, a);
                case "LZW":
                case "LZWDecode":
                    let t1 = 1;
                    if (r) {
                        r.has("EarlyChange") && (t1 = r.get("EarlyChange"));
                        return new PredictorStream(new LZWStream(e1, a, t1), a, r);
                    }
                    return new LZWStream(e1, a, t1);
                case "DCT":
                case "DCTDecode":
                    return new JpegStream(e1, a, r);
                case "JPX":
                case "JPXDecode":
                    return new JpxStream(e1, a, r);
                case "A85":
                case "ASCII85Decode":
                    return new Ascii85Stream(e1, a);
                case "AHx":
                case "ASCIIHexDecode":
                    return new AsciiHexStream(e1, a);
                case "CCF":
                case "CCITTFaxDecode":
                    return new CCITTFaxStream(e1, a, r);
                case "RL":
                case "RunLengthDecode":
                    return new RunLengthStream(e1, a);
                case "JBIG2Decode":
                    return new Jbig2Stream(e1, a, r);
            }
            warn(`Filter "${t}" is not supported.`);
            return e1;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Invalid stream: "${e1}"`);
            return new NullStream;
        }
    }
}
const Qa = [
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    2,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
function toHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 ? 15 & e1 : e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102 ? 9 + (15 & e1) : -1;
}
class Lexer {
    constructor(e1, t = null){
        this.stream = e1;
        this.nextChar();
        this.strBuf = [];
        this.knownCommands = t;
        this._hexStringNumWarn = 0;
        this.beginInlineImagePos = -1;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    peekChar() {
        return this.stream.peekByte();
    }
    getNumber() {
        let e1 = this.currentChar, t = !1, a = 0, r = 1;
        if (45 === e1) {
            r = -1;
            e1 = this.nextChar();
            45 === e1 && (e1 = this.nextChar());
        } else 43 === e1 && (e1 = this.nextChar());
        if (10 === e1 || 13 === e1) do {
            e1 = this.nextChar();
        }while (10 === e1 || 13 === e1)
        if (46 === e1) {
            a = 10;
            e1 = this.nextChar();
        }
        if (e1 < 48 || e1 > 57) {
            const t = `Invalid number: ${String.fromCharCode(e1)} (charCode ${e1})`;
            if (isWhiteSpace(e1) || 40 === e1 || 60 === e1 || -1 === e1) {
                info(`Lexer.getNumber - "${t}".`);
                return 0;
            }
            throw new FormatError(t);
        }
        let i = e1 - 48, n = 0, s = 1;
        for(; (e1 = this.nextChar()) >= 0;)if (e1 >= 48 && e1 <= 57) {
            const r = e1 - 48;
            if (t) n = 10 * n + r;
            else {
                0 !== a && (a *= 10);
                i = 10 * i + r;
            }
        } else if (46 === e1) {
            if (0 !== a) break;
            a = 1;
        } else if (45 === e1) warn("Badly formatted number: minus sign in the middle");
        else {
            if (69 !== e1 && 101 !== e1) break;
            e1 = this.peekChar();
            if (43 === e1 || 45 === e1) {
                s = 45 === e1 ? -1 : 1;
                this.nextChar();
            } else if (e1 < 48 || e1 > 57) break;
            t = !0;
        }
        0 !== a && (i /= a);
        t && (i *= 10 ** (s * n));
        return r * i;
    }
    getString() {
        let e1 = 1, t = !1;
        const a = this.strBuf;
        a.length = 0;
        let r = this.nextChar();
        for(;;){
            let i = !1;
            switch(0 | r){
                case -1:
                    warn("Unterminated string");
                    t = !0;
                    break;
                case 40:
                    ++e1;
                    a.push("(");
                    break;
                case 41:
                    if (0 == --e1) {
                        this.nextChar();
                        t = !0;
                    } else a.push(")");
                    break;
                case 92:
                    r = this.nextChar();
                    switch(r){
                        case -1:
                            warn("Unterminated string");
                            t = !0;
                            break;
                        case 110:
                            a.push("\n");
                            break;
                        case 114:
                            a.push("\r");
                            break;
                        case 116:
                            a.push("\t");
                            break;
                        case 98:
                            a.push("\b");
                            break;
                        case 102:
                            a.push("\f");
                            break;
                        case 92:
                        case 40:
                        case 41:
                            a.push(String.fromCharCode(r));
                            break;
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                            let e2 = 15 & r;
                            r = this.nextChar();
                            i = !0;
                            if (r >= 48 && r <= 55) {
                                e2 = (e2 << 3) + (15 & r);
                                r = this.nextChar();
                                if (r >= 48 && r <= 55) {
                                    i = !1;
                                    e2 = (e2 << 3) + (15 & r);
                                }
                            }
                            a.push(String.fromCharCode(e2));
                            break;
                        case 13:
                            10 === this.peekChar() && this.nextChar();
                            break;
                        case 10:
                            break;
                        default:
                            a.push(String.fromCharCode(r));
                    }
                    break;
                default:
                    a.push(String.fromCharCode(r));
            }
            if (t) break;
            i || (r = this.nextChar());
        }
        return a.join("");
    }
    getName() {
        let e1, t;
        const a = this.strBuf;
        a.length = 0;
        for(; (e1 = this.nextChar()) >= 0 && !Qa[e1];)if (35 === e1) {
            e1 = this.nextChar();
            if (Qa[e1]) {
                warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                a.push("#");
                break;
            }
            const r = toHexDigit(e1);
            if (-1 !== r) {
                t = e1;
                e1 = this.nextChar();
                const i = toHexDigit(e1);
                if (-1 === i) {
                    warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e1)}) in hexadecimal number.`);
                    a.push("#", String.fromCharCode(t));
                    if (Qa[e1]) break;
                    a.push(String.fromCharCode(e1));
                    continue;
                }
                a.push(String.fromCharCode(r << 4 | i));
            } else a.push("#", String.fromCharCode(e1));
        } else a.push(String.fromCharCode(e1));
        a.length > 127 && warn(`Name token is longer than allowed by the spec: ${a.length}`);
        return Name.get(a.join(""));
    }
    _hexStringWarn(e1) {
        5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e1}`) : warn("getHexString - ignoring additional invalid characters.");
    }
    getHexString() {
        const e1 = this.strBuf;
        e1.length = 0;
        let t = this.currentChar, a = -1, r = -1;
        this._hexStringNumWarn = 0;
        for(;;){
            if (t < 0) {
                warn("Unterminated hex string");
                break;
            }
            if (62 === t) {
                this.nextChar();
                break;
            }
            if (1 !== Qa[t]) {
                r = toHexDigit(t);
                if (-1 === r) this._hexStringWarn(t);
                else if (-1 === a) a = r;
                else {
                    e1.push(String.fromCharCode(a << 4 | r));
                    a = -1;
                }
                t = this.nextChar();
            } else t = this.nextChar();
        }
        -1 !== a && e1.push(String.fromCharCode(a << 4));
        return e1.join("");
    }
    getObj() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return aa;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (1 !== Qa[t]) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return this.getNumber();
            case 40:
                return this.getString();
            case 47:
                return this.getName();
            case 91:
                this.nextChar();
                return Cmd.get("[");
            case 93:
                this.nextChar();
                return Cmd.get("]");
            case 60:
                t = this.nextChar();
                if (60 === t) {
                    this.nextChar();
                    return Cmd.get("<<");
                }
                return this.getHexString();
            case 62:
                t = this.nextChar();
                if (62 === t) {
                    this.nextChar();
                    return Cmd.get(">>");
                }
                return Cmd.get(">");
            case 123:
                this.nextChar();
                return Cmd.get("{");
            case 125:
                this.nextChar();
                return Cmd.get("}");
            case 41:
                this.nextChar();
                throw new FormatError(`Illegal character: ${t}`);
        }
        let a = String.fromCharCode(t);
        if (t < 32 || t > 127) {
            const e1 = this.peekChar();
            if (e1 >= 32 && e1 <= 127) {
                this.nextChar();
                return Cmd.get(a);
            }
        }
        const r = this.knownCommands;
        let i = void 0 !== r?.[a];
        for(; (t = this.nextChar()) >= 0 && !Qa[t];){
            const e1 = a + String.fromCharCode(t);
            if (i && void 0 === r[e1]) break;
            if (128 === a.length) throw new FormatError(`Command token too long: ${a.length}`);
            a = e1;
            i = void 0 !== r?.[a];
        }
        if ("true" === a) return !0;
        if ("false" === a) return !1;
        if ("null" === a) return null;
        "BI" === a && (this.beginInlineImagePos = this.stream.pos);
        return Cmd.get(a);
    }
    skipToNextLine() {
        let e1 = this.currentChar;
        for(; e1 >= 0;){
            if (13 === e1) {
                e1 = this.nextChar();
                10 === e1 && this.nextChar();
                break;
            }
            if (10 === e1) {
                this.nextChar();
                break;
            }
            e1 = this.nextChar();
        }
    }
}
class Linearization {
    static create(e1) {
        function getInt(e1, t, a = !1) {
            const r = e1.get(t);
            if (Number.isInteger(r) && (a ? r >= 0 : r > 0)) return r;
            throw new Error(`The "${t}" parameter in the linearization dictionary is invalid.`);
        }
        const t = new Parser({
            lexer: new Lexer(e1),
            xref: null
        }), a = t.getObj(), r = t.getObj(), i = t.getObj(), n = t.getObj();
        let s, o;
        if (!(Number.isInteger(a) && Number.isInteger(r) && isCmd(i, "obj") && n instanceof Dict && "number" == typeof (s = n.get("Linearized")) && s > 0)) return null;
        if ((o = getInt(n, "L")) !== e1.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
        return {
            length: o,
            hints: function getHints(e1) {
                const t = e1.get("H");
                let a;
                if (Array.isArray(t) && (2 === (a = t.length) || 4 === a)) {
                    for(let e1 = 0; e1 < a; e1++){
                        const a = t[e1];
                        if (!(Number.isInteger(a) && a > 0)) throw new Error(`Hint (${e1}) in the linearization dictionary is invalid.`);
                    }
                    return t;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
            }(n),
            objectNumberFirst: getInt(n, "O"),
            endFirst: getInt(n, "E"),
            numPages: getInt(n, "N"),
            mainXRefEntriesOffset: getInt(n, "T"),
            pageFirst: n.has("P") ? getInt(n, "P", !0) : 0
        };
    }
}
const er = [
    "Adobe-GB1-UCS2",
    "Adobe-CNS1-UCS2",
    "Adobe-Japan1-UCS2",
    "Adobe-Korea1-UCS2",
    "78-EUC-H",
    "78-EUC-V",
    "78-H",
    "78-RKSJ-H",
    "78-RKSJ-V",
    "78-V",
    "78ms-RKSJ-H",
    "78ms-RKSJ-V",
    "83pv-RKSJ-H",
    "90ms-RKSJ-H",
    "90ms-RKSJ-V",
    "90msp-RKSJ-H",
    "90msp-RKSJ-V",
    "90pv-RKSJ-H",
    "90pv-RKSJ-V",
    "Add-H",
    "Add-RKSJ-H",
    "Add-RKSJ-V",
    "Add-V",
    "Adobe-CNS1-0",
    "Adobe-CNS1-1",
    "Adobe-CNS1-2",
    "Adobe-CNS1-3",
    "Adobe-CNS1-4",
    "Adobe-CNS1-5",
    "Adobe-CNS1-6",
    "Adobe-GB1-0",
    "Adobe-GB1-1",
    "Adobe-GB1-2",
    "Adobe-GB1-3",
    "Adobe-GB1-4",
    "Adobe-GB1-5",
    "Adobe-Japan1-0",
    "Adobe-Japan1-1",
    "Adobe-Japan1-2",
    "Adobe-Japan1-3",
    "Adobe-Japan1-4",
    "Adobe-Japan1-5",
    "Adobe-Japan1-6",
    "Adobe-Korea1-0",
    "Adobe-Korea1-1",
    "Adobe-Korea1-2",
    "B5-H",
    "B5-V",
    "B5pc-H",
    "B5pc-V",
    "CNS-EUC-H",
    "CNS-EUC-V",
    "CNS1-H",
    "CNS1-V",
    "CNS2-H",
    "CNS2-V",
    "ETHK-B5-H",
    "ETHK-B5-V",
    "ETen-B5-H",
    "ETen-B5-V",
    "ETenms-B5-H",
    "ETenms-B5-V",
    "EUC-H",
    "EUC-V",
    "Ext-H",
    "Ext-RKSJ-H",
    "Ext-RKSJ-V",
    "Ext-V",
    "GB-EUC-H",
    "GB-EUC-V",
    "GB-H",
    "GB-V",
    "GBK-EUC-H",
    "GBK-EUC-V",
    "GBK2K-H",
    "GBK2K-V",
    "GBKp-EUC-H",
    "GBKp-EUC-V",
    "GBT-EUC-H",
    "GBT-EUC-V",
    "GBT-H",
    "GBT-V",
    "GBTpc-EUC-H",
    "GBTpc-EUC-V",
    "GBpc-EUC-H",
    "GBpc-EUC-V",
    "H",
    "HKdla-B5-H",
    "HKdla-B5-V",
    "HKdlb-B5-H",
    "HKdlb-B5-V",
    "HKgccs-B5-H",
    "HKgccs-B5-V",
    "HKm314-B5-H",
    "HKm314-B5-V",
    "HKm471-B5-H",
    "HKm471-B5-V",
    "HKscs-B5-H",
    "HKscs-B5-V",
    "Hankaku",
    "Hiragana",
    "KSC-EUC-H",
    "KSC-EUC-V",
    "KSC-H",
    "KSC-Johab-H",
    "KSC-Johab-V",
    "KSC-V",
    "KSCms-UHC-H",
    "KSCms-UHC-HW-H",
    "KSCms-UHC-HW-V",
    "KSCms-UHC-V",
    "KSCpc-EUC-H",
    "KSCpc-EUC-V",
    "Katakana",
    "NWP-H",
    "NWP-V",
    "RKSJ-H",
    "RKSJ-V",
    "Roman",
    "UniCNS-UCS2-H",
    "UniCNS-UCS2-V",
    "UniCNS-UTF16-H",
    "UniCNS-UTF16-V",
    "UniCNS-UTF32-H",
    "UniCNS-UTF32-V",
    "UniCNS-UTF8-H",
    "UniCNS-UTF8-V",
    "UniGB-UCS2-H",
    "UniGB-UCS2-V",
    "UniGB-UTF16-H",
    "UniGB-UTF16-V",
    "UniGB-UTF32-H",
    "UniGB-UTF32-V",
    "UniGB-UTF8-H",
    "UniGB-UTF8-V",
    "UniJIS-UCS2-H",
    "UniJIS-UCS2-HW-H",
    "UniJIS-UCS2-HW-V",
    "UniJIS-UCS2-V",
    "UniJIS-UTF16-H",
    "UniJIS-UTF16-V",
    "UniJIS-UTF32-H",
    "UniJIS-UTF32-V",
    "UniJIS-UTF8-H",
    "UniJIS-UTF8-V",
    "UniJIS2004-UTF16-H",
    "UniJIS2004-UTF16-V",
    "UniJIS2004-UTF32-H",
    "UniJIS2004-UTF32-V",
    "UniJIS2004-UTF8-H",
    "UniJIS2004-UTF8-V",
    "UniJISPro-UCS2-HW-V",
    "UniJISPro-UCS2-V",
    "UniJISPro-UTF8-V",
    "UniJISX0213-UTF32-H",
    "UniJISX0213-UTF32-V",
    "UniJISX02132004-UTF32-H",
    "UniJISX02132004-UTF32-V",
    "UniKS-UCS2-H",
    "UniKS-UCS2-V",
    "UniKS-UTF16-H",
    "UniKS-UTF16-V",
    "UniKS-UTF32-H",
    "UniKS-UTF32-V",
    "UniKS-UTF8-H",
    "UniKS-UTF8-V",
    "V",
    "WP-Symbol"
], tr = 2 ** 24 - 1;
class CMap {
    constructor(e1 = !1){
        this.codespaceRanges = [
            [],
            [],
            [],
            []
        ];
        this.numCodespaceRanges = 0;
        this._map = [];
        this.name = "";
        this.vertical = !1;
        this.useCMap = null;
        this.builtInCMap = e1;
    }
    addCodespaceRange(e1, t, a) {
        this.codespaceRanges[e1 - 1].push(t, a);
        this.numCodespaceRanges++;
    }
    mapCidRange(e1, t, a) {
        if (t - e1 > tr) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
        for(; e1 <= t;)this._map[e1++] = a++;
    }
    mapBfRange(e1, t, a) {
        if (t - e1 > tr) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
        const r = a.length - 1;
        for(; e1 <= t;){
            this._map[e1++] = a;
            const t = a.charCodeAt(r) + 1;
            t > 255 ? a = a.substring(0, r - 1) + String.fromCharCode(a.charCodeAt(r - 1) + 1) + "\0" : a = a.substring(0, r) + String.fromCharCode(t);
        }
    }
    mapBfRangeToArray(e1, t, a) {
        if (t - e1 > tr) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
        const r = a.length;
        let i = 0;
        for(; e1 <= t && i < r;){
            this._map[e1] = a[i++];
            ++e1;
        }
    }
    mapOne(e1, t) {
        this._map[e1] = t;
    }
    lookup(e1) {
        return this._map[e1];
    }
    contains(e1) {
        return void 0 !== this._map[e1];
    }
    forEach(e1) {
        const t = this._map, a = t.length;
        if (a <= 65536) for(let r = 0; r < a; r++)void 0 !== t[r] && e1(r, t[r]);
        else for(const a in t)e1(a, t[a]);
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const a in t)if (t[a] === e1) return 0 | a;
        return -1;
    }
    getMap() {
        return this._map;
    }
    readCharCode(e1, t, a) {
        let r = 0;
        const i = this.codespaceRanges;
        for(let n = 0, s = i.length; n < s; n++){
            r = (r << 8 | e1.charCodeAt(t + n)) >>> 0;
            const s = i[n];
            for(let e1 = 0, t = s.length; e1 < t;){
                const t = s[e1++], i = s[e1++];
                if (r >= t && r <= i) {
                    a.charcode = r;
                    a.length = n + 1;
                    return;
                }
            }
        }
        a.charcode = 0;
        a.length = 1;
    }
    getCharCodeLength(e1) {
        const t = this.codespaceRanges;
        for(let a = 0, r = t.length; a < r; a++){
            const r = t[a];
            for(let t = 0, i = r.length; t < i;){
                const i = r[t++], n = r[t++];
                if (e1 >= i && e1 <= n) return a + 1;
            }
        }
        return 1;
    }
    get length() {
        return this._map.length;
    }
    get isIdentityCMap() {
        if ("Identity-H" !== this.name && "Identity-V" !== this.name) return !1;
        if (65536 !== this._map.length) return !1;
        for(let e1 = 0; e1 < 65536; e1++)if (this._map[e1] !== e1) return !1;
        return !0;
    }
}
class IdentityCMap extends CMap {
    constructor(e1, t){
        super();
        this.vertical = e1;
        this.addCodespaceRange(t, 0, 65535);
    }
    mapCidRange(e1, t, a) {
        unreachable("should not call mapCidRange");
    }
    mapBfRange(e1, t, a) {
        unreachable("should not call mapBfRange");
    }
    mapBfRangeToArray(e1, t, a) {
        unreachable("should not call mapBfRangeToArray");
    }
    mapOne(e1, t) {
        unreachable("should not call mapCidOne");
    }
    lookup(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : void 0;
    }
    contains(e1) {
        return Number.isInteger(e1) && e1 <= 65535;
    }
    forEach(e1) {
        for(let t = 0; t <= 65535; t++)e1(t, t);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 <= 65535 ? e1 : -1;
    }
    getMap() {
        const e1 = new Array(65536);
        for(let t = 0; t <= 65535; t++)e1[t] = t;
        return e1;
    }
    get length() {
        return 65536;
    }
    get isIdentityCMap() {
        unreachable("should not access .isIdentityCMap");
    }
}
function strToInt(e1) {
    let t = 0;
    for(let a = 0; a < e1.length; a++)t = t << 8 | e1.charCodeAt(a);
    return t >>> 0;
}
function expectString(e1) {
    if ("string" != typeof e1) throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e1) {
    if (!Number.isInteger(e1)) throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e1, t) {
    for(;;){
        let a = t.getObj();
        if (a === aa) break;
        if (isCmd(a, "endbfchar")) return;
        expectString(a);
        const r = strToInt(a);
        a = t.getObj();
        expectString(a);
        const i = a;
        e1.mapOne(r, i);
    }
}
function parseBfRange(e1, t) {
    for(;;){
        let a = t.getObj();
        if (a === aa) break;
        if (isCmd(a, "endbfrange")) return;
        expectString(a);
        const r = strToInt(a);
        a = t.getObj();
        expectString(a);
        const i = strToInt(a);
        a = t.getObj();
        if (Number.isInteger(a) || "string" == typeof a) {
            const t = Number.isInteger(a) ? String.fromCharCode(a) : a;
            e1.mapBfRange(r, i, t);
        } else {
            if (!isCmd(a, "[")) break;
            {
                a = t.getObj();
                const n = [];
                for(; !isCmd(a, "]") && a !== aa;){
                    n.push(a);
                    a = t.getObj();
                }
                e1.mapBfRangeToArray(r, i, n);
            }
        }
    }
    throw new FormatError("Invalid bf range.");
}
function parseCidChar(e1, t) {
    for(;;){
        let a = t.getObj();
        if (a === aa) break;
        if (isCmd(a, "endcidchar")) return;
        expectString(a);
        const r = strToInt(a);
        a = t.getObj();
        expectInt(a);
        const i = a;
        e1.mapOne(r, i);
    }
}
function parseCidRange(e1, t) {
    for(;;){
        let a = t.getObj();
        if (a === aa) break;
        if (isCmd(a, "endcidrange")) return;
        expectString(a);
        const r = strToInt(a);
        a = t.getObj();
        expectString(a);
        const i = strToInt(a);
        a = t.getObj();
        expectInt(a);
        const n = a;
        e1.mapCidRange(r, i, n);
    }
}
function parseCodespaceRange(e1, t) {
    for(;;){
        let a = t.getObj();
        if (a === aa) break;
        if (isCmd(a, "endcodespacerange")) return;
        if ("string" != typeof a) break;
        const r = strToInt(a);
        a = t.getObj();
        if ("string" != typeof a) break;
        const i = strToInt(a);
        e1.addCodespaceRange(a.length, r, i);
    }
    throw new FormatError("Invalid codespace range.");
}
function parseWMode(e1, t) {
    const a = t.getObj();
    Number.isInteger(a) && (e1.vertical = !!a);
}
function parseCMapName(e1, t) {
    const a = t.getObj();
    a instanceof Name && (e1.name = a.name);
}
async function parseCMap(e1, t, a, r) {
    let i, n;
    e: for(;;)try {
        const a = t.getObj();
        if (a === aa) break;
        if (a instanceof Name) {
            "WMode" === a.name ? parseWMode(e1, t) : "CMapName" === a.name && parseCMapName(e1, t);
            i = a;
        } else if (a instanceof Cmd) switch(a.cmd){
            case "endcmap":
                break e;
            case "usecmap":
                i instanceof Name && (n = i.name);
                break;
            case "begincodespacerange":
                parseCodespaceRange(e1, t);
                break;
            case "beginbfchar":
                parseBfChar(e1, t);
                break;
            case "begincidchar":
                parseCidChar(e1, t);
                break;
            case "beginbfrange":
                parseBfRange(e1, t);
                break;
            case "begincidrange":
                parseCidRange(e1, t);
        }
    } catch (e1) {
        if (e1 instanceof MissingDataException) throw e1;
        warn("Invalid cMap data: " + e1);
        continue;
    }
    !r && n && (r = n);
    return r ? extendCMap(e1, a, r) : e1;
}
async function extendCMap(e1, t, a) {
    e1.useCMap = await createBuiltInCMap(a, t);
    if (0 === e1.numCodespaceRanges) {
        const t = e1.useCMap.codespaceRanges;
        for(let a = 0; a < t.length; a++)e1.codespaceRanges[a] = t[a].slice();
        e1.numCodespaceRanges = e1.useCMap.numCodespaceRanges;
    }
    e1.useCMap.forEach(function(t, a) {
        e1.contains(t) || e1.mapOne(t, a);
    });
    return e1;
}
async function createBuiltInCMap(e1, t) {
    if ("Identity-H" === e1) return new IdentityCMap(!1, 2);
    if ("Identity-V" === e1) return new IdentityCMap(!0, 2);
    if (!er.includes(e1)) throw new Error("Unknown CMap name: " + e1);
    if (!t) throw new Error("Built-in CMap parameters are not provided.");
    const { cMapData: a, isCompressed: r } = await t(e1), i = new CMap(!0);
    if (r) return (new BinaryCMapReader).process(a, i, (e1)=>extendCMap(i, t, e1));
    const n = new Lexer(new Stream(a));
    return parseCMap(i, n, t, null);
}
class CMapFactory {
    static async create({ encoding: e1, fetchBuiltInCMap: t, useCMap: a }) {
        if (e1 instanceof Name) return createBuiltInCMap(e1.name, t);
        if (e1 instanceof BaseStream) {
            const r = await parseCMap(new CMap, new Lexer(e1), t, a);
            return r.isIdentityCMap ? createBuiltInCMap(r.name, t) : r;
        }
        throw new Error("Encoding required.");
    }
}
const ar = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "",
    "",
    "",
    "isuperior",
    "",
    "",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "",
    "",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "",
    "",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "",
    "Dotaccentsmall",
    "",
    "",
    "Macronsmall",
    "",
    "",
    "figuredash",
    "hypheninferior",
    "",
    "",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], rr = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "centoldstyle",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "",
    "threequartersemdash",
    "",
    "questionsmall",
    "",
    "",
    "",
    "",
    "Ethsmall",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "",
    "",
    "",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hypheninferior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "asuperior",
    "centsuperior",
    "",
    "",
    "",
    "",
    "Aacutesmall",
    "Agravesmall",
    "Acircumflexsmall",
    "Adieresissmall",
    "Atildesmall",
    "Aringsmall",
    "Ccedillasmall",
    "Eacutesmall",
    "Egravesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Iacutesmall",
    "Igravesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ntildesmall",
    "Oacutesmall",
    "Ogravesmall",
    "Ocircumflexsmall",
    "Odieresissmall",
    "Otildesmall",
    "Uacutesmall",
    "Ugravesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "",
    "eightsuperior",
    "fourinferior",
    "threeinferior",
    "sixinferior",
    "eightinferior",
    "seveninferior",
    "Scaronsmall",
    "",
    "centinferior",
    "twoinferior",
    "",
    "Dieresissmall",
    "",
    "Caronsmall",
    "osuperior",
    "fiveinferior",
    "",
    "commainferior",
    "periodinferior",
    "Yacutesmall",
    "",
    "dollarinferior",
    "",
    "",
    "Thornsmall",
    "",
    "nineinferior",
    "zeroinferior",
    "Zcaronsmall",
    "AEsmall",
    "Oslashsmall",
    "questiondownsmall",
    "oneinferior",
    "Lslashsmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "Cedillasmall",
    "",
    "",
    "",
    "",
    "",
    "OEsmall",
    "figuredash",
    "hyphensuperior",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "",
    "Ydieresissmall",
    "",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "ninesuperior",
    "zerosuperior",
    "",
    "esuperior",
    "rsuperior",
    "tsuperior",
    "",
    "",
    "isuperior",
    "ssuperior",
    "dsuperior",
    "",
    "",
    "",
    "",
    "",
    "lsuperior",
    "Ogoneksmall",
    "Brevesmall",
    "Macronsmall",
    "bsuperior",
    "nsuperior",
    "msuperior",
    "commasuperior",
    "periodsuperior",
    "Dotaccentsmall",
    "Ringsmall",
    "",
    "",
    "",
    ""
], ir = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "space",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron"
], nr = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "",
    "questiondown",
    "",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "",
    "ring",
    "cedilla",
    "",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AE",
    "",
    "ordfeminine",
    "",
    "",
    "",
    "",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "",
    "",
    "",
    "",
    "",
    "ae",
    "",
    "",
    "",
    "dotlessi",
    "",
    "",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "",
    "",
    "",
    ""
], sr = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "bullet",
    "Euro",
    "bullet",
    "quotesinglbase",
    "florin",
    "quotedblbase",
    "ellipsis",
    "dagger",
    "daggerdbl",
    "circumflex",
    "perthousand",
    "Scaron",
    "guilsinglleft",
    "OE",
    "bullet",
    "Zcaron",
    "bullet",
    "bullet",
    "quoteleft",
    "quoteright",
    "quotedblleft",
    "quotedblright",
    "bullet",
    "endash",
    "emdash",
    "tilde",
    "trademark",
    "scaron",
    "guilsinglright",
    "oe",
    "bullet",
    "zcaron",
    "Ydieresis",
    "space",
    "exclamdown",
    "cent",
    "sterling",
    "currency",
    "yen",
    "brokenbar",
    "section",
    "dieresis",
    "copyright",
    "ordfeminine",
    "guillemotleft",
    "logicalnot",
    "hyphen",
    "registered",
    "macron",
    "degree",
    "plusminus",
    "twosuperior",
    "threesuperior",
    "acute",
    "mu",
    "paragraph",
    "periodcentered",
    "cedilla",
    "onesuperior",
    "ordmasculine",
    "guillemotright",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondown",
    "Agrave",
    "Aacute",
    "Acircumflex",
    "Atilde",
    "Adieresis",
    "Aring",
    "AE",
    "Ccedilla",
    "Egrave",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Igrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Eth",
    "Ntilde",
    "Ograve",
    "Oacute",
    "Ocircumflex",
    "Otilde",
    "Odieresis",
    "multiply",
    "Oslash",
    "Ugrave",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Yacute",
    "Thorn",
    "germandbls",
    "agrave",
    "aacute",
    "acircumflex",
    "atilde",
    "adieresis",
    "aring",
    "ae",
    "ccedilla",
    "egrave",
    "eacute",
    "ecircumflex",
    "edieresis",
    "igrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "eth",
    "ntilde",
    "ograve",
    "oacute",
    "ocircumflex",
    "otilde",
    "odieresis",
    "divide",
    "oslash",
    "ugrave",
    "uacute",
    "ucircumflex",
    "udieresis",
    "yacute",
    "thorn",
    "ydieresis"
], or = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "universal",
    "numbersign",
    "existential",
    "percent",
    "ampersand",
    "suchthat",
    "parenleft",
    "parenright",
    "asteriskmath",
    "plus",
    "comma",
    "minus",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "congruent",
    "Alpha",
    "Beta",
    "Chi",
    "Delta",
    "Epsilon",
    "Phi",
    "Gamma",
    "Eta",
    "Iota",
    "theta1",
    "Kappa",
    "Lambda",
    "Mu",
    "Nu",
    "Omicron",
    "Pi",
    "Theta",
    "Rho",
    "Sigma",
    "Tau",
    "Upsilon",
    "sigma1",
    "Omega",
    "Xi",
    "Psi",
    "Zeta",
    "bracketleft",
    "therefore",
    "bracketright",
    "perpendicular",
    "underscore",
    "radicalex",
    "alpha",
    "beta",
    "chi",
    "delta",
    "epsilon",
    "phi",
    "gamma",
    "eta",
    "iota",
    "phi1",
    "kappa",
    "lambda",
    "mu",
    "nu",
    "omicron",
    "pi",
    "theta",
    "rho",
    "sigma",
    "tau",
    "upsilon",
    "omega1",
    "omega",
    "xi",
    "psi",
    "zeta",
    "braceleft",
    "bar",
    "braceright",
    "similar",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Euro",
    "Upsilon1",
    "minute",
    "lessequal",
    "fraction",
    "infinity",
    "florin",
    "club",
    "diamond",
    "heart",
    "spade",
    "arrowboth",
    "arrowleft",
    "arrowup",
    "arrowright",
    "arrowdown",
    "degree",
    "plusminus",
    "second",
    "greaterequal",
    "multiply",
    "proportional",
    "partialdiff",
    "bullet",
    "divide",
    "notequal",
    "equivalence",
    "approxequal",
    "ellipsis",
    "arrowvertex",
    "arrowhorizex",
    "carriagereturn",
    "aleph",
    "Ifraktur",
    "Rfraktur",
    "weierstrass",
    "circlemultiply",
    "circleplus",
    "emptyset",
    "intersection",
    "union",
    "propersuperset",
    "reflexsuperset",
    "notsubset",
    "propersubset",
    "reflexsubset",
    "element",
    "notelement",
    "angle",
    "gradient",
    "registerserif",
    "copyrightserif",
    "trademarkserif",
    "product",
    "radical",
    "dotmath",
    "logicalnot",
    "logicaland",
    "logicalor",
    "arrowdblboth",
    "arrowdblleft",
    "arrowdblup",
    "arrowdblright",
    "arrowdbldown",
    "lozenge",
    "angleleft",
    "registersans",
    "copyrightsans",
    "trademarksans",
    "summation",
    "parenlefttp",
    "parenleftex",
    "parenleftbt",
    "bracketlefttp",
    "bracketleftex",
    "bracketleftbt",
    "bracelefttp",
    "braceleftmid",
    "braceleftbt",
    "braceex",
    "",
    "angleright",
    "integral",
    "integraltp",
    "integralex",
    "integralbt",
    "parenrighttp",
    "parenrightex",
    "parenrightbt",
    "bracketrighttp",
    "bracketrightex",
    "bracketrightbt",
    "bracerighttp",
    "bracerightmid",
    "bracerightbt",
    ""
], cr = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "a1",
    "a2",
    "a202",
    "a3",
    "a4",
    "a5",
    "a119",
    "a118",
    "a117",
    "a11",
    "a12",
    "a13",
    "a14",
    "a15",
    "a16",
    "a105",
    "a17",
    "a18",
    "a19",
    "a20",
    "a21",
    "a22",
    "a23",
    "a24",
    "a25",
    "a26",
    "a27",
    "a28",
    "a6",
    "a7",
    "a8",
    "a9",
    "a10",
    "a29",
    "a30",
    "a31",
    "a32",
    "a33",
    "a34",
    "a35",
    "a36",
    "a37",
    "a38",
    "a39",
    "a40",
    "a41",
    "a42",
    "a43",
    "a44",
    "a45",
    "a46",
    "a47",
    "a48",
    "a49",
    "a50",
    "a51",
    "a52",
    "a53",
    "a54",
    "a55",
    "a56",
    "a57",
    "a58",
    "a59",
    "a60",
    "a61",
    "a62",
    "a63",
    "a64",
    "a65",
    "a66",
    "a67",
    "a68",
    "a69",
    "a70",
    "a71",
    "a72",
    "a73",
    "a74",
    "a203",
    "a75",
    "a204",
    "a76",
    "a77",
    "a78",
    "a79",
    "a81",
    "a82",
    "a83",
    "a84",
    "a97",
    "a98",
    "a99",
    "a100",
    "",
    "a89",
    "a90",
    "a93",
    "a94",
    "a91",
    "a92",
    "a205",
    "a85",
    "a206",
    "a86",
    "a87",
    "a88",
    "a95",
    "a96",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "a101",
    "a102",
    "a103",
    "a104",
    "a106",
    "a107",
    "a108",
    "a112",
    "a111",
    "a110",
    "a109",
    "a120",
    "a121",
    "a122",
    "a123",
    "a124",
    "a125",
    "a126",
    "a127",
    "a128",
    "a129",
    "a130",
    "a131",
    "a132",
    "a133",
    "a134",
    "a135",
    "a136",
    "a137",
    "a138",
    "a139",
    "a140",
    "a141",
    "a142",
    "a143",
    "a144",
    "a145",
    "a146",
    "a147",
    "a148",
    "a149",
    "a150",
    "a151",
    "a152",
    "a153",
    "a154",
    "a155",
    "a156",
    "a157",
    "a158",
    "a159",
    "a160",
    "a161",
    "a163",
    "a164",
    "a196",
    "a165",
    "a192",
    "a166",
    "a167",
    "a168",
    "a169",
    "a170",
    "a171",
    "a172",
    "a173",
    "a162",
    "a174",
    "a175",
    "a176",
    "a177",
    "a178",
    "a179",
    "a193",
    "a180",
    "a199",
    "a181",
    "a200",
    "a182",
    "",
    "a201",
    "a183",
    "a184",
    "a197",
    "a185",
    "a194",
    "a198",
    "a186",
    "a195",
    "a187",
    "a188",
    "a189",
    "a190",
    "a191",
    ""
];
function getEncoding(e1) {
    switch(e1){
        case "WinAnsiEncoding":
            return sr;
        case "StandardEncoding":
            return nr;
        case "MacRomanEncoding":
            return ir;
        case "SymbolSetEncoding":
            return or;
        case "ZapfDingbatsEncoding":
            return cr;
        case "ExpertEncoding":
            return ar;
        case "MacExpertEncoding":
            return rr;
        default:
            return null;
    }
}
const lr = getLookupTableFactory(function(e1) {
    e1.A = 65;
    e1.AE = 198;
    e1.AEacute = 508;
    e1.AEmacron = 482;
    e1.AEsmall = 63462;
    e1.Aacute = 193;
    e1.Aacutesmall = 63457;
    e1.Abreve = 258;
    e1.Abreveacute = 7854;
    e1.Abrevecyrillic = 1232;
    e1.Abrevedotbelow = 7862;
    e1.Abrevegrave = 7856;
    e1.Abrevehookabove = 7858;
    e1.Abrevetilde = 7860;
    e1.Acaron = 461;
    e1.Acircle = 9398;
    e1.Acircumflex = 194;
    e1.Acircumflexacute = 7844;
    e1.Acircumflexdotbelow = 7852;
    e1.Acircumflexgrave = 7846;
    e1.Acircumflexhookabove = 7848;
    e1.Acircumflexsmall = 63458;
    e1.Acircumflextilde = 7850;
    e1.Acute = 63177;
    e1.Acutesmall = 63412;
    e1.Acyrillic = 1040;
    e1.Adblgrave = 512;
    e1.Adieresis = 196;
    e1.Adieresiscyrillic = 1234;
    e1.Adieresismacron = 478;
    e1.Adieresissmall = 63460;
    e1.Adotbelow = 7840;
    e1.Adotmacron = 480;
    e1.Agrave = 192;
    e1.Agravesmall = 63456;
    e1.Ahookabove = 7842;
    e1.Aiecyrillic = 1236;
    e1.Ainvertedbreve = 514;
    e1.Alpha = 913;
    e1.Alphatonos = 902;
    e1.Amacron = 256;
    e1.Amonospace = 65313;
    e1.Aogonek = 260;
    e1.Aring = 197;
    e1.Aringacute = 506;
    e1.Aringbelow = 7680;
    e1.Aringsmall = 63461;
    e1.Asmall = 63329;
    e1.Atilde = 195;
    e1.Atildesmall = 63459;
    e1.Aybarmenian = 1329;
    e1.B = 66;
    e1.Bcircle = 9399;
    e1.Bdotaccent = 7682;
    e1.Bdotbelow = 7684;
    e1.Becyrillic = 1041;
    e1.Benarmenian = 1330;
    e1.Beta = 914;
    e1.Bhook = 385;
    e1.Blinebelow = 7686;
    e1.Bmonospace = 65314;
    e1.Brevesmall = 63220;
    e1.Bsmall = 63330;
    e1.Btopbar = 386;
    e1.C = 67;
    e1.Caarmenian = 1342;
    e1.Cacute = 262;
    e1.Caron = 63178;
    e1.Caronsmall = 63221;
    e1.Ccaron = 268;
    e1.Ccedilla = 199;
    e1.Ccedillaacute = 7688;
    e1.Ccedillasmall = 63463;
    e1.Ccircle = 9400;
    e1.Ccircumflex = 264;
    e1.Cdot = 266;
    e1.Cdotaccent = 266;
    e1.Cedillasmall = 63416;
    e1.Chaarmenian = 1353;
    e1.Cheabkhasiancyrillic = 1212;
    e1.Checyrillic = 1063;
    e1.Chedescenderabkhasiancyrillic = 1214;
    e1.Chedescendercyrillic = 1206;
    e1.Chedieresiscyrillic = 1268;
    e1.Cheharmenian = 1347;
    e1.Chekhakassiancyrillic = 1227;
    e1.Cheverticalstrokecyrillic = 1208;
    e1.Chi = 935;
    e1.Chook = 391;
    e1.Circumflexsmall = 63222;
    e1.Cmonospace = 65315;
    e1.Coarmenian = 1361;
    e1.Csmall = 63331;
    e1.D = 68;
    e1.DZ = 497;
    e1.DZcaron = 452;
    e1.Daarmenian = 1332;
    e1.Dafrican = 393;
    e1.Dcaron = 270;
    e1.Dcedilla = 7696;
    e1.Dcircle = 9401;
    e1.Dcircumflexbelow = 7698;
    e1.Dcroat = 272;
    e1.Ddotaccent = 7690;
    e1.Ddotbelow = 7692;
    e1.Decyrillic = 1044;
    e1.Deicoptic = 1006;
    e1.Delta = 8710;
    e1.Deltagreek = 916;
    e1.Dhook = 394;
    e1.Dieresis = 63179;
    e1.DieresisAcute = 63180;
    e1.DieresisGrave = 63181;
    e1.Dieresissmall = 63400;
    e1.Digammagreek = 988;
    e1.Djecyrillic = 1026;
    e1.Dlinebelow = 7694;
    e1.Dmonospace = 65316;
    e1.Dotaccentsmall = 63223;
    e1.Dslash = 272;
    e1.Dsmall = 63332;
    e1.Dtopbar = 395;
    e1.Dz = 498;
    e1.Dzcaron = 453;
    e1.Dzeabkhasiancyrillic = 1248;
    e1.Dzecyrillic = 1029;
    e1.Dzhecyrillic = 1039;
    e1.E = 69;
    e1.Eacute = 201;
    e1.Eacutesmall = 63465;
    e1.Ebreve = 276;
    e1.Ecaron = 282;
    e1.Ecedillabreve = 7708;
    e1.Echarmenian = 1333;
    e1.Ecircle = 9402;
    e1.Ecircumflex = 202;
    e1.Ecircumflexacute = 7870;
    e1.Ecircumflexbelow = 7704;
    e1.Ecircumflexdotbelow = 7878;
    e1.Ecircumflexgrave = 7872;
    e1.Ecircumflexhookabove = 7874;
    e1.Ecircumflexsmall = 63466;
    e1.Ecircumflextilde = 7876;
    e1.Ecyrillic = 1028;
    e1.Edblgrave = 516;
    e1.Edieresis = 203;
    e1.Edieresissmall = 63467;
    e1.Edot = 278;
    e1.Edotaccent = 278;
    e1.Edotbelow = 7864;
    e1.Efcyrillic = 1060;
    e1.Egrave = 200;
    e1.Egravesmall = 63464;
    e1.Eharmenian = 1335;
    e1.Ehookabove = 7866;
    e1.Eightroman = 8551;
    e1.Einvertedbreve = 518;
    e1.Eiotifiedcyrillic = 1124;
    e1.Elcyrillic = 1051;
    e1.Elevenroman = 8554;
    e1.Emacron = 274;
    e1.Emacronacute = 7702;
    e1.Emacrongrave = 7700;
    e1.Emcyrillic = 1052;
    e1.Emonospace = 65317;
    e1.Encyrillic = 1053;
    e1.Endescendercyrillic = 1186;
    e1.Eng = 330;
    e1.Enghecyrillic = 1188;
    e1.Enhookcyrillic = 1223;
    e1.Eogonek = 280;
    e1.Eopen = 400;
    e1.Epsilon = 917;
    e1.Epsilontonos = 904;
    e1.Ercyrillic = 1056;
    e1.Ereversed = 398;
    e1.Ereversedcyrillic = 1069;
    e1.Escyrillic = 1057;
    e1.Esdescendercyrillic = 1194;
    e1.Esh = 425;
    e1.Esmall = 63333;
    e1.Eta = 919;
    e1.Etarmenian = 1336;
    e1.Etatonos = 905;
    e1.Eth = 208;
    e1.Ethsmall = 63472;
    e1.Etilde = 7868;
    e1.Etildebelow = 7706;
    e1.Euro = 8364;
    e1.Ezh = 439;
    e1.Ezhcaron = 494;
    e1.Ezhreversed = 440;
    e1.F = 70;
    e1.Fcircle = 9403;
    e1.Fdotaccent = 7710;
    e1.Feharmenian = 1366;
    e1.Feicoptic = 996;
    e1.Fhook = 401;
    e1.Fitacyrillic = 1138;
    e1.Fiveroman = 8548;
    e1.Fmonospace = 65318;
    e1.Fourroman = 8547;
    e1.Fsmall = 63334;
    e1.G = 71;
    e1.GBsquare = 13191;
    e1.Gacute = 500;
    e1.Gamma = 915;
    e1.Gammaafrican = 404;
    e1.Gangiacoptic = 1002;
    e1.Gbreve = 286;
    e1.Gcaron = 486;
    e1.Gcedilla = 290;
    e1.Gcircle = 9404;
    e1.Gcircumflex = 284;
    e1.Gcommaaccent = 290;
    e1.Gdot = 288;
    e1.Gdotaccent = 288;
    e1.Gecyrillic = 1043;
    e1.Ghadarmenian = 1346;
    e1.Ghemiddlehookcyrillic = 1172;
    e1.Ghestrokecyrillic = 1170;
    e1.Gheupturncyrillic = 1168;
    e1.Ghook = 403;
    e1.Gimarmenian = 1331;
    e1.Gjecyrillic = 1027;
    e1.Gmacron = 7712;
    e1.Gmonospace = 65319;
    e1.Grave = 63182;
    e1.Gravesmall = 63328;
    e1.Gsmall = 63335;
    e1.Gsmallhook = 667;
    e1.Gstroke = 484;
    e1.H = 72;
    e1.H18533 = 9679;
    e1.H18543 = 9642;
    e1.H18551 = 9643;
    e1.H22073 = 9633;
    e1.HPsquare = 13259;
    e1.Haabkhasiancyrillic = 1192;
    e1.Hadescendercyrillic = 1202;
    e1.Hardsigncyrillic = 1066;
    e1.Hbar = 294;
    e1.Hbrevebelow = 7722;
    e1.Hcedilla = 7720;
    e1.Hcircle = 9405;
    e1.Hcircumflex = 292;
    e1.Hdieresis = 7718;
    e1.Hdotaccent = 7714;
    e1.Hdotbelow = 7716;
    e1.Hmonospace = 65320;
    e1.Hoarmenian = 1344;
    e1.Horicoptic = 1e3;
    e1.Hsmall = 63336;
    e1.Hungarumlaut = 63183;
    e1.Hungarumlautsmall = 63224;
    e1.Hzsquare = 13200;
    e1.I = 73;
    e1.IAcyrillic = 1071;
    e1.IJ = 306;
    e1.IUcyrillic = 1070;
    e1.Iacute = 205;
    e1.Iacutesmall = 63469;
    e1.Ibreve = 300;
    e1.Icaron = 463;
    e1.Icircle = 9406;
    e1.Icircumflex = 206;
    e1.Icircumflexsmall = 63470;
    e1.Icyrillic = 1030;
    e1.Idblgrave = 520;
    e1.Idieresis = 207;
    e1.Idieresisacute = 7726;
    e1.Idieresiscyrillic = 1252;
    e1.Idieresissmall = 63471;
    e1.Idot = 304;
    e1.Idotaccent = 304;
    e1.Idotbelow = 7882;
    e1.Iebrevecyrillic = 1238;
    e1.Iecyrillic = 1045;
    e1.Ifraktur = 8465;
    e1.Igrave = 204;
    e1.Igravesmall = 63468;
    e1.Ihookabove = 7880;
    e1.Iicyrillic = 1048;
    e1.Iinvertedbreve = 522;
    e1.Iishortcyrillic = 1049;
    e1.Imacron = 298;
    e1.Imacroncyrillic = 1250;
    e1.Imonospace = 65321;
    e1.Iniarmenian = 1339;
    e1.Iocyrillic = 1025;
    e1.Iogonek = 302;
    e1.Iota = 921;
    e1.Iotaafrican = 406;
    e1.Iotadieresis = 938;
    e1.Iotatonos = 906;
    e1.Ismall = 63337;
    e1.Istroke = 407;
    e1.Itilde = 296;
    e1.Itildebelow = 7724;
    e1.Izhitsacyrillic = 1140;
    e1.Izhitsadblgravecyrillic = 1142;
    e1.J = 74;
    e1.Jaarmenian = 1345;
    e1.Jcircle = 9407;
    e1.Jcircumflex = 308;
    e1.Jecyrillic = 1032;
    e1.Jheharmenian = 1355;
    e1.Jmonospace = 65322;
    e1.Jsmall = 63338;
    e1.K = 75;
    e1.KBsquare = 13189;
    e1.KKsquare = 13261;
    e1.Kabashkircyrillic = 1184;
    e1.Kacute = 7728;
    e1.Kacyrillic = 1050;
    e1.Kadescendercyrillic = 1178;
    e1.Kahookcyrillic = 1219;
    e1.Kappa = 922;
    e1.Kastrokecyrillic = 1182;
    e1.Kaverticalstrokecyrillic = 1180;
    e1.Kcaron = 488;
    e1.Kcedilla = 310;
    e1.Kcircle = 9408;
    e1.Kcommaaccent = 310;
    e1.Kdotbelow = 7730;
    e1.Keharmenian = 1364;
    e1.Kenarmenian = 1343;
    e1.Khacyrillic = 1061;
    e1.Kheicoptic = 998;
    e1.Khook = 408;
    e1.Kjecyrillic = 1036;
    e1.Klinebelow = 7732;
    e1.Kmonospace = 65323;
    e1.Koppacyrillic = 1152;
    e1.Koppagreek = 990;
    e1.Ksicyrillic = 1134;
    e1.Ksmall = 63339;
    e1.L = 76;
    e1.LJ = 455;
    e1.LL = 63167;
    e1.Lacute = 313;
    e1.Lambda = 923;
    e1.Lcaron = 317;
    e1.Lcedilla = 315;
    e1.Lcircle = 9409;
    e1.Lcircumflexbelow = 7740;
    e1.Lcommaaccent = 315;
    e1.Ldot = 319;
    e1.Ldotaccent = 319;
    e1.Ldotbelow = 7734;
    e1.Ldotbelowmacron = 7736;
    e1.Liwnarmenian = 1340;
    e1.Lj = 456;
    e1.Ljecyrillic = 1033;
    e1.Llinebelow = 7738;
    e1.Lmonospace = 65324;
    e1.Lslash = 321;
    e1.Lslashsmall = 63225;
    e1.Lsmall = 63340;
    e1.M = 77;
    e1.MBsquare = 13190;
    e1.Macron = 63184;
    e1.Macronsmall = 63407;
    e1.Macute = 7742;
    e1.Mcircle = 9410;
    e1.Mdotaccent = 7744;
    e1.Mdotbelow = 7746;
    e1.Menarmenian = 1348;
    e1.Mmonospace = 65325;
    e1.Msmall = 63341;
    e1.Mturned = 412;
    e1.Mu = 924;
    e1.N = 78;
    e1.NJ = 458;
    e1.Nacute = 323;
    e1.Ncaron = 327;
    e1.Ncedilla = 325;
    e1.Ncircle = 9411;
    e1.Ncircumflexbelow = 7754;
    e1.Ncommaaccent = 325;
    e1.Ndotaccent = 7748;
    e1.Ndotbelow = 7750;
    e1.Nhookleft = 413;
    e1.Nineroman = 8552;
    e1.Nj = 459;
    e1.Njecyrillic = 1034;
    e1.Nlinebelow = 7752;
    e1.Nmonospace = 65326;
    e1.Nowarmenian = 1350;
    e1.Nsmall = 63342;
    e1.Ntilde = 209;
    e1.Ntildesmall = 63473;
    e1.Nu = 925;
    e1.O = 79;
    e1.OE = 338;
    e1.OEsmall = 63226;
    e1.Oacute = 211;
    e1.Oacutesmall = 63475;
    e1.Obarredcyrillic = 1256;
    e1.Obarreddieresiscyrillic = 1258;
    e1.Obreve = 334;
    e1.Ocaron = 465;
    e1.Ocenteredtilde = 415;
    e1.Ocircle = 9412;
    e1.Ocircumflex = 212;
    e1.Ocircumflexacute = 7888;
    e1.Ocircumflexdotbelow = 7896;
    e1.Ocircumflexgrave = 7890;
    e1.Ocircumflexhookabove = 7892;
    e1.Ocircumflexsmall = 63476;
    e1.Ocircumflextilde = 7894;
    e1.Ocyrillic = 1054;
    e1.Odblacute = 336;
    e1.Odblgrave = 524;
    e1.Odieresis = 214;
    e1.Odieresiscyrillic = 1254;
    e1.Odieresissmall = 63478;
    e1.Odotbelow = 7884;
    e1.Ogoneksmall = 63227;
    e1.Ograve = 210;
    e1.Ogravesmall = 63474;
    e1.Oharmenian = 1365;
    e1.Ohm = 8486;
    e1.Ohookabove = 7886;
    e1.Ohorn = 416;
    e1.Ohornacute = 7898;
    e1.Ohorndotbelow = 7906;
    e1.Ohorngrave = 7900;
    e1.Ohornhookabove = 7902;
    e1.Ohorntilde = 7904;
    e1.Ohungarumlaut = 336;
    e1.Oi = 418;
    e1.Oinvertedbreve = 526;
    e1.Omacron = 332;
    e1.Omacronacute = 7762;
    e1.Omacrongrave = 7760;
    e1.Omega = 8486;
    e1.Omegacyrillic = 1120;
    e1.Omegagreek = 937;
    e1.Omegaroundcyrillic = 1146;
    e1.Omegatitlocyrillic = 1148;
    e1.Omegatonos = 911;
    e1.Omicron = 927;
    e1.Omicrontonos = 908;
    e1.Omonospace = 65327;
    e1.Oneroman = 8544;
    e1.Oogonek = 490;
    e1.Oogonekmacron = 492;
    e1.Oopen = 390;
    e1.Oslash = 216;
    e1.Oslashacute = 510;
    e1.Oslashsmall = 63480;
    e1.Osmall = 63343;
    e1.Ostrokeacute = 510;
    e1.Otcyrillic = 1150;
    e1.Otilde = 213;
    e1.Otildeacute = 7756;
    e1.Otildedieresis = 7758;
    e1.Otildesmall = 63477;
    e1.P = 80;
    e1.Pacute = 7764;
    e1.Pcircle = 9413;
    e1.Pdotaccent = 7766;
    e1.Pecyrillic = 1055;
    e1.Peharmenian = 1354;
    e1.Pemiddlehookcyrillic = 1190;
    e1.Phi = 934;
    e1.Phook = 420;
    e1.Pi = 928;
    e1.Piwrarmenian = 1363;
    e1.Pmonospace = 65328;
    e1.Psi = 936;
    e1.Psicyrillic = 1136;
    e1.Psmall = 63344;
    e1.Q = 81;
    e1.Qcircle = 9414;
    e1.Qmonospace = 65329;
    e1.Qsmall = 63345;
    e1.R = 82;
    e1.Raarmenian = 1356;
    e1.Racute = 340;
    e1.Rcaron = 344;
    e1.Rcedilla = 342;
    e1.Rcircle = 9415;
    e1.Rcommaaccent = 342;
    e1.Rdblgrave = 528;
    e1.Rdotaccent = 7768;
    e1.Rdotbelow = 7770;
    e1.Rdotbelowmacron = 7772;
    e1.Reharmenian = 1360;
    e1.Rfraktur = 8476;
    e1.Rho = 929;
    e1.Ringsmall = 63228;
    e1.Rinvertedbreve = 530;
    e1.Rlinebelow = 7774;
    e1.Rmonospace = 65330;
    e1.Rsmall = 63346;
    e1.Rsmallinverted = 641;
    e1.Rsmallinvertedsuperior = 694;
    e1.S = 83;
    e1.SF010000 = 9484;
    e1.SF020000 = 9492;
    e1.SF030000 = 9488;
    e1.SF040000 = 9496;
    e1.SF050000 = 9532;
    e1.SF060000 = 9516;
    e1.SF070000 = 9524;
    e1.SF080000 = 9500;
    e1.SF090000 = 9508;
    e1.SF100000 = 9472;
    e1.SF110000 = 9474;
    e1.SF190000 = 9569;
    e1.SF200000 = 9570;
    e1.SF210000 = 9558;
    e1.SF220000 = 9557;
    e1.SF230000 = 9571;
    e1.SF240000 = 9553;
    e1.SF250000 = 9559;
    e1.SF260000 = 9565;
    e1.SF270000 = 9564;
    e1.SF280000 = 9563;
    e1.SF360000 = 9566;
    e1.SF370000 = 9567;
    e1.SF380000 = 9562;
    e1.SF390000 = 9556;
    e1.SF400000 = 9577;
    e1.SF410000 = 9574;
    e1.SF420000 = 9568;
    e1.SF430000 = 9552;
    e1.SF440000 = 9580;
    e1.SF450000 = 9575;
    e1.SF460000 = 9576;
    e1.SF470000 = 9572;
    e1.SF480000 = 9573;
    e1.SF490000 = 9561;
    e1.SF500000 = 9560;
    e1.SF510000 = 9554;
    e1.SF520000 = 9555;
    e1.SF530000 = 9579;
    e1.SF540000 = 9578;
    e1.Sacute = 346;
    e1.Sacutedotaccent = 7780;
    e1.Sampigreek = 992;
    e1.Scaron = 352;
    e1.Scarondotaccent = 7782;
    e1.Scaronsmall = 63229;
    e1.Scedilla = 350;
    e1.Schwa = 399;
    e1.Schwacyrillic = 1240;
    e1.Schwadieresiscyrillic = 1242;
    e1.Scircle = 9416;
    e1.Scircumflex = 348;
    e1.Scommaaccent = 536;
    e1.Sdotaccent = 7776;
    e1.Sdotbelow = 7778;
    e1.Sdotbelowdotaccent = 7784;
    e1.Seharmenian = 1357;
    e1.Sevenroman = 8550;
    e1.Shaarmenian = 1351;
    e1.Shacyrillic = 1064;
    e1.Shchacyrillic = 1065;
    e1.Sheicoptic = 994;
    e1.Shhacyrillic = 1210;
    e1.Shimacoptic = 1004;
    e1.Sigma = 931;
    e1.Sixroman = 8549;
    e1.Smonospace = 65331;
    e1.Softsigncyrillic = 1068;
    e1.Ssmall = 63347;
    e1.Stigmagreek = 986;
    e1.T = 84;
    e1.Tau = 932;
    e1.Tbar = 358;
    e1.Tcaron = 356;
    e1.Tcedilla = 354;
    e1.Tcircle = 9417;
    e1.Tcircumflexbelow = 7792;
    e1.Tcommaaccent = 354;
    e1.Tdotaccent = 7786;
    e1.Tdotbelow = 7788;
    e1.Tecyrillic = 1058;
    e1.Tedescendercyrillic = 1196;
    e1.Tenroman = 8553;
    e1.Tetsecyrillic = 1204;
    e1.Theta = 920;
    e1.Thook = 428;
    e1.Thorn = 222;
    e1.Thornsmall = 63486;
    e1.Threeroman = 8546;
    e1.Tildesmall = 63230;
    e1.Tiwnarmenian = 1359;
    e1.Tlinebelow = 7790;
    e1.Tmonospace = 65332;
    e1.Toarmenian = 1337;
    e1.Tonefive = 444;
    e1.Tonesix = 388;
    e1.Tonetwo = 423;
    e1.Tretroflexhook = 430;
    e1.Tsecyrillic = 1062;
    e1.Tshecyrillic = 1035;
    e1.Tsmall = 63348;
    e1.Twelveroman = 8555;
    e1.Tworoman = 8545;
    e1.U = 85;
    e1.Uacute = 218;
    e1.Uacutesmall = 63482;
    e1.Ubreve = 364;
    e1.Ucaron = 467;
    e1.Ucircle = 9418;
    e1.Ucircumflex = 219;
    e1.Ucircumflexbelow = 7798;
    e1.Ucircumflexsmall = 63483;
    e1.Ucyrillic = 1059;
    e1.Udblacute = 368;
    e1.Udblgrave = 532;
    e1.Udieresis = 220;
    e1.Udieresisacute = 471;
    e1.Udieresisbelow = 7794;
    e1.Udieresiscaron = 473;
    e1.Udieresiscyrillic = 1264;
    e1.Udieresisgrave = 475;
    e1.Udieresismacron = 469;
    e1.Udieresissmall = 63484;
    e1.Udotbelow = 7908;
    e1.Ugrave = 217;
    e1.Ugravesmall = 63481;
    e1.Uhookabove = 7910;
    e1.Uhorn = 431;
    e1.Uhornacute = 7912;
    e1.Uhorndotbelow = 7920;
    e1.Uhorngrave = 7914;
    e1.Uhornhookabove = 7916;
    e1.Uhorntilde = 7918;
    e1.Uhungarumlaut = 368;
    e1.Uhungarumlautcyrillic = 1266;
    e1.Uinvertedbreve = 534;
    e1.Ukcyrillic = 1144;
    e1.Umacron = 362;
    e1.Umacroncyrillic = 1262;
    e1.Umacrondieresis = 7802;
    e1.Umonospace = 65333;
    e1.Uogonek = 370;
    e1.Upsilon = 933;
    e1.Upsilon1 = 978;
    e1.Upsilonacutehooksymbolgreek = 979;
    e1.Upsilonafrican = 433;
    e1.Upsilondieresis = 939;
    e1.Upsilondieresishooksymbolgreek = 980;
    e1.Upsilonhooksymbol = 978;
    e1.Upsilontonos = 910;
    e1.Uring = 366;
    e1.Ushortcyrillic = 1038;
    e1.Usmall = 63349;
    e1.Ustraightcyrillic = 1198;
    e1.Ustraightstrokecyrillic = 1200;
    e1.Utilde = 360;
    e1.Utildeacute = 7800;
    e1.Utildebelow = 7796;
    e1.V = 86;
    e1.Vcircle = 9419;
    e1.Vdotbelow = 7806;
    e1.Vecyrillic = 1042;
    e1.Vewarmenian = 1358;
    e1.Vhook = 434;
    e1.Vmonospace = 65334;
    e1.Voarmenian = 1352;
    e1.Vsmall = 63350;
    e1.Vtilde = 7804;
    e1.W = 87;
    e1.Wacute = 7810;
    e1.Wcircle = 9420;
    e1.Wcircumflex = 372;
    e1.Wdieresis = 7812;
    e1.Wdotaccent = 7814;
    e1.Wdotbelow = 7816;
    e1.Wgrave = 7808;
    e1.Wmonospace = 65335;
    e1.Wsmall = 63351;
    e1.X = 88;
    e1.Xcircle = 9421;
    e1.Xdieresis = 7820;
    e1.Xdotaccent = 7818;
    e1.Xeharmenian = 1341;
    e1.Xi = 926;
    e1.Xmonospace = 65336;
    e1.Xsmall = 63352;
    e1.Y = 89;
    e1.Yacute = 221;
    e1.Yacutesmall = 63485;
    e1.Yatcyrillic = 1122;
    e1.Ycircle = 9422;
    e1.Ycircumflex = 374;
    e1.Ydieresis = 376;
    e1.Ydieresissmall = 63487;
    e1.Ydotaccent = 7822;
    e1.Ydotbelow = 7924;
    e1.Yericyrillic = 1067;
    e1.Yerudieresiscyrillic = 1272;
    e1.Ygrave = 7922;
    e1.Yhook = 435;
    e1.Yhookabove = 7926;
    e1.Yiarmenian = 1349;
    e1.Yicyrillic = 1031;
    e1.Yiwnarmenian = 1362;
    e1.Ymonospace = 65337;
    e1.Ysmall = 63353;
    e1.Ytilde = 7928;
    e1.Yusbigcyrillic = 1130;
    e1.Yusbigiotifiedcyrillic = 1132;
    e1.Yuslittlecyrillic = 1126;
    e1.Yuslittleiotifiedcyrillic = 1128;
    e1.Z = 90;
    e1.Zaarmenian = 1334;
    e1.Zacute = 377;
    e1.Zcaron = 381;
    e1.Zcaronsmall = 63231;
    e1.Zcircle = 9423;
    e1.Zcircumflex = 7824;
    e1.Zdot = 379;
    e1.Zdotaccent = 379;
    e1.Zdotbelow = 7826;
    e1.Zecyrillic = 1047;
    e1.Zedescendercyrillic = 1176;
    e1.Zedieresiscyrillic = 1246;
    e1.Zeta = 918;
    e1.Zhearmenian = 1338;
    e1.Zhebrevecyrillic = 1217;
    e1.Zhecyrillic = 1046;
    e1.Zhedescendercyrillic = 1174;
    e1.Zhedieresiscyrillic = 1244;
    e1.Zlinebelow = 7828;
    e1.Zmonospace = 65338;
    e1.Zsmall = 63354;
    e1.Zstroke = 437;
    e1.a = 97;
    e1.aabengali = 2438;
    e1.aacute = 225;
    e1.aadeva = 2310;
    e1.aagujarati = 2694;
    e1.aagurmukhi = 2566;
    e1.aamatragurmukhi = 2622;
    e1.aarusquare = 13059;
    e1.aavowelsignbengali = 2494;
    e1.aavowelsigndeva = 2366;
    e1.aavowelsigngujarati = 2750;
    e1.abbreviationmarkarmenian = 1375;
    e1.abbreviationsigndeva = 2416;
    e1.abengali = 2437;
    e1.abopomofo = 12570;
    e1.abreve = 259;
    e1.abreveacute = 7855;
    e1.abrevecyrillic = 1233;
    e1.abrevedotbelow = 7863;
    e1.abrevegrave = 7857;
    e1.abrevehookabove = 7859;
    e1.abrevetilde = 7861;
    e1.acaron = 462;
    e1.acircle = 9424;
    e1.acircumflex = 226;
    e1.acircumflexacute = 7845;
    e1.acircumflexdotbelow = 7853;
    e1.acircumflexgrave = 7847;
    e1.acircumflexhookabove = 7849;
    e1.acircumflextilde = 7851;
    e1.acute = 180;
    e1.acutebelowcmb = 791;
    e1.acutecmb = 769;
    e1.acutecomb = 769;
    e1.acutedeva = 2388;
    e1.acutelowmod = 719;
    e1.acutetonecmb = 833;
    e1.acyrillic = 1072;
    e1.adblgrave = 513;
    e1.addakgurmukhi = 2673;
    e1.adeva = 2309;
    e1.adieresis = 228;
    e1.adieresiscyrillic = 1235;
    e1.adieresismacron = 479;
    e1.adotbelow = 7841;
    e1.adotmacron = 481;
    e1.ae = 230;
    e1.aeacute = 509;
    e1.aekorean = 12624;
    e1.aemacron = 483;
    e1.afii00208 = 8213;
    e1.afii08941 = 8356;
    e1.afii10017 = 1040;
    e1.afii10018 = 1041;
    e1.afii10019 = 1042;
    e1.afii10020 = 1043;
    e1.afii10021 = 1044;
    e1.afii10022 = 1045;
    e1.afii10023 = 1025;
    e1.afii10024 = 1046;
    e1.afii10025 = 1047;
    e1.afii10026 = 1048;
    e1.afii10027 = 1049;
    e1.afii10028 = 1050;
    e1.afii10029 = 1051;
    e1.afii10030 = 1052;
    e1.afii10031 = 1053;
    e1.afii10032 = 1054;
    e1.afii10033 = 1055;
    e1.afii10034 = 1056;
    e1.afii10035 = 1057;
    e1.afii10036 = 1058;
    e1.afii10037 = 1059;
    e1.afii10038 = 1060;
    e1.afii10039 = 1061;
    e1.afii10040 = 1062;
    e1.afii10041 = 1063;
    e1.afii10042 = 1064;
    e1.afii10043 = 1065;
    e1.afii10044 = 1066;
    e1.afii10045 = 1067;
    e1.afii10046 = 1068;
    e1.afii10047 = 1069;
    e1.afii10048 = 1070;
    e1.afii10049 = 1071;
    e1.afii10050 = 1168;
    e1.afii10051 = 1026;
    e1.afii10052 = 1027;
    e1.afii10053 = 1028;
    e1.afii10054 = 1029;
    e1.afii10055 = 1030;
    e1.afii10056 = 1031;
    e1.afii10057 = 1032;
    e1.afii10058 = 1033;
    e1.afii10059 = 1034;
    e1.afii10060 = 1035;
    e1.afii10061 = 1036;
    e1.afii10062 = 1038;
    e1.afii10063 = 63172;
    e1.afii10064 = 63173;
    e1.afii10065 = 1072;
    e1.afii10066 = 1073;
    e1.afii10067 = 1074;
    e1.afii10068 = 1075;
    e1.afii10069 = 1076;
    e1.afii10070 = 1077;
    e1.afii10071 = 1105;
    e1.afii10072 = 1078;
    e1.afii10073 = 1079;
    e1.afii10074 = 1080;
    e1.afii10075 = 1081;
    e1.afii10076 = 1082;
    e1.afii10077 = 1083;
    e1.afii10078 = 1084;
    e1.afii10079 = 1085;
    e1.afii10080 = 1086;
    e1.afii10081 = 1087;
    e1.afii10082 = 1088;
    e1.afii10083 = 1089;
    e1.afii10084 = 1090;
    e1.afii10085 = 1091;
    e1.afii10086 = 1092;
    e1.afii10087 = 1093;
    e1.afii10088 = 1094;
    e1.afii10089 = 1095;
    e1.afii10090 = 1096;
    e1.afii10091 = 1097;
    e1.afii10092 = 1098;
    e1.afii10093 = 1099;
    e1.afii10094 = 1100;
    e1.afii10095 = 1101;
    e1.afii10096 = 1102;
    e1.afii10097 = 1103;
    e1.afii10098 = 1169;
    e1.afii10099 = 1106;
    e1.afii10100 = 1107;
    e1.afii10101 = 1108;
    e1.afii10102 = 1109;
    e1.afii10103 = 1110;
    e1.afii10104 = 1111;
    e1.afii10105 = 1112;
    e1.afii10106 = 1113;
    e1.afii10107 = 1114;
    e1.afii10108 = 1115;
    e1.afii10109 = 1116;
    e1.afii10110 = 1118;
    e1.afii10145 = 1039;
    e1.afii10146 = 1122;
    e1.afii10147 = 1138;
    e1.afii10148 = 1140;
    e1.afii10192 = 63174;
    e1.afii10193 = 1119;
    e1.afii10194 = 1123;
    e1.afii10195 = 1139;
    e1.afii10196 = 1141;
    e1.afii10831 = 63175;
    e1.afii10832 = 63176;
    e1.afii10846 = 1241;
    e1.afii299 = 8206;
    e1.afii300 = 8207;
    e1.afii301 = 8205;
    e1.afii57381 = 1642;
    e1.afii57388 = 1548;
    e1.afii57392 = 1632;
    e1.afii57393 = 1633;
    e1.afii57394 = 1634;
    e1.afii57395 = 1635;
    e1.afii57396 = 1636;
    e1.afii57397 = 1637;
    e1.afii57398 = 1638;
    e1.afii57399 = 1639;
    e1.afii57400 = 1640;
    e1.afii57401 = 1641;
    e1.afii57403 = 1563;
    e1.afii57407 = 1567;
    e1.afii57409 = 1569;
    e1.afii57410 = 1570;
    e1.afii57411 = 1571;
    e1.afii57412 = 1572;
    e1.afii57413 = 1573;
    e1.afii57414 = 1574;
    e1.afii57415 = 1575;
    e1.afii57416 = 1576;
    e1.afii57417 = 1577;
    e1.afii57418 = 1578;
    e1.afii57419 = 1579;
    e1.afii57420 = 1580;
    e1.afii57421 = 1581;
    e1.afii57422 = 1582;
    e1.afii57423 = 1583;
    e1.afii57424 = 1584;
    e1.afii57425 = 1585;
    e1.afii57426 = 1586;
    e1.afii57427 = 1587;
    e1.afii57428 = 1588;
    e1.afii57429 = 1589;
    e1.afii57430 = 1590;
    e1.afii57431 = 1591;
    e1.afii57432 = 1592;
    e1.afii57433 = 1593;
    e1.afii57434 = 1594;
    e1.afii57440 = 1600;
    e1.afii57441 = 1601;
    e1.afii57442 = 1602;
    e1.afii57443 = 1603;
    e1.afii57444 = 1604;
    e1.afii57445 = 1605;
    e1.afii57446 = 1606;
    e1.afii57448 = 1608;
    e1.afii57449 = 1609;
    e1.afii57450 = 1610;
    e1.afii57451 = 1611;
    e1.afii57452 = 1612;
    e1.afii57453 = 1613;
    e1.afii57454 = 1614;
    e1.afii57455 = 1615;
    e1.afii57456 = 1616;
    e1.afii57457 = 1617;
    e1.afii57458 = 1618;
    e1.afii57470 = 1607;
    e1.afii57505 = 1700;
    e1.afii57506 = 1662;
    e1.afii57507 = 1670;
    e1.afii57508 = 1688;
    e1.afii57509 = 1711;
    e1.afii57511 = 1657;
    e1.afii57512 = 1672;
    e1.afii57513 = 1681;
    e1.afii57514 = 1722;
    e1.afii57519 = 1746;
    e1.afii57534 = 1749;
    e1.afii57636 = 8362;
    e1.afii57645 = 1470;
    e1.afii57658 = 1475;
    e1.afii57664 = 1488;
    e1.afii57665 = 1489;
    e1.afii57666 = 1490;
    e1.afii57667 = 1491;
    e1.afii57668 = 1492;
    e1.afii57669 = 1493;
    e1.afii57670 = 1494;
    e1.afii57671 = 1495;
    e1.afii57672 = 1496;
    e1.afii57673 = 1497;
    e1.afii57674 = 1498;
    e1.afii57675 = 1499;
    e1.afii57676 = 1500;
    e1.afii57677 = 1501;
    e1.afii57678 = 1502;
    e1.afii57679 = 1503;
    e1.afii57680 = 1504;
    e1.afii57681 = 1505;
    e1.afii57682 = 1506;
    e1.afii57683 = 1507;
    e1.afii57684 = 1508;
    e1.afii57685 = 1509;
    e1.afii57686 = 1510;
    e1.afii57687 = 1511;
    e1.afii57688 = 1512;
    e1.afii57689 = 1513;
    e1.afii57690 = 1514;
    e1.afii57694 = 64298;
    e1.afii57695 = 64299;
    e1.afii57700 = 64331;
    e1.afii57705 = 64287;
    e1.afii57716 = 1520;
    e1.afii57717 = 1521;
    e1.afii57718 = 1522;
    e1.afii57723 = 64309;
    e1.afii57793 = 1460;
    e1.afii57794 = 1461;
    e1.afii57795 = 1462;
    e1.afii57796 = 1467;
    e1.afii57797 = 1464;
    e1.afii57798 = 1463;
    e1.afii57799 = 1456;
    e1.afii57800 = 1458;
    e1.afii57801 = 1457;
    e1.afii57802 = 1459;
    e1.afii57803 = 1474;
    e1.afii57804 = 1473;
    e1.afii57806 = 1465;
    e1.afii57807 = 1468;
    e1.afii57839 = 1469;
    e1.afii57841 = 1471;
    e1.afii57842 = 1472;
    e1.afii57929 = 700;
    e1.afii61248 = 8453;
    e1.afii61289 = 8467;
    e1.afii61352 = 8470;
    e1.afii61573 = 8236;
    e1.afii61574 = 8237;
    e1.afii61575 = 8238;
    e1.afii61664 = 8204;
    e1.afii63167 = 1645;
    e1.afii64937 = 701;
    e1.agrave = 224;
    e1.agujarati = 2693;
    e1.agurmukhi = 2565;
    e1.ahiragana = 12354;
    e1.ahookabove = 7843;
    e1.aibengali = 2448;
    e1.aibopomofo = 12574;
    e1.aideva = 2320;
    e1.aiecyrillic = 1237;
    e1.aigujarati = 2704;
    e1.aigurmukhi = 2576;
    e1.aimatragurmukhi = 2632;
    e1.ainarabic = 1593;
    e1.ainfinalarabic = 65226;
    e1.aininitialarabic = 65227;
    e1.ainmedialarabic = 65228;
    e1.ainvertedbreve = 515;
    e1.aivowelsignbengali = 2504;
    e1.aivowelsigndeva = 2376;
    e1.aivowelsigngujarati = 2760;
    e1.akatakana = 12450;
    e1.akatakanahalfwidth = 65393;
    e1.akorean = 12623;
    e1.alef = 1488;
    e1.alefarabic = 1575;
    e1.alefdageshhebrew = 64304;
    e1.aleffinalarabic = 65166;
    e1.alefhamzaabovearabic = 1571;
    e1.alefhamzaabovefinalarabic = 65156;
    e1.alefhamzabelowarabic = 1573;
    e1.alefhamzabelowfinalarabic = 65160;
    e1.alefhebrew = 1488;
    e1.aleflamedhebrew = 64335;
    e1.alefmaddaabovearabic = 1570;
    e1.alefmaddaabovefinalarabic = 65154;
    e1.alefmaksuraarabic = 1609;
    e1.alefmaksurafinalarabic = 65264;
    e1.alefmaksurainitialarabic = 65267;
    e1.alefmaksuramedialarabic = 65268;
    e1.alefpatahhebrew = 64302;
    e1.alefqamatshebrew = 64303;
    e1.aleph = 8501;
    e1.allequal = 8780;
    e1.alpha = 945;
    e1.alphatonos = 940;
    e1.amacron = 257;
    e1.amonospace = 65345;
    e1.ampersand = 38;
    e1.ampersandmonospace = 65286;
    e1.ampersandsmall = 63270;
    e1.amsquare = 13250;
    e1.anbopomofo = 12578;
    e1.angbopomofo = 12580;
    e1.angbracketleft = 12296;
    e1.angbracketright = 12297;
    e1.angkhankhuthai = 3674;
    e1.angle = 8736;
    e1.anglebracketleft = 12296;
    e1.anglebracketleftvertical = 65087;
    e1.anglebracketright = 12297;
    e1.anglebracketrightvertical = 65088;
    e1.angleleft = 9001;
    e1.angleright = 9002;
    e1.angstrom = 8491;
    e1.anoteleia = 903;
    e1.anudattadeva = 2386;
    e1.anusvarabengali = 2434;
    e1.anusvaradeva = 2306;
    e1.anusvaragujarati = 2690;
    e1.aogonek = 261;
    e1.apaatosquare = 13056;
    e1.aparen = 9372;
    e1.apostrophearmenian = 1370;
    e1.apostrophemod = 700;
    e1.apple = 63743;
    e1.approaches = 8784;
    e1.approxequal = 8776;
    e1.approxequalorimage = 8786;
    e1.approximatelyequal = 8773;
    e1.araeaekorean = 12686;
    e1.araeakorean = 12685;
    e1.arc = 8978;
    e1.arighthalfring = 7834;
    e1.aring = 229;
    e1.aringacute = 507;
    e1.aringbelow = 7681;
    e1.arrowboth = 8596;
    e1.arrowdashdown = 8675;
    e1.arrowdashleft = 8672;
    e1.arrowdashright = 8674;
    e1.arrowdashup = 8673;
    e1.arrowdblboth = 8660;
    e1.arrowdbldown = 8659;
    e1.arrowdblleft = 8656;
    e1.arrowdblright = 8658;
    e1.arrowdblup = 8657;
    e1.arrowdown = 8595;
    e1.arrowdownleft = 8601;
    e1.arrowdownright = 8600;
    e1.arrowdownwhite = 8681;
    e1.arrowheaddownmod = 709;
    e1.arrowheadleftmod = 706;
    e1.arrowheadrightmod = 707;
    e1.arrowheadupmod = 708;
    e1.arrowhorizex = 63719;
    e1.arrowleft = 8592;
    e1.arrowleftdbl = 8656;
    e1.arrowleftdblstroke = 8653;
    e1.arrowleftoverright = 8646;
    e1.arrowleftwhite = 8678;
    e1.arrowright = 8594;
    e1.arrowrightdblstroke = 8655;
    e1.arrowrightheavy = 10142;
    e1.arrowrightoverleft = 8644;
    e1.arrowrightwhite = 8680;
    e1.arrowtableft = 8676;
    e1.arrowtabright = 8677;
    e1.arrowup = 8593;
    e1.arrowupdn = 8597;
    e1.arrowupdnbse = 8616;
    e1.arrowupdownbase = 8616;
    e1.arrowupleft = 8598;
    e1.arrowupleftofdown = 8645;
    e1.arrowupright = 8599;
    e1.arrowupwhite = 8679;
    e1.arrowvertex = 63718;
    e1.asciicircum = 94;
    e1.asciicircummonospace = 65342;
    e1.asciitilde = 126;
    e1.asciitildemonospace = 65374;
    e1.ascript = 593;
    e1.ascriptturned = 594;
    e1.asmallhiragana = 12353;
    e1.asmallkatakana = 12449;
    e1.asmallkatakanahalfwidth = 65383;
    e1.asterisk = 42;
    e1.asteriskaltonearabic = 1645;
    e1.asteriskarabic = 1645;
    e1.asteriskmath = 8727;
    e1.asteriskmonospace = 65290;
    e1.asterisksmall = 65121;
    e1.asterism = 8258;
    e1.asuperior = 63209;
    e1.asymptoticallyequal = 8771;
    e1.at = 64;
    e1.atilde = 227;
    e1.atmonospace = 65312;
    e1.atsmall = 65131;
    e1.aturned = 592;
    e1.aubengali = 2452;
    e1.aubopomofo = 12576;
    e1.audeva = 2324;
    e1.augujarati = 2708;
    e1.augurmukhi = 2580;
    e1.aulengthmarkbengali = 2519;
    e1.aumatragurmukhi = 2636;
    e1.auvowelsignbengali = 2508;
    e1.auvowelsigndeva = 2380;
    e1.auvowelsigngujarati = 2764;
    e1.avagrahadeva = 2365;
    e1.aybarmenian = 1377;
    e1.ayin = 1506;
    e1.ayinaltonehebrew = 64288;
    e1.ayinhebrew = 1506;
    e1.b = 98;
    e1.babengali = 2476;
    e1.backslash = 92;
    e1.backslashmonospace = 65340;
    e1.badeva = 2348;
    e1.bagujarati = 2732;
    e1.bagurmukhi = 2604;
    e1.bahiragana = 12400;
    e1.bahtthai = 3647;
    e1.bakatakana = 12496;
    e1.bar = 124;
    e1.barmonospace = 65372;
    e1.bbopomofo = 12549;
    e1.bcircle = 9425;
    e1.bdotaccent = 7683;
    e1.bdotbelow = 7685;
    e1.beamedsixteenthnotes = 9836;
    e1.because = 8757;
    e1.becyrillic = 1073;
    e1.beharabic = 1576;
    e1.behfinalarabic = 65168;
    e1.behinitialarabic = 65169;
    e1.behiragana = 12409;
    e1.behmedialarabic = 65170;
    e1.behmeeminitialarabic = 64671;
    e1.behmeemisolatedarabic = 64520;
    e1.behnoonfinalarabic = 64621;
    e1.bekatakana = 12505;
    e1.benarmenian = 1378;
    e1.bet = 1489;
    e1.beta = 946;
    e1.betasymbolgreek = 976;
    e1.betdagesh = 64305;
    e1.betdageshhebrew = 64305;
    e1.bethebrew = 1489;
    e1.betrafehebrew = 64332;
    e1.bhabengali = 2477;
    e1.bhadeva = 2349;
    e1.bhagujarati = 2733;
    e1.bhagurmukhi = 2605;
    e1.bhook = 595;
    e1.bihiragana = 12403;
    e1.bikatakana = 12499;
    e1.bilabialclick = 664;
    e1.bindigurmukhi = 2562;
    e1.birusquare = 13105;
    e1.blackcircle = 9679;
    e1.blackdiamond = 9670;
    e1.blackdownpointingtriangle = 9660;
    e1.blackleftpointingpointer = 9668;
    e1.blackleftpointingtriangle = 9664;
    e1.blacklenticularbracketleft = 12304;
    e1.blacklenticularbracketleftvertical = 65083;
    e1.blacklenticularbracketright = 12305;
    e1.blacklenticularbracketrightvertical = 65084;
    e1.blacklowerlefttriangle = 9699;
    e1.blacklowerrighttriangle = 9698;
    e1.blackrectangle = 9644;
    e1.blackrightpointingpointer = 9658;
    e1.blackrightpointingtriangle = 9654;
    e1.blacksmallsquare = 9642;
    e1.blacksmilingface = 9787;
    e1.blacksquare = 9632;
    e1.blackstar = 9733;
    e1.blackupperlefttriangle = 9700;
    e1.blackupperrighttriangle = 9701;
    e1.blackuppointingsmalltriangle = 9652;
    e1.blackuppointingtriangle = 9650;
    e1.blank = 9251;
    e1.blinebelow = 7687;
    e1.block = 9608;
    e1.bmonospace = 65346;
    e1.bobaimaithai = 3610;
    e1.bohiragana = 12412;
    e1.bokatakana = 12508;
    e1.bparen = 9373;
    e1.bqsquare = 13251;
    e1.braceex = 63732;
    e1.braceleft = 123;
    e1.braceleftbt = 63731;
    e1.braceleftmid = 63730;
    e1.braceleftmonospace = 65371;
    e1.braceleftsmall = 65115;
    e1.bracelefttp = 63729;
    e1.braceleftvertical = 65079;
    e1.braceright = 125;
    e1.bracerightbt = 63742;
    e1.bracerightmid = 63741;
    e1.bracerightmonospace = 65373;
    e1.bracerightsmall = 65116;
    e1.bracerighttp = 63740;
    e1.bracerightvertical = 65080;
    e1.bracketleft = 91;
    e1.bracketleftbt = 63728;
    e1.bracketleftex = 63727;
    e1.bracketleftmonospace = 65339;
    e1.bracketlefttp = 63726;
    e1.bracketright = 93;
    e1.bracketrightbt = 63739;
    e1.bracketrightex = 63738;
    e1.bracketrightmonospace = 65341;
    e1.bracketrighttp = 63737;
    e1.breve = 728;
    e1.brevebelowcmb = 814;
    e1.brevecmb = 774;
    e1.breveinvertedbelowcmb = 815;
    e1.breveinvertedcmb = 785;
    e1.breveinverteddoublecmb = 865;
    e1.bridgebelowcmb = 810;
    e1.bridgeinvertedbelowcmb = 826;
    e1.brokenbar = 166;
    e1.bstroke = 384;
    e1.bsuperior = 63210;
    e1.btopbar = 387;
    e1.buhiragana = 12406;
    e1.bukatakana = 12502;
    e1.bullet = 8226;
    e1.bulletinverse = 9688;
    e1.bulletoperator = 8729;
    e1.bullseye = 9678;
    e1.c = 99;
    e1.caarmenian = 1390;
    e1.cabengali = 2458;
    e1.cacute = 263;
    e1.cadeva = 2330;
    e1.cagujarati = 2714;
    e1.cagurmukhi = 2586;
    e1.calsquare = 13192;
    e1.candrabindubengali = 2433;
    e1.candrabinducmb = 784;
    e1.candrabindudeva = 2305;
    e1.candrabindugujarati = 2689;
    e1.capslock = 8682;
    e1.careof = 8453;
    e1.caron = 711;
    e1.caronbelowcmb = 812;
    e1.caroncmb = 780;
    e1.carriagereturn = 8629;
    e1.cbopomofo = 12568;
    e1.ccaron = 269;
    e1.ccedilla = 231;
    e1.ccedillaacute = 7689;
    e1.ccircle = 9426;
    e1.ccircumflex = 265;
    e1.ccurl = 597;
    e1.cdot = 267;
    e1.cdotaccent = 267;
    e1.cdsquare = 13253;
    e1.cedilla = 184;
    e1.cedillacmb = 807;
    e1.cent = 162;
    e1.centigrade = 8451;
    e1.centinferior = 63199;
    e1.centmonospace = 65504;
    e1.centoldstyle = 63394;
    e1.centsuperior = 63200;
    e1.chaarmenian = 1401;
    e1.chabengali = 2459;
    e1.chadeva = 2331;
    e1.chagujarati = 2715;
    e1.chagurmukhi = 2587;
    e1.chbopomofo = 12564;
    e1.cheabkhasiancyrillic = 1213;
    e1.checkmark = 10003;
    e1.checyrillic = 1095;
    e1.chedescenderabkhasiancyrillic = 1215;
    e1.chedescendercyrillic = 1207;
    e1.chedieresiscyrillic = 1269;
    e1.cheharmenian = 1395;
    e1.chekhakassiancyrillic = 1228;
    e1.cheverticalstrokecyrillic = 1209;
    e1.chi = 967;
    e1.chieuchacirclekorean = 12919;
    e1.chieuchaparenkorean = 12823;
    e1.chieuchcirclekorean = 12905;
    e1.chieuchkorean = 12618;
    e1.chieuchparenkorean = 12809;
    e1.chochangthai = 3594;
    e1.chochanthai = 3592;
    e1.chochingthai = 3593;
    e1.chochoethai = 3596;
    e1.chook = 392;
    e1.cieucacirclekorean = 12918;
    e1.cieucaparenkorean = 12822;
    e1.cieuccirclekorean = 12904;
    e1.cieuckorean = 12616;
    e1.cieucparenkorean = 12808;
    e1.cieucuparenkorean = 12828;
    e1.circle = 9675;
    e1.circlecopyrt = 169;
    e1.circlemultiply = 8855;
    e1.circleot = 8857;
    e1.circleplus = 8853;
    e1.circlepostalmark = 12342;
    e1.circlewithlefthalfblack = 9680;
    e1.circlewithrighthalfblack = 9681;
    e1.circumflex = 710;
    e1.circumflexbelowcmb = 813;
    e1.circumflexcmb = 770;
    e1.clear = 8999;
    e1.clickalveolar = 450;
    e1.clickdental = 448;
    e1.clicklateral = 449;
    e1.clickretroflex = 451;
    e1.club = 9827;
    e1.clubsuitblack = 9827;
    e1.clubsuitwhite = 9831;
    e1.cmcubedsquare = 13220;
    e1.cmonospace = 65347;
    e1.cmsquaredsquare = 13216;
    e1.coarmenian = 1409;
    e1.colon = 58;
    e1.colonmonetary = 8353;
    e1.colonmonospace = 65306;
    e1.colonsign = 8353;
    e1.colonsmall = 65109;
    e1.colontriangularhalfmod = 721;
    e1.colontriangularmod = 720;
    e1.comma = 44;
    e1.commaabovecmb = 787;
    e1.commaaboverightcmb = 789;
    e1.commaaccent = 63171;
    e1.commaarabic = 1548;
    e1.commaarmenian = 1373;
    e1.commainferior = 63201;
    e1.commamonospace = 65292;
    e1.commareversedabovecmb = 788;
    e1.commareversedmod = 701;
    e1.commasmall = 65104;
    e1.commasuperior = 63202;
    e1.commaturnedabovecmb = 786;
    e1.commaturnedmod = 699;
    e1.compass = 9788;
    e1.congruent = 8773;
    e1.contourintegral = 8750;
    e1.control = 8963;
    e1.controlACK = 6;
    e1.controlBEL = 7;
    e1.controlBS = 8;
    e1.controlCAN = 24;
    e1.controlCR = 13;
    e1.controlDC1 = 17;
    e1.controlDC2 = 18;
    e1.controlDC3 = 19;
    e1.controlDC4 = 20;
    e1.controlDEL = 127;
    e1.controlDLE = 16;
    e1.controlEM = 25;
    e1.controlENQ = 5;
    e1.controlEOT = 4;
    e1.controlESC = 27;
    e1.controlETB = 23;
    e1.controlETX = 3;
    e1.controlFF = 12;
    e1.controlFS = 28;
    e1.controlGS = 29;
    e1.controlHT = 9;
    e1.controlLF = 10;
    e1.controlNAK = 21;
    e1.controlNULL = 0;
    e1.controlRS = 30;
    e1.controlSI = 15;
    e1.controlSO = 14;
    e1.controlSOT = 2;
    e1.controlSTX = 1;
    e1.controlSUB = 26;
    e1.controlSYN = 22;
    e1.controlUS = 31;
    e1.controlVT = 11;
    e1.copyright = 169;
    e1.copyrightsans = 63721;
    e1.copyrightserif = 63193;
    e1.cornerbracketleft = 12300;
    e1.cornerbracketlefthalfwidth = 65378;
    e1.cornerbracketleftvertical = 65089;
    e1.cornerbracketright = 12301;
    e1.cornerbracketrighthalfwidth = 65379;
    e1.cornerbracketrightvertical = 65090;
    e1.corporationsquare = 13183;
    e1.cosquare = 13255;
    e1.coverkgsquare = 13254;
    e1.cparen = 9374;
    e1.cruzeiro = 8354;
    e1.cstretched = 663;
    e1.curlyand = 8911;
    e1.curlyor = 8910;
    e1.currency = 164;
    e1.cyrBreve = 63185;
    e1.cyrFlex = 63186;
    e1.cyrbreve = 63188;
    e1.cyrflex = 63189;
    e1.d = 100;
    e1.daarmenian = 1380;
    e1.dabengali = 2470;
    e1.dadarabic = 1590;
    e1.dadeva = 2342;
    e1.dadfinalarabic = 65214;
    e1.dadinitialarabic = 65215;
    e1.dadmedialarabic = 65216;
    e1.dagesh = 1468;
    e1.dageshhebrew = 1468;
    e1.dagger = 8224;
    e1.daggerdbl = 8225;
    e1.dagujarati = 2726;
    e1.dagurmukhi = 2598;
    e1.dahiragana = 12384;
    e1.dakatakana = 12480;
    e1.dalarabic = 1583;
    e1.dalet = 1491;
    e1.daletdagesh = 64307;
    e1.daletdageshhebrew = 64307;
    e1.dalethebrew = 1491;
    e1.dalfinalarabic = 65194;
    e1.dammaarabic = 1615;
    e1.dammalowarabic = 1615;
    e1.dammatanaltonearabic = 1612;
    e1.dammatanarabic = 1612;
    e1.danda = 2404;
    e1.dargahebrew = 1447;
    e1.dargalefthebrew = 1447;
    e1.dasiapneumatacyrilliccmb = 1157;
    e1.dblGrave = 63187;
    e1.dblanglebracketleft = 12298;
    e1.dblanglebracketleftvertical = 65085;
    e1.dblanglebracketright = 12299;
    e1.dblanglebracketrightvertical = 65086;
    e1.dblarchinvertedbelowcmb = 811;
    e1.dblarrowleft = 8660;
    e1.dblarrowright = 8658;
    e1.dbldanda = 2405;
    e1.dblgrave = 63190;
    e1.dblgravecmb = 783;
    e1.dblintegral = 8748;
    e1.dbllowline = 8215;
    e1.dbllowlinecmb = 819;
    e1.dbloverlinecmb = 831;
    e1.dblprimemod = 698;
    e1.dblverticalbar = 8214;
    e1.dblverticallineabovecmb = 782;
    e1.dbopomofo = 12553;
    e1.dbsquare = 13256;
    e1.dcaron = 271;
    e1.dcedilla = 7697;
    e1.dcircle = 9427;
    e1.dcircumflexbelow = 7699;
    e1.dcroat = 273;
    e1.ddabengali = 2465;
    e1.ddadeva = 2337;
    e1.ddagujarati = 2721;
    e1.ddagurmukhi = 2593;
    e1.ddalarabic = 1672;
    e1.ddalfinalarabic = 64393;
    e1.dddhadeva = 2396;
    e1.ddhabengali = 2466;
    e1.ddhadeva = 2338;
    e1.ddhagujarati = 2722;
    e1.ddhagurmukhi = 2594;
    e1.ddotaccent = 7691;
    e1.ddotbelow = 7693;
    e1.decimalseparatorarabic = 1643;
    e1.decimalseparatorpersian = 1643;
    e1.decyrillic = 1076;
    e1.degree = 176;
    e1.dehihebrew = 1453;
    e1.dehiragana = 12391;
    e1.deicoptic = 1007;
    e1.dekatakana = 12487;
    e1.deleteleft = 9003;
    e1.deleteright = 8998;
    e1.delta = 948;
    e1.deltaturned = 397;
    e1.denominatorminusonenumeratorbengali = 2552;
    e1.dezh = 676;
    e1.dhabengali = 2471;
    e1.dhadeva = 2343;
    e1.dhagujarati = 2727;
    e1.dhagurmukhi = 2599;
    e1.dhook = 599;
    e1.dialytikatonos = 901;
    e1.dialytikatonoscmb = 836;
    e1.diamond = 9830;
    e1.diamondsuitwhite = 9826;
    e1.dieresis = 168;
    e1.dieresisacute = 63191;
    e1.dieresisbelowcmb = 804;
    e1.dieresiscmb = 776;
    e1.dieresisgrave = 63192;
    e1.dieresistonos = 901;
    e1.dihiragana = 12386;
    e1.dikatakana = 12482;
    e1.dittomark = 12291;
    e1.divide = 247;
    e1.divides = 8739;
    e1.divisionslash = 8725;
    e1.djecyrillic = 1106;
    e1.dkshade = 9619;
    e1.dlinebelow = 7695;
    e1.dlsquare = 13207;
    e1.dmacron = 273;
    e1.dmonospace = 65348;
    e1.dnblock = 9604;
    e1.dochadathai = 3598;
    e1.dodekthai = 3604;
    e1.dohiragana = 12393;
    e1.dokatakana = 12489;
    e1.dollar = 36;
    e1.dollarinferior = 63203;
    e1.dollarmonospace = 65284;
    e1.dollaroldstyle = 63268;
    e1.dollarsmall = 65129;
    e1.dollarsuperior = 63204;
    e1.dong = 8363;
    e1.dorusquare = 13094;
    e1.dotaccent = 729;
    e1.dotaccentcmb = 775;
    e1.dotbelowcmb = 803;
    e1.dotbelowcomb = 803;
    e1.dotkatakana = 12539;
    e1.dotlessi = 305;
    e1.dotlessj = 63166;
    e1.dotlessjstrokehook = 644;
    e1.dotmath = 8901;
    e1.dottedcircle = 9676;
    e1.doubleyodpatah = 64287;
    e1.doubleyodpatahhebrew = 64287;
    e1.downtackbelowcmb = 798;
    e1.downtackmod = 725;
    e1.dparen = 9375;
    e1.dsuperior = 63211;
    e1.dtail = 598;
    e1.dtopbar = 396;
    e1.duhiragana = 12389;
    e1.dukatakana = 12485;
    e1.dz = 499;
    e1.dzaltone = 675;
    e1.dzcaron = 454;
    e1.dzcurl = 677;
    e1.dzeabkhasiancyrillic = 1249;
    e1.dzecyrillic = 1109;
    e1.dzhecyrillic = 1119;
    e1.e = 101;
    e1.eacute = 233;
    e1.earth = 9793;
    e1.ebengali = 2447;
    e1.ebopomofo = 12572;
    e1.ebreve = 277;
    e1.ecandradeva = 2317;
    e1.ecandragujarati = 2701;
    e1.ecandravowelsigndeva = 2373;
    e1.ecandravowelsigngujarati = 2757;
    e1.ecaron = 283;
    e1.ecedillabreve = 7709;
    e1.echarmenian = 1381;
    e1.echyiwnarmenian = 1415;
    e1.ecircle = 9428;
    e1.ecircumflex = 234;
    e1.ecircumflexacute = 7871;
    e1.ecircumflexbelow = 7705;
    e1.ecircumflexdotbelow = 7879;
    e1.ecircumflexgrave = 7873;
    e1.ecircumflexhookabove = 7875;
    e1.ecircumflextilde = 7877;
    e1.ecyrillic = 1108;
    e1.edblgrave = 517;
    e1.edeva = 2319;
    e1.edieresis = 235;
    e1.edot = 279;
    e1.edotaccent = 279;
    e1.edotbelow = 7865;
    e1.eegurmukhi = 2575;
    e1.eematragurmukhi = 2631;
    e1.efcyrillic = 1092;
    e1.egrave = 232;
    e1.egujarati = 2703;
    e1.eharmenian = 1383;
    e1.ehbopomofo = 12573;
    e1.ehiragana = 12360;
    e1.ehookabove = 7867;
    e1.eibopomofo = 12575;
    e1.eight = 56;
    e1.eightarabic = 1640;
    e1.eightbengali = 2542;
    e1.eightcircle = 9319;
    e1.eightcircleinversesansserif = 10129;
    e1.eightdeva = 2414;
    e1.eighteencircle = 9329;
    e1.eighteenparen = 9349;
    e1.eighteenperiod = 9369;
    e1.eightgujarati = 2798;
    e1.eightgurmukhi = 2670;
    e1.eighthackarabic = 1640;
    e1.eighthangzhou = 12328;
    e1.eighthnotebeamed = 9835;
    e1.eightideographicparen = 12839;
    e1.eightinferior = 8328;
    e1.eightmonospace = 65304;
    e1.eightoldstyle = 63288;
    e1.eightparen = 9339;
    e1.eightperiod = 9359;
    e1.eightpersian = 1784;
    e1.eightroman = 8567;
    e1.eightsuperior = 8312;
    e1.eightthai = 3672;
    e1.einvertedbreve = 519;
    e1.eiotifiedcyrillic = 1125;
    e1.ekatakana = 12456;
    e1.ekatakanahalfwidth = 65396;
    e1.ekonkargurmukhi = 2676;
    e1.ekorean = 12628;
    e1.elcyrillic = 1083;
    e1.element = 8712;
    e1.elevencircle = 9322;
    e1.elevenparen = 9342;
    e1.elevenperiod = 9362;
    e1.elevenroman = 8570;
    e1.ellipsis = 8230;
    e1.ellipsisvertical = 8942;
    e1.emacron = 275;
    e1.emacronacute = 7703;
    e1.emacrongrave = 7701;
    e1.emcyrillic = 1084;
    e1.emdash = 8212;
    e1.emdashvertical = 65073;
    e1.emonospace = 65349;
    e1.emphasismarkarmenian = 1371;
    e1.emptyset = 8709;
    e1.enbopomofo = 12579;
    e1.encyrillic = 1085;
    e1.endash = 8211;
    e1.endashvertical = 65074;
    e1.endescendercyrillic = 1187;
    e1.eng = 331;
    e1.engbopomofo = 12581;
    e1.enghecyrillic = 1189;
    e1.enhookcyrillic = 1224;
    e1.enspace = 8194;
    e1.eogonek = 281;
    e1.eokorean = 12627;
    e1.eopen = 603;
    e1.eopenclosed = 666;
    e1.eopenreversed = 604;
    e1.eopenreversedclosed = 606;
    e1.eopenreversedhook = 605;
    e1.eparen = 9376;
    e1.epsilon = 949;
    e1.epsilontonos = 941;
    e1.equal = 61;
    e1.equalmonospace = 65309;
    e1.equalsmall = 65126;
    e1.equalsuperior = 8316;
    e1.equivalence = 8801;
    e1.erbopomofo = 12582;
    e1.ercyrillic = 1088;
    e1.ereversed = 600;
    e1.ereversedcyrillic = 1101;
    e1.escyrillic = 1089;
    e1.esdescendercyrillic = 1195;
    e1.esh = 643;
    e1.eshcurl = 646;
    e1.eshortdeva = 2318;
    e1.eshortvowelsigndeva = 2374;
    e1.eshreversedloop = 426;
    e1.eshsquatreversed = 645;
    e1.esmallhiragana = 12359;
    e1.esmallkatakana = 12455;
    e1.esmallkatakanahalfwidth = 65386;
    e1.estimated = 8494;
    e1.esuperior = 63212;
    e1.eta = 951;
    e1.etarmenian = 1384;
    e1.etatonos = 942;
    e1.eth = 240;
    e1.etilde = 7869;
    e1.etildebelow = 7707;
    e1.etnahtafoukhhebrew = 1425;
    e1.etnahtafoukhlefthebrew = 1425;
    e1.etnahtahebrew = 1425;
    e1.etnahtalefthebrew = 1425;
    e1.eturned = 477;
    e1.eukorean = 12641;
    e1.euro = 8364;
    e1.evowelsignbengali = 2503;
    e1.evowelsigndeva = 2375;
    e1.evowelsigngujarati = 2759;
    e1.exclam = 33;
    e1.exclamarmenian = 1372;
    e1.exclamdbl = 8252;
    e1.exclamdown = 161;
    e1.exclamdownsmall = 63393;
    e1.exclammonospace = 65281;
    e1.exclamsmall = 63265;
    e1.existential = 8707;
    e1.ezh = 658;
    e1.ezhcaron = 495;
    e1.ezhcurl = 659;
    e1.ezhreversed = 441;
    e1.ezhtail = 442;
    e1.f = 102;
    e1.fadeva = 2398;
    e1.fagurmukhi = 2654;
    e1.fahrenheit = 8457;
    e1.fathaarabic = 1614;
    e1.fathalowarabic = 1614;
    e1.fathatanarabic = 1611;
    e1.fbopomofo = 12552;
    e1.fcircle = 9429;
    e1.fdotaccent = 7711;
    e1.feharabic = 1601;
    e1.feharmenian = 1414;
    e1.fehfinalarabic = 65234;
    e1.fehinitialarabic = 65235;
    e1.fehmedialarabic = 65236;
    e1.feicoptic = 997;
    e1.female = 9792;
    e1.ff = 64256;
    e1.f_f = 64256;
    e1.ffi = 64259;
    e1.f_f_i = 64259;
    e1.ffl = 64260;
    e1.f_f_l = 64260;
    e1.fi = 64257;
    e1.f_i = 64257;
    e1.fifteencircle = 9326;
    e1.fifteenparen = 9346;
    e1.fifteenperiod = 9366;
    e1.figuredash = 8210;
    e1.filledbox = 9632;
    e1.filledrect = 9644;
    e1.finalkaf = 1498;
    e1.finalkafdagesh = 64314;
    e1.finalkafdageshhebrew = 64314;
    e1.finalkafhebrew = 1498;
    e1.finalmem = 1501;
    e1.finalmemhebrew = 1501;
    e1.finalnun = 1503;
    e1.finalnunhebrew = 1503;
    e1.finalpe = 1507;
    e1.finalpehebrew = 1507;
    e1.finaltsadi = 1509;
    e1.finaltsadihebrew = 1509;
    e1.firsttonechinese = 713;
    e1.fisheye = 9673;
    e1.fitacyrillic = 1139;
    e1.five = 53;
    e1.fivearabic = 1637;
    e1.fivebengali = 2539;
    e1.fivecircle = 9316;
    e1.fivecircleinversesansserif = 10126;
    e1.fivedeva = 2411;
    e1.fiveeighths = 8541;
    e1.fivegujarati = 2795;
    e1.fivegurmukhi = 2667;
    e1.fivehackarabic = 1637;
    e1.fivehangzhou = 12325;
    e1.fiveideographicparen = 12836;
    e1.fiveinferior = 8325;
    e1.fivemonospace = 65301;
    e1.fiveoldstyle = 63285;
    e1.fiveparen = 9336;
    e1.fiveperiod = 9356;
    e1.fivepersian = 1781;
    e1.fiveroman = 8564;
    e1.fivesuperior = 8309;
    e1.fivethai = 3669;
    e1.fl = 64258;
    e1.f_l = 64258;
    e1.florin = 402;
    e1.fmonospace = 65350;
    e1.fmsquare = 13209;
    e1.fofanthai = 3615;
    e1.fofathai = 3613;
    e1.fongmanthai = 3663;
    e1.forall = 8704;
    e1.four = 52;
    e1.fourarabic = 1636;
    e1.fourbengali = 2538;
    e1.fourcircle = 9315;
    e1.fourcircleinversesansserif = 10125;
    e1.fourdeva = 2410;
    e1.fourgujarati = 2794;
    e1.fourgurmukhi = 2666;
    e1.fourhackarabic = 1636;
    e1.fourhangzhou = 12324;
    e1.fourideographicparen = 12835;
    e1.fourinferior = 8324;
    e1.fourmonospace = 65300;
    e1.fournumeratorbengali = 2551;
    e1.fouroldstyle = 63284;
    e1.fourparen = 9335;
    e1.fourperiod = 9355;
    e1.fourpersian = 1780;
    e1.fourroman = 8563;
    e1.foursuperior = 8308;
    e1.fourteencircle = 9325;
    e1.fourteenparen = 9345;
    e1.fourteenperiod = 9365;
    e1.fourthai = 3668;
    e1.fourthtonechinese = 715;
    e1.fparen = 9377;
    e1.fraction = 8260;
    e1.franc = 8355;
    e1.g = 103;
    e1.gabengali = 2455;
    e1.gacute = 501;
    e1.gadeva = 2327;
    e1.gafarabic = 1711;
    e1.gaffinalarabic = 64403;
    e1.gafinitialarabic = 64404;
    e1.gafmedialarabic = 64405;
    e1.gagujarati = 2711;
    e1.gagurmukhi = 2583;
    e1.gahiragana = 12364;
    e1.gakatakana = 12460;
    e1.gamma = 947;
    e1.gammalatinsmall = 611;
    e1.gammasuperior = 736;
    e1.gangiacoptic = 1003;
    e1.gbopomofo = 12557;
    e1.gbreve = 287;
    e1.gcaron = 487;
    e1.gcedilla = 291;
    e1.gcircle = 9430;
    e1.gcircumflex = 285;
    e1.gcommaaccent = 291;
    e1.gdot = 289;
    e1.gdotaccent = 289;
    e1.gecyrillic = 1075;
    e1.gehiragana = 12370;
    e1.gekatakana = 12466;
    e1.geometricallyequal = 8785;
    e1.gereshaccenthebrew = 1436;
    e1.gereshhebrew = 1523;
    e1.gereshmuqdamhebrew = 1437;
    e1.germandbls = 223;
    e1.gershayimaccenthebrew = 1438;
    e1.gershayimhebrew = 1524;
    e1.getamark = 12307;
    e1.ghabengali = 2456;
    e1.ghadarmenian = 1394;
    e1.ghadeva = 2328;
    e1.ghagujarati = 2712;
    e1.ghagurmukhi = 2584;
    e1.ghainarabic = 1594;
    e1.ghainfinalarabic = 65230;
    e1.ghaininitialarabic = 65231;
    e1.ghainmedialarabic = 65232;
    e1.ghemiddlehookcyrillic = 1173;
    e1.ghestrokecyrillic = 1171;
    e1.gheupturncyrillic = 1169;
    e1.ghhadeva = 2394;
    e1.ghhagurmukhi = 2650;
    e1.ghook = 608;
    e1.ghzsquare = 13203;
    e1.gihiragana = 12366;
    e1.gikatakana = 12462;
    e1.gimarmenian = 1379;
    e1.gimel = 1490;
    e1.gimeldagesh = 64306;
    e1.gimeldageshhebrew = 64306;
    e1.gimelhebrew = 1490;
    e1.gjecyrillic = 1107;
    e1.glottalinvertedstroke = 446;
    e1.glottalstop = 660;
    e1.glottalstopinverted = 662;
    e1.glottalstopmod = 704;
    e1.glottalstopreversed = 661;
    e1.glottalstopreversedmod = 705;
    e1.glottalstopreversedsuperior = 740;
    e1.glottalstopstroke = 673;
    e1.glottalstopstrokereversed = 674;
    e1.gmacron = 7713;
    e1.gmonospace = 65351;
    e1.gohiragana = 12372;
    e1.gokatakana = 12468;
    e1.gparen = 9378;
    e1.gpasquare = 13228;
    e1.gradient = 8711;
    e1.grave = 96;
    e1.gravebelowcmb = 790;
    e1.gravecmb = 768;
    e1.gravecomb = 768;
    e1.gravedeva = 2387;
    e1.gravelowmod = 718;
    e1.gravemonospace = 65344;
    e1.gravetonecmb = 832;
    e1.greater = 62;
    e1.greaterequal = 8805;
    e1.greaterequalorless = 8923;
    e1.greatermonospace = 65310;
    e1.greaterorequivalent = 8819;
    e1.greaterorless = 8823;
    e1.greateroverequal = 8807;
    e1.greatersmall = 65125;
    e1.gscript = 609;
    e1.gstroke = 485;
    e1.guhiragana = 12368;
    e1.guillemotleft = 171;
    e1.guillemotright = 187;
    e1.guilsinglleft = 8249;
    e1.guilsinglright = 8250;
    e1.gukatakana = 12464;
    e1.guramusquare = 13080;
    e1.gysquare = 13257;
    e1.h = 104;
    e1.haabkhasiancyrillic = 1193;
    e1.haaltonearabic = 1729;
    e1.habengali = 2489;
    e1.hadescendercyrillic = 1203;
    e1.hadeva = 2361;
    e1.hagujarati = 2745;
    e1.hagurmukhi = 2617;
    e1.haharabic = 1581;
    e1.hahfinalarabic = 65186;
    e1.hahinitialarabic = 65187;
    e1.hahiragana = 12399;
    e1.hahmedialarabic = 65188;
    e1.haitusquare = 13098;
    e1.hakatakana = 12495;
    e1.hakatakanahalfwidth = 65418;
    e1.halantgurmukhi = 2637;
    e1.hamzaarabic = 1569;
    e1.hamzalowarabic = 1569;
    e1.hangulfiller = 12644;
    e1.hardsigncyrillic = 1098;
    e1.harpoonleftbarbup = 8636;
    e1.harpoonrightbarbup = 8640;
    e1.hasquare = 13258;
    e1.hatafpatah = 1458;
    e1.hatafpatah16 = 1458;
    e1.hatafpatah23 = 1458;
    e1.hatafpatah2f = 1458;
    e1.hatafpatahhebrew = 1458;
    e1.hatafpatahnarrowhebrew = 1458;
    e1.hatafpatahquarterhebrew = 1458;
    e1.hatafpatahwidehebrew = 1458;
    e1.hatafqamats = 1459;
    e1.hatafqamats1b = 1459;
    e1.hatafqamats28 = 1459;
    e1.hatafqamats34 = 1459;
    e1.hatafqamatshebrew = 1459;
    e1.hatafqamatsnarrowhebrew = 1459;
    e1.hatafqamatsquarterhebrew = 1459;
    e1.hatafqamatswidehebrew = 1459;
    e1.hatafsegol = 1457;
    e1.hatafsegol17 = 1457;
    e1.hatafsegol24 = 1457;
    e1.hatafsegol30 = 1457;
    e1.hatafsegolhebrew = 1457;
    e1.hatafsegolnarrowhebrew = 1457;
    e1.hatafsegolquarterhebrew = 1457;
    e1.hatafsegolwidehebrew = 1457;
    e1.hbar = 295;
    e1.hbopomofo = 12559;
    e1.hbrevebelow = 7723;
    e1.hcedilla = 7721;
    e1.hcircle = 9431;
    e1.hcircumflex = 293;
    e1.hdieresis = 7719;
    e1.hdotaccent = 7715;
    e1.hdotbelow = 7717;
    e1.he = 1492;
    e1.heart = 9829;
    e1.heartsuitblack = 9829;
    e1.heartsuitwhite = 9825;
    e1.hedagesh = 64308;
    e1.hedageshhebrew = 64308;
    e1.hehaltonearabic = 1729;
    e1.heharabic = 1607;
    e1.hehebrew = 1492;
    e1.hehfinalaltonearabic = 64423;
    e1.hehfinalalttwoarabic = 65258;
    e1.hehfinalarabic = 65258;
    e1.hehhamzaabovefinalarabic = 64421;
    e1.hehhamzaaboveisolatedarabic = 64420;
    e1.hehinitialaltonearabic = 64424;
    e1.hehinitialarabic = 65259;
    e1.hehiragana = 12408;
    e1.hehmedialaltonearabic = 64425;
    e1.hehmedialarabic = 65260;
    e1.heiseierasquare = 13179;
    e1.hekatakana = 12504;
    e1.hekatakanahalfwidth = 65421;
    e1.hekutaarusquare = 13110;
    e1.henghook = 615;
    e1.herutusquare = 13113;
    e1.het = 1495;
    e1.hethebrew = 1495;
    e1.hhook = 614;
    e1.hhooksuperior = 689;
    e1.hieuhacirclekorean = 12923;
    e1.hieuhaparenkorean = 12827;
    e1.hieuhcirclekorean = 12909;
    e1.hieuhkorean = 12622;
    e1.hieuhparenkorean = 12813;
    e1.hihiragana = 12402;
    e1.hikatakana = 12498;
    e1.hikatakanahalfwidth = 65419;
    e1.hiriq = 1460;
    e1.hiriq14 = 1460;
    e1.hiriq21 = 1460;
    e1.hiriq2d = 1460;
    e1.hiriqhebrew = 1460;
    e1.hiriqnarrowhebrew = 1460;
    e1.hiriqquarterhebrew = 1460;
    e1.hiriqwidehebrew = 1460;
    e1.hlinebelow = 7830;
    e1.hmonospace = 65352;
    e1.hoarmenian = 1392;
    e1.hohipthai = 3627;
    e1.hohiragana = 12411;
    e1.hokatakana = 12507;
    e1.hokatakanahalfwidth = 65422;
    e1.holam = 1465;
    e1.holam19 = 1465;
    e1.holam26 = 1465;
    e1.holam32 = 1465;
    e1.holamhebrew = 1465;
    e1.holamnarrowhebrew = 1465;
    e1.holamquarterhebrew = 1465;
    e1.holamwidehebrew = 1465;
    e1.honokhukthai = 3630;
    e1.hookabovecomb = 777;
    e1.hookcmb = 777;
    e1.hookpalatalizedbelowcmb = 801;
    e1.hookretroflexbelowcmb = 802;
    e1.hoonsquare = 13122;
    e1.horicoptic = 1001;
    e1.horizontalbar = 8213;
    e1.horncmb = 795;
    e1.hotsprings = 9832;
    e1.house = 8962;
    e1.hparen = 9379;
    e1.hsuperior = 688;
    e1.hturned = 613;
    e1.huhiragana = 12405;
    e1.huiitosquare = 13107;
    e1.hukatakana = 12501;
    e1.hukatakanahalfwidth = 65420;
    e1.hungarumlaut = 733;
    e1.hungarumlautcmb = 779;
    e1.hv = 405;
    e1.hyphen = 45;
    e1.hypheninferior = 63205;
    e1.hyphenmonospace = 65293;
    e1.hyphensmall = 65123;
    e1.hyphensuperior = 63206;
    e1.hyphentwo = 8208;
    e1.i = 105;
    e1.iacute = 237;
    e1.iacyrillic = 1103;
    e1.ibengali = 2439;
    e1.ibopomofo = 12583;
    e1.ibreve = 301;
    e1.icaron = 464;
    e1.icircle = 9432;
    e1.icircumflex = 238;
    e1.icyrillic = 1110;
    e1.idblgrave = 521;
    e1.ideographearthcircle = 12943;
    e1.ideographfirecircle = 12939;
    e1.ideographicallianceparen = 12863;
    e1.ideographiccallparen = 12858;
    e1.ideographiccentrecircle = 12965;
    e1.ideographicclose = 12294;
    e1.ideographiccomma = 12289;
    e1.ideographiccommaleft = 65380;
    e1.ideographiccongratulationparen = 12855;
    e1.ideographiccorrectcircle = 12963;
    e1.ideographicearthparen = 12847;
    e1.ideographicenterpriseparen = 12861;
    e1.ideographicexcellentcircle = 12957;
    e1.ideographicfestivalparen = 12864;
    e1.ideographicfinancialcircle = 12950;
    e1.ideographicfinancialparen = 12854;
    e1.ideographicfireparen = 12843;
    e1.ideographichaveparen = 12850;
    e1.ideographichighcircle = 12964;
    e1.ideographiciterationmark = 12293;
    e1.ideographiclaborcircle = 12952;
    e1.ideographiclaborparen = 12856;
    e1.ideographicleftcircle = 12967;
    e1.ideographiclowcircle = 12966;
    e1.ideographicmedicinecircle = 12969;
    e1.ideographicmetalparen = 12846;
    e1.ideographicmoonparen = 12842;
    e1.ideographicnameparen = 12852;
    e1.ideographicperiod = 12290;
    e1.ideographicprintcircle = 12958;
    e1.ideographicreachparen = 12867;
    e1.ideographicrepresentparen = 12857;
    e1.ideographicresourceparen = 12862;
    e1.ideographicrightcircle = 12968;
    e1.ideographicsecretcircle = 12953;
    e1.ideographicselfparen = 12866;
    e1.ideographicsocietyparen = 12851;
    e1.ideographicspace = 12288;
    e1.ideographicspecialparen = 12853;
    e1.ideographicstockparen = 12849;
    e1.ideographicstudyparen = 12859;
    e1.ideographicsunparen = 12848;
    e1.ideographicsuperviseparen = 12860;
    e1.ideographicwaterparen = 12844;
    e1.ideographicwoodparen = 12845;
    e1.ideographiczero = 12295;
    e1.ideographmetalcircle = 12942;
    e1.ideographmooncircle = 12938;
    e1.ideographnamecircle = 12948;
    e1.ideographsuncircle = 12944;
    e1.ideographwatercircle = 12940;
    e1.ideographwoodcircle = 12941;
    e1.ideva = 2311;
    e1.idieresis = 239;
    e1.idieresisacute = 7727;
    e1.idieresiscyrillic = 1253;
    e1.idotbelow = 7883;
    e1.iebrevecyrillic = 1239;
    e1.iecyrillic = 1077;
    e1.ieungacirclekorean = 12917;
    e1.ieungaparenkorean = 12821;
    e1.ieungcirclekorean = 12903;
    e1.ieungkorean = 12615;
    e1.ieungparenkorean = 12807;
    e1.igrave = 236;
    e1.igujarati = 2695;
    e1.igurmukhi = 2567;
    e1.ihiragana = 12356;
    e1.ihookabove = 7881;
    e1.iibengali = 2440;
    e1.iicyrillic = 1080;
    e1.iideva = 2312;
    e1.iigujarati = 2696;
    e1.iigurmukhi = 2568;
    e1.iimatragurmukhi = 2624;
    e1.iinvertedbreve = 523;
    e1.iishortcyrillic = 1081;
    e1.iivowelsignbengali = 2496;
    e1.iivowelsigndeva = 2368;
    e1.iivowelsigngujarati = 2752;
    e1.ij = 307;
    e1.ikatakana = 12452;
    e1.ikatakanahalfwidth = 65394;
    e1.ikorean = 12643;
    e1.ilde = 732;
    e1.iluyhebrew = 1452;
    e1.imacron = 299;
    e1.imacroncyrillic = 1251;
    e1.imageorapproximatelyequal = 8787;
    e1.imatragurmukhi = 2623;
    e1.imonospace = 65353;
    e1.increment = 8710;
    e1.infinity = 8734;
    e1.iniarmenian = 1387;
    e1.integral = 8747;
    e1.integralbottom = 8993;
    e1.integralbt = 8993;
    e1.integralex = 63733;
    e1.integraltop = 8992;
    e1.integraltp = 8992;
    e1.intersection = 8745;
    e1.intisquare = 13061;
    e1.invbullet = 9688;
    e1.invcircle = 9689;
    e1.invsmileface = 9787;
    e1.iocyrillic = 1105;
    e1.iogonek = 303;
    e1.iota = 953;
    e1.iotadieresis = 970;
    e1.iotadieresistonos = 912;
    e1.iotalatin = 617;
    e1.iotatonos = 943;
    e1.iparen = 9380;
    e1.irigurmukhi = 2674;
    e1.ismallhiragana = 12355;
    e1.ismallkatakana = 12451;
    e1.ismallkatakanahalfwidth = 65384;
    e1.issharbengali = 2554;
    e1.istroke = 616;
    e1.isuperior = 63213;
    e1.iterationhiragana = 12445;
    e1.iterationkatakana = 12541;
    e1.itilde = 297;
    e1.itildebelow = 7725;
    e1.iubopomofo = 12585;
    e1.iucyrillic = 1102;
    e1.ivowelsignbengali = 2495;
    e1.ivowelsigndeva = 2367;
    e1.ivowelsigngujarati = 2751;
    e1.izhitsacyrillic = 1141;
    e1.izhitsadblgravecyrillic = 1143;
    e1.j = 106;
    e1.jaarmenian = 1393;
    e1.jabengali = 2460;
    e1.jadeva = 2332;
    e1.jagujarati = 2716;
    e1.jagurmukhi = 2588;
    e1.jbopomofo = 12560;
    e1.jcaron = 496;
    e1.jcircle = 9433;
    e1.jcircumflex = 309;
    e1.jcrossedtail = 669;
    e1.jdotlessstroke = 607;
    e1.jecyrillic = 1112;
    e1.jeemarabic = 1580;
    e1.jeemfinalarabic = 65182;
    e1.jeeminitialarabic = 65183;
    e1.jeemmedialarabic = 65184;
    e1.jeharabic = 1688;
    e1.jehfinalarabic = 64395;
    e1.jhabengali = 2461;
    e1.jhadeva = 2333;
    e1.jhagujarati = 2717;
    e1.jhagurmukhi = 2589;
    e1.jheharmenian = 1403;
    e1.jis = 12292;
    e1.jmonospace = 65354;
    e1.jparen = 9381;
    e1.jsuperior = 690;
    e1.k = 107;
    e1.kabashkircyrillic = 1185;
    e1.kabengali = 2453;
    e1.kacute = 7729;
    e1.kacyrillic = 1082;
    e1.kadescendercyrillic = 1179;
    e1.kadeva = 2325;
    e1.kaf = 1499;
    e1.kafarabic = 1603;
    e1.kafdagesh = 64315;
    e1.kafdageshhebrew = 64315;
    e1.kaffinalarabic = 65242;
    e1.kafhebrew = 1499;
    e1.kafinitialarabic = 65243;
    e1.kafmedialarabic = 65244;
    e1.kafrafehebrew = 64333;
    e1.kagujarati = 2709;
    e1.kagurmukhi = 2581;
    e1.kahiragana = 12363;
    e1.kahookcyrillic = 1220;
    e1.kakatakana = 12459;
    e1.kakatakanahalfwidth = 65398;
    e1.kappa = 954;
    e1.kappasymbolgreek = 1008;
    e1.kapyeounmieumkorean = 12657;
    e1.kapyeounphieuphkorean = 12676;
    e1.kapyeounpieupkorean = 12664;
    e1.kapyeounssangpieupkorean = 12665;
    e1.karoriisquare = 13069;
    e1.kashidaautoarabic = 1600;
    e1.kashidaautonosidebearingarabic = 1600;
    e1.kasmallkatakana = 12533;
    e1.kasquare = 13188;
    e1.kasraarabic = 1616;
    e1.kasratanarabic = 1613;
    e1.kastrokecyrillic = 1183;
    e1.katahiraprolongmarkhalfwidth = 65392;
    e1.kaverticalstrokecyrillic = 1181;
    e1.kbopomofo = 12558;
    e1.kcalsquare = 13193;
    e1.kcaron = 489;
    e1.kcedilla = 311;
    e1.kcircle = 9434;
    e1.kcommaaccent = 311;
    e1.kdotbelow = 7731;
    e1.keharmenian = 1412;
    e1.kehiragana = 12369;
    e1.kekatakana = 12465;
    e1.kekatakanahalfwidth = 65401;
    e1.kenarmenian = 1391;
    e1.kesmallkatakana = 12534;
    e1.kgreenlandic = 312;
    e1.khabengali = 2454;
    e1.khacyrillic = 1093;
    e1.khadeva = 2326;
    e1.khagujarati = 2710;
    e1.khagurmukhi = 2582;
    e1.khaharabic = 1582;
    e1.khahfinalarabic = 65190;
    e1.khahinitialarabic = 65191;
    e1.khahmedialarabic = 65192;
    e1.kheicoptic = 999;
    e1.khhadeva = 2393;
    e1.khhagurmukhi = 2649;
    e1.khieukhacirclekorean = 12920;
    e1.khieukhaparenkorean = 12824;
    e1.khieukhcirclekorean = 12906;
    e1.khieukhkorean = 12619;
    e1.khieukhparenkorean = 12810;
    e1.khokhaithai = 3586;
    e1.khokhonthai = 3589;
    e1.khokhuatthai = 3587;
    e1.khokhwaithai = 3588;
    e1.khomutthai = 3675;
    e1.khook = 409;
    e1.khorakhangthai = 3590;
    e1.khzsquare = 13201;
    e1.kihiragana = 12365;
    e1.kikatakana = 12461;
    e1.kikatakanahalfwidth = 65399;
    e1.kiroguramusquare = 13077;
    e1.kiromeetorusquare = 13078;
    e1.kirosquare = 13076;
    e1.kiyeokacirclekorean = 12910;
    e1.kiyeokaparenkorean = 12814;
    e1.kiyeokcirclekorean = 12896;
    e1.kiyeokkorean = 12593;
    e1.kiyeokparenkorean = 12800;
    e1.kiyeoksioskorean = 12595;
    e1.kjecyrillic = 1116;
    e1.klinebelow = 7733;
    e1.klsquare = 13208;
    e1.kmcubedsquare = 13222;
    e1.kmonospace = 65355;
    e1.kmsquaredsquare = 13218;
    e1.kohiragana = 12371;
    e1.kohmsquare = 13248;
    e1.kokaithai = 3585;
    e1.kokatakana = 12467;
    e1.kokatakanahalfwidth = 65402;
    e1.kooposquare = 13086;
    e1.koppacyrillic = 1153;
    e1.koreanstandardsymbol = 12927;
    e1.koroniscmb = 835;
    e1.kparen = 9382;
    e1.kpasquare = 13226;
    e1.ksicyrillic = 1135;
    e1.ktsquare = 13263;
    e1.kturned = 670;
    e1.kuhiragana = 12367;
    e1.kukatakana = 12463;
    e1.kukatakanahalfwidth = 65400;
    e1.kvsquare = 13240;
    e1.kwsquare = 13246;
    e1.l = 108;
    e1.labengali = 2482;
    e1.lacute = 314;
    e1.ladeva = 2354;
    e1.lagujarati = 2738;
    e1.lagurmukhi = 2610;
    e1.lakkhangyaothai = 3653;
    e1.lamaleffinalarabic = 65276;
    e1.lamalefhamzaabovefinalarabic = 65272;
    e1.lamalefhamzaaboveisolatedarabic = 65271;
    e1.lamalefhamzabelowfinalarabic = 65274;
    e1.lamalefhamzabelowisolatedarabic = 65273;
    e1.lamalefisolatedarabic = 65275;
    e1.lamalefmaddaabovefinalarabic = 65270;
    e1.lamalefmaddaaboveisolatedarabic = 65269;
    e1.lamarabic = 1604;
    e1.lambda = 955;
    e1.lambdastroke = 411;
    e1.lamed = 1500;
    e1.lameddagesh = 64316;
    e1.lameddageshhebrew = 64316;
    e1.lamedhebrew = 1500;
    e1.lamfinalarabic = 65246;
    e1.lamhahinitialarabic = 64714;
    e1.laminitialarabic = 65247;
    e1.lamjeeminitialarabic = 64713;
    e1.lamkhahinitialarabic = 64715;
    e1.lamlamhehisolatedarabic = 65010;
    e1.lammedialarabic = 65248;
    e1.lammeemhahinitialarabic = 64904;
    e1.lammeeminitialarabic = 64716;
    e1.largecircle = 9711;
    e1.lbar = 410;
    e1.lbelt = 620;
    e1.lbopomofo = 12556;
    e1.lcaron = 318;
    e1.lcedilla = 316;
    e1.lcircle = 9435;
    e1.lcircumflexbelow = 7741;
    e1.lcommaaccent = 316;
    e1.ldot = 320;
    e1.ldotaccent = 320;
    e1.ldotbelow = 7735;
    e1.ldotbelowmacron = 7737;
    e1.leftangleabovecmb = 794;
    e1.lefttackbelowcmb = 792;
    e1.less = 60;
    e1.lessequal = 8804;
    e1.lessequalorgreater = 8922;
    e1.lessmonospace = 65308;
    e1.lessorequivalent = 8818;
    e1.lessorgreater = 8822;
    e1.lessoverequal = 8806;
    e1.lesssmall = 65124;
    e1.lezh = 622;
    e1.lfblock = 9612;
    e1.lhookretroflex = 621;
    e1.lira = 8356;
    e1.liwnarmenian = 1388;
    e1.lj = 457;
    e1.ljecyrillic = 1113;
    e1.ll = 63168;
    e1.lladeva = 2355;
    e1.llagujarati = 2739;
    e1.llinebelow = 7739;
    e1.llladeva = 2356;
    e1.llvocalicbengali = 2529;
    e1.llvocalicdeva = 2401;
    e1.llvocalicvowelsignbengali = 2531;
    e1.llvocalicvowelsigndeva = 2403;
    e1.lmiddletilde = 619;
    e1.lmonospace = 65356;
    e1.lmsquare = 13264;
    e1.lochulathai = 3628;
    e1.logicaland = 8743;
    e1.logicalnot = 172;
    e1.logicalnotreversed = 8976;
    e1.logicalor = 8744;
    e1.lolingthai = 3621;
    e1.longs = 383;
    e1.lowlinecenterline = 65102;
    e1.lowlinecmb = 818;
    e1.lowlinedashed = 65101;
    e1.lozenge = 9674;
    e1.lparen = 9383;
    e1.lslash = 322;
    e1.lsquare = 8467;
    e1.lsuperior = 63214;
    e1.ltshade = 9617;
    e1.luthai = 3622;
    e1.lvocalicbengali = 2444;
    e1.lvocalicdeva = 2316;
    e1.lvocalicvowelsignbengali = 2530;
    e1.lvocalicvowelsigndeva = 2402;
    e1.lxsquare = 13267;
    e1.m = 109;
    e1.mabengali = 2478;
    e1.macron = 175;
    e1.macronbelowcmb = 817;
    e1.macroncmb = 772;
    e1.macronlowmod = 717;
    e1.macronmonospace = 65507;
    e1.macute = 7743;
    e1.madeva = 2350;
    e1.magujarati = 2734;
    e1.magurmukhi = 2606;
    e1.mahapakhhebrew = 1444;
    e1.mahapakhlefthebrew = 1444;
    e1.mahiragana = 12414;
    e1.maichattawalowleftthai = 63637;
    e1.maichattawalowrightthai = 63636;
    e1.maichattawathai = 3659;
    e1.maichattawaupperleftthai = 63635;
    e1.maieklowleftthai = 63628;
    e1.maieklowrightthai = 63627;
    e1.maiekthai = 3656;
    e1.maiekupperleftthai = 63626;
    e1.maihanakatleftthai = 63620;
    e1.maihanakatthai = 3633;
    e1.maitaikhuleftthai = 63625;
    e1.maitaikhuthai = 3655;
    e1.maitholowleftthai = 63631;
    e1.maitholowrightthai = 63630;
    e1.maithothai = 3657;
    e1.maithoupperleftthai = 63629;
    e1.maitrilowleftthai = 63634;
    e1.maitrilowrightthai = 63633;
    e1.maitrithai = 3658;
    e1.maitriupperleftthai = 63632;
    e1.maiyamokthai = 3654;
    e1.makatakana = 12510;
    e1.makatakanahalfwidth = 65423;
    e1.male = 9794;
    e1.mansyonsquare = 13127;
    e1.maqafhebrew = 1470;
    e1.mars = 9794;
    e1.masoracirclehebrew = 1455;
    e1.masquare = 13187;
    e1.mbopomofo = 12551;
    e1.mbsquare = 13268;
    e1.mcircle = 9436;
    e1.mcubedsquare = 13221;
    e1.mdotaccent = 7745;
    e1.mdotbelow = 7747;
    e1.meemarabic = 1605;
    e1.meemfinalarabic = 65250;
    e1.meeminitialarabic = 65251;
    e1.meemmedialarabic = 65252;
    e1.meemmeeminitialarabic = 64721;
    e1.meemmeemisolatedarabic = 64584;
    e1.meetorusquare = 13133;
    e1.mehiragana = 12417;
    e1.meizierasquare = 13182;
    e1.mekatakana = 12513;
    e1.mekatakanahalfwidth = 65426;
    e1.mem = 1502;
    e1.memdagesh = 64318;
    e1.memdageshhebrew = 64318;
    e1.memhebrew = 1502;
    e1.menarmenian = 1396;
    e1.merkhahebrew = 1445;
    e1.merkhakefulahebrew = 1446;
    e1.merkhakefulalefthebrew = 1446;
    e1.merkhalefthebrew = 1445;
    e1.mhook = 625;
    e1.mhzsquare = 13202;
    e1.middledotkatakanahalfwidth = 65381;
    e1.middot = 183;
    e1.mieumacirclekorean = 12914;
    e1.mieumaparenkorean = 12818;
    e1.mieumcirclekorean = 12900;
    e1.mieumkorean = 12609;
    e1.mieumpansioskorean = 12656;
    e1.mieumparenkorean = 12804;
    e1.mieumpieupkorean = 12654;
    e1.mieumsioskorean = 12655;
    e1.mihiragana = 12415;
    e1.mikatakana = 12511;
    e1.mikatakanahalfwidth = 65424;
    e1.minus = 8722;
    e1.minusbelowcmb = 800;
    e1.minuscircle = 8854;
    e1.minusmod = 727;
    e1.minusplus = 8723;
    e1.minute = 8242;
    e1.miribaarusquare = 13130;
    e1.mirisquare = 13129;
    e1.mlonglegturned = 624;
    e1.mlsquare = 13206;
    e1.mmcubedsquare = 13219;
    e1.mmonospace = 65357;
    e1.mmsquaredsquare = 13215;
    e1.mohiragana = 12418;
    e1.mohmsquare = 13249;
    e1.mokatakana = 12514;
    e1.mokatakanahalfwidth = 65427;
    e1.molsquare = 13270;
    e1.momathai = 3617;
    e1.moverssquare = 13223;
    e1.moverssquaredsquare = 13224;
    e1.mparen = 9384;
    e1.mpasquare = 13227;
    e1.mssquare = 13235;
    e1.msuperior = 63215;
    e1.mturned = 623;
    e1.mu = 181;
    e1.mu1 = 181;
    e1.muasquare = 13186;
    e1.muchgreater = 8811;
    e1.muchless = 8810;
    e1.mufsquare = 13196;
    e1.mugreek = 956;
    e1.mugsquare = 13197;
    e1.muhiragana = 12416;
    e1.mukatakana = 12512;
    e1.mukatakanahalfwidth = 65425;
    e1.mulsquare = 13205;
    e1.multiply = 215;
    e1.mumsquare = 13211;
    e1.munahhebrew = 1443;
    e1.munahlefthebrew = 1443;
    e1.musicalnote = 9834;
    e1.musicalnotedbl = 9835;
    e1.musicflatsign = 9837;
    e1.musicsharpsign = 9839;
    e1.mussquare = 13234;
    e1.muvsquare = 13238;
    e1.muwsquare = 13244;
    e1.mvmegasquare = 13241;
    e1.mvsquare = 13239;
    e1.mwmegasquare = 13247;
    e1.mwsquare = 13245;
    e1.n = 110;
    e1.nabengali = 2472;
    e1.nabla = 8711;
    e1.nacute = 324;
    e1.nadeva = 2344;
    e1.nagujarati = 2728;
    e1.nagurmukhi = 2600;
    e1.nahiragana = 12394;
    e1.nakatakana = 12490;
    e1.nakatakanahalfwidth = 65413;
    e1.napostrophe = 329;
    e1.nasquare = 13185;
    e1.nbopomofo = 12555;
    e1.nbspace = 160;
    e1.ncaron = 328;
    e1.ncedilla = 326;
    e1.ncircle = 9437;
    e1.ncircumflexbelow = 7755;
    e1.ncommaaccent = 326;
    e1.ndotaccent = 7749;
    e1.ndotbelow = 7751;
    e1.nehiragana = 12397;
    e1.nekatakana = 12493;
    e1.nekatakanahalfwidth = 65416;
    e1.newsheqelsign = 8362;
    e1.nfsquare = 13195;
    e1.ngabengali = 2457;
    e1.ngadeva = 2329;
    e1.ngagujarati = 2713;
    e1.ngagurmukhi = 2585;
    e1.ngonguthai = 3591;
    e1.nhiragana = 12435;
    e1.nhookleft = 626;
    e1.nhookretroflex = 627;
    e1.nieunacirclekorean = 12911;
    e1.nieunaparenkorean = 12815;
    e1.nieuncieuckorean = 12597;
    e1.nieuncirclekorean = 12897;
    e1.nieunhieuhkorean = 12598;
    e1.nieunkorean = 12596;
    e1.nieunpansioskorean = 12648;
    e1.nieunparenkorean = 12801;
    e1.nieunsioskorean = 12647;
    e1.nieuntikeutkorean = 12646;
    e1.nihiragana = 12395;
    e1.nikatakana = 12491;
    e1.nikatakanahalfwidth = 65414;
    e1.nikhahitleftthai = 63641;
    e1.nikhahitthai = 3661;
    e1.nine = 57;
    e1.ninearabic = 1641;
    e1.ninebengali = 2543;
    e1.ninecircle = 9320;
    e1.ninecircleinversesansserif = 10130;
    e1.ninedeva = 2415;
    e1.ninegujarati = 2799;
    e1.ninegurmukhi = 2671;
    e1.ninehackarabic = 1641;
    e1.ninehangzhou = 12329;
    e1.nineideographicparen = 12840;
    e1.nineinferior = 8329;
    e1.ninemonospace = 65305;
    e1.nineoldstyle = 63289;
    e1.nineparen = 9340;
    e1.nineperiod = 9360;
    e1.ninepersian = 1785;
    e1.nineroman = 8568;
    e1.ninesuperior = 8313;
    e1.nineteencircle = 9330;
    e1.nineteenparen = 9350;
    e1.nineteenperiod = 9370;
    e1.ninethai = 3673;
    e1.nj = 460;
    e1.njecyrillic = 1114;
    e1.nkatakana = 12531;
    e1.nkatakanahalfwidth = 65437;
    e1.nlegrightlong = 414;
    e1.nlinebelow = 7753;
    e1.nmonospace = 65358;
    e1.nmsquare = 13210;
    e1.nnabengali = 2467;
    e1.nnadeva = 2339;
    e1.nnagujarati = 2723;
    e1.nnagurmukhi = 2595;
    e1.nnnadeva = 2345;
    e1.nohiragana = 12398;
    e1.nokatakana = 12494;
    e1.nokatakanahalfwidth = 65417;
    e1.nonbreakingspace = 160;
    e1.nonenthai = 3603;
    e1.nonuthai = 3609;
    e1.noonarabic = 1606;
    e1.noonfinalarabic = 65254;
    e1.noonghunnaarabic = 1722;
    e1.noonghunnafinalarabic = 64415;
    e1.nooninitialarabic = 65255;
    e1.noonjeeminitialarabic = 64722;
    e1.noonjeemisolatedarabic = 64587;
    e1.noonmedialarabic = 65256;
    e1.noonmeeminitialarabic = 64725;
    e1.noonmeemisolatedarabic = 64590;
    e1.noonnoonfinalarabic = 64653;
    e1.notcontains = 8716;
    e1.notelement = 8713;
    e1.notelementof = 8713;
    e1.notequal = 8800;
    e1.notgreater = 8815;
    e1.notgreaternorequal = 8817;
    e1.notgreaternorless = 8825;
    e1.notidentical = 8802;
    e1.notless = 8814;
    e1.notlessnorequal = 8816;
    e1.notparallel = 8742;
    e1.notprecedes = 8832;
    e1.notsubset = 8836;
    e1.notsucceeds = 8833;
    e1.notsuperset = 8837;
    e1.nowarmenian = 1398;
    e1.nparen = 9385;
    e1.nssquare = 13233;
    e1.nsuperior = 8319;
    e1.ntilde = 241;
    e1.nu = 957;
    e1.nuhiragana = 12396;
    e1.nukatakana = 12492;
    e1.nukatakanahalfwidth = 65415;
    e1.nuktabengali = 2492;
    e1.nuktadeva = 2364;
    e1.nuktagujarati = 2748;
    e1.nuktagurmukhi = 2620;
    e1.numbersign = 35;
    e1.numbersignmonospace = 65283;
    e1.numbersignsmall = 65119;
    e1.numeralsigngreek = 884;
    e1.numeralsignlowergreek = 885;
    e1.numero = 8470;
    e1.nun = 1504;
    e1.nundagesh = 64320;
    e1.nundageshhebrew = 64320;
    e1.nunhebrew = 1504;
    e1.nvsquare = 13237;
    e1.nwsquare = 13243;
    e1.nyabengali = 2462;
    e1.nyadeva = 2334;
    e1.nyagujarati = 2718;
    e1.nyagurmukhi = 2590;
    e1.o = 111;
    e1.oacute = 243;
    e1.oangthai = 3629;
    e1.obarred = 629;
    e1.obarredcyrillic = 1257;
    e1.obarreddieresiscyrillic = 1259;
    e1.obengali = 2451;
    e1.obopomofo = 12571;
    e1.obreve = 335;
    e1.ocandradeva = 2321;
    e1.ocandragujarati = 2705;
    e1.ocandravowelsigndeva = 2377;
    e1.ocandravowelsigngujarati = 2761;
    e1.ocaron = 466;
    e1.ocircle = 9438;
    e1.ocircumflex = 244;
    e1.ocircumflexacute = 7889;
    e1.ocircumflexdotbelow = 7897;
    e1.ocircumflexgrave = 7891;
    e1.ocircumflexhookabove = 7893;
    e1.ocircumflextilde = 7895;
    e1.ocyrillic = 1086;
    e1.odblacute = 337;
    e1.odblgrave = 525;
    e1.odeva = 2323;
    e1.odieresis = 246;
    e1.odieresiscyrillic = 1255;
    e1.odotbelow = 7885;
    e1.oe = 339;
    e1.oekorean = 12634;
    e1.ogonek = 731;
    e1.ogonekcmb = 808;
    e1.ograve = 242;
    e1.ogujarati = 2707;
    e1.oharmenian = 1413;
    e1.ohiragana = 12362;
    e1.ohookabove = 7887;
    e1.ohorn = 417;
    e1.ohornacute = 7899;
    e1.ohorndotbelow = 7907;
    e1.ohorngrave = 7901;
    e1.ohornhookabove = 7903;
    e1.ohorntilde = 7905;
    e1.ohungarumlaut = 337;
    e1.oi = 419;
    e1.oinvertedbreve = 527;
    e1.okatakana = 12458;
    e1.okatakanahalfwidth = 65397;
    e1.okorean = 12631;
    e1.olehebrew = 1451;
    e1.omacron = 333;
    e1.omacronacute = 7763;
    e1.omacrongrave = 7761;
    e1.omdeva = 2384;
    e1.omega = 969;
    e1.omega1 = 982;
    e1.omegacyrillic = 1121;
    e1.omegalatinclosed = 631;
    e1.omegaroundcyrillic = 1147;
    e1.omegatitlocyrillic = 1149;
    e1.omegatonos = 974;
    e1.omgujarati = 2768;
    e1.omicron = 959;
    e1.omicrontonos = 972;
    e1.omonospace = 65359;
    e1.one = 49;
    e1.onearabic = 1633;
    e1.onebengali = 2535;
    e1.onecircle = 9312;
    e1.onecircleinversesansserif = 10122;
    e1.onedeva = 2407;
    e1.onedotenleader = 8228;
    e1.oneeighth = 8539;
    e1.onefitted = 63196;
    e1.onegujarati = 2791;
    e1.onegurmukhi = 2663;
    e1.onehackarabic = 1633;
    e1.onehalf = 189;
    e1.onehangzhou = 12321;
    e1.oneideographicparen = 12832;
    e1.oneinferior = 8321;
    e1.onemonospace = 65297;
    e1.onenumeratorbengali = 2548;
    e1.oneoldstyle = 63281;
    e1.oneparen = 9332;
    e1.oneperiod = 9352;
    e1.onepersian = 1777;
    e1.onequarter = 188;
    e1.oneroman = 8560;
    e1.onesuperior = 185;
    e1.onethai = 3665;
    e1.onethird = 8531;
    e1.oogonek = 491;
    e1.oogonekmacron = 493;
    e1.oogurmukhi = 2579;
    e1.oomatragurmukhi = 2635;
    e1.oopen = 596;
    e1.oparen = 9386;
    e1.openbullet = 9702;
    e1.option = 8997;
    e1.ordfeminine = 170;
    e1.ordmasculine = 186;
    e1.orthogonal = 8735;
    e1.oshortdeva = 2322;
    e1.oshortvowelsigndeva = 2378;
    e1.oslash = 248;
    e1.oslashacute = 511;
    e1.osmallhiragana = 12361;
    e1.osmallkatakana = 12457;
    e1.osmallkatakanahalfwidth = 65387;
    e1.ostrokeacute = 511;
    e1.osuperior = 63216;
    e1.otcyrillic = 1151;
    e1.otilde = 245;
    e1.otildeacute = 7757;
    e1.otildedieresis = 7759;
    e1.oubopomofo = 12577;
    e1.overline = 8254;
    e1.overlinecenterline = 65098;
    e1.overlinecmb = 773;
    e1.overlinedashed = 65097;
    e1.overlinedblwavy = 65100;
    e1.overlinewavy = 65099;
    e1.overscore = 175;
    e1.ovowelsignbengali = 2507;
    e1.ovowelsigndeva = 2379;
    e1.ovowelsigngujarati = 2763;
    e1.p = 112;
    e1.paampssquare = 13184;
    e1.paasentosquare = 13099;
    e1.pabengali = 2474;
    e1.pacute = 7765;
    e1.padeva = 2346;
    e1.pagedown = 8671;
    e1.pageup = 8670;
    e1.pagujarati = 2730;
    e1.pagurmukhi = 2602;
    e1.pahiragana = 12401;
    e1.paiyannoithai = 3631;
    e1.pakatakana = 12497;
    e1.palatalizationcyrilliccmb = 1156;
    e1.palochkacyrillic = 1216;
    e1.pansioskorean = 12671;
    e1.paragraph = 182;
    e1.parallel = 8741;
    e1.parenleft = 40;
    e1.parenleftaltonearabic = 64830;
    e1.parenleftbt = 63725;
    e1.parenleftex = 63724;
    e1.parenleftinferior = 8333;
    e1.parenleftmonospace = 65288;
    e1.parenleftsmall = 65113;
    e1.parenleftsuperior = 8317;
    e1.parenlefttp = 63723;
    e1.parenleftvertical = 65077;
    e1.parenright = 41;
    e1.parenrightaltonearabic = 64831;
    e1.parenrightbt = 63736;
    e1.parenrightex = 63735;
    e1.parenrightinferior = 8334;
    e1.parenrightmonospace = 65289;
    e1.parenrightsmall = 65114;
    e1.parenrightsuperior = 8318;
    e1.parenrighttp = 63734;
    e1.parenrightvertical = 65078;
    e1.partialdiff = 8706;
    e1.paseqhebrew = 1472;
    e1.pashtahebrew = 1433;
    e1.pasquare = 13225;
    e1.patah = 1463;
    e1.patah11 = 1463;
    e1.patah1d = 1463;
    e1.patah2a = 1463;
    e1.patahhebrew = 1463;
    e1.patahnarrowhebrew = 1463;
    e1.patahquarterhebrew = 1463;
    e1.patahwidehebrew = 1463;
    e1.pazerhebrew = 1441;
    e1.pbopomofo = 12550;
    e1.pcircle = 9439;
    e1.pdotaccent = 7767;
    e1.pe = 1508;
    e1.pecyrillic = 1087;
    e1.pedagesh = 64324;
    e1.pedageshhebrew = 64324;
    e1.peezisquare = 13115;
    e1.pefinaldageshhebrew = 64323;
    e1.peharabic = 1662;
    e1.peharmenian = 1402;
    e1.pehebrew = 1508;
    e1.pehfinalarabic = 64343;
    e1.pehinitialarabic = 64344;
    e1.pehiragana = 12410;
    e1.pehmedialarabic = 64345;
    e1.pekatakana = 12506;
    e1.pemiddlehookcyrillic = 1191;
    e1.perafehebrew = 64334;
    e1.percent = 37;
    e1.percentarabic = 1642;
    e1.percentmonospace = 65285;
    e1.percentsmall = 65130;
    e1.period = 46;
    e1.periodarmenian = 1417;
    e1.periodcentered = 183;
    e1.periodhalfwidth = 65377;
    e1.periodinferior = 63207;
    e1.periodmonospace = 65294;
    e1.periodsmall = 65106;
    e1.periodsuperior = 63208;
    e1.perispomenigreekcmb = 834;
    e1.perpendicular = 8869;
    e1.perthousand = 8240;
    e1.peseta = 8359;
    e1.pfsquare = 13194;
    e1.phabengali = 2475;
    e1.phadeva = 2347;
    e1.phagujarati = 2731;
    e1.phagurmukhi = 2603;
    e1.phi = 966;
    e1.phi1 = 981;
    e1.phieuphacirclekorean = 12922;
    e1.phieuphaparenkorean = 12826;
    e1.phieuphcirclekorean = 12908;
    e1.phieuphkorean = 12621;
    e1.phieuphparenkorean = 12812;
    e1.philatin = 632;
    e1.phinthuthai = 3642;
    e1.phisymbolgreek = 981;
    e1.phook = 421;
    e1.phophanthai = 3614;
    e1.phophungthai = 3612;
    e1.phosamphaothai = 3616;
    e1.pi = 960;
    e1.pieupacirclekorean = 12915;
    e1.pieupaparenkorean = 12819;
    e1.pieupcieuckorean = 12662;
    e1.pieupcirclekorean = 12901;
    e1.pieupkiyeokkorean = 12658;
    e1.pieupkorean = 12610;
    e1.pieupparenkorean = 12805;
    e1.pieupsioskiyeokkorean = 12660;
    e1.pieupsioskorean = 12612;
    e1.pieupsiostikeutkorean = 12661;
    e1.pieupthieuthkorean = 12663;
    e1.pieuptikeutkorean = 12659;
    e1.pihiragana = 12404;
    e1.pikatakana = 12500;
    e1.pisymbolgreek = 982;
    e1.piwrarmenian = 1411;
    e1.planckover2pi = 8463;
    e1.planckover2pi1 = 8463;
    e1.plus = 43;
    e1.plusbelowcmb = 799;
    e1.pluscircle = 8853;
    e1.plusminus = 177;
    e1.plusmod = 726;
    e1.plusmonospace = 65291;
    e1.plussmall = 65122;
    e1.plussuperior = 8314;
    e1.pmonospace = 65360;
    e1.pmsquare = 13272;
    e1.pohiragana = 12413;
    e1.pointingindexdownwhite = 9759;
    e1.pointingindexleftwhite = 9756;
    e1.pointingindexrightwhite = 9758;
    e1.pointingindexupwhite = 9757;
    e1.pokatakana = 12509;
    e1.poplathai = 3611;
    e1.postalmark = 12306;
    e1.postalmarkface = 12320;
    e1.pparen = 9387;
    e1.precedes = 8826;
    e1.prescription = 8478;
    e1.primemod = 697;
    e1.primereversed = 8245;
    e1.product = 8719;
    e1.projective = 8965;
    e1.prolongedkana = 12540;
    e1.propellor = 8984;
    e1.propersubset = 8834;
    e1.propersuperset = 8835;
    e1.proportion = 8759;
    e1.proportional = 8733;
    e1.psi = 968;
    e1.psicyrillic = 1137;
    e1.psilipneumatacyrilliccmb = 1158;
    e1.pssquare = 13232;
    e1.puhiragana = 12407;
    e1.pukatakana = 12503;
    e1.pvsquare = 13236;
    e1.pwsquare = 13242;
    e1.q = 113;
    e1.qadeva = 2392;
    e1.qadmahebrew = 1448;
    e1.qafarabic = 1602;
    e1.qaffinalarabic = 65238;
    e1.qafinitialarabic = 65239;
    e1.qafmedialarabic = 65240;
    e1.qamats = 1464;
    e1.qamats10 = 1464;
    e1.qamats1a = 1464;
    e1.qamats1c = 1464;
    e1.qamats27 = 1464;
    e1.qamats29 = 1464;
    e1.qamats33 = 1464;
    e1.qamatsde = 1464;
    e1.qamatshebrew = 1464;
    e1.qamatsnarrowhebrew = 1464;
    e1.qamatsqatanhebrew = 1464;
    e1.qamatsqatannarrowhebrew = 1464;
    e1.qamatsqatanquarterhebrew = 1464;
    e1.qamatsqatanwidehebrew = 1464;
    e1.qamatsquarterhebrew = 1464;
    e1.qamatswidehebrew = 1464;
    e1.qarneyparahebrew = 1439;
    e1.qbopomofo = 12561;
    e1.qcircle = 9440;
    e1.qhook = 672;
    e1.qmonospace = 65361;
    e1.qof = 1511;
    e1.qofdagesh = 64327;
    e1.qofdageshhebrew = 64327;
    e1.qofhebrew = 1511;
    e1.qparen = 9388;
    e1.quarternote = 9833;
    e1.qubuts = 1467;
    e1.qubuts18 = 1467;
    e1.qubuts25 = 1467;
    e1.qubuts31 = 1467;
    e1.qubutshebrew = 1467;
    e1.qubutsnarrowhebrew = 1467;
    e1.qubutsquarterhebrew = 1467;
    e1.qubutswidehebrew = 1467;
    e1.question = 63;
    e1.questionarabic = 1567;
    e1.questionarmenian = 1374;
    e1.questiondown = 191;
    e1.questiondownsmall = 63423;
    e1.questiongreek = 894;
    e1.questionmonospace = 65311;
    e1.questionsmall = 63295;
    e1.quotedbl = 34;
    e1.quotedblbase = 8222;
    e1.quotedblleft = 8220;
    e1.quotedblmonospace = 65282;
    e1.quotedblprime = 12318;
    e1.quotedblprimereversed = 12317;
    e1.quotedblright = 8221;
    e1.quoteleft = 8216;
    e1.quoteleftreversed = 8219;
    e1.quotereversed = 8219;
    e1.quoteright = 8217;
    e1.quoterightn = 329;
    e1.quotesinglbase = 8218;
    e1.quotesingle = 39;
    e1.quotesinglemonospace = 65287;
    e1.r = 114;
    e1.raarmenian = 1404;
    e1.rabengali = 2480;
    e1.racute = 341;
    e1.radeva = 2352;
    e1.radical = 8730;
    e1.radicalex = 63717;
    e1.radoverssquare = 13230;
    e1.radoverssquaredsquare = 13231;
    e1.radsquare = 13229;
    e1.rafe = 1471;
    e1.rafehebrew = 1471;
    e1.ragujarati = 2736;
    e1.ragurmukhi = 2608;
    e1.rahiragana = 12425;
    e1.rakatakana = 12521;
    e1.rakatakanahalfwidth = 65431;
    e1.ralowerdiagonalbengali = 2545;
    e1.ramiddlediagonalbengali = 2544;
    e1.ramshorn = 612;
    e1.ratio = 8758;
    e1.rbopomofo = 12566;
    e1.rcaron = 345;
    e1.rcedilla = 343;
    e1.rcircle = 9441;
    e1.rcommaaccent = 343;
    e1.rdblgrave = 529;
    e1.rdotaccent = 7769;
    e1.rdotbelow = 7771;
    e1.rdotbelowmacron = 7773;
    e1.referencemark = 8251;
    e1.reflexsubset = 8838;
    e1.reflexsuperset = 8839;
    e1.registered = 174;
    e1.registersans = 63720;
    e1.registerserif = 63194;
    e1.reharabic = 1585;
    e1.reharmenian = 1408;
    e1.rehfinalarabic = 65198;
    e1.rehiragana = 12428;
    e1.rekatakana = 12524;
    e1.rekatakanahalfwidth = 65434;
    e1.resh = 1512;
    e1.reshdageshhebrew = 64328;
    e1.reshhebrew = 1512;
    e1.reversedtilde = 8765;
    e1.reviahebrew = 1431;
    e1.reviamugrashhebrew = 1431;
    e1.revlogicalnot = 8976;
    e1.rfishhook = 638;
    e1.rfishhookreversed = 639;
    e1.rhabengali = 2525;
    e1.rhadeva = 2397;
    e1.rho = 961;
    e1.rhook = 637;
    e1.rhookturned = 635;
    e1.rhookturnedsuperior = 693;
    e1.rhosymbolgreek = 1009;
    e1.rhotichookmod = 734;
    e1.rieulacirclekorean = 12913;
    e1.rieulaparenkorean = 12817;
    e1.rieulcirclekorean = 12899;
    e1.rieulhieuhkorean = 12608;
    e1.rieulkiyeokkorean = 12602;
    e1.rieulkiyeoksioskorean = 12649;
    e1.rieulkorean = 12601;
    e1.rieulmieumkorean = 12603;
    e1.rieulpansioskorean = 12652;
    e1.rieulparenkorean = 12803;
    e1.rieulphieuphkorean = 12607;
    e1.rieulpieupkorean = 12604;
    e1.rieulpieupsioskorean = 12651;
    e1.rieulsioskorean = 12605;
    e1.rieulthieuthkorean = 12606;
    e1.rieultikeutkorean = 12650;
    e1.rieulyeorinhieuhkorean = 12653;
    e1.rightangle = 8735;
    e1.righttackbelowcmb = 793;
    e1.righttriangle = 8895;
    e1.rihiragana = 12426;
    e1.rikatakana = 12522;
    e1.rikatakanahalfwidth = 65432;
    e1.ring = 730;
    e1.ringbelowcmb = 805;
    e1.ringcmb = 778;
    e1.ringhalfleft = 703;
    e1.ringhalfleftarmenian = 1369;
    e1.ringhalfleftbelowcmb = 796;
    e1.ringhalfleftcentered = 723;
    e1.ringhalfright = 702;
    e1.ringhalfrightbelowcmb = 825;
    e1.ringhalfrightcentered = 722;
    e1.rinvertedbreve = 531;
    e1.rittorusquare = 13137;
    e1.rlinebelow = 7775;
    e1.rlongleg = 636;
    e1.rlonglegturned = 634;
    e1.rmonospace = 65362;
    e1.rohiragana = 12429;
    e1.rokatakana = 12525;
    e1.rokatakanahalfwidth = 65435;
    e1.roruathai = 3619;
    e1.rparen = 9389;
    e1.rrabengali = 2524;
    e1.rradeva = 2353;
    e1.rragurmukhi = 2652;
    e1.rreharabic = 1681;
    e1.rrehfinalarabic = 64397;
    e1.rrvocalicbengali = 2528;
    e1.rrvocalicdeva = 2400;
    e1.rrvocalicgujarati = 2784;
    e1.rrvocalicvowelsignbengali = 2500;
    e1.rrvocalicvowelsigndeva = 2372;
    e1.rrvocalicvowelsigngujarati = 2756;
    e1.rsuperior = 63217;
    e1.rtblock = 9616;
    e1.rturned = 633;
    e1.rturnedsuperior = 692;
    e1.ruhiragana = 12427;
    e1.rukatakana = 12523;
    e1.rukatakanahalfwidth = 65433;
    e1.rupeemarkbengali = 2546;
    e1.rupeesignbengali = 2547;
    e1.rupiah = 63197;
    e1.ruthai = 3620;
    e1.rvocalicbengali = 2443;
    e1.rvocalicdeva = 2315;
    e1.rvocalicgujarati = 2699;
    e1.rvocalicvowelsignbengali = 2499;
    e1.rvocalicvowelsigndeva = 2371;
    e1.rvocalicvowelsigngujarati = 2755;
    e1.s = 115;
    e1.sabengali = 2488;
    e1.sacute = 347;
    e1.sacutedotaccent = 7781;
    e1.sadarabic = 1589;
    e1.sadeva = 2360;
    e1.sadfinalarabic = 65210;
    e1.sadinitialarabic = 65211;
    e1.sadmedialarabic = 65212;
    e1.sagujarati = 2744;
    e1.sagurmukhi = 2616;
    e1.sahiragana = 12373;
    e1.sakatakana = 12469;
    e1.sakatakanahalfwidth = 65403;
    e1.sallallahoualayhewasallamarabic = 65018;
    e1.samekh = 1505;
    e1.samekhdagesh = 64321;
    e1.samekhdageshhebrew = 64321;
    e1.samekhhebrew = 1505;
    e1.saraaathai = 3634;
    e1.saraaethai = 3649;
    e1.saraaimaimalaithai = 3652;
    e1.saraaimaimuanthai = 3651;
    e1.saraamthai = 3635;
    e1.saraathai = 3632;
    e1.saraethai = 3648;
    e1.saraiileftthai = 63622;
    e1.saraiithai = 3637;
    e1.saraileftthai = 63621;
    e1.saraithai = 3636;
    e1.saraothai = 3650;
    e1.saraueeleftthai = 63624;
    e1.saraueethai = 3639;
    e1.saraueleftthai = 63623;
    e1.sarauethai = 3638;
    e1.sarauthai = 3640;
    e1.sarauuthai = 3641;
    e1.sbopomofo = 12569;
    e1.scaron = 353;
    e1.scarondotaccent = 7783;
    e1.scedilla = 351;
    e1.schwa = 601;
    e1.schwacyrillic = 1241;
    e1.schwadieresiscyrillic = 1243;
    e1.schwahook = 602;
    e1.scircle = 9442;
    e1.scircumflex = 349;
    e1.scommaaccent = 537;
    e1.sdotaccent = 7777;
    e1.sdotbelow = 7779;
    e1.sdotbelowdotaccent = 7785;
    e1.seagullbelowcmb = 828;
    e1.second = 8243;
    e1.secondtonechinese = 714;
    e1.section = 167;
    e1.seenarabic = 1587;
    e1.seenfinalarabic = 65202;
    e1.seeninitialarabic = 65203;
    e1.seenmedialarabic = 65204;
    e1.segol = 1462;
    e1.segol13 = 1462;
    e1.segol1f = 1462;
    e1.segol2c = 1462;
    e1.segolhebrew = 1462;
    e1.segolnarrowhebrew = 1462;
    e1.segolquarterhebrew = 1462;
    e1.segoltahebrew = 1426;
    e1.segolwidehebrew = 1462;
    e1.seharmenian = 1405;
    e1.sehiragana = 12379;
    e1.sekatakana = 12475;
    e1.sekatakanahalfwidth = 65406;
    e1.semicolon = 59;
    e1.semicolonarabic = 1563;
    e1.semicolonmonospace = 65307;
    e1.semicolonsmall = 65108;
    e1.semivoicedmarkkana = 12444;
    e1.semivoicedmarkkanahalfwidth = 65439;
    e1.sentisquare = 13090;
    e1.sentosquare = 13091;
    e1.seven = 55;
    e1.sevenarabic = 1639;
    e1.sevenbengali = 2541;
    e1.sevencircle = 9318;
    e1.sevencircleinversesansserif = 10128;
    e1.sevendeva = 2413;
    e1.seveneighths = 8542;
    e1.sevengujarati = 2797;
    e1.sevengurmukhi = 2669;
    e1.sevenhackarabic = 1639;
    e1.sevenhangzhou = 12327;
    e1.sevenideographicparen = 12838;
    e1.seveninferior = 8327;
    e1.sevenmonospace = 65303;
    e1.sevenoldstyle = 63287;
    e1.sevenparen = 9338;
    e1.sevenperiod = 9358;
    e1.sevenpersian = 1783;
    e1.sevenroman = 8566;
    e1.sevensuperior = 8311;
    e1.seventeencircle = 9328;
    e1.seventeenparen = 9348;
    e1.seventeenperiod = 9368;
    e1.seventhai = 3671;
    e1.sfthyphen = 173;
    e1.shaarmenian = 1399;
    e1.shabengali = 2486;
    e1.shacyrillic = 1096;
    e1.shaddaarabic = 1617;
    e1.shaddadammaarabic = 64609;
    e1.shaddadammatanarabic = 64606;
    e1.shaddafathaarabic = 64608;
    e1.shaddakasraarabic = 64610;
    e1.shaddakasratanarabic = 64607;
    e1.shade = 9618;
    e1.shadedark = 9619;
    e1.shadelight = 9617;
    e1.shademedium = 9618;
    e1.shadeva = 2358;
    e1.shagujarati = 2742;
    e1.shagurmukhi = 2614;
    e1.shalshelethebrew = 1427;
    e1.shbopomofo = 12565;
    e1.shchacyrillic = 1097;
    e1.sheenarabic = 1588;
    e1.sheenfinalarabic = 65206;
    e1.sheeninitialarabic = 65207;
    e1.sheenmedialarabic = 65208;
    e1.sheicoptic = 995;
    e1.sheqel = 8362;
    e1.sheqelhebrew = 8362;
    e1.sheva = 1456;
    e1.sheva115 = 1456;
    e1.sheva15 = 1456;
    e1.sheva22 = 1456;
    e1.sheva2e = 1456;
    e1.shevahebrew = 1456;
    e1.shevanarrowhebrew = 1456;
    e1.shevaquarterhebrew = 1456;
    e1.shevawidehebrew = 1456;
    e1.shhacyrillic = 1211;
    e1.shimacoptic = 1005;
    e1.shin = 1513;
    e1.shindagesh = 64329;
    e1.shindageshhebrew = 64329;
    e1.shindageshshindot = 64300;
    e1.shindageshshindothebrew = 64300;
    e1.shindageshsindot = 64301;
    e1.shindageshsindothebrew = 64301;
    e1.shindothebrew = 1473;
    e1.shinhebrew = 1513;
    e1.shinshindot = 64298;
    e1.shinshindothebrew = 64298;
    e1.shinsindot = 64299;
    e1.shinsindothebrew = 64299;
    e1.shook = 642;
    e1.sigma = 963;
    e1.sigma1 = 962;
    e1.sigmafinal = 962;
    e1.sigmalunatesymbolgreek = 1010;
    e1.sihiragana = 12375;
    e1.sikatakana = 12471;
    e1.sikatakanahalfwidth = 65404;
    e1.siluqhebrew = 1469;
    e1.siluqlefthebrew = 1469;
    e1.similar = 8764;
    e1.sindothebrew = 1474;
    e1.siosacirclekorean = 12916;
    e1.siosaparenkorean = 12820;
    e1.sioscieuckorean = 12670;
    e1.sioscirclekorean = 12902;
    e1.sioskiyeokkorean = 12666;
    e1.sioskorean = 12613;
    e1.siosnieunkorean = 12667;
    e1.siosparenkorean = 12806;
    e1.siospieupkorean = 12669;
    e1.siostikeutkorean = 12668;
    e1.six = 54;
    e1.sixarabic = 1638;
    e1.sixbengali = 2540;
    e1.sixcircle = 9317;
    e1.sixcircleinversesansserif = 10127;
    e1.sixdeva = 2412;
    e1.sixgujarati = 2796;
    e1.sixgurmukhi = 2668;
    e1.sixhackarabic = 1638;
    e1.sixhangzhou = 12326;
    e1.sixideographicparen = 12837;
    e1.sixinferior = 8326;
    e1.sixmonospace = 65302;
    e1.sixoldstyle = 63286;
    e1.sixparen = 9337;
    e1.sixperiod = 9357;
    e1.sixpersian = 1782;
    e1.sixroman = 8565;
    e1.sixsuperior = 8310;
    e1.sixteencircle = 9327;
    e1.sixteencurrencydenominatorbengali = 2553;
    e1.sixteenparen = 9347;
    e1.sixteenperiod = 9367;
    e1.sixthai = 3670;
    e1.slash = 47;
    e1.slashmonospace = 65295;
    e1.slong = 383;
    e1.slongdotaccent = 7835;
    e1.smileface = 9786;
    e1.smonospace = 65363;
    e1.sofpasuqhebrew = 1475;
    e1.softhyphen = 173;
    e1.softsigncyrillic = 1100;
    e1.sohiragana = 12381;
    e1.sokatakana = 12477;
    e1.sokatakanahalfwidth = 65407;
    e1.soliduslongoverlaycmb = 824;
    e1.solidusshortoverlaycmb = 823;
    e1.sorusithai = 3625;
    e1.sosalathai = 3624;
    e1.sosothai = 3595;
    e1.sosuathai = 3626;
    e1.space = 32;
    e1.spacehackarabic = 32;
    e1.spade = 9824;
    e1.spadesuitblack = 9824;
    e1.spadesuitwhite = 9828;
    e1.sparen = 9390;
    e1.squarebelowcmb = 827;
    e1.squarecc = 13252;
    e1.squarecm = 13213;
    e1.squarediagonalcrosshatchfill = 9641;
    e1.squarehorizontalfill = 9636;
    e1.squarekg = 13199;
    e1.squarekm = 13214;
    e1.squarekmcapital = 13262;
    e1.squareln = 13265;
    e1.squarelog = 13266;
    e1.squaremg = 13198;
    e1.squaremil = 13269;
    e1.squaremm = 13212;
    e1.squaremsquared = 13217;
    e1.squareorthogonalcrosshatchfill = 9638;
    e1.squareupperlefttolowerrightfill = 9639;
    e1.squareupperrighttolowerleftfill = 9640;
    e1.squareverticalfill = 9637;
    e1.squarewhitewithsmallblack = 9635;
    e1.srsquare = 13275;
    e1.ssabengali = 2487;
    e1.ssadeva = 2359;
    e1.ssagujarati = 2743;
    e1.ssangcieuckorean = 12617;
    e1.ssanghieuhkorean = 12677;
    e1.ssangieungkorean = 12672;
    e1.ssangkiyeokkorean = 12594;
    e1.ssangnieunkorean = 12645;
    e1.ssangpieupkorean = 12611;
    e1.ssangsioskorean = 12614;
    e1.ssangtikeutkorean = 12600;
    e1.ssuperior = 63218;
    e1.sterling = 163;
    e1.sterlingmonospace = 65505;
    e1.strokelongoverlaycmb = 822;
    e1.strokeshortoverlaycmb = 821;
    e1.subset = 8834;
    e1.subsetnotequal = 8842;
    e1.subsetorequal = 8838;
    e1.succeeds = 8827;
    e1.suchthat = 8715;
    e1.suhiragana = 12377;
    e1.sukatakana = 12473;
    e1.sukatakanahalfwidth = 65405;
    e1.sukunarabic = 1618;
    e1.summation = 8721;
    e1.sun = 9788;
    e1.superset = 8835;
    e1.supersetnotequal = 8843;
    e1.supersetorequal = 8839;
    e1.svsquare = 13276;
    e1.syouwaerasquare = 13180;
    e1.t = 116;
    e1.tabengali = 2468;
    e1.tackdown = 8868;
    e1.tackleft = 8867;
    e1.tadeva = 2340;
    e1.tagujarati = 2724;
    e1.tagurmukhi = 2596;
    e1.taharabic = 1591;
    e1.tahfinalarabic = 65218;
    e1.tahinitialarabic = 65219;
    e1.tahiragana = 12383;
    e1.tahmedialarabic = 65220;
    e1.taisyouerasquare = 13181;
    e1.takatakana = 12479;
    e1.takatakanahalfwidth = 65408;
    e1.tatweelarabic = 1600;
    e1.tau = 964;
    e1.tav = 1514;
    e1.tavdages = 64330;
    e1.tavdagesh = 64330;
    e1.tavdageshhebrew = 64330;
    e1.tavhebrew = 1514;
    e1.tbar = 359;
    e1.tbopomofo = 12554;
    e1.tcaron = 357;
    e1.tccurl = 680;
    e1.tcedilla = 355;
    e1.tcheharabic = 1670;
    e1.tchehfinalarabic = 64379;
    e1.tchehinitialarabic = 64380;
    e1.tchehmedialarabic = 64381;
    e1.tcircle = 9443;
    e1.tcircumflexbelow = 7793;
    e1.tcommaaccent = 355;
    e1.tdieresis = 7831;
    e1.tdotaccent = 7787;
    e1.tdotbelow = 7789;
    e1.tecyrillic = 1090;
    e1.tedescendercyrillic = 1197;
    e1.teharabic = 1578;
    e1.tehfinalarabic = 65174;
    e1.tehhahinitialarabic = 64674;
    e1.tehhahisolatedarabic = 64524;
    e1.tehinitialarabic = 65175;
    e1.tehiragana = 12390;
    e1.tehjeeminitialarabic = 64673;
    e1.tehjeemisolatedarabic = 64523;
    e1.tehmarbutaarabic = 1577;
    e1.tehmarbutafinalarabic = 65172;
    e1.tehmedialarabic = 65176;
    e1.tehmeeminitialarabic = 64676;
    e1.tehmeemisolatedarabic = 64526;
    e1.tehnoonfinalarabic = 64627;
    e1.tekatakana = 12486;
    e1.tekatakanahalfwidth = 65411;
    e1.telephone = 8481;
    e1.telephoneblack = 9742;
    e1.telishagedolahebrew = 1440;
    e1.telishaqetanahebrew = 1449;
    e1.tencircle = 9321;
    e1.tenideographicparen = 12841;
    e1.tenparen = 9341;
    e1.tenperiod = 9361;
    e1.tenroman = 8569;
    e1.tesh = 679;
    e1.tet = 1496;
    e1.tetdagesh = 64312;
    e1.tetdageshhebrew = 64312;
    e1.tethebrew = 1496;
    e1.tetsecyrillic = 1205;
    e1.tevirhebrew = 1435;
    e1.tevirlefthebrew = 1435;
    e1.thabengali = 2469;
    e1.thadeva = 2341;
    e1.thagujarati = 2725;
    e1.thagurmukhi = 2597;
    e1.thalarabic = 1584;
    e1.thalfinalarabic = 65196;
    e1.thanthakhatlowleftthai = 63640;
    e1.thanthakhatlowrightthai = 63639;
    e1.thanthakhatthai = 3660;
    e1.thanthakhatupperleftthai = 63638;
    e1.theharabic = 1579;
    e1.thehfinalarabic = 65178;
    e1.thehinitialarabic = 65179;
    e1.thehmedialarabic = 65180;
    e1.thereexists = 8707;
    e1.therefore = 8756;
    e1.theta = 952;
    e1.theta1 = 977;
    e1.thetasymbolgreek = 977;
    e1.thieuthacirclekorean = 12921;
    e1.thieuthaparenkorean = 12825;
    e1.thieuthcirclekorean = 12907;
    e1.thieuthkorean = 12620;
    e1.thieuthparenkorean = 12811;
    e1.thirteencircle = 9324;
    e1.thirteenparen = 9344;
    e1.thirteenperiod = 9364;
    e1.thonangmonthothai = 3601;
    e1.thook = 429;
    e1.thophuthaothai = 3602;
    e1.thorn = 254;
    e1.thothahanthai = 3607;
    e1.thothanthai = 3600;
    e1.thothongthai = 3608;
    e1.thothungthai = 3606;
    e1.thousandcyrillic = 1154;
    e1.thousandsseparatorarabic = 1644;
    e1.thousandsseparatorpersian = 1644;
    e1.three = 51;
    e1.threearabic = 1635;
    e1.threebengali = 2537;
    e1.threecircle = 9314;
    e1.threecircleinversesansserif = 10124;
    e1.threedeva = 2409;
    e1.threeeighths = 8540;
    e1.threegujarati = 2793;
    e1.threegurmukhi = 2665;
    e1.threehackarabic = 1635;
    e1.threehangzhou = 12323;
    e1.threeideographicparen = 12834;
    e1.threeinferior = 8323;
    e1.threemonospace = 65299;
    e1.threenumeratorbengali = 2550;
    e1.threeoldstyle = 63283;
    e1.threeparen = 9334;
    e1.threeperiod = 9354;
    e1.threepersian = 1779;
    e1.threequarters = 190;
    e1.threequartersemdash = 63198;
    e1.threeroman = 8562;
    e1.threesuperior = 179;
    e1.threethai = 3667;
    e1.thzsquare = 13204;
    e1.tihiragana = 12385;
    e1.tikatakana = 12481;
    e1.tikatakanahalfwidth = 65409;
    e1.tikeutacirclekorean = 12912;
    e1.tikeutaparenkorean = 12816;
    e1.tikeutcirclekorean = 12898;
    e1.tikeutkorean = 12599;
    e1.tikeutparenkorean = 12802;
    e1.tilde = 732;
    e1.tildebelowcmb = 816;
    e1.tildecmb = 771;
    e1.tildecomb = 771;
    e1.tildedoublecmb = 864;
    e1.tildeoperator = 8764;
    e1.tildeoverlaycmb = 820;
    e1.tildeverticalcmb = 830;
    e1.timescircle = 8855;
    e1.tipehahebrew = 1430;
    e1.tipehalefthebrew = 1430;
    e1.tippigurmukhi = 2672;
    e1.titlocyrilliccmb = 1155;
    e1.tiwnarmenian = 1407;
    e1.tlinebelow = 7791;
    e1.tmonospace = 65364;
    e1.toarmenian = 1385;
    e1.tohiragana = 12392;
    e1.tokatakana = 12488;
    e1.tokatakanahalfwidth = 65412;
    e1.tonebarextrahighmod = 741;
    e1.tonebarextralowmod = 745;
    e1.tonebarhighmod = 742;
    e1.tonebarlowmod = 744;
    e1.tonebarmidmod = 743;
    e1.tonefive = 445;
    e1.tonesix = 389;
    e1.tonetwo = 424;
    e1.tonos = 900;
    e1.tonsquare = 13095;
    e1.topatakthai = 3599;
    e1.tortoiseshellbracketleft = 12308;
    e1.tortoiseshellbracketleftsmall = 65117;
    e1.tortoiseshellbracketleftvertical = 65081;
    e1.tortoiseshellbracketright = 12309;
    e1.tortoiseshellbracketrightsmall = 65118;
    e1.tortoiseshellbracketrightvertical = 65082;
    e1.totaothai = 3605;
    e1.tpalatalhook = 427;
    e1.tparen = 9391;
    e1.trademark = 8482;
    e1.trademarksans = 63722;
    e1.trademarkserif = 63195;
    e1.tretroflexhook = 648;
    e1.triagdn = 9660;
    e1.triaglf = 9668;
    e1.triagrt = 9658;
    e1.triagup = 9650;
    e1.ts = 678;
    e1.tsadi = 1510;
    e1.tsadidagesh = 64326;
    e1.tsadidageshhebrew = 64326;
    e1.tsadihebrew = 1510;
    e1.tsecyrillic = 1094;
    e1.tsere = 1461;
    e1.tsere12 = 1461;
    e1.tsere1e = 1461;
    e1.tsere2b = 1461;
    e1.tserehebrew = 1461;
    e1.tserenarrowhebrew = 1461;
    e1.tserequarterhebrew = 1461;
    e1.tserewidehebrew = 1461;
    e1.tshecyrillic = 1115;
    e1.tsuperior = 63219;
    e1.ttabengali = 2463;
    e1.ttadeva = 2335;
    e1.ttagujarati = 2719;
    e1.ttagurmukhi = 2591;
    e1.tteharabic = 1657;
    e1.ttehfinalarabic = 64359;
    e1.ttehinitialarabic = 64360;
    e1.ttehmedialarabic = 64361;
    e1.tthabengali = 2464;
    e1.tthadeva = 2336;
    e1.tthagujarati = 2720;
    e1.tthagurmukhi = 2592;
    e1.tturned = 647;
    e1.tuhiragana = 12388;
    e1.tukatakana = 12484;
    e1.tukatakanahalfwidth = 65410;
    e1.tusmallhiragana = 12387;
    e1.tusmallkatakana = 12483;
    e1.tusmallkatakanahalfwidth = 65391;
    e1.twelvecircle = 9323;
    e1.twelveparen = 9343;
    e1.twelveperiod = 9363;
    e1.twelveroman = 8571;
    e1.twentycircle = 9331;
    e1.twentyhangzhou = 21316;
    e1.twentyparen = 9351;
    e1.twentyperiod = 9371;
    e1.two = 50;
    e1.twoarabic = 1634;
    e1.twobengali = 2536;
    e1.twocircle = 9313;
    e1.twocircleinversesansserif = 10123;
    e1.twodeva = 2408;
    e1.twodotenleader = 8229;
    e1.twodotleader = 8229;
    e1.twodotleadervertical = 65072;
    e1.twogujarati = 2792;
    e1.twogurmukhi = 2664;
    e1.twohackarabic = 1634;
    e1.twohangzhou = 12322;
    e1.twoideographicparen = 12833;
    e1.twoinferior = 8322;
    e1.twomonospace = 65298;
    e1.twonumeratorbengali = 2549;
    e1.twooldstyle = 63282;
    e1.twoparen = 9333;
    e1.twoperiod = 9353;
    e1.twopersian = 1778;
    e1.tworoman = 8561;
    e1.twostroke = 443;
    e1.twosuperior = 178;
    e1.twothai = 3666;
    e1.twothirds = 8532;
    e1.u = 117;
    e1.uacute = 250;
    e1.ubar = 649;
    e1.ubengali = 2441;
    e1.ubopomofo = 12584;
    e1.ubreve = 365;
    e1.ucaron = 468;
    e1.ucircle = 9444;
    e1.ucircumflex = 251;
    e1.ucircumflexbelow = 7799;
    e1.ucyrillic = 1091;
    e1.udattadeva = 2385;
    e1.udblacute = 369;
    e1.udblgrave = 533;
    e1.udeva = 2313;
    e1.udieresis = 252;
    e1.udieresisacute = 472;
    e1.udieresisbelow = 7795;
    e1.udieresiscaron = 474;
    e1.udieresiscyrillic = 1265;
    e1.udieresisgrave = 476;
    e1.udieresismacron = 470;
    e1.udotbelow = 7909;
    e1.ugrave = 249;
    e1.ugujarati = 2697;
    e1.ugurmukhi = 2569;
    e1.uhiragana = 12358;
    e1.uhookabove = 7911;
    e1.uhorn = 432;
    e1.uhornacute = 7913;
    e1.uhorndotbelow = 7921;
    e1.uhorngrave = 7915;
    e1.uhornhookabove = 7917;
    e1.uhorntilde = 7919;
    e1.uhungarumlaut = 369;
    e1.uhungarumlautcyrillic = 1267;
    e1.uinvertedbreve = 535;
    e1.ukatakana = 12454;
    e1.ukatakanahalfwidth = 65395;
    e1.ukcyrillic = 1145;
    e1.ukorean = 12636;
    e1.umacron = 363;
    e1.umacroncyrillic = 1263;
    e1.umacrondieresis = 7803;
    e1.umatragurmukhi = 2625;
    e1.umonospace = 65365;
    e1.underscore = 95;
    e1.underscoredbl = 8215;
    e1.underscoremonospace = 65343;
    e1.underscorevertical = 65075;
    e1.underscorewavy = 65103;
    e1.union = 8746;
    e1.universal = 8704;
    e1.uogonek = 371;
    e1.uparen = 9392;
    e1.upblock = 9600;
    e1.upperdothebrew = 1476;
    e1.upsilon = 965;
    e1.upsilondieresis = 971;
    e1.upsilondieresistonos = 944;
    e1.upsilonlatin = 650;
    e1.upsilontonos = 973;
    e1.uptackbelowcmb = 797;
    e1.uptackmod = 724;
    e1.uragurmukhi = 2675;
    e1.uring = 367;
    e1.ushortcyrillic = 1118;
    e1.usmallhiragana = 12357;
    e1.usmallkatakana = 12453;
    e1.usmallkatakanahalfwidth = 65385;
    e1.ustraightcyrillic = 1199;
    e1.ustraightstrokecyrillic = 1201;
    e1.utilde = 361;
    e1.utildeacute = 7801;
    e1.utildebelow = 7797;
    e1.uubengali = 2442;
    e1.uudeva = 2314;
    e1.uugujarati = 2698;
    e1.uugurmukhi = 2570;
    e1.uumatragurmukhi = 2626;
    e1.uuvowelsignbengali = 2498;
    e1.uuvowelsigndeva = 2370;
    e1.uuvowelsigngujarati = 2754;
    e1.uvowelsignbengali = 2497;
    e1.uvowelsigndeva = 2369;
    e1.uvowelsigngujarati = 2753;
    e1.v = 118;
    e1.vadeva = 2357;
    e1.vagujarati = 2741;
    e1.vagurmukhi = 2613;
    e1.vakatakana = 12535;
    e1.vav = 1493;
    e1.vavdagesh = 64309;
    e1.vavdagesh65 = 64309;
    e1.vavdageshhebrew = 64309;
    e1.vavhebrew = 1493;
    e1.vavholam = 64331;
    e1.vavholamhebrew = 64331;
    e1.vavvavhebrew = 1520;
    e1.vavyodhebrew = 1521;
    e1.vcircle = 9445;
    e1.vdotbelow = 7807;
    e1.vecyrillic = 1074;
    e1.veharabic = 1700;
    e1.vehfinalarabic = 64363;
    e1.vehinitialarabic = 64364;
    e1.vehmedialarabic = 64365;
    e1.vekatakana = 12537;
    e1.venus = 9792;
    e1.verticalbar = 124;
    e1.verticallineabovecmb = 781;
    e1.verticallinebelowcmb = 809;
    e1.verticallinelowmod = 716;
    e1.verticallinemod = 712;
    e1.vewarmenian = 1406;
    e1.vhook = 651;
    e1.vikatakana = 12536;
    e1.viramabengali = 2509;
    e1.viramadeva = 2381;
    e1.viramagujarati = 2765;
    e1.visargabengali = 2435;
    e1.visargadeva = 2307;
    e1.visargagujarati = 2691;
    e1.vmonospace = 65366;
    e1.voarmenian = 1400;
    e1.voicediterationhiragana = 12446;
    e1.voicediterationkatakana = 12542;
    e1.voicedmarkkana = 12443;
    e1.voicedmarkkanahalfwidth = 65438;
    e1.vokatakana = 12538;
    e1.vparen = 9393;
    e1.vtilde = 7805;
    e1.vturned = 652;
    e1.vuhiragana = 12436;
    e1.vukatakana = 12532;
    e1.w = 119;
    e1.wacute = 7811;
    e1.waekorean = 12633;
    e1.wahiragana = 12431;
    e1.wakatakana = 12527;
    e1.wakatakanahalfwidth = 65436;
    e1.wakorean = 12632;
    e1.wasmallhiragana = 12430;
    e1.wasmallkatakana = 12526;
    e1.wattosquare = 13143;
    e1.wavedash = 12316;
    e1.wavyunderscorevertical = 65076;
    e1.wawarabic = 1608;
    e1.wawfinalarabic = 65262;
    e1.wawhamzaabovearabic = 1572;
    e1.wawhamzaabovefinalarabic = 65158;
    e1.wbsquare = 13277;
    e1.wcircle = 9446;
    e1.wcircumflex = 373;
    e1.wdieresis = 7813;
    e1.wdotaccent = 7815;
    e1.wdotbelow = 7817;
    e1.wehiragana = 12433;
    e1.weierstrass = 8472;
    e1.wekatakana = 12529;
    e1.wekorean = 12638;
    e1.weokorean = 12637;
    e1.wgrave = 7809;
    e1.whitebullet = 9702;
    e1.whitecircle = 9675;
    e1.whitecircleinverse = 9689;
    e1.whitecornerbracketleft = 12302;
    e1.whitecornerbracketleftvertical = 65091;
    e1.whitecornerbracketright = 12303;
    e1.whitecornerbracketrightvertical = 65092;
    e1.whitediamond = 9671;
    e1.whitediamondcontainingblacksmalldiamond = 9672;
    e1.whitedownpointingsmalltriangle = 9663;
    e1.whitedownpointingtriangle = 9661;
    e1.whiteleftpointingsmalltriangle = 9667;
    e1.whiteleftpointingtriangle = 9665;
    e1.whitelenticularbracketleft = 12310;
    e1.whitelenticularbracketright = 12311;
    e1.whiterightpointingsmalltriangle = 9657;
    e1.whiterightpointingtriangle = 9655;
    e1.whitesmallsquare = 9643;
    e1.whitesmilingface = 9786;
    e1.whitesquare = 9633;
    e1.whitestar = 9734;
    e1.whitetelephone = 9743;
    e1.whitetortoiseshellbracketleft = 12312;
    e1.whitetortoiseshellbracketright = 12313;
    e1.whiteuppointingsmalltriangle = 9653;
    e1.whiteuppointingtriangle = 9651;
    e1.wihiragana = 12432;
    e1.wikatakana = 12528;
    e1.wikorean = 12639;
    e1.wmonospace = 65367;
    e1.wohiragana = 12434;
    e1.wokatakana = 12530;
    e1.wokatakanahalfwidth = 65382;
    e1.won = 8361;
    e1.wonmonospace = 65510;
    e1.wowaenthai = 3623;
    e1.wparen = 9394;
    e1.wring = 7832;
    e1.wsuperior = 695;
    e1.wturned = 653;
    e1.wynn = 447;
    e1.x = 120;
    e1.xabovecmb = 829;
    e1.xbopomofo = 12562;
    e1.xcircle = 9447;
    e1.xdieresis = 7821;
    e1.xdotaccent = 7819;
    e1.xeharmenian = 1389;
    e1.xi = 958;
    e1.xmonospace = 65368;
    e1.xparen = 9395;
    e1.xsuperior = 739;
    e1.y = 121;
    e1.yaadosquare = 13134;
    e1.yabengali = 2479;
    e1.yacute = 253;
    e1.yadeva = 2351;
    e1.yaekorean = 12626;
    e1.yagujarati = 2735;
    e1.yagurmukhi = 2607;
    e1.yahiragana = 12420;
    e1.yakatakana = 12516;
    e1.yakatakanahalfwidth = 65428;
    e1.yakorean = 12625;
    e1.yamakkanthai = 3662;
    e1.yasmallhiragana = 12419;
    e1.yasmallkatakana = 12515;
    e1.yasmallkatakanahalfwidth = 65388;
    e1.yatcyrillic = 1123;
    e1.ycircle = 9448;
    e1.ycircumflex = 375;
    e1.ydieresis = 255;
    e1.ydotaccent = 7823;
    e1.ydotbelow = 7925;
    e1.yeharabic = 1610;
    e1.yehbarreearabic = 1746;
    e1.yehbarreefinalarabic = 64431;
    e1.yehfinalarabic = 65266;
    e1.yehhamzaabovearabic = 1574;
    e1.yehhamzaabovefinalarabic = 65162;
    e1.yehhamzaaboveinitialarabic = 65163;
    e1.yehhamzaabovemedialarabic = 65164;
    e1.yehinitialarabic = 65267;
    e1.yehmedialarabic = 65268;
    e1.yehmeeminitialarabic = 64733;
    e1.yehmeemisolatedarabic = 64600;
    e1.yehnoonfinalarabic = 64660;
    e1.yehthreedotsbelowarabic = 1745;
    e1.yekorean = 12630;
    e1.yen = 165;
    e1.yenmonospace = 65509;
    e1.yeokorean = 12629;
    e1.yeorinhieuhkorean = 12678;
    e1.yerahbenyomohebrew = 1450;
    e1.yerahbenyomolefthebrew = 1450;
    e1.yericyrillic = 1099;
    e1.yerudieresiscyrillic = 1273;
    e1.yesieungkorean = 12673;
    e1.yesieungpansioskorean = 12675;
    e1.yesieungsioskorean = 12674;
    e1.yetivhebrew = 1434;
    e1.ygrave = 7923;
    e1.yhook = 436;
    e1.yhookabove = 7927;
    e1.yiarmenian = 1397;
    e1.yicyrillic = 1111;
    e1.yikorean = 12642;
    e1.yinyang = 9775;
    e1.yiwnarmenian = 1410;
    e1.ymonospace = 65369;
    e1.yod = 1497;
    e1.yoddagesh = 64313;
    e1.yoddageshhebrew = 64313;
    e1.yodhebrew = 1497;
    e1.yodyodhebrew = 1522;
    e1.yodyodpatahhebrew = 64287;
    e1.yohiragana = 12424;
    e1.yoikorean = 12681;
    e1.yokatakana = 12520;
    e1.yokatakanahalfwidth = 65430;
    e1.yokorean = 12635;
    e1.yosmallhiragana = 12423;
    e1.yosmallkatakana = 12519;
    e1.yosmallkatakanahalfwidth = 65390;
    e1.yotgreek = 1011;
    e1.yoyaekorean = 12680;
    e1.yoyakorean = 12679;
    e1.yoyakthai = 3618;
    e1.yoyingthai = 3597;
    e1.yparen = 9396;
    e1.ypogegrammeni = 890;
    e1.ypogegrammenigreekcmb = 837;
    e1.yr = 422;
    e1.yring = 7833;
    e1.ysuperior = 696;
    e1.ytilde = 7929;
    e1.yturned = 654;
    e1.yuhiragana = 12422;
    e1.yuikorean = 12684;
    e1.yukatakana = 12518;
    e1.yukatakanahalfwidth = 65429;
    e1.yukorean = 12640;
    e1.yusbigcyrillic = 1131;
    e1.yusbigiotifiedcyrillic = 1133;
    e1.yuslittlecyrillic = 1127;
    e1.yuslittleiotifiedcyrillic = 1129;
    e1.yusmallhiragana = 12421;
    e1.yusmallkatakana = 12517;
    e1.yusmallkatakanahalfwidth = 65389;
    e1.yuyekorean = 12683;
    e1.yuyeokorean = 12682;
    e1.yyabengali = 2527;
    e1.yyadeva = 2399;
    e1.z = 122;
    e1.zaarmenian = 1382;
    e1.zacute = 378;
    e1.zadeva = 2395;
    e1.zagurmukhi = 2651;
    e1.zaharabic = 1592;
    e1.zahfinalarabic = 65222;
    e1.zahinitialarabic = 65223;
    e1.zahiragana = 12374;
    e1.zahmedialarabic = 65224;
    e1.zainarabic = 1586;
    e1.zainfinalarabic = 65200;
    e1.zakatakana = 12470;
    e1.zaqefgadolhebrew = 1429;
    e1.zaqefqatanhebrew = 1428;
    e1.zarqahebrew = 1432;
    e1.zayin = 1494;
    e1.zayindagesh = 64310;
    e1.zayindageshhebrew = 64310;
    e1.zayinhebrew = 1494;
    e1.zbopomofo = 12567;
    e1.zcaron = 382;
    e1.zcircle = 9449;
    e1.zcircumflex = 7825;
    e1.zcurl = 657;
    e1.zdot = 380;
    e1.zdotaccent = 380;
    e1.zdotbelow = 7827;
    e1.zecyrillic = 1079;
    e1.zedescendercyrillic = 1177;
    e1.zedieresiscyrillic = 1247;
    e1.zehiragana = 12380;
    e1.zekatakana = 12476;
    e1.zero = 48;
    e1.zeroarabic = 1632;
    e1.zerobengali = 2534;
    e1.zerodeva = 2406;
    e1.zerogujarati = 2790;
    e1.zerogurmukhi = 2662;
    e1.zerohackarabic = 1632;
    e1.zeroinferior = 8320;
    e1.zeromonospace = 65296;
    e1.zerooldstyle = 63280;
    e1.zeropersian = 1776;
    e1.zerosuperior = 8304;
    e1.zerothai = 3664;
    e1.zerowidthjoiner = 65279;
    e1.zerowidthnonjoiner = 8204;
    e1.zerowidthspace = 8203;
    e1.zeta = 950;
    e1.zhbopomofo = 12563;
    e1.zhearmenian = 1386;
    e1.zhebrevecyrillic = 1218;
    e1.zhecyrillic = 1078;
    e1.zhedescendercyrillic = 1175;
    e1.zhedieresiscyrillic = 1245;
    e1.zihiragana = 12376;
    e1.zikatakana = 12472;
    e1.zinorhebrew = 1454;
    e1.zlinebelow = 7829;
    e1.zmonospace = 65370;
    e1.zohiragana = 12382;
    e1.zokatakana = 12478;
    e1.zparen = 9397;
    e1.zretroflexhook = 656;
    e1.zstroke = 438;
    e1.zuhiragana = 12378;
    e1.zukatakana = 12474;
    e1[".notdef"] = 0;
    e1.angbracketleftbig = 9001;
    e1.angbracketleftBig = 9001;
    e1.angbracketleftbigg = 9001;
    e1.angbracketleftBigg = 9001;
    e1.angbracketrightBig = 9002;
    e1.angbracketrightbig = 9002;
    e1.angbracketrightBigg = 9002;
    e1.angbracketrightbigg = 9002;
    e1.arrowhookleft = 8618;
    e1.arrowhookright = 8617;
    e1.arrowlefttophalf = 8636;
    e1.arrowleftbothalf = 8637;
    e1.arrownortheast = 8599;
    e1.arrownorthwest = 8598;
    e1.arrowrighttophalf = 8640;
    e1.arrowrightbothalf = 8641;
    e1.arrowsoutheast = 8600;
    e1.arrowsouthwest = 8601;
    e1.backslashbig = 8726;
    e1.backslashBig = 8726;
    e1.backslashBigg = 8726;
    e1.backslashbigg = 8726;
    e1.bardbl = 8214;
    e1.bracehtipdownleft = 65079;
    e1.bracehtipdownright = 65079;
    e1.bracehtipupleft = 65080;
    e1.bracehtipupright = 65080;
    e1.braceleftBig = 123;
    e1.braceleftbig = 123;
    e1.braceleftbigg = 123;
    e1.braceleftBigg = 123;
    e1.bracerightBig = 125;
    e1.bracerightbig = 125;
    e1.bracerightbigg = 125;
    e1.bracerightBigg = 125;
    e1.bracketleftbig = 91;
    e1.bracketleftBig = 91;
    e1.bracketleftbigg = 91;
    e1.bracketleftBigg = 91;
    e1.bracketrightBig = 93;
    e1.bracketrightbig = 93;
    e1.bracketrightbigg = 93;
    e1.bracketrightBigg = 93;
    e1.ceilingleftbig = 8968;
    e1.ceilingleftBig = 8968;
    e1.ceilingleftBigg = 8968;
    e1.ceilingleftbigg = 8968;
    e1.ceilingrightbig = 8969;
    e1.ceilingrightBig = 8969;
    e1.ceilingrightbigg = 8969;
    e1.ceilingrightBigg = 8969;
    e1.circledotdisplay = 8857;
    e1.circledottext = 8857;
    e1.circlemultiplydisplay = 8855;
    e1.circlemultiplytext = 8855;
    e1.circleplusdisplay = 8853;
    e1.circleplustext = 8853;
    e1.contintegraldisplay = 8750;
    e1.contintegraltext = 8750;
    e1.coproductdisplay = 8720;
    e1.coproducttext = 8720;
    e1.floorleftBig = 8970;
    e1.floorleftbig = 8970;
    e1.floorleftbigg = 8970;
    e1.floorleftBigg = 8970;
    e1.floorrightbig = 8971;
    e1.floorrightBig = 8971;
    e1.floorrightBigg = 8971;
    e1.floorrightbigg = 8971;
    e1.hatwide = 770;
    e1.hatwider = 770;
    e1.hatwidest = 770;
    e1.intercal = 7488;
    e1.integraldisplay = 8747;
    e1.integraltext = 8747;
    e1.intersectiondisplay = 8898;
    e1.intersectiontext = 8898;
    e1.logicalanddisplay = 8743;
    e1.logicalandtext = 8743;
    e1.logicalordisplay = 8744;
    e1.logicalortext = 8744;
    e1.parenleftBig = 40;
    e1.parenleftbig = 40;
    e1.parenleftBigg = 40;
    e1.parenleftbigg = 40;
    e1.parenrightBig = 41;
    e1.parenrightbig = 41;
    e1.parenrightBigg = 41;
    e1.parenrightbigg = 41;
    e1.prime = 8242;
    e1.productdisplay = 8719;
    e1.producttext = 8719;
    e1.radicalbig = 8730;
    e1.radicalBig = 8730;
    e1.radicalBigg = 8730;
    e1.radicalbigg = 8730;
    e1.radicalbt = 8730;
    e1.radicaltp = 8730;
    e1.radicalvertex = 8730;
    e1.slashbig = 47;
    e1.slashBig = 47;
    e1.slashBigg = 47;
    e1.slashbigg = 47;
    e1.summationdisplay = 8721;
    e1.summationtext = 8721;
    e1.tildewide = 732;
    e1.tildewider = 732;
    e1.tildewidest = 732;
    e1.uniondisplay = 8899;
    e1.unionmultidisplay = 8846;
    e1.unionmultitext = 8846;
    e1.unionsqdisplay = 8852;
    e1.unionsqtext = 8852;
    e1.uniontext = 8899;
    e1.vextenddouble = 8741;
    e1.vextendsingle = 8739;
}), hr = getLookupTableFactory(function(e1) {
    e1.space = 32;
    e1.a1 = 9985;
    e1.a2 = 9986;
    e1.a202 = 9987;
    e1.a3 = 9988;
    e1.a4 = 9742;
    e1.a5 = 9990;
    e1.a119 = 9991;
    e1.a118 = 9992;
    e1.a117 = 9993;
    e1.a11 = 9755;
    e1.a12 = 9758;
    e1.a13 = 9996;
    e1.a14 = 9997;
    e1.a15 = 9998;
    e1.a16 = 9999;
    e1.a105 = 1e4;
    e1.a17 = 10001;
    e1.a18 = 10002;
    e1.a19 = 10003;
    e1.a20 = 10004;
    e1.a21 = 10005;
    e1.a22 = 10006;
    e1.a23 = 10007;
    e1.a24 = 10008;
    e1.a25 = 10009;
    e1.a26 = 10010;
    e1.a27 = 10011;
    e1.a28 = 10012;
    e1.a6 = 10013;
    e1.a7 = 10014;
    e1.a8 = 10015;
    e1.a9 = 10016;
    e1.a10 = 10017;
    e1.a29 = 10018;
    e1.a30 = 10019;
    e1.a31 = 10020;
    e1.a32 = 10021;
    e1.a33 = 10022;
    e1.a34 = 10023;
    e1.a35 = 9733;
    e1.a36 = 10025;
    e1.a37 = 10026;
    e1.a38 = 10027;
    e1.a39 = 10028;
    e1.a40 = 10029;
    e1.a41 = 10030;
    e1.a42 = 10031;
    e1.a43 = 10032;
    e1.a44 = 10033;
    e1.a45 = 10034;
    e1.a46 = 10035;
    e1.a47 = 10036;
    e1.a48 = 10037;
    e1.a49 = 10038;
    e1.a50 = 10039;
    e1.a51 = 10040;
    e1.a52 = 10041;
    e1.a53 = 10042;
    e1.a54 = 10043;
    e1.a55 = 10044;
    e1.a56 = 10045;
    e1.a57 = 10046;
    e1.a58 = 10047;
    e1.a59 = 10048;
    e1.a60 = 10049;
    e1.a61 = 10050;
    e1.a62 = 10051;
    e1.a63 = 10052;
    e1.a64 = 10053;
    e1.a65 = 10054;
    e1.a66 = 10055;
    e1.a67 = 10056;
    e1.a68 = 10057;
    e1.a69 = 10058;
    e1.a70 = 10059;
    e1.a71 = 9679;
    e1.a72 = 10061;
    e1.a73 = 9632;
    e1.a74 = 10063;
    e1.a203 = 10064;
    e1.a75 = 10065;
    e1.a204 = 10066;
    e1.a76 = 9650;
    e1.a77 = 9660;
    e1.a78 = 9670;
    e1.a79 = 10070;
    e1.a81 = 9687;
    e1.a82 = 10072;
    e1.a83 = 10073;
    e1.a84 = 10074;
    e1.a97 = 10075;
    e1.a98 = 10076;
    e1.a99 = 10077;
    e1.a100 = 10078;
    e1.a101 = 10081;
    e1.a102 = 10082;
    e1.a103 = 10083;
    e1.a104 = 10084;
    e1.a106 = 10085;
    e1.a107 = 10086;
    e1.a108 = 10087;
    e1.a112 = 9827;
    e1.a111 = 9830;
    e1.a110 = 9829;
    e1.a109 = 9824;
    e1.a120 = 9312;
    e1.a121 = 9313;
    e1.a122 = 9314;
    e1.a123 = 9315;
    e1.a124 = 9316;
    e1.a125 = 9317;
    e1.a126 = 9318;
    e1.a127 = 9319;
    e1.a128 = 9320;
    e1.a129 = 9321;
    e1.a130 = 10102;
    e1.a131 = 10103;
    e1.a132 = 10104;
    e1.a133 = 10105;
    e1.a134 = 10106;
    e1.a135 = 10107;
    e1.a136 = 10108;
    e1.a137 = 10109;
    e1.a138 = 10110;
    e1.a139 = 10111;
    e1.a140 = 10112;
    e1.a141 = 10113;
    e1.a142 = 10114;
    e1.a143 = 10115;
    e1.a144 = 10116;
    e1.a145 = 10117;
    e1.a146 = 10118;
    e1.a147 = 10119;
    e1.a148 = 10120;
    e1.a149 = 10121;
    e1.a150 = 10122;
    e1.a151 = 10123;
    e1.a152 = 10124;
    e1.a153 = 10125;
    e1.a154 = 10126;
    e1.a155 = 10127;
    e1.a156 = 10128;
    e1.a157 = 10129;
    e1.a158 = 10130;
    e1.a159 = 10131;
    e1.a160 = 10132;
    e1.a161 = 8594;
    e1.a163 = 8596;
    e1.a164 = 8597;
    e1.a196 = 10136;
    e1.a165 = 10137;
    e1.a192 = 10138;
    e1.a166 = 10139;
    e1.a167 = 10140;
    e1.a168 = 10141;
    e1.a169 = 10142;
    e1.a170 = 10143;
    e1.a171 = 10144;
    e1.a172 = 10145;
    e1.a173 = 10146;
    e1.a162 = 10147;
    e1.a174 = 10148;
    e1.a175 = 10149;
    e1.a176 = 10150;
    e1.a177 = 10151;
    e1.a178 = 10152;
    e1.a179 = 10153;
    e1.a193 = 10154;
    e1.a180 = 10155;
    e1.a199 = 10156;
    e1.a181 = 10157;
    e1.a200 = 10158;
    e1.a182 = 10159;
    e1.a201 = 10161;
    e1.a183 = 10162;
    e1.a184 = 10163;
    e1.a197 = 10164;
    e1.a185 = 10165;
    e1.a194 = 10166;
    e1.a198 = 10167;
    e1.a186 = 10168;
    e1.a195 = 10169;
    e1.a187 = 10170;
    e1.a188 = 10171;
    e1.a189 = 10172;
    e1.a190 = 10173;
    e1.a191 = 10174;
    e1.a89 = 10088;
    e1.a90 = 10089;
    e1.a93 = 10090;
    e1.a94 = 10091;
    e1.a91 = 10092;
    e1.a92 = 10093;
    e1.a205 = 10094;
    e1.a85 = 10095;
    e1.a206 = 10096;
    e1.a86 = 10097;
    e1.a87 = 10098;
    e1.a88 = 10099;
    e1.a95 = 10100;
    e1.a96 = 10101;
    e1[".notdef"] = 0;
}), ur = getLookupTableFactory(function(e1) {
    e1[63721] = 169;
    e1[63193] = 169;
    e1[63720] = 174;
    e1[63194] = 174;
    e1[63722] = 8482;
    e1[63195] = 8482;
    e1[63729] = 9127;
    e1[63730] = 9128;
    e1[63731] = 9129;
    e1[63740] = 9131;
    e1[63741] = 9132;
    e1[63742] = 9133;
    e1[63726] = 9121;
    e1[63727] = 9122;
    e1[63728] = 9123;
    e1[63737] = 9124;
    e1[63738] = 9125;
    e1[63739] = 9126;
    e1[63723] = 9115;
    e1[63724] = 9116;
    e1[63725] = 9117;
    e1[63734] = 9118;
    e1[63735] = 9119;
    e1[63736] = 9120;
});
function getUnicodeForGlyph(e1, t) {
    let a = t[e1];
    if (void 0 !== a) return a;
    if (!e1) return -1;
    if ("u" === e1[0]) {
        const t = e1.length;
        let r;
        if (7 === t && "n" === e1[1] && "i" === e1[2]) r = e1.substring(3);
        else {
            if (!(t >= 5 && t <= 7)) return -1;
            r = e1.substring(1);
        }
        if (r === r.toUpperCase()) {
            a = parseInt(r, 16);
            if (a >= 0) return a;
        }
    }
    return -1;
}
const dr = [
    [
        0,
        127
    ],
    [
        128,
        255
    ],
    [
        256,
        383
    ],
    [
        384,
        591
    ],
    [
        592,
        687,
        7424,
        7551,
        7552,
        7615
    ],
    [
        688,
        767,
        42752,
        42783
    ],
    [
        768,
        879,
        7616,
        7679
    ],
    [
        880,
        1023
    ],
    [
        11392,
        11519
    ],
    [
        1024,
        1279,
        1280,
        1327,
        11744,
        11775,
        42560,
        42655
    ],
    [
        1328,
        1423
    ],
    [
        1424,
        1535
    ],
    [
        42240,
        42559
    ],
    [
        1536,
        1791,
        1872,
        1919
    ],
    [
        1984,
        2047
    ],
    [
        2304,
        2431
    ],
    [
        2432,
        2559
    ],
    [
        2560,
        2687
    ],
    [
        2688,
        2815
    ],
    [
        2816,
        2943
    ],
    [
        2944,
        3071
    ],
    [
        3072,
        3199
    ],
    [
        3200,
        3327
    ],
    [
        3328,
        3455
    ],
    [
        3584,
        3711
    ],
    [
        3712,
        3839
    ],
    [
        4256,
        4351,
        11520,
        11567
    ],
    [
        6912,
        7039
    ],
    [
        4352,
        4607
    ],
    [
        7680,
        7935,
        11360,
        11391,
        42784,
        43007
    ],
    [
        7936,
        8191
    ],
    [
        8192,
        8303,
        11776,
        11903
    ],
    [
        8304,
        8351
    ],
    [
        8352,
        8399
    ],
    [
        8400,
        8447
    ],
    [
        8448,
        8527
    ],
    [
        8528,
        8591
    ],
    [
        8592,
        8703,
        10224,
        10239,
        10496,
        10623,
        11008,
        11263
    ],
    [
        8704,
        8959,
        10752,
        11007,
        10176,
        10223,
        10624,
        10751
    ],
    [
        8960,
        9215
    ],
    [
        9216,
        9279
    ],
    [
        9280,
        9311
    ],
    [
        9312,
        9471
    ],
    [
        9472,
        9599
    ],
    [
        9600,
        9631
    ],
    [
        9632,
        9727
    ],
    [
        9728,
        9983
    ],
    [
        9984,
        10175
    ],
    [
        12288,
        12351
    ],
    [
        12352,
        12447
    ],
    [
        12448,
        12543,
        12784,
        12799
    ],
    [
        12544,
        12591,
        12704,
        12735
    ],
    [
        12592,
        12687
    ],
    [
        43072,
        43135
    ],
    [
        12800,
        13055
    ],
    [
        13056,
        13311
    ],
    [
        44032,
        55215
    ],
    [
        55296,
        57343
    ],
    [
        67840,
        67871
    ],
    [
        19968,
        40959,
        11904,
        12031,
        12032,
        12255,
        12272,
        12287,
        13312,
        19903,
        131072,
        173791,
        12688,
        12703
    ],
    [
        57344,
        63743
    ],
    [
        12736,
        12783,
        63744,
        64255,
        194560,
        195103
    ],
    [
        64256,
        64335
    ],
    [
        64336,
        65023
    ],
    [
        65056,
        65071
    ],
    [
        65040,
        65055
    ],
    [
        65104,
        65135
    ],
    [
        65136,
        65279
    ],
    [
        65280,
        65519
    ],
    [
        65520,
        65535
    ],
    [
        3840,
        4095
    ],
    [
        1792,
        1871
    ],
    [
        1920,
        1983
    ],
    [
        3456,
        3583
    ],
    [
        4096,
        4255
    ],
    [
        4608,
        4991,
        4992,
        5023,
        11648,
        11743
    ],
    [
        5024,
        5119
    ],
    [
        5120,
        5759
    ],
    [
        5760,
        5791
    ],
    [
        5792,
        5887
    ],
    [
        6016,
        6143
    ],
    [
        6144,
        6319
    ],
    [
        10240,
        10495
    ],
    [
        40960,
        42127
    ],
    [
        5888,
        5919,
        5920,
        5951,
        5952,
        5983,
        5984,
        6015
    ],
    [
        66304,
        66351
    ],
    [
        66352,
        66383
    ],
    [
        66560,
        66639
    ],
    [
        118784,
        119039,
        119040,
        119295,
        119296,
        119375
    ],
    [
        119808,
        120831
    ],
    [
        1044480,
        1048573
    ],
    [
        65024,
        65039,
        917760,
        917999
    ],
    [
        917504,
        917631
    ],
    [
        6400,
        6479
    ],
    [
        6480,
        6527
    ],
    [
        6528,
        6623
    ],
    [
        6656,
        6687
    ],
    [
        11264,
        11359
    ],
    [
        11568,
        11647
    ],
    [
        19904,
        19967
    ],
    [
        43008,
        43055
    ],
    [
        65536,
        65663,
        65664,
        65791,
        65792,
        65855
    ],
    [
        65856,
        65935
    ],
    [
        66432,
        66463
    ],
    [
        66464,
        66527
    ],
    [
        66640,
        66687
    ],
    [
        66688,
        66735
    ],
    [
        67584,
        67647
    ],
    [
        68096,
        68191
    ],
    [
        119552,
        119647
    ],
    [
        73728,
        74751,
        74752,
        74879
    ],
    [
        119648,
        119679
    ],
    [
        7040,
        7103
    ],
    [
        7168,
        7247
    ],
    [
        7248,
        7295
    ],
    [
        43136,
        43231
    ],
    [
        43264,
        43311
    ],
    [
        43312,
        43359
    ],
    [
        43520,
        43615
    ],
    [
        65936,
        65999
    ],
    [
        66e3,
        66047
    ],
    [
        66208,
        66271,
        66176,
        66207,
        67872,
        67903
    ],
    [
        127024,
        127135,
        126976,
        127023
    ]
];
function getUnicodeRangeFor(e1, t = -1) {
    if (-1 !== t) {
        const a = dr[t];
        for(let r = 0, i = a.length; r < i; r += 2)if (e1 >= a[r] && e1 <= a[r + 1]) return t;
    }
    for(let t = 0, a = dr.length; t < a; t++){
        const a = dr[t];
        for(let r = 0, i = a.length; r < i; r += 2)if (e1 >= a[r] && e1 <= a[r + 1]) return t;
    }
    return -1;
}
const fr = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), gr = new Map;
const pr = !0, mr = 1, br = 2, yr = 4, wr = 32, xr = [
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
];
function recoverGlyphName(e1, t) {
    if (void 0 !== t[e1]) return e1;
    const a = getUnicodeForGlyph(e1, t);
    if (-1 !== a) {
        for(const e1 in t)if (t[e1] === a) return e1;
    }
    info("Unable to recover a standard glyph name for: " + e1);
    return e1;
}
function type1FontGlyphMapping(e1, t, a) {
    const r = Object.create(null);
    let i, n, s;
    const o = !!(e1.flags & yr);
    if (e1.isInternalFont) {
        s = t;
        for(n = 0; n < s.length; n++){
            i = a.indexOf(s[n]);
            r[n] = i >= 0 ? i : 0;
        }
    } else if (e1.baseEncodingName) {
        s = getEncoding(e1.baseEncodingName);
        for(n = 0; n < s.length; n++){
            i = a.indexOf(s[n]);
            r[n] = i >= 0 ? i : 0;
        }
    } else if (o) for(n in t)r[n] = t[n];
    else {
        s = nr;
        for(n = 0; n < s.length; n++){
            i = a.indexOf(s[n]);
            r[n] = i >= 0 ? i : 0;
        }
    }
    const c = e1.differences;
    let l;
    if (c) for(n in c){
        const e1 = c[n];
        i = a.indexOf(e1);
        if (-1 === i) {
            l || (l = lr());
            const t = recoverGlyphName(e1, l);
            t !== e1 && (i = a.indexOf(t));
        }
        r[n] = i >= 0 ? i : 0;
    }
    return r;
}
function normalizeFontName(e1) {
    return e1.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const Sr = getLookupTableFactory((e1)=>{
    e1[8211] = 65074;
    e1[8212] = 65073;
    e1[8229] = 65072;
    e1[8230] = 65049;
    e1[12289] = 65041;
    e1[12290] = 65042;
    e1[12296] = 65087;
    e1[12297] = 65088;
    e1[12298] = 65085;
    e1[12299] = 65086;
    e1[12300] = 65089;
    e1[12301] = 65090;
    e1[12302] = 65091;
    e1[12303] = 65092;
    e1[12304] = 65083;
    e1[12305] = 65084;
    e1[12308] = 65081;
    e1[12309] = 65082;
    e1[12310] = 65047;
    e1[12311] = 65048;
    e1[65103] = 65076;
    e1[65281] = 65045;
    e1[65288] = 65077;
    e1[65289] = 65078;
    e1[65292] = 65040;
    e1[65306] = 65043;
    e1[65307] = 65044;
    e1[65311] = 65046;
    e1[65339] = 65095;
    e1[65341] = 65096;
    e1[65343] = 65075;
    e1[65371] = 65079;
    e1[65373] = 65080;
});
const Ar = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron"
], kr = [
    ".notdef",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
], Cr = [
    ".notdef",
    "space",
    "dollaroldstyle",
    "dollarsuperior",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "hyphensuperior",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "centoldstyle",
    "figuredash",
    "hypheninferior",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior"
], vr = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall",
    "001.000",
    "001.001",
    "001.002",
    "001.003",
    "Black",
    "Bold",
    "Book",
    "Light",
    "Medium",
    "Regular",
    "Roman",
    "Semibold"
], Fr = 391, Ir = [
    null,
    {
        id: "hstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    null,
    {
        id: "vstem",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "vmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "rlineto",
        min: 2,
        resetStack: !0
    },
    {
        id: "hlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "vlineto",
        min: 1,
        resetStack: !0
    },
    {
        id: "rrcurveto",
        min: 6,
        resetStack: !0
    },
    null,
    {
        id: "callsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "return",
        min: 0,
        undefStack: !0
    },
    null,
    null,
    {
        id: "endchar",
        min: 0,
        stackClearing: !0
    },
    null,
    null,
    null,
    {
        id: "hstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "hintmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "cntrmask",
        min: 0,
        stackClearing: !0
    },
    {
        id: "rmoveto",
        min: 2,
        stackClearing: !0
    },
    {
        id: "hmoveto",
        min: 1,
        stackClearing: !0
    },
    {
        id: "vstemhm",
        min: 2,
        stackClearing: !0,
        stem: !0
    },
    {
        id: "rcurveline",
        min: 8,
        resetStack: !0
    },
    {
        id: "rlinecurve",
        min: 8,
        resetStack: !0
    },
    {
        id: "vvcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hhcurveto",
        min: 4,
        resetStack: !0
    },
    null,
    {
        id: "callgsubr",
        min: 1,
        undefStack: !0
    },
    {
        id: "vhcurveto",
        min: 4,
        resetStack: !0
    },
    {
        id: "hvcurveto",
        min: 4,
        resetStack: !0
    }
], Tr = [
    null,
    null,
    null,
    {
        id: "and",
        min: 2,
        stackDelta: -1
    },
    {
        id: "or",
        min: 2,
        stackDelta: -1
    },
    {
        id: "not",
        min: 1,
        stackDelta: 0
    },
    null,
    null,
    null,
    {
        id: "abs",
        min: 1,
        stackDelta: 0
    },
    {
        id: "add",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] + e1[t - 1];
        }
    },
    {
        id: "sub",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] - e1[t - 1];
        }
    },
    {
        id: "div",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] / e1[t - 1];
        }
    },
    null,
    {
        id: "neg",
        min: 1,
        stackDelta: 0,
        stackFn (e1, t) {
            e1[t - 1] = -e1[t - 1];
        }
    },
    {
        id: "eq",
        min: 2,
        stackDelta: -1
    },
    null,
    null,
    {
        id: "drop",
        min: 1,
        stackDelta: -1
    },
    null,
    {
        id: "put",
        min: 2,
        stackDelta: -2
    },
    {
        id: "get",
        min: 1,
        stackDelta: 0
    },
    {
        id: "ifelse",
        min: 4,
        stackDelta: -3
    },
    {
        id: "random",
        min: 0,
        stackDelta: 1
    },
    {
        id: "mul",
        min: 2,
        stackDelta: -1,
        stackFn (e1, t) {
            e1[t - 2] = e1[t - 2] * e1[t - 1];
        }
    },
    null,
    {
        id: "sqrt",
        min: 1,
        stackDelta: 0
    },
    {
        id: "dup",
        min: 1,
        stackDelta: 1
    },
    {
        id: "exch",
        min: 2,
        stackDelta: 0
    },
    {
        id: "index",
        min: 2,
        stackDelta: 0
    },
    {
        id: "roll",
        min: 3,
        stackDelta: -2
    },
    null,
    null,
    null,
    {
        id: "hflex",
        min: 7,
        resetStack: !0
    },
    {
        id: "flex",
        min: 13,
        resetStack: !0
    },
    {
        id: "hflex1",
        min: 9,
        resetStack: !0
    },
    {
        id: "flex1",
        min: 11,
        resetStack: !0
    }
];
class CFFParser {
    constructor(e1, t, a){
        this.bytes = e1.getBytes();
        this.properties = t;
        this.seacAnalysisEnabled = !!a;
    }
    parse() {
        const e1 = this.properties, t = new CFF;
        this.cff = t;
        const a = this.parseHeader(), r = this.parseIndex(a.endPos), i = this.parseIndex(r.endPos), n = this.parseIndex(i.endPos), s = this.parseIndex(n.endPos), o = this.parseDict(i.obj.get(0)), c = this.createDict(CFFTopDict, o, t.strings);
        t.header = a.obj;
        t.names = this.parseNameIndex(r.obj);
        t.strings = this.parseStringIndex(n.obj);
        t.topDict = c;
        t.globalSubrIndex = s.obj;
        this.parsePrivateDict(t.topDict);
        t.isCIDFont = c.hasName("ROS");
        const l = c.getByName("CharStrings"), h = this.parseIndex(l).obj, u = c.getByName("FontMatrix");
        u && (e1.fontMatrix = u);
        const d = c.getByName("FontBBox");
        if (d) {
            e1.ascent = Math.max(d[3], d[1]);
            e1.descent = Math.min(d[1], d[3]);
            e1.ascentScaled = !0;
        }
        let f, g;
        if (t.isCIDFont) {
            const e1 = this.parseIndex(c.getByName("FDArray")).obj;
            for(let a = 0, r = e1.count; a < r; ++a){
                const r = e1.get(a), i = this.createDict(CFFTopDict, this.parseDict(r), t.strings);
                this.parsePrivateDict(i);
                t.fdArray.push(i);
            }
            g = null;
            f = this.parseCharsets(c.getByName("charset"), h.count, t.strings, !0);
            t.fdSelect = this.parseFDSelect(c.getByName("FDSelect"), h.count);
        } else {
            f = this.parseCharsets(c.getByName("charset"), h.count, t.strings, !1);
            g = this.parseEncoding(c.getByName("Encoding"), e1, t.strings, f.charset);
        }
        t.charset = f;
        t.encoding = g;
        const p = this.parseCharStrings({
            charStrings: h,
            localSubrIndex: c.privateDict.subrsIndex,
            globalSubrIndex: s.obj,
            fdSelect: t.fdSelect,
            fdArray: t.fdArray,
            privateDict: c.privateDict
        });
        t.charStrings = p.charStrings;
        t.seacs = p.seacs;
        t.widths = p.widths;
        return t;
    }
    parseHeader() {
        let e1 = this.bytes;
        const t = e1.length;
        let a = 0;
        for(; a < t && 1 !== e1[a];)++a;
        if (a >= t) throw new FormatError("Invalid CFF header");
        if (0 !== a) {
            info("cff data is shifted");
            e1 = e1.subarray(a);
            this.bytes = e1;
        }
        const r = e1[0], i = e1[1], n = e1[2], s = e1[3];
        return {
            obj: new CFFHeader(r, i, n, s),
            endPos: n
        };
    }
    parseDict(e1) {
        let t = 0;
        function parseOperand() {
            let a = e1[t++];
            if (30 === a) return function parseFloatOperand() {
                let a = "";
                const r = 15, i = [
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    ".",
                    "E",
                    "E-",
                    null,
                    "-"
                ], n = e1.length;
                for(; t < n;){
                    const n = e1[t++], s = n >> 4, o = 15 & n;
                    if (s === r) break;
                    a += i[s];
                    if (o === r) break;
                    a += i[o];
                }
                return parseFloat(a);
            }();
            if (28 === a) {
                a = readInt16(e1, t);
                t += 2;
                return a;
            }
            if (29 === a) {
                a = e1[t++];
                a = a << 8 | e1[t++];
                a = a << 8 | e1[t++];
                a = a << 8 | e1[t++];
                return a;
            }
            if (a >= 32 && a <= 246) return a - 139;
            if (a >= 247 && a <= 250) return 256 * (a - 247) + e1[t++] + 108;
            if (a >= 251 && a <= 254) return -256 * (a - 251) - e1[t++] - 108;
            warn('CFFParser_parseDict: "' + a + '" is a reserved command.');
            return NaN;
        }
        let a = [];
        const r = [];
        t = 0;
        const i = e1.length;
        for(; t < i;){
            let i = e1[t];
            if (i <= 21) {
                12 === i && (i = i << 8 | e1[++t]);
                r.push([
                    i,
                    a
                ]);
                a = [];
                ++t;
            } else a.push(parseOperand());
        }
        return r;
    }
    parseIndex(e1) {
        const t = new CFFIndex, a = this.bytes, r = a[e1++] << 8 | a[e1++], i = [];
        let n, s, o = e1;
        if (0 !== r) {
            const t = a[e1++], c = e1 + (r + 1) * t - 1;
            for(n = 0, s = r + 1; n < s; ++n){
                let r = 0;
                for(let i = 0; i < t; ++i){
                    r <<= 8;
                    r += a[e1++];
                }
                i.push(c + r);
            }
            o = i[r];
        }
        for(n = 0, s = i.length - 1; n < s; ++n){
            const e1 = i[n], r = i[n + 1];
            t.add(a.subarray(e1, r));
        }
        return {
            obj: t,
            endPos: o
        };
    }
    parseNameIndex(e1) {
        const t = [];
        for(let a = 0, r = e1.count; a < r; ++a){
            const r = e1.get(a);
            t.push(bytesToString(r));
        }
        return t;
    }
    parseStringIndex(e1) {
        const t = new CFFStrings;
        for(let a = 0, r = e1.count; a < r; ++a){
            const r = e1.get(a);
            t.add(bytesToString(r));
        }
        return t;
    }
    createDict(e1, t, a) {
        const r = new e1(a);
        for (const [e1, a] of t)r.setByKey(e1, a);
        return r;
    }
    parseCharString(e1, t, a, r) {
        if (!t || e1.callDepth > 10) return !1;
        let i = e1.stackSize;
        const n = e1.stack;
        let s = t.length;
        for(let o = 0; o < s;){
            const c = t[o++];
            let l = null;
            if (12 === c) {
                const e1 = t[o++];
                if (0 === e1) {
                    t[o - 2] = 139;
                    t[o - 1] = 22;
                    i = 0;
                } else l = Tr[e1];
            } else if (28 === c) {
                n[i] = readInt16(t, o);
                o += 2;
                i++;
            } else if (14 === c) {
                if (i >= 4) {
                    i -= 4;
                    if (this.seacAnalysisEnabled) {
                        e1.seac = n.slice(i, i + 4);
                        return !1;
                    }
                }
                l = Ir[c];
            } else if (c >= 32 && c <= 246) {
                n[i] = c - 139;
                i++;
            } else if (c >= 247 && c <= 254) {
                n[i] = c < 251 ? (c - 247 << 8) + t[o] + 108 : -(c - 251 << 8) - t[o] - 108;
                o++;
                i++;
            } else if (255 === c) {
                n[i] = (t[o] << 24 | t[o + 1] << 16 | t[o + 2] << 8 | t[o + 3]) / 65536;
                o += 4;
                i++;
            } else if (19 === c || 20 === c) {
                e1.hints += i >> 1;
                if (0 === e1.hints) {
                    t.copyWithin(o - 1, o, -1);
                    o -= 1;
                    s -= 1;
                    continue;
                }
                o += e1.hints + 7 >> 3;
                i %= 2;
                l = Ir[c];
            } else {
                if (10 === c || 29 === c) {
                    const t = 10 === c ? a : r;
                    if (!t) {
                        l = Ir[c];
                        warn("Missing subrsIndex for " + l.id);
                        return !1;
                    }
                    let s = 32768;
                    t.count < 1240 ? s = 107 : t.count < 33900 && (s = 1131);
                    const o = n[--i] + s;
                    if (o < 0 || o >= t.count || isNaN(o)) {
                        l = Ir[c];
                        warn("Out of bounds subrIndex for " + l.id);
                        return !1;
                    }
                    e1.stackSize = i;
                    e1.callDepth++;
                    if (!this.parseCharString(e1, t.get(o), a, r)) return !1;
                    e1.callDepth--;
                    i = e1.stackSize;
                    continue;
                }
                if (11 === c) {
                    e1.stackSize = i;
                    return !0;
                }
                if (0 === c && o === t.length) {
                    t[o - 1] = 14;
                    l = Ir[14];
                } else {
                    if (9 === c) {
                        t.copyWithin(o - 1, o, -1);
                        o -= 1;
                        s -= 1;
                        continue;
                    }
                    l = Ir[c];
                }
            }
            if (l) {
                if (l.stem) {
                    e1.hints += i >> 1;
                    if (3 === c || 23 === c) e1.hasVStems = !0;
                    else if (e1.hasVStems && (1 === c || 18 === c)) {
                        warn("CFF stem hints are in wrong order");
                        t[o - 1] = 1 === c ? 3 : 23;
                    }
                }
                if ("min" in l && !e1.undefStack && i < l.min) {
                    warn("Not enough parameters for " + l.id + "; actual: " + i + ", expected: " + l.min);
                    if (0 === i) {
                        t[o - 1] = 14;
                        return !0;
                    }
                    return !1;
                }
                if (e1.firstStackClearing && l.stackClearing) {
                    e1.firstStackClearing = !1;
                    i -= l.min;
                    i >= 2 && l.stem ? i %= 2 : i > 1 && warn("Found too many parameters for stack-clearing command");
                    i > 0 && (e1.width = n[i - 1]);
                }
                if ("stackDelta" in l) {
                    "stackFn" in l && l.stackFn(n, i);
                    i += l.stackDelta;
                } else if (l.stackClearing) i = 0;
                else if (l.resetStack) {
                    i = 0;
                    e1.undefStack = !1;
                } else if (l.undefStack) {
                    i = 0;
                    e1.undefStack = !0;
                    e1.firstStackClearing = !1;
                }
            }
        }
        s < t.length && t.fill(14, s);
        e1.stackSize = i;
        return !0;
    }
    parseCharStrings({ charStrings: e1, localSubrIndex: t, globalSubrIndex: a, fdSelect: r, fdArray: i, privateDict: n }) {
        const s = [], o = [], c = e1.count;
        for(let l = 0; l < c; l++){
            const c = e1.get(l), h = {
                callDepth: 0,
                stackSize: 0,
                stack: [],
                undefStack: !0,
                hints: 0,
                firstStackClearing: !0,
                seac: null,
                width: null,
                hasVStems: !1
            };
            let u = !0, d = null, f = n;
            if (r && i.length) {
                const e1 = r.getFDIndex(l);
                if (-1 === e1) {
                    warn("Glyph index is not in fd select.");
                    u = !1;
                }
                if (e1 >= i.length) {
                    warn("Invalid fd index for glyph index.");
                    u = !1;
                }
                if (u) {
                    f = i[e1].privateDict;
                    d = f.subrsIndex;
                }
            } else t && (d = t);
            u && (u = this.parseCharString(h, c, d, a));
            if (null !== h.width) {
                const e1 = f.getByName("nominalWidthX");
                o[l] = e1 + h.width;
            } else {
                const e1 = f.getByName("defaultWidthX");
                o[l] = e1;
            }
            null !== h.seac && (s[l] = h.seac);
            u || e1.set(l, new Uint8Array([
                14
            ]));
        }
        return {
            charStrings: e1,
            seacs: s,
            widths: o
        };
    }
    emptyPrivateDictionary(e1) {
        const t = this.createDict(CFFPrivateDict, [], e1.strings);
        e1.setByKey(18, [
            0,
            0
        ]);
        e1.privateDict = t;
    }
    parsePrivateDict(e1) {
        if (!e1.hasName("Private")) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const t = e1.getByName("Private");
        if (!Array.isArray(t) || 2 !== t.length) {
            e1.removeByName("Private");
            return;
        }
        const a = t[0], r = t[1];
        if (0 === a || r >= this.bytes.length) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const i = r + a, n = this.bytes.subarray(r, i), s = this.parseDict(n), o = this.createDict(CFFPrivateDict, s, e1.strings);
        e1.privateDict = o;
        0 === o.getByName("ExpansionFactor") && o.setByName("ExpansionFactor", .06);
        if (!o.getByName("Subrs")) return;
        const c = o.getByName("Subrs"), l = r + c;
        if (0 === c || l >= this.bytes.length) {
            this.emptyPrivateDictionary(e1);
            return;
        }
        const h = this.parseIndex(l);
        o.subrsIndex = h.obj;
    }
    parseCharsets(e1, t, a, r) {
        if (0 === e1) return new CFFCharset(!0, Dr.ISO_ADOBE, Ar);
        if (1 === e1) return new CFFCharset(!0, Dr.EXPERT, kr);
        if (2 === e1) return new CFFCharset(!0, Dr.EXPERT_SUBSET, Cr);
        const i = this.bytes, n = e1, s = i[e1++], o = [
            r ? 0 : ".notdef"
        ];
        let c, l, h;
        t -= 1;
        switch(s){
            case 0:
                for(h = 0; h < t; h++){
                    c = i[e1++] << 8 | i[e1++];
                    o.push(r ? c : a.get(c));
                }
                break;
            case 1:
                for(; o.length <= t;){
                    c = i[e1++] << 8 | i[e1++];
                    l = i[e1++];
                    for(h = 0; h <= l; h++)o.push(r ? c++ : a.get(c++));
                }
                break;
            case 2:
                for(; o.length <= t;){
                    c = i[e1++] << 8 | i[e1++];
                    l = i[e1++] << 8 | i[e1++];
                    for(h = 0; h <= l; h++)o.push(r ? c++ : a.get(c++));
                }
                break;
            default:
                throw new FormatError("Unknown charset format");
        }
        const u = e1, d = i.subarray(n, u);
        return new CFFCharset(!1, s, o, d);
    }
    parseEncoding(e1, t, a, r) {
        const i = Object.create(null), n = this.bytes;
        let s, o, c, l = !1, h = null;
        if (0 === e1 || 1 === e1) {
            l = !0;
            s = e1;
            const t = e1 ? ar : nr;
            for(o = 0, c = r.length; o < c; o++){
                const e1 = t.indexOf(r[o]);
                -1 !== e1 && (i[e1] = o);
            }
        } else {
            const t = e1;
            s = n[e1++];
            switch(127 & s){
                case 0:
                    const t1 = n[e1++];
                    for(o = 1; o <= t1; o++)i[n[e1++]] = o;
                    break;
                case 1:
                    const a1 = n[e1++];
                    let r1 = 1;
                    for(o = 0; o < a1; o++){
                        const t = n[e1++], a = n[e1++];
                        for(let e1 = t; e1 <= t + a; e1++)i[e1] = r1++;
                    }
                    break;
                default:
                    throw new FormatError(`Unknown encoding format: ${s} in CFF`);
            }
            const c = e1;
            if (128 & s) {
                n[t] &= 127;
                !function readSupplement() {
                    const t = n[e1++];
                    for(o = 0; o < t; o++){
                        const t = n[e1++], s = (n[e1++] << 8) + (255 & n[e1++]);
                        i[t] = r.indexOf(a.get(s));
                    }
                }();
            }
            h = n.subarray(t, c);
        }
        s &= 127;
        return new CFFEncoding(l, s, i, h);
    }
    parseFDSelect(e1, t) {
        const a = this.bytes, r = a[e1++], i = [];
        let n;
        switch(r){
            case 0:
                for(n = 0; n < t; ++n){
                    const t = a[e1++];
                    i.push(t);
                }
                break;
            case 3:
                const s = a[e1++] << 8 | a[e1++];
                for(n = 0; n < s; ++n){
                    let t = a[e1++] << 8 | a[e1++];
                    if (0 === n && 0 !== t) {
                        warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                        t = 0;
                    }
                    const r = a[e1++], s = a[e1] << 8 | a[e1 + 1];
                    for(let e1 = t; e1 < s; ++e1)i.push(r);
                }
                e1 += 2;
                break;
            default:
                throw new FormatError(`parseFDSelect: Unknown format "${r}".`);
        }
        if (i.length !== t) throw new FormatError("parseFDSelect: Invalid font data.");
        return new CFFFDSelect(r, i);
    }
}
class CFF {
    constructor(){
        this.header = null;
        this.names = [];
        this.topDict = null;
        this.strings = new CFFStrings;
        this.globalSubrIndex = null;
        this.encoding = null;
        this.charset = null;
        this.charStrings = null;
        this.fdArray = [];
        this.fdSelect = null;
        this.isCIDFont = !1;
    }
    duplicateFirstGlyph() {
        if (this.charStrings.count >= 65535) {
            warn("Not enough space in charstrings to duplicate first glyph.");
            return;
        }
        const e1 = this.charStrings.get(0);
        this.charStrings.add(e1);
        this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.charStrings.count) return !1;
        return this.charStrings.get(e1).length > 0;
    }
}
class CFFHeader {
    constructor(e1, t, a, r){
        this.major = e1;
        this.minor = t;
        this.hdrSize = a;
        this.offSize = r;
    }
}
class CFFStrings {
    constructor(){
        this.strings = [];
    }
    get(e1) {
        return e1 >= 0 && e1 <= 390 ? vr[e1] : e1 - Fr <= this.strings.length ? this.strings[e1 - Fr] : vr[0];
    }
    getSID(e1) {
        let t = vr.indexOf(e1);
        if (-1 !== t) return t;
        t = this.strings.indexOf(e1);
        return -1 !== t ? t + Fr : -1;
    }
    add(e1) {
        this.strings.push(e1);
    }
    get count() {
        return this.strings.length;
    }
}
class CFFIndex {
    constructor(){
        this.objects = [];
        this.length = 0;
    }
    add(e1) {
        this.length += e1.length;
        this.objects.push(e1);
    }
    set(e1, t) {
        this.length += t.length - this.objects[e1].length;
        this.objects[e1] = t;
    }
    get(e1) {
        return this.objects[e1];
    }
    get count() {
        return this.objects.length;
    }
}
class CFFDict {
    constructor(e1, t){
        this.keyToNameMap = e1.keyToNameMap;
        this.nameToKeyMap = e1.nameToKeyMap;
        this.defaults = e1.defaults;
        this.types = e1.types;
        this.opcodes = e1.opcodes;
        this.order = e1.order;
        this.strings = t;
        this.values = Object.create(null);
    }
    setByKey(e1, t) {
        if (!(e1 in this.keyToNameMap)) return !1;
        if (0 === t.length) return !0;
        for (const a of t)if (isNaN(a)) {
            warn(`Invalid CFFDict value: "${t}" for key "${e1}".`);
            return !0;
        }
        const a = this.types[e1];
        "num" !== a && "sid" !== a && "offset" !== a || (t = t[0]);
        this.values[e1] = t;
        return !0;
    }
    setByName(e1, t) {
        if (!(e1 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name "${e1}"`);
        this.values[this.nameToKeyMap[e1]] = t;
    }
    hasName(e1) {
        return this.nameToKeyMap[e1] in this.values;
    }
    getByName(e1) {
        if (!(e1 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e1}"`);
        const t = this.nameToKeyMap[e1];
        return t in this.values ? this.values[t] : this.defaults[t];
    }
    removeByName(e1) {
        delete this.values[this.nameToKeyMap[e1]];
    }
    static createTables(e1) {
        const t = {
            keyToNameMap: {},
            nameToKeyMap: {},
            defaults: {},
            types: {},
            opcodes: {},
            order: []
        };
        for (const a of e1){
            const e1 = Array.isArray(a[0]) ? (a[0][0] << 8) + a[0][1] : a[0];
            t.keyToNameMap[e1] = a[1];
            t.nameToKeyMap[a[1]] = e1;
            t.types[e1] = a[2];
            t.defaults[e1] = a[3];
            t.opcodes[e1] = Array.isArray(a[0]) ? a[0] : [
                a[0]
            ];
            t.order.push(e1);
        }
        return t;
    }
}
const Or = [
    [
        [
            12,
            30
        ],
        "ROS",
        [
            "sid",
            "sid",
            "num"
        ],
        null
    ],
    [
        [
            12,
            20
        ],
        "SyntheticBase",
        "num",
        null
    ],
    [
        0,
        "version",
        "sid",
        null
    ],
    [
        1,
        "Notice",
        "sid",
        null
    ],
    [
        [
            12,
            0
        ],
        "Copyright",
        "sid",
        null
    ],
    [
        2,
        "FullName",
        "sid",
        null
    ],
    [
        3,
        "FamilyName",
        "sid",
        null
    ],
    [
        4,
        "Weight",
        "sid",
        null
    ],
    [
        [
            12,
            1
        ],
        "isFixedPitch",
        "num",
        0
    ],
    [
        [
            12,
            2
        ],
        "ItalicAngle",
        "num",
        0
    ],
    [
        [
            12,
            3
        ],
        "UnderlinePosition",
        "num",
        -100
    ],
    [
        [
            12,
            4
        ],
        "UnderlineThickness",
        "num",
        50
    ],
    [
        [
            12,
            5
        ],
        "PaintType",
        "num",
        0
    ],
    [
        [
            12,
            6
        ],
        "CharstringType",
        "num",
        2
    ],
    [
        [
            12,
            7
        ],
        "FontMatrix",
        [
            "num",
            "num",
            "num",
            "num",
            "num",
            "num"
        ],
        [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]
    ],
    [
        13,
        "UniqueID",
        "num",
        null
    ],
    [
        5,
        "FontBBox",
        [
            "num",
            "num",
            "num",
            "num"
        ],
        [
            0,
            0,
            0,
            0
        ]
    ],
    [
        [
            12,
            8
        ],
        "StrokeWidth",
        "num",
        0
    ],
    [
        14,
        "XUID",
        "array",
        null
    ],
    [
        15,
        "charset",
        "offset",
        0
    ],
    [
        16,
        "Encoding",
        "offset",
        0
    ],
    [
        17,
        "CharStrings",
        "offset",
        0
    ],
    [
        18,
        "Private",
        [
            "offset",
            "offset"
        ],
        null
    ],
    [
        [
            12,
            21
        ],
        "PostScript",
        "sid",
        null
    ],
    [
        [
            12,
            22
        ],
        "BaseFontName",
        "sid",
        null
    ],
    [
        [
            12,
            23
        ],
        "BaseFontBlend",
        "delta",
        null
    ],
    [
        [
            12,
            31
        ],
        "CIDFontVersion",
        "num",
        0
    ],
    [
        [
            12,
            32
        ],
        "CIDFontRevision",
        "num",
        0
    ],
    [
        [
            12,
            33
        ],
        "CIDFontType",
        "num",
        0
    ],
    [
        [
            12,
            34
        ],
        "CIDCount",
        "num",
        8720
    ],
    [
        [
            12,
            35
        ],
        "UIDBase",
        "num",
        null
    ],
    [
        [
            12,
            37
        ],
        "FDSelect",
        "offset",
        null
    ],
    [
        [
            12,
            36
        ],
        "FDArray",
        "offset",
        null
    ],
    [
        [
            12,
            38
        ],
        "FontName",
        "sid",
        null
    ]
];
class CFFTopDict extends CFFDict {
    static get tables() {
        return shadow(this, "tables", this.createTables(Or));
    }
    constructor(e1){
        super(CFFTopDict.tables, e1);
        this.privateDict = null;
    }
}
const Mr = [
    [
        6,
        "BlueValues",
        "delta",
        null
    ],
    [
        7,
        "OtherBlues",
        "delta",
        null
    ],
    [
        8,
        "FamilyBlues",
        "delta",
        null
    ],
    [
        9,
        "FamilyOtherBlues",
        "delta",
        null
    ],
    [
        [
            12,
            9
        ],
        "BlueScale",
        "num",
        .039625
    ],
    [
        [
            12,
            10
        ],
        "BlueShift",
        "num",
        7
    ],
    [
        [
            12,
            11
        ],
        "BlueFuzz",
        "num",
        1
    ],
    [
        10,
        "StdHW",
        "num",
        null
    ],
    [
        11,
        "StdVW",
        "num",
        null
    ],
    [
        [
            12,
            12
        ],
        "StemSnapH",
        "delta",
        null
    ],
    [
        [
            12,
            13
        ],
        "StemSnapV",
        "delta",
        null
    ],
    [
        [
            12,
            14
        ],
        "ForceBold",
        "num",
        0
    ],
    [
        [
            12,
            17
        ],
        "LanguageGroup",
        "num",
        0
    ],
    [
        [
            12,
            18
        ],
        "ExpansionFactor",
        "num",
        .06
    ],
    [
        [
            12,
            19
        ],
        "initialRandomSeed",
        "num",
        0
    ],
    [
        20,
        "defaultWidthX",
        "num",
        0
    ],
    [
        21,
        "nominalWidthX",
        "num",
        0
    ],
    [
        19,
        "Subrs",
        "offset",
        null
    ]
];
class CFFPrivateDict extends CFFDict {
    static get tables() {
        return shadow(this, "tables", this.createTables(Mr));
    }
    constructor(e1){
        super(CFFPrivateDict.tables, e1);
        this.subrsIndex = null;
    }
}
const Dr = {
    ISO_ADOBE: 0,
    EXPERT: 1,
    EXPERT_SUBSET: 2
};
class CFFCharset {
    constructor(e1, t, a, r){
        this.predefined = e1;
        this.format = t;
        this.charset = a;
        this.raw = r;
    }
}
class CFFEncoding {
    constructor(e1, t, a, r){
        this.predefined = e1;
        this.format = t;
        this.encoding = a;
        this.raw = r;
    }
}
class CFFFDSelect {
    constructor(e1, t){
        this.format = e1;
        this.fdSelect = t;
    }
    getFDIndex(e1) {
        return e1 < 0 || e1 >= this.fdSelect.length ? -1 : this.fdSelect[e1];
    }
}
class CFFOffsetTracker {
    constructor(){
        this.offsets = Object.create(null);
    }
    isTracking(e1) {
        return e1 in this.offsets;
    }
    track(e1, t) {
        if (e1 in this.offsets) throw new FormatError(`Already tracking location of ${e1}`);
        this.offsets[e1] = t;
    }
    offset(e1) {
        for(const t in this.offsets)this.offsets[t] += e1;
    }
    setEntryLocation(e1, t, a) {
        if (!(e1 in this.offsets)) throw new FormatError(`Not tracking location of ${e1}`);
        const r = a.data, i = this.offsets[e1];
        for(let e1 = 0, a = t.length; e1 < a; ++e1){
            const a = 5 * e1 + i, n = a + 1, s = a + 2, o = a + 3, c = a + 4;
            if (29 !== r[a] || 0 !== r[n] || 0 !== r[s] || 0 !== r[o] || 0 !== r[c]) throw new FormatError("writing to an offset that is not empty");
            const l = t[e1];
            r[a] = 29;
            r[n] = l >> 24 & 255;
            r[s] = l >> 16 & 255;
            r[o] = l >> 8 & 255;
            r[c] = 255 & l;
        }
    }
}
class CFFCompiler {
    constructor(e1){
        this.cff = e1;
    }
    compile() {
        const e1 = this.cff, t = {
            data: [],
            length: 0,
            add (e1) {
                try {
                    this.data.push(...e1);
                } catch  {
                    this.data = this.data.concat(e1);
                }
                this.length = this.data.length;
            }
        }, a = this.compileHeader(e1.header);
        t.add(a);
        const r = this.compileNameIndex(e1.names);
        t.add(r);
        if (e1.isCIDFont && e1.topDict.hasName("FontMatrix")) {
            const t = e1.topDict.getByName("FontMatrix");
            e1.topDict.removeByName("FontMatrix");
            for (const a of e1.fdArray){
                let e1 = t.slice(0);
                a.hasName("FontMatrix") && (e1 = Util.transform(e1, a.getByName("FontMatrix")));
                a.setByName("FontMatrix", e1);
            }
        }
        const i = e1.topDict.getByName("XUID");
        i?.length > 16 && e1.topDict.removeByName("XUID");
        e1.topDict.setByName("charset", 0);
        let n = this.compileTopDicts([
            e1.topDict
        ], t.length, e1.isCIDFont);
        t.add(n.output);
        const s = n.trackers[0], o = this.compileStringIndex(e1.strings.strings);
        t.add(o);
        const c = this.compileIndex(e1.globalSubrIndex);
        t.add(c);
        if (e1.encoding && e1.topDict.hasName("Encoding")) if (e1.encoding.predefined) s.setEntryLocation("Encoding", [
            e1.encoding.format
        ], t);
        else {
            const a = this.compileEncoding(e1.encoding);
            s.setEntryLocation("Encoding", [
                t.length
            ], t);
            t.add(a);
        }
        const l = this.compileCharset(e1.charset, e1.charStrings.count, e1.strings, e1.isCIDFont);
        s.setEntryLocation("charset", [
            t.length
        ], t);
        t.add(l);
        const h = this.compileCharStrings(e1.charStrings);
        s.setEntryLocation("CharStrings", [
            t.length
        ], t);
        t.add(h);
        if (e1.isCIDFont) {
            s.setEntryLocation("FDSelect", [
                t.length
            ], t);
            const a = this.compileFDSelect(e1.fdSelect);
            t.add(a);
            n = this.compileTopDicts(e1.fdArray, t.length, !0);
            s.setEntryLocation("FDArray", [
                t.length
            ], t);
            t.add(n.output);
            const r = n.trackers;
            this.compilePrivateDicts(e1.fdArray, r, t);
        }
        this.compilePrivateDicts([
            e1.topDict
        ], [
            s
        ], t);
        t.add([
            0
        ]);
        return t.data;
    }
    encodeNumber(e1) {
        return Number.isInteger(e1) ? this.encodeInteger(e1) : this.encodeFloat(e1);
    }
    static get EncodeFloatRegExp() {
        return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
    }
    encodeFloat(e1) {
        let t = e1.toString();
        const a = CFFCompiler.EncodeFloatRegExp.exec(t);
        if (a) {
            const r = parseFloat("1e" + ((a[2] ? +a[2] : 0) + a[1].length));
            t = (Math.round(e1 * r) / r).toString();
        }
        let r, i, n = "";
        for(r = 0, i = t.length; r < i; ++r){
            const e1 = t[r];
            n += "e" === e1 ? "-" === t[++r] ? "c" : "b" : "." === e1 ? "a" : "-" === e1 ? "e" : e1;
        }
        n += 1 & n.length ? "f" : "ff";
        const s = [
            30
        ];
        for(r = 0, i = n.length; r < i; r += 2)s.push(parseInt(n.substring(r, r + 2), 16));
        return s;
    }
    encodeInteger(e1) {
        let t;
        t = e1 >= -107 && e1 <= 107 ? [
            e1 + 139
        ] : e1 >= 108 && e1 <= 1131 ? [
            247 + ((e1 -= 108) >> 8),
            255 & e1
        ] : e1 >= -1131 && e1 <= -108 ? [
            251 + ((e1 = -e1 - 108) >> 8),
            255 & e1
        ] : e1 >= -32768 && e1 <= 32767 ? [
            28,
            e1 >> 8 & 255,
            255 & e1
        ] : [
            29,
            e1 >> 24 & 255,
            e1 >> 16 & 255,
            e1 >> 8 & 255,
            255 & e1
        ];
        return t;
    }
    compileHeader(e1) {
        return [
            e1.major,
            e1.minor,
            4,
            e1.offSize
        ];
    }
    compileNameIndex(e1) {
        const t = new CFFIndex;
        for (const a of e1){
            const e1 = Math.min(a.length, 127);
            let r = new Array(e1);
            for(let t = 0; t < e1; t++){
                let e1 = a[t];
                (e1 < "!" || e1 > "~" || "[" === e1 || "]" === e1 || "(" === e1 || ")" === e1 || "{" === e1 || "}" === e1 || "<" === e1 || ">" === e1 || "/" === e1 || "%" === e1) && (e1 = "_");
                r[t] = e1;
            }
            r = r.join("");
            "" === r && (r = "Bad_Font_Name");
            t.add(stringToBytes(r));
        }
        return this.compileIndex(t);
    }
    compileTopDicts(e1, t, a) {
        const r = [];
        let i = new CFFIndex;
        for (const n of e1){
            if (a) {
                n.removeByName("CIDFontVersion");
                n.removeByName("CIDFontRevision");
                n.removeByName("CIDFontType");
                n.removeByName("CIDCount");
                n.removeByName("UIDBase");
            }
            const e1 = new CFFOffsetTracker, s = this.compileDict(n, e1);
            r.push(e1);
            i.add(s);
            e1.offset(t);
        }
        i = this.compileIndex(i, r);
        return {
            trackers: r,
            output: i
        };
    }
    compilePrivateDicts(e1, t, a) {
        for(let r = 0, i = e1.length; r < i; ++r){
            const i = e1[r], n = i.privateDict;
            if (!n || !i.hasName("Private")) throw new FormatError("There must be a private dictionary.");
            const s = new CFFOffsetTracker, o = this.compileDict(n, s);
            let c = a.length;
            s.offset(c);
            o.length || (c = 0);
            t[r].setEntryLocation("Private", [
                o.length,
                c
            ], a);
            a.add(o);
            if (n.subrsIndex && n.hasName("Subrs")) {
                const e1 = this.compileIndex(n.subrsIndex);
                s.setEntryLocation("Subrs", [
                    o.length
                ], a);
                a.add(e1);
            }
        }
    }
    compileDict(e1, t) {
        const a = [];
        for (const r of e1.order){
            if (!(r in e1.values)) continue;
            let i = e1.values[r], n = e1.types[r];
            Array.isArray(n) || (n = [
                n
            ]);
            Array.isArray(i) || (i = [
                i
            ]);
            if (0 !== i.length) {
                for(let s = 0, o = n.length; s < o; ++s){
                    const o = n[s], c = i[s];
                    switch(o){
                        case "num":
                        case "sid":
                            a.push(...this.encodeNumber(c));
                            break;
                        case "offset":
                            const n1 = e1.keyToNameMap[r];
                            t.isTracking(n1) || t.track(n1, a.length);
                            a.push(29, 0, 0, 0, 0);
                            break;
                        case "array":
                        case "delta":
                            a.push(...this.encodeNumber(c));
                            for(let e1 = 1, t = i.length; e1 < t; ++e1)a.push(...this.encodeNumber(i[e1]));
                            break;
                        default:
                            throw new FormatError(`Unknown data type of ${o}`);
                    }
                }
                a.push(...e1.opcodes[r]);
            }
        }
        return a;
    }
    compileStringIndex(e1) {
        const t = new CFFIndex;
        for (const a of e1)t.add(stringToBytes(a));
        return this.compileIndex(t);
    }
    compileCharStrings(e1) {
        const t = new CFFIndex;
        for(let a = 0; a < e1.count; a++){
            const r = e1.get(a);
            0 !== r.length ? t.add(r) : t.add(new Uint8Array([
                139,
                14
            ]));
        }
        return this.compileIndex(t);
    }
    compileCharset(e1, t, a, r) {
        let i;
        const n = t - 1;
        if (r) {
            const e1 = n - 1;
            i = new Uint8Array([
                2,
                0,
                1,
                e1 >> 8 & 255,
                255 & e1
            ]);
        } else {
            i = new Uint8Array(1 + 2 * n);
            i[0] = 0;
            let t = 0;
            const r = e1.charset.length;
            let s = !1;
            for(let n = 1; n < i.length; n += 2){
                let o = 0;
                if (t < r) {
                    const r = e1.charset[t++];
                    o = a.getSID(r);
                    if (-1 === o) {
                        o = 0;
                        if (!s) {
                            s = !0;
                            warn(`Couldn't find ${r} in CFF strings`);
                        }
                    }
                }
                i[n] = o >> 8 & 255;
                i[n + 1] = 255 & o;
            }
        }
        return this.compileTypedArray(i);
    }
    compileEncoding(e1) {
        return this.compileTypedArray(e1.raw);
    }
    compileFDSelect(e1) {
        const t = e1.format;
        let a, r;
        switch(t){
            case 0:
                a = new Uint8Array(1 + e1.fdSelect.length);
                a[0] = t;
                for(r = 0; r < e1.fdSelect.length; r++)a[r + 1] = e1.fdSelect[r];
                break;
            case 3:
                const i = 0;
                let n = e1.fdSelect[0];
                const s = [
                    t,
                    0,
                    0,
                    i >> 8 & 255,
                    255 & i,
                    n
                ];
                for(r = 1; r < e1.fdSelect.length; r++){
                    const t = e1.fdSelect[r];
                    if (t !== n) {
                        s.push(r >> 8 & 255, 255 & r, t);
                        n = t;
                    }
                }
                const o = (s.length - 3) / 3;
                s[1] = o >> 8 & 255;
                s[2] = 255 & o;
                s.push(r >> 8 & 255, 255 & r);
                a = new Uint8Array(s);
        }
        return this.compileTypedArray(a);
    }
    compileTypedArray(e1) {
        return Array.from(e1);
    }
    compileIndex(e1, t = []) {
        const a = e1.objects, r = a.length;
        if (0 === r) return [
            0,
            0
        ];
        const i = [
            r >> 8 & 255,
            255 & r
        ];
        let n, s, o = 1;
        for(n = 0; n < r; ++n)o += a[n].length;
        s = o < 256 ? 1 : o < 65536 ? 2 : o < 16777216 ? 3 : 4;
        i.push(s);
        let c = 1;
        for(n = 0; n < r + 1; n++){
            1 === s ? i.push(255 & c) : 2 === s ? i.push(c >> 8 & 255, 255 & c) : 3 === s ? i.push(c >> 16 & 255, c >> 8 & 255, 255 & c) : i.push(c >>> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c);
            a[n] && (c += a[n].length);
        }
        for(n = 0; n < r; n++){
            t[n] && t[n].offset(i.length);
            i.push(...a[n]);
        }
        return i;
    }
}
const Rr = getLookupTableFactory(function(e1) {
    e1["Times-Roman"] = "Times-Roman";
    e1.Helvetica = "Helvetica";
    e1.Courier = "Courier";
    e1.Symbol = "Symbol";
    e1["Times-Bold"] = "Times-Bold";
    e1["Helvetica-Bold"] = "Helvetica-Bold";
    e1["Courier-Bold"] = "Courier-Bold";
    e1.ZapfDingbats = "ZapfDingbats";
    e1["Times-Italic"] = "Times-Italic";
    e1["Helvetica-Oblique"] = "Helvetica-Oblique";
    e1["Courier-Oblique"] = "Courier-Oblique";
    e1["Times-BoldItalic"] = "Times-BoldItalic";
    e1["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
    e1["Courier-BoldOblique"] = "Courier-BoldOblique";
    e1.ArialNarrow = "Helvetica";
    e1["ArialNarrow-Bold"] = "Helvetica-Bold";
    e1["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialNarrow-Italic"] = "Helvetica-Oblique";
    e1.ArialBlack = "Helvetica";
    e1["ArialBlack-Bold"] = "Helvetica-Bold";
    e1["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialBlack-Italic"] = "Helvetica-Oblique";
    e1["Arial-Black"] = "Helvetica";
    e1["Arial-Black-Bold"] = "Helvetica-Bold";
    e1["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-Black-Italic"] = "Helvetica-Oblique";
    e1.Arial = "Helvetica";
    e1["Arial-Bold"] = "Helvetica-Bold";
    e1["Arial-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-Italic"] = "Helvetica-Oblique";
    e1.ArialMT = "Helvetica";
    e1["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
    e1["Arial-BoldMT"] = "Helvetica-Bold";
    e1["Arial-ItalicMT"] = "Helvetica-Oblique";
    e1["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Arial-BoldMT-Bold"] = "Helvetica-Bold";
    e1["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
    e1.ArialUnicodeMS = "Helvetica";
    e1["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
    e1["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
    e1["Courier-BoldItalic"] = "Courier-BoldOblique";
    e1["Courier-Italic"] = "Courier-Oblique";
    e1.CourierNew = "Courier";
    e1["CourierNew-Bold"] = "Courier-Bold";
    e1["CourierNew-BoldItalic"] = "Courier-BoldOblique";
    e1["CourierNew-Italic"] = "Courier-Oblique";
    e1["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
    e1["CourierNewPS-BoldMT"] = "Courier-Bold";
    e1["CourierNewPS-ItalicMT"] = "Courier-Oblique";
    e1.CourierNewPSMT = "Courier";
    e1["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Helvetica-Italic"] = "Helvetica-Oblique";
    e1["HelveticaLTStd-Bold"] = "Helvetica-Bold";
    e1["Symbol-Bold"] = "Symbol";
    e1["Symbol-BoldItalic"] = "Symbol";
    e1["Symbol-Italic"] = "Symbol";
    e1.TimesNewRoman = "Times-Roman";
    e1["TimesNewRoman-Bold"] = "Times-Bold";
    e1["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRoman-Italic"] = "Times-Italic";
    e1.TimesNewRomanPS = "Times-Roman";
    e1["TimesNewRomanPS-Bold"] = "Times-Bold";
    e1["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
    e1["TimesNewRomanPS-BoldMT"] = "Times-Bold";
    e1["TimesNewRomanPS-Italic"] = "Times-Italic";
    e1["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
    e1.TimesNewRomanPSMT = "Times-Roman";
    e1["TimesNewRomanPSMT-Bold"] = "Times-Bold";
    e1["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
    e1["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), Nr = getLookupTableFactory(function(e1) {
    e1.Courier = "FoxitFixed.pfb";
    e1["Courier-Bold"] = "FoxitFixedBold.pfb";
    e1["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
    e1["Courier-Oblique"] = "FoxitFixedItalic.pfb";
    e1.Helvetica = "LiberationSans-Regular.ttf";
    e1["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
    e1["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
    e1["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
    e1["Times-Roman"] = "FoxitSerif.pfb";
    e1["Times-Bold"] = "FoxitSerifBold.pfb";
    e1["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
    e1["Times-Italic"] = "FoxitSerifItalic.pfb";
    e1.Symbol = "FoxitSymbol.pfb";
    e1.ZapfDingbats = "FoxitDingbats.pfb";
    e1["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
    e1["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
    e1["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
    e1["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), Er = getLookupTableFactory(function(e1) {
    e1.Calibri = "Helvetica";
    e1["Calibri-Bold"] = "Helvetica-Bold";
    e1["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
    e1["Calibri-Italic"] = "Helvetica-Oblique";
    e1.CenturyGothic = "Helvetica";
    e1["CenturyGothic-Bold"] = "Helvetica-Bold";
    e1["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
    e1["CenturyGothic-Italic"] = "Helvetica-Oblique";
    e1.ComicSansMS = "Comic Sans MS";
    e1["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
    e1["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
    e1["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
    e1.GillSansMT = "Helvetica";
    e1["GillSansMT-Bold"] = "Helvetica-Bold";
    e1["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique";
    e1["GillSansMT-Italic"] = "Helvetica-Oblique";
    e1.Impact = "Helvetica";
    e1["ItcSymbol-Bold"] = "Helvetica-Bold";
    e1["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
    e1["ItcSymbol-Book"] = "Helvetica";
    e1["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
    e1["ItcSymbol-Medium"] = "Helvetica";
    e1["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
    e1.LucidaConsole = "Courier";
    e1["LucidaConsole-Bold"] = "Courier-Bold";
    e1["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
    e1["LucidaConsole-Italic"] = "Courier-Oblique";
    e1["LucidaSans-Demi"] = "Helvetica-Bold";
    e1["MS-Gothic"] = "MS Gothic";
    e1["MS-Gothic-Bold"] = "MS Gothic-Bold";
    e1["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
    e1["MS-Gothic-Italic"] = "MS Gothic-Italic";
    e1["MS-Mincho"] = "MS Mincho";
    e1["MS-Mincho-Bold"] = "MS Mincho-Bold";
    e1["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
    e1["MS-Mincho-Italic"] = "MS Mincho-Italic";
    e1["MS-PGothic"] = "MS PGothic";
    e1["MS-PGothic-Bold"] = "MS PGothic-Bold";
    e1["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
    e1["MS-PGothic-Italic"] = "MS PGothic-Italic";
    e1["MS-PMincho"] = "MS PMincho";
    e1["MS-PMincho-Bold"] = "MS PMincho-Bold";
    e1["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
    e1["MS-PMincho-Italic"] = "MS PMincho-Italic";
    e1.NuptialScript = "Times-Italic";
    e1.SegoeUISymbol = "Helvetica";
}), Pr = getLookupTableFactory(function(e1) {
    e1["Adobe Jenson"] = !0;
    e1["Adobe Text"] = !0;
    e1.Albertus = !0;
    e1.Aldus = !0;
    e1.Alexandria = !0;
    e1.Algerian = !0;
    e1["American Typewriter"] = !0;
    e1.Antiqua = !0;
    e1.Apex = !0;
    e1.Arno = !0;
    e1.Aster = !0;
    e1.Aurora = !0;
    e1.Baskerville = !0;
    e1.Bell = !0;
    e1.Bembo = !0;
    e1["Bembo Schoolbook"] = !0;
    e1.Benguiat = !0;
    e1["Berkeley Old Style"] = !0;
    e1["Bernhard Modern"] = !0;
    e1["Berthold City"] = !0;
    e1.Bodoni = !0;
    e1["Bauer Bodoni"] = !0;
    e1["Book Antiqua"] = !0;
    e1.Bookman = !0;
    e1["Bordeaux Roman"] = !0;
    e1["Californian FB"] = !0;
    e1.Calisto = !0;
    e1.Calvert = !0;
    e1.Capitals = !0;
    e1.Cambria = !0;
    e1.Cartier = !0;
    e1.Caslon = !0;
    e1.Catull = !0;
    e1.Centaur = !0;
    e1["Century Old Style"] = !0;
    e1["Century Schoolbook"] = !0;
    e1.Chaparral = !0;
    e1["Charis SIL"] = !0;
    e1.Cheltenham = !0;
    e1["Cholla Slab"] = !0;
    e1.Clarendon = !0;
    e1.Clearface = !0;
    e1.Cochin = !0;
    e1.Colonna = !0;
    e1["Computer Modern"] = !0;
    e1["Concrete Roman"] = !0;
    e1.Constantia = !0;
    e1["Cooper Black"] = !0;
    e1.Corona = !0;
    e1.Ecotype = !0;
    e1.Egyptienne = !0;
    e1.Elephant = !0;
    e1.Excelsior = !0;
    e1.Fairfield = !0;
    e1["FF Scala"] = !0;
    e1.Folkard = !0;
    e1.Footlight = !0;
    e1.FreeSerif = !0;
    e1["Friz Quadrata"] = !0;
    e1.Garamond = !0;
    e1.Gentium = !0;
    e1.Georgia = !0;
    e1.Gloucester = !0;
    e1["Goudy Old Style"] = !0;
    e1["Goudy Schoolbook"] = !0;
    e1["Goudy Pro Font"] = !0;
    e1.Granjon = !0;
    e1["Guardian Egyptian"] = !0;
    e1.Heather = !0;
    e1.Hercules = !0;
    e1["High Tower Text"] = !0;
    e1.Hiroshige = !0;
    e1["Hoefler Text"] = !0;
    e1["Humana Serif"] = !0;
    e1.Imprint = !0;
    e1["Ionic No. 5"] = !0;
    e1.Janson = !0;
    e1.Joanna = !0;
    e1.Korinna = !0;
    e1.Lexicon = !0;
    e1.LiberationSerif = !0;
    e1["Liberation Serif"] = !0;
    e1["Linux Libertine"] = !0;
    e1.Literaturnaya = !0;
    e1.Lucida = !0;
    e1["Lucida Bright"] = !0;
    e1.Melior = !0;
    e1.Memphis = !0;
    e1.Miller = !0;
    e1.Minion = !0;
    e1.Modern = !0;
    e1["Mona Lisa"] = !0;
    e1["Mrs Eaves"] = !0;
    e1["MS Serif"] = !0;
    e1["Museo Slab"] = !0;
    e1["New York"] = !0;
    e1["Nimbus Roman"] = !0;
    e1["NPS Rawlinson Roadway"] = !0;
    e1.NuptialScript = !0;
    e1.Palatino = !0;
    e1.Perpetua = !0;
    e1.Plantin = !0;
    e1["Plantin Schoolbook"] = !0;
    e1.Playbill = !0;
    e1["Poor Richard"] = !0;
    e1["Rawlinson Roadway"] = !0;
    e1.Renault = !0;
    e1.Requiem = !0;
    e1.Rockwell = !0;
    e1.Roman = !0;
    e1["Rotis Serif"] = !0;
    e1.Sabon = !0;
    e1.Scala = !0;
    e1.Seagull = !0;
    e1.Sistina = !0;
    e1.Souvenir = !0;
    e1.STIX = !0;
    e1["Stone Informal"] = !0;
    e1["Stone Serif"] = !0;
    e1.Sylfaen = !0;
    e1.Times = !0;
    e1.Trajan = !0;
    e1["Trinité"] = !0;
    e1["Trump Mediaeval"] = !0;
    e1.Utopia = !0;
    e1["Vale Type"] = !0;
    e1["Bitstream Vera"] = !0;
    e1["Vera Serif"] = !0;
    e1.Versailles = !0;
    e1.Wanted = !0;
    e1.Weiss = !0;
    e1["Wide Latin"] = !0;
    e1.Windsor = !0;
    e1.XITS = !0;
}), Lr = getLookupTableFactory(function(e1) {
    e1.Dingbats = !0;
    e1.Symbol = !0;
    e1.ZapfDingbats = !0;
    e1.Wingdings = !0;
    e1["Wingdings-Bold"] = !0;
    e1["Wingdings-Regular"] = !0;
}), jr = getLookupTableFactory(function(e1) {
    e1[2] = 10;
    e1[3] = 32;
    e1[4] = 33;
    e1[5] = 34;
    e1[6] = 35;
    e1[7] = 36;
    e1[8] = 37;
    e1[9] = 38;
    e1[10] = 39;
    e1[11] = 40;
    e1[12] = 41;
    e1[13] = 42;
    e1[14] = 43;
    e1[15] = 44;
    e1[16] = 45;
    e1[17] = 46;
    e1[18] = 47;
    e1[19] = 48;
    e1[20] = 49;
    e1[21] = 50;
    e1[22] = 51;
    e1[23] = 52;
    e1[24] = 53;
    e1[25] = 54;
    e1[26] = 55;
    e1[27] = 56;
    e1[28] = 57;
    e1[29] = 58;
    e1[30] = 894;
    e1[31] = 60;
    e1[32] = 61;
    e1[33] = 62;
    e1[34] = 63;
    e1[35] = 64;
    e1[36] = 65;
    e1[37] = 66;
    e1[38] = 67;
    e1[39] = 68;
    e1[40] = 69;
    e1[41] = 70;
    e1[42] = 71;
    e1[43] = 72;
    e1[44] = 73;
    e1[45] = 74;
    e1[46] = 75;
    e1[47] = 76;
    e1[48] = 77;
    e1[49] = 78;
    e1[50] = 79;
    e1[51] = 80;
    e1[52] = 81;
    e1[53] = 82;
    e1[54] = 83;
    e1[55] = 84;
    e1[56] = 85;
    e1[57] = 86;
    e1[58] = 87;
    e1[59] = 88;
    e1[60] = 89;
    e1[61] = 90;
    e1[62] = 91;
    e1[63] = 92;
    e1[64] = 93;
    e1[65] = 94;
    e1[66] = 95;
    e1[67] = 96;
    e1[68] = 97;
    e1[69] = 98;
    e1[70] = 99;
    e1[71] = 100;
    e1[72] = 101;
    e1[73] = 102;
    e1[74] = 103;
    e1[75] = 104;
    e1[76] = 105;
    e1[77] = 106;
    e1[78] = 107;
    e1[79] = 108;
    e1[80] = 109;
    e1[81] = 110;
    e1[82] = 111;
    e1[83] = 112;
    e1[84] = 113;
    e1[85] = 114;
    e1[86] = 115;
    e1[87] = 116;
    e1[88] = 117;
    e1[89] = 118;
    e1[90] = 119;
    e1[91] = 120;
    e1[92] = 121;
    e1[93] = 122;
    e1[94] = 123;
    e1[95] = 124;
    e1[96] = 125;
    e1[97] = 126;
    e1[98] = 196;
    e1[99] = 197;
    e1[100] = 199;
    e1[101] = 201;
    e1[102] = 209;
    e1[103] = 214;
    e1[104] = 220;
    e1[105] = 225;
    e1[106] = 224;
    e1[107] = 226;
    e1[108] = 228;
    e1[109] = 227;
    e1[110] = 229;
    e1[111] = 231;
    e1[112] = 233;
    e1[113] = 232;
    e1[114] = 234;
    e1[115] = 235;
    e1[116] = 237;
    e1[117] = 236;
    e1[118] = 238;
    e1[119] = 239;
    e1[120] = 241;
    e1[121] = 243;
    e1[122] = 242;
    e1[123] = 244;
    e1[124] = 246;
    e1[125] = 245;
    e1[126] = 250;
    e1[127] = 249;
    e1[128] = 251;
    e1[129] = 252;
    e1[130] = 8224;
    e1[131] = 176;
    e1[132] = 162;
    e1[133] = 163;
    e1[134] = 167;
    e1[135] = 8226;
    e1[136] = 182;
    e1[137] = 223;
    e1[138] = 174;
    e1[139] = 169;
    e1[140] = 8482;
    e1[141] = 180;
    e1[142] = 168;
    e1[143] = 8800;
    e1[144] = 198;
    e1[145] = 216;
    e1[146] = 8734;
    e1[147] = 177;
    e1[148] = 8804;
    e1[149] = 8805;
    e1[150] = 165;
    e1[151] = 181;
    e1[152] = 8706;
    e1[153] = 8721;
    e1[154] = 8719;
    e1[156] = 8747;
    e1[157] = 170;
    e1[158] = 186;
    e1[159] = 8486;
    e1[160] = 230;
    e1[161] = 248;
    e1[162] = 191;
    e1[163] = 161;
    e1[164] = 172;
    e1[165] = 8730;
    e1[166] = 402;
    e1[167] = 8776;
    e1[168] = 8710;
    e1[169] = 171;
    e1[170] = 187;
    e1[171] = 8230;
    e1[179] = 8220;
    e1[180] = 8221;
    e1[181] = 8216;
    e1[182] = 8217;
    e1[200] = 193;
    e1[203] = 205;
    e1[207] = 211;
    e1[210] = 218;
    e1[223] = 711;
    e1[224] = 321;
    e1[225] = 322;
    e1[226] = 352;
    e1[227] = 353;
    e1[228] = 381;
    e1[229] = 382;
    e1[233] = 221;
    e1[234] = 253;
    e1[252] = 263;
    e1[253] = 268;
    e1[254] = 269;
    e1[258] = 258;
    e1[260] = 260;
    e1[261] = 261;
    e1[265] = 280;
    e1[266] = 281;
    e1[267] = 282;
    e1[268] = 283;
    e1[269] = 313;
    e1[275] = 323;
    e1[276] = 324;
    e1[278] = 328;
    e1[283] = 344;
    e1[284] = 345;
    e1[285] = 346;
    e1[286] = 347;
    e1[292] = 367;
    e1[295] = 377;
    e1[296] = 378;
    e1[298] = 380;
    e1[305] = 963;
    e1[306] = 964;
    e1[307] = 966;
    e1[308] = 8215;
    e1[309] = 8252;
    e1[310] = 8319;
    e1[311] = 8359;
    e1[312] = 8592;
    e1[313] = 8593;
    e1[337] = 9552;
    e1[493] = 1039;
    e1[494] = 1040;
    e1[570] = 1040;
    e1[571] = 1041;
    e1[572] = 1042;
    e1[573] = 1043;
    e1[574] = 1044;
    e1[575] = 1045;
    e1[576] = 1046;
    e1[577] = 1047;
    e1[578] = 1048;
    e1[579] = 1049;
    e1[580] = 1050;
    e1[581] = 1051;
    e1[582] = 1052;
    e1[583] = 1053;
    e1[584] = 1054;
    e1[585] = 1055;
    e1[586] = 1056;
    e1[587] = 1057;
    e1[588] = 1058;
    e1[589] = 1059;
    e1[590] = 1060;
    e1[591] = 1061;
    e1[592] = 1062;
    e1[593] = 1063;
    e1[594] = 1064;
    e1[595] = 1065;
    e1[596] = 1066;
    e1[597] = 1067;
    e1[598] = 1068;
    e1[599] = 1069;
    e1[600] = 1070;
    e1[672] = 1488;
    e1[673] = 1489;
    e1[674] = 1490;
    e1[675] = 1491;
    e1[676] = 1492;
    e1[677] = 1493;
    e1[678] = 1494;
    e1[679] = 1495;
    e1[680] = 1496;
    e1[681] = 1497;
    e1[682] = 1498;
    e1[683] = 1499;
    e1[684] = 1500;
    e1[685] = 1501;
    e1[686] = 1502;
    e1[687] = 1503;
    e1[688] = 1504;
    e1[689] = 1505;
    e1[690] = 1506;
    e1[691] = 1507;
    e1[692] = 1508;
    e1[693] = 1509;
    e1[694] = 1510;
    e1[695] = 1511;
    e1[696] = 1512;
    e1[697] = 1513;
    e1[698] = 1514;
    e1[705] = 1524;
    e1[706] = 8362;
    e1[710] = 64288;
    e1[711] = 64298;
    e1[759] = 1617;
    e1[761] = 1776;
    e1[763] = 1778;
    e1[775] = 1652;
    e1[777] = 1764;
    e1[778] = 1780;
    e1[779] = 1781;
    e1[780] = 1782;
    e1[782] = 771;
    e1[783] = 64726;
    e1[786] = 8363;
    e1[788] = 8532;
    e1[790] = 768;
    e1[791] = 769;
    e1[792] = 768;
    e1[795] = 803;
    e1[797] = 64336;
    e1[798] = 64337;
    e1[799] = 64342;
    e1[800] = 64343;
    e1[801] = 64344;
    e1[802] = 64345;
    e1[803] = 64362;
    e1[804] = 64363;
    e1[805] = 64364;
    e1[2424] = 7821;
    e1[2425] = 7822;
    e1[2426] = 7823;
    e1[2427] = 7824;
    e1[2428] = 7825;
    e1[2429] = 7826;
    e1[2430] = 7827;
    e1[2433] = 7682;
    e1[2678] = 8045;
    e1[2679] = 8046;
    e1[2830] = 1552;
    e1[2838] = 686;
    e1[2840] = 751;
    e1[2842] = 753;
    e1[2843] = 754;
    e1[2844] = 755;
    e1[2846] = 757;
    e1[2856] = 767;
    e1[2857] = 848;
    e1[2858] = 849;
    e1[2862] = 853;
    e1[2863] = 854;
    e1[2864] = 855;
    e1[2865] = 861;
    e1[2866] = 862;
    e1[2906] = 7460;
    e1[2908] = 7462;
    e1[2909] = 7463;
    e1[2910] = 7464;
    e1[2912] = 7466;
    e1[2913] = 7467;
    e1[2914] = 7468;
    e1[2916] = 7470;
    e1[2917] = 7471;
    e1[2918] = 7472;
    e1[2920] = 7474;
    e1[2921] = 7475;
    e1[2922] = 7476;
    e1[2924] = 7478;
    e1[2925] = 7479;
    e1[2926] = 7480;
    e1[2928] = 7482;
    e1[2929] = 7483;
    e1[2930] = 7484;
    e1[2932] = 7486;
    e1[2933] = 7487;
    e1[2934] = 7488;
    e1[2936] = 7490;
    e1[2937] = 7491;
    e1[2938] = 7492;
    e1[2940] = 7494;
    e1[2941] = 7495;
    e1[2942] = 7496;
    e1[2944] = 7498;
    e1[2946] = 7500;
    e1[2948] = 7502;
    e1[2950] = 7504;
    e1[2951] = 7505;
    e1[2952] = 7506;
    e1[2954] = 7508;
    e1[2955] = 7509;
    e1[2956] = 7510;
    e1[2958] = 7512;
    e1[2959] = 7513;
    e1[2960] = 7514;
    e1[2962] = 7516;
    e1[2963] = 7517;
    e1[2964] = 7518;
    e1[2966] = 7520;
    e1[2967] = 7521;
    e1[2968] = 7522;
    e1[2970] = 7524;
    e1[2971] = 7525;
    e1[2972] = 7526;
    e1[2974] = 7528;
    e1[2975] = 7529;
    e1[2976] = 7530;
    e1[2978] = 1537;
    e1[2979] = 1538;
    e1[2980] = 1539;
    e1[2982] = 1549;
    e1[2983] = 1551;
    e1[2984] = 1552;
    e1[2986] = 1554;
    e1[2987] = 1555;
    e1[2988] = 1556;
    e1[2990] = 1623;
    e1[2991] = 1624;
    e1[2995] = 1775;
    e1[2999] = 1791;
    e1[3002] = 64290;
    e1[3003] = 64291;
    e1[3004] = 64292;
    e1[3006] = 64294;
    e1[3007] = 64295;
    e1[3008] = 64296;
    e1[3011] = 1900;
    e1[3014] = 8223;
    e1[3015] = 8244;
    e1[3017] = 7532;
    e1[3018] = 7533;
    e1[3019] = 7534;
    e1[3075] = 7590;
    e1[3076] = 7591;
    e1[3079] = 7594;
    e1[3080] = 7595;
    e1[3083] = 7598;
    e1[3084] = 7599;
    e1[3087] = 7602;
    e1[3088] = 7603;
    e1[3091] = 7606;
    e1[3092] = 7607;
    e1[3095] = 7610;
    e1[3096] = 7611;
    e1[3099] = 7614;
    e1[3100] = 7615;
    e1[3103] = 7618;
    e1[3104] = 7619;
    e1[3107] = 8337;
    e1[3108] = 8338;
    e1[3116] = 1884;
    e1[3119] = 1885;
    e1[3120] = 1885;
    e1[3123] = 1886;
    e1[3124] = 1886;
    e1[3127] = 1887;
    e1[3128] = 1887;
    e1[3131] = 1888;
    e1[3132] = 1888;
    e1[3135] = 1889;
    e1[3136] = 1889;
    e1[3139] = 1890;
    e1[3140] = 1890;
    e1[3143] = 1891;
    e1[3144] = 1891;
    e1[3147] = 1892;
    e1[3148] = 1892;
    e1[3153] = 580;
    e1[3154] = 581;
    e1[3157] = 584;
    e1[3158] = 585;
    e1[3161] = 588;
    e1[3162] = 589;
    e1[3165] = 891;
    e1[3166] = 892;
    e1[3169] = 1274;
    e1[3170] = 1275;
    e1[3173] = 1278;
    e1[3174] = 1279;
    e1[3181] = 7622;
    e1[3182] = 7623;
    e1[3282] = 11799;
    e1[3316] = 578;
    e1[3379] = 42785;
    e1[3393] = 1159;
    e1[3416] = 8377;
}), _r = getLookupTableFactory(function(e1) {
    e1[227] = 322;
    e1[264] = 261;
    e1[291] = 346;
}), Ur = getLookupTableFactory(function(e1) {
    e1[1] = 32;
    e1[4] = 65;
    e1[5] = 192;
    e1[6] = 193;
    e1[9] = 196;
    e1[17] = 66;
    e1[18] = 67;
    e1[21] = 268;
    e1[24] = 68;
    e1[28] = 69;
    e1[29] = 200;
    e1[30] = 201;
    e1[32] = 282;
    e1[38] = 70;
    e1[39] = 71;
    e1[44] = 72;
    e1[47] = 73;
    e1[48] = 204;
    e1[49] = 205;
    e1[58] = 74;
    e1[60] = 75;
    e1[62] = 76;
    e1[68] = 77;
    e1[69] = 78;
    e1[75] = 79;
    e1[76] = 210;
    e1[80] = 214;
    e1[87] = 80;
    e1[89] = 81;
    e1[90] = 82;
    e1[92] = 344;
    e1[94] = 83;
    e1[97] = 352;
    e1[100] = 84;
    e1[104] = 85;
    e1[109] = 220;
    e1[115] = 86;
    e1[116] = 87;
    e1[121] = 88;
    e1[122] = 89;
    e1[124] = 221;
    e1[127] = 90;
    e1[129] = 381;
    e1[258] = 97;
    e1[259] = 224;
    e1[260] = 225;
    e1[263] = 228;
    e1[268] = 261;
    e1[271] = 98;
    e1[272] = 99;
    e1[273] = 263;
    e1[275] = 269;
    e1[282] = 100;
    e1[286] = 101;
    e1[287] = 232;
    e1[288] = 233;
    e1[290] = 283;
    e1[295] = 281;
    e1[296] = 102;
    e1[336] = 103;
    e1[346] = 104;
    e1[349] = 105;
    e1[350] = 236;
    e1[351] = 237;
    e1[361] = 106;
    e1[364] = 107;
    e1[367] = 108;
    e1[371] = 322;
    e1[373] = 109;
    e1[374] = 110;
    e1[381] = 111;
    e1[382] = 242;
    e1[383] = 243;
    e1[386] = 246;
    e1[393] = 112;
    e1[395] = 113;
    e1[396] = 114;
    e1[398] = 345;
    e1[400] = 115;
    e1[401] = 347;
    e1[403] = 353;
    e1[410] = 116;
    e1[437] = 117;
    e1[442] = 252;
    e1[448] = 118;
    e1[449] = 119;
    e1[454] = 120;
    e1[455] = 121;
    e1[457] = 253;
    e1[460] = 122;
    e1[462] = 382;
    e1[463] = 380;
    e1[853] = 44;
    e1[855] = 58;
    e1[856] = 46;
    e1[876] = 47;
    e1[878] = 45;
    e1[882] = 45;
    e1[894] = 40;
    e1[895] = 41;
    e1[896] = 91;
    e1[897] = 93;
    e1[923] = 64;
    e1[940] = 163;
    e1[1004] = 48;
    e1[1005] = 49;
    e1[1006] = 50;
    e1[1007] = 51;
    e1[1008] = 52;
    e1[1009] = 53;
    e1[1010] = 54;
    e1[1011] = 55;
    e1[1012] = 56;
    e1[1013] = 57;
    e1[1081] = 37;
    e1[1085] = 43;
    e1[1086] = 45;
});
function getStandardFontName(e1) {
    const t = normalizeFontName(e1);
    return Rr()[t];
}
function isKnownFontName(e1) {
    const t = normalizeFontName(e1);
    return !!(Rr()[t] || Er()[t] || Pr()[t] || Lr()[t]);
}
class ToUnicodeMap {
    constructor(e1 = []){
        this._map = e1;
    }
    get length() {
        return this._map.length;
    }
    forEach(e1) {
        for(const t in this._map)e1(t, this._map[t].codePointAt(0));
    }
    has(e1) {
        return void 0 !== this._map[e1];
    }
    get(e1) {
        return this._map[e1];
    }
    charCodeOf(e1) {
        const t = this._map;
        if (t.length <= 65536) return t.indexOf(e1);
        for(const a in t)if (t[a] === e1) return 0 | a;
        return -1;
    }
    amend(e1) {
        for(const t in e1)this._map[t] = e1[t];
    }
}
class IdentityToUnicodeMap {
    constructor(e1, t){
        this.firstChar = e1;
        this.lastChar = t;
    }
    get length() {
        return this.lastChar + 1 - this.firstChar;
    }
    forEach(e1) {
        for(let t = this.firstChar, a = this.lastChar; t <= a; t++)e1(t, t);
    }
    has(e1) {
        return this.firstChar <= e1 && e1 <= this.lastChar;
    }
    get(e1) {
        if (this.firstChar <= e1 && e1 <= this.lastChar) return String.fromCharCode(e1);
    }
    charCodeOf(e1) {
        return Number.isInteger(e1) && e1 >= this.firstChar && e1 <= this.lastChar ? e1 : -1;
    }
    amend(e1) {
        unreachable("Should not call amend()");
    }
}
class CFFFont {
    constructor(e1, t){
        this.properties = t;
        const a = new CFFParser(e1, t, pr);
        this.cff = a.parse();
        this.cff.duplicateFirstGlyph();
        const r = new CFFCompiler(this.cff);
        this.seacs = this.cff.seacs;
        try {
            this.data = r.compile();
        } catch  {
            warn("Failed to compile font " + t.loadedName);
            this.data = e1;
        }
        this._createBuiltInEncoding();
    }
    get numGlyphs() {
        return this.cff.charStrings.count;
    }
    getCharset() {
        return this.cff.charset.charset;
    }
    getGlyphMapping() {
        const e1 = this.cff, t = this.properties, { cidToGidMap: a, cMap: r } = t, i = e1.charset.charset;
        let n, s;
        if (t.composite) {
            let t, o;
            if (a?.length > 0) {
                t = Object.create(null);
                for(let e1 = 0, r = a.length; e1 < r; e1++){
                    const r = a[e1];
                    void 0 !== r && (t[r] = e1);
                }
            }
            n = Object.create(null);
            if (e1.isCIDFont) for(s = 0; s < i.length; s++){
                const e1 = i[s];
                o = r.charCodeOf(e1);
                void 0 !== t?.[o] && (o = t[o]);
                n[o] = s;
            }
            else for(s = 0; s < e1.charStrings.count; s++){
                o = r.charCodeOf(s);
                n[o] = s;
            }
            return n;
        }
        let o = e1.encoding ? e1.encoding.encoding : null;
        t.isInternalFont && (o = t.defaultEncoding);
        n = type1FontGlyphMapping(t, o, i);
        return n;
    }
    hasGlyphId(e1) {
        return this.cff.hasGlyphId(e1);
    }
    _createBuiltInEncoding() {
        const { charset: e1, encoding: t } = this.cff;
        if (!e1 || !t) return;
        const a = e1.charset, r = t.encoding, i = [];
        for(const e1 in r){
            const t = r[e1];
            if (t >= 0) {
                const r = a[t];
                r && (i[e1] = r);
            }
        }
        i.length > 0 && (this.properties.builtInEncoding = i);
    }
}
function getFloat214(e1, t) {
    return readInt16(e1, t) / 16384;
}
function getSubroutineBias(e1) {
    const t = e1.length;
    let a = 32768;
    t < 1240 ? a = 107 : t < 33900 && (a = 1131);
    return a;
}
function parseCmap(e1, t, a) {
    const r = 1 === readUint16(e1, t + 2) ? readUint32(e1, t + 8) : readUint32(e1, t + 16), i = readUint16(e1, t + r);
    let n, s, o;
    if (4 === i) {
        readUint16(e1, t + r + 2);
        const a = readUint16(e1, t + r + 6) >> 1;
        s = t + r + 14;
        n = [];
        for(o = 0; o < a; o++, s += 2)n[o] = {
            end: readUint16(e1, s)
        };
        s += 2;
        for(o = 0; o < a; o++, s += 2)n[o].start = readUint16(e1, s);
        for(o = 0; o < a; o++, s += 2)n[o].idDelta = readUint16(e1, s);
        for(o = 0; o < a; o++, s += 2){
            let t = readUint16(e1, s);
            if (0 !== t) {
                n[o].ids = [];
                for(let a = 0, r = n[o].end - n[o].start + 1; a < r; a++){
                    n[o].ids[a] = readUint16(e1, s + t);
                    t += 2;
                }
            }
        }
        return n;
    }
    if (12 === i) {
        const a = readUint32(e1, t + r + 12);
        s = t + r + 16;
        n = [];
        for(o = 0; o < a; o++){
            t = readUint32(e1, s);
            n.push({
                start: t,
                end: readUint32(e1, s + 4),
                idDelta: readUint32(e1, s + 8) - t
            });
            s += 12;
        }
        return n;
    }
    throw new FormatError(`unsupported cmap: ${i}`);
}
function parseCff(e1, t, a, r) {
    const i = new CFFParser(new Stream(e1, t, a - t), {}, r).parse();
    return {
        glyphs: i.charStrings.objects,
        subrs: i.topDict.privateDict?.subrsIndex?.objects,
        gsubrs: i.globalSubrIndex?.objects,
        isCFFCIDFont: i.isCIDFont,
        fdSelect: i.fdSelect,
        fdArray: i.fdArray
    };
}
function lookupCmap(e1, t) {
    const a = t.codePointAt(0);
    let r = 0, i = 0, n = e1.length - 1;
    for(; i < n;){
        const t = i + n + 1 >> 1;
        a < e1[t].start ? n = t - 1 : i = t;
    }
    e1[i].start <= a && a <= e1[i].end && (r = e1[i].idDelta + (e1[i].ids ? e1[i].ids[a - e1[i].start] : a) & 65535);
    return {
        charCode: a,
        glyphId: r
    };
}
function compileGlyf(e1, t, a) {
    function moveTo(e1, a) {
        s && t.add("L", s);
        s = [
            e1,
            a
        ];
        t.add("M", [
            e1,
            a
        ]);
    }
    function lineTo(e1, a) {
        t.add("L", [
            e1,
            a
        ]);
    }
    function quadraticCurveTo(e1, a, r, i) {
        t.add("Q", [
            e1,
            a,
            r,
            i
        ]);
    }
    let r = 0;
    const i = readInt16(e1, r);
    let n, s = null, o = 0, c = 0;
    r += 10;
    if (i < 0) do {
        n = readUint16(e1, r);
        const i = readUint16(e1, r + 2);
        r += 4;
        let s, l;
        if (1 & n) {
            if (2 & n) {
                s = readInt16(e1, r);
                l = readInt16(e1, r + 2);
            } else {
                s = readUint16(e1, r);
                l = readUint16(e1, r + 2);
            }
            r += 4;
        } else if (2 & n) {
            s = readInt8(e1, r++);
            l = readInt8(e1, r++);
        } else {
            s = e1[r++];
            l = e1[r++];
        }
        if (2 & n) {
            o = s;
            c = l;
        } else {
            o = 0;
            c = 0;
        }
        let h = 1, u = 1, d = 0, f = 0;
        if (8 & n) {
            h = u = getFloat214(e1, r);
            r += 2;
        } else if (64 & n) {
            h = getFloat214(e1, r);
            u = getFloat214(e1, r + 2);
            r += 4;
        } else if (128 & n) {
            h = getFloat214(e1, r);
            d = getFloat214(e1, r + 2);
            f = getFloat214(e1, r + 4);
            u = getFloat214(e1, r + 6);
            r += 8;
        }
        const g = a.glyphs[i];
        if (g) {
            t.save();
            t.transform([
                h,
                d,
                f,
                u,
                o,
                c
            ]);
            compileGlyf(g, t, a);
            t.restore();
        }
    }while (32 & n)
    else {
        const t = [];
        let a, s;
        for(a = 0; a < i; a++){
            t.push(readUint16(e1, r));
            r += 2;
        }
        r += 2 + readUint16(e1, r);
        const l = t.at(-1) + 1, h = [];
        for(; h.length < l;){
            n = e1[r++];
            let t = 1;
            8 & n && (t += e1[r++]);
            for(; t-- > 0;)h.push({
                flags: n
            });
        }
        for(a = 0; a < l; a++){
            switch(18 & h[a].flags){
                case 0:
                    o += readInt16(e1, r);
                    r += 2;
                    break;
                case 2:
                    o -= e1[r++];
                    break;
                case 18:
                    o += e1[r++];
            }
            h[a].x = o;
        }
        for(a = 0; a < l; a++){
            switch(36 & h[a].flags){
                case 0:
                    c += readInt16(e1, r);
                    r += 2;
                    break;
                case 4:
                    c -= e1[r++];
                    break;
                case 36:
                    c += e1[r++];
            }
            h[a].y = c;
        }
        let u = 0;
        for(r = 0; r < i; r++){
            const e1 = t[r], i = h.slice(u, e1 + 1);
            if (1 & i[0].flags) i.push(i[0]);
            else if (1 & i.at(-1).flags) i.unshift(i.at(-1));
            else {
                const e1 = {
                    flags: 1,
                    x: (i[0].x + i.at(-1).x) / 2,
                    y: (i[0].y + i.at(-1).y) / 2
                };
                i.unshift(e1);
                i.push(e1);
            }
            moveTo(i[0].x, i[0].y);
            for(a = 1, s = i.length; a < s; a++)if (1 & i[a].flags) lineTo(i[a].x, i[a].y);
            else if (1 & i[a + 1].flags) {
                quadraticCurveTo(i[a].x, i[a].y, i[a + 1].x, i[a + 1].y);
                a++;
            } else quadraticCurveTo(i[a].x, i[a].y, (i[a].x + i[a + 1].x) / 2, (i[a].y + i[a + 1].y) / 2);
            u = e1 + 1;
        }
    }
}
function compileCharString(e1, t, a, r) {
    function moveTo(e1, a) {
        c && t.add("L", c);
        c = [
            e1,
            a
        ];
        t.add("M", [
            e1,
            a
        ]);
    }
    function lineTo(e1, a) {
        t.add("L", [
            e1,
            a
        ]);
    }
    function bezierCurveTo(e1, a, r, i, n, s) {
        t.add("C", [
            e1,
            a,
            r,
            i,
            n,
            s
        ]);
    }
    const i = [];
    let n = 0, s = 0, o = 0, c = null;
    !function parse(e1) {
        let c = 0;
        for(; c < e1.length;){
            let l, h, u, d, f, g, p, m, b, y = !1, w = e1[c++];
            switch(w){
                case 1:
                case 3:
                case 18:
                case 23:
                    o += i.length >> 1;
                    y = !0;
                    break;
                case 4:
                    s += i.pop();
                    moveTo(n, s);
                    y = !0;
                    break;
                case 5:
                    for(; i.length > 0;){
                        n += i.shift();
                        s += i.shift();
                        lineTo(n, s);
                    }
                    break;
                case 6:
                    for(; i.length > 0;){
                        n += i.shift();
                        lineTo(n, s);
                        if (0 === i.length) break;
                        s += i.shift();
                        lineTo(n, s);
                    }
                    break;
                case 7:
                    for(; i.length > 0;){
                        s += i.shift();
                        lineTo(n, s);
                        if (0 === i.length) break;
                        n += i.shift();
                        lineTo(n, s);
                    }
                    break;
                case 8:
                    for(; i.length > 0;){
                        l = n + i.shift();
                        u = s + i.shift();
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h + i.shift();
                        s = d + i.shift();
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    break;
                case 10:
                    m = i.pop();
                    b = null;
                    if (a.isCFFCIDFont) {
                        const e1 = a.fdSelect.getFDIndex(r);
                        if (e1 >= 0 && e1 < a.fdArray.length) {
                            const t = a.fdArray[e1];
                            let r;
                            t.privateDict?.subrsIndex && (r = t.privateDict.subrsIndex.objects);
                            if (r) {
                                m += getSubroutineBias(r);
                                b = r[m];
                            }
                        } else warn("Invalid fd index for glyph index.");
                    } else b = a.subrs[m + a.subrsBias];
                    b && parse(b);
                    break;
                case 11:
                    return;
                case 12:
                    w = e1[c++];
                    switch(w){
                        case 34:
                            l = n + i.shift();
                            h = l + i.shift();
                            f = s + i.shift();
                            n = h + i.shift();
                            bezierCurveTo(l, s, h, f, n, f);
                            l = n + i.shift();
                            h = l + i.shift();
                            n = h + i.shift();
                            bezierCurveTo(l, f, h, s, n, s);
                            break;
                        case 35:
                            l = n + i.shift();
                            u = s + i.shift();
                            h = l + i.shift();
                            d = u + i.shift();
                            n = h + i.shift();
                            s = d + i.shift();
                            bezierCurveTo(l, u, h, d, n, s);
                            l = n + i.shift();
                            u = s + i.shift();
                            h = l + i.shift();
                            d = u + i.shift();
                            n = h + i.shift();
                            s = d + i.shift();
                            bezierCurveTo(l, u, h, d, n, s);
                            i.pop();
                            break;
                        case 36:
                            l = n + i.shift();
                            f = s + i.shift();
                            h = l + i.shift();
                            g = f + i.shift();
                            n = h + i.shift();
                            bezierCurveTo(l, f, h, g, n, g);
                            l = n + i.shift();
                            h = l + i.shift();
                            p = g + i.shift();
                            n = h + i.shift();
                            bezierCurveTo(l, g, h, p, n, s);
                            break;
                        case 37:
                            const e2 = n, t1 = s;
                            l = n + i.shift();
                            u = s + i.shift();
                            h = l + i.shift();
                            d = u + i.shift();
                            n = h + i.shift();
                            s = d + i.shift();
                            bezierCurveTo(l, u, h, d, n, s);
                            l = n + i.shift();
                            u = s + i.shift();
                            h = l + i.shift();
                            d = u + i.shift();
                            n = h;
                            s = d;
                            Math.abs(n - e2) > Math.abs(s - t1) ? n += i.shift() : s += i.shift();
                            bezierCurveTo(l, u, h, d, n, s);
                            break;
                        default:
                            throw new FormatError(`unknown operator: 12 ${w}`);
                    }
                    break;
                case 14:
                    if (i.length >= 4) {
                        const e1 = i.pop(), r = i.pop();
                        s = i.pop();
                        n = i.pop();
                        t.save();
                        t.translate(n, s);
                        let o = lookupCmap(a.cmap, String.fromCharCode(a.glyphNameMap[nr[e1]]));
                        compileCharString(a.glyphs[o.glyphId], t, a, o.glyphId);
                        t.restore();
                        o = lookupCmap(a.cmap, String.fromCharCode(a.glyphNameMap[nr[r]]));
                        compileCharString(a.glyphs[o.glyphId], t, a, o.glyphId);
                    }
                    return;
                case 19:
                case 20:
                    o += i.length >> 1;
                    c += o + 7 >> 3;
                    y = !0;
                    break;
                case 21:
                    s += i.pop();
                    n += i.pop();
                    moveTo(n, s);
                    y = !0;
                    break;
                case 22:
                    n += i.pop();
                    moveTo(n, s);
                    y = !0;
                    break;
                case 24:
                    for(; i.length > 2;){
                        l = n + i.shift();
                        u = s + i.shift();
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h + i.shift();
                        s = d + i.shift();
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    n += i.shift();
                    s += i.shift();
                    lineTo(n, s);
                    break;
                case 25:
                    for(; i.length > 6;){
                        n += i.shift();
                        s += i.shift();
                        lineTo(n, s);
                    }
                    l = n + i.shift();
                    u = s + i.shift();
                    h = l + i.shift();
                    d = u + i.shift();
                    n = h + i.shift();
                    s = d + i.shift();
                    bezierCurveTo(l, u, h, d, n, s);
                    break;
                case 26:
                    i.length % 2 && (n += i.shift());
                    for(; i.length > 0;){
                        l = n;
                        u = s + i.shift();
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h;
                        s = d + i.shift();
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    break;
                case 27:
                    i.length % 2 && (s += i.shift());
                    for(; i.length > 0;){
                        l = n + i.shift();
                        u = s;
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h + i.shift();
                        s = d;
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    break;
                case 28:
                    i.push(readInt16(e1, c));
                    c += 2;
                    break;
                case 29:
                    m = i.pop() + a.gsubrsBias;
                    b = a.gsubrs[m];
                    b && parse(b);
                    break;
                case 30:
                    for(; i.length > 0;){
                        l = n;
                        u = s + i.shift();
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h + i.shift();
                        s = d + (1 === i.length ? i.shift() : 0);
                        bezierCurveTo(l, u, h, d, n, s);
                        if (0 === i.length) break;
                        l = n + i.shift();
                        u = s;
                        h = l + i.shift();
                        d = u + i.shift();
                        s = d + i.shift();
                        n = h + (1 === i.length ? i.shift() : 0);
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    break;
                case 31:
                    for(; i.length > 0;){
                        l = n + i.shift();
                        u = s;
                        h = l + i.shift();
                        d = u + i.shift();
                        s = d + i.shift();
                        n = h + (1 === i.length ? i.shift() : 0);
                        bezierCurveTo(l, u, h, d, n, s);
                        if (0 === i.length) break;
                        l = n;
                        u = s + i.shift();
                        h = l + i.shift();
                        d = u + i.shift();
                        n = h + i.shift();
                        s = d + (1 === i.length ? i.shift() : 0);
                        bezierCurveTo(l, u, h, d, n, s);
                    }
                    break;
                default:
                    if (w < 32) throw new FormatError(`unknown operator: ${w}`);
                    if (w < 247) i.push(w - 139);
                    else if (w < 251) i.push(256 * (w - 247) + e1[c++] + 108);
                    else if (w < 255) i.push(256 * -(w - 251) - e1[c++] - 108);
                    else {
                        i.push((e1[c] << 24 | e1[c + 1] << 16 | e1[c + 2] << 8 | e1[c + 3]) / 65536);
                        c += 4;
                    }
            }
            y && (i.length = 0);
        }
    }(e1);
}
class Commands {
    cmds = [];
    transformStack = [];
    currentTransform = [
        1,
        0,
        0,
        1,
        0,
        0
    ];
    add(e1, t) {
        if (t) {
            const { currentTransform: a } = this;
            for(let e1 = 0, r = t.length; e1 < r; e1 += 2)Util.applyTransform(t, a, e1);
            this.cmds.push(`${e1}${t.join(" ")}`);
        } else this.cmds.push(e1);
    }
    transform(e1) {
        this.currentTransform = Util.transform(this.currentTransform, e1);
    }
    translate(e1, t) {
        this.transform([
            1,
            0,
            0,
            1,
            e1,
            t
        ]);
    }
    save() {
        this.transformStack.push(this.currentTransform.slice());
    }
    restore() {
        this.currentTransform = this.transformStack.pop() || [
            1,
            0,
            0,
            1,
            0,
            0
        ];
    }
    getSVG() {
        return this.cmds.join("");
    }
}
class CompiledFont {
    constructor(e1){
        this.fontMatrix = e1;
        this.compiledGlyphs = Object.create(null);
        this.compiledCharCodeToGlyphId = Object.create(null);
    }
    getPathJs(e1) {
        const { charCode: t, glyphId: a } = lookupCmap(this.cmap, e1);
        let r, i = this.compiledGlyphs[a];
        if (void 0 === i) {
            try {
                i = this.compileGlyph(this.glyphs[a], a);
            } catch (e1) {
                i = "";
                r = e1;
            }
            this.compiledGlyphs[a] = i;
        }
        this.compiledCharCodeToGlyphId[t] ??= a;
        if (r) throw r;
        return i;
    }
    compileGlyph(e1, a) {
        if (!e1?.length || 14 === e1[0]) return "";
        let r = this.fontMatrix;
        if (this.isCFFCIDFont) {
            const e1 = this.fdSelect.getFDIndex(a);
            if (e1 >= 0 && e1 < this.fdArray.length) {
                r = this.fdArray[e1].getByName("FontMatrix") || t;
            } else warn("Invalid fd index for glyph index.");
        }
        assert(isNumberArray(r, 6), "Expected a valid fontMatrix.");
        const i = new Commands;
        i.transform(r.slice());
        this.compileGlyphImpl(e1, i, a);
        i.add("Z");
        return i.getSVG();
    }
    compileGlyphImpl() {
        unreachable("Children classes should implement this.");
    }
    hasBuiltPath(e1) {
        const { charCode: t, glyphId: a } = lookupCmap(this.cmap, e1);
        return void 0 !== this.compiledGlyphs[a] && void 0 !== this.compiledCharCodeToGlyphId[t];
    }
}
class TrueTypeCompiled extends CompiledFont {
    constructor(e1, t, a){
        super(a || [
            488e-6,
            0,
            0,
            488e-6,
            0,
            0
        ]);
        this.glyphs = e1;
        this.cmap = t;
    }
    compileGlyphImpl(e1, t) {
        compileGlyf(e1, t, this);
    }
}
class Type2Compiled extends CompiledFont {
    constructor(e1, t, a){
        super(a || [
            .001,
            0,
            0,
            .001,
            0,
            0
        ]);
        this.glyphs = e1.glyphs;
        this.gsubrs = e1.gsubrs || [];
        this.subrs = e1.subrs || [];
        this.cmap = t;
        this.glyphNameMap = lr();
        this.gsubrsBias = getSubroutineBias(this.gsubrs);
        this.subrsBias = getSubroutineBias(this.subrs);
        this.isCFFCIDFont = e1.isCFFCIDFont;
        this.fdSelect = e1.fdSelect;
        this.fdArray = e1.fdArray;
    }
    compileGlyphImpl(e1, t, a) {
        compileCharString(e1, t, this, a);
    }
}
class FontRendererFactory {
    static create(e1, t) {
        const a = new Uint8Array(e1.data);
        let r, i, n, s, o, c;
        const l = readUint16(a, 4);
        for(let e1 = 0, h = 12; e1 < l; e1++, h += 16){
            const e1 = bytesToString(a.subarray(h, h + 4)), l = readUint32(a, h + 8), u = readUint32(a, h + 12);
            switch(e1){
                case "cmap":
                    r = parseCmap(a, l);
                    break;
                case "glyf":
                    i = a.subarray(l, l + u);
                    break;
                case "loca":
                    n = a.subarray(l, l + u);
                    break;
                case "head":
                    c = readUint16(a, l + 18);
                    o = readUint16(a, l + 50);
                    break;
                case "CFF ":
                    s = parseCff(a, l, l + u, t);
            }
        }
        if (i) {
            const t = c ? [
                1 / c,
                0,
                0,
                1 / c,
                0,
                0
            ] : e1.fontMatrix;
            return new TrueTypeCompiled(function parseGlyfTable(e1, t, a) {
                let r, i;
                if (a) {
                    r = 4;
                    i = readUint32;
                } else {
                    r = 2;
                    i = (e1, t)=>2 * readUint16(e1, t);
                }
                const n = [];
                let s = i(t, 0);
                for(let a = r; a < t.length; a += r){
                    const r = i(t, a);
                    n.push(e1.subarray(s, r));
                    s = r;
                }
                return n;
            }(i, n, o), r, t);
        }
        return new Type2Compiled(s, r, e1.fontMatrix);
    }
}
const Xr = getLookupTableFactory(function(e1) {
    e1.Courier = 600;
    e1["Courier-Bold"] = 600;
    e1["Courier-BoldOblique"] = 600;
    e1["Courier-Oblique"] = 600;
    e1.Helvetica = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 278;
        e1.quotedbl = 355;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 667;
        e1.quoteright = 222;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 556;
        e1.at = 1015;
        e1.A = 667;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 500;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 278;
        e1.backslash = 278;
        e1.bracketright = 278;
        e1.asciicircum = 469;
        e1.underscore = 556;
        e1.quoteleft = 222;
        e1.a = 556;
        e1.b = 556;
        e1.c = 500;
        e1.d = 556;
        e1.e = 556;
        e1.f = 278;
        e1.g = 556;
        e1.h = 556;
        e1.i = 222;
        e1.j = 222;
        e1.k = 500;
        e1.l = 222;
        e1.m = 833;
        e1.n = 556;
        e1.o = 556;
        e1.p = 556;
        e1.q = 556;
        e1.r = 333;
        e1.s = 500;
        e1.t = 278;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 500;
        e1.braceleft = 334;
        e1.bar = 260;
        e1.braceright = 334;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 191;
        e1.quotedblleft = 333;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 537;
        e1.bullet = 350;
        e1.quotesinglbase = 222;
        e1.quotedblbase = 333;
        e1.quotedblright = 333;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 556;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 222;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 556;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 667;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 500;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 500;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 222;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 500;
        e1.scedilla = 500;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 556;
        e1.Amacron = 667;
        e1.rcaron = 333;
        e1.ccedilla = 500;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 643;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 584;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 500;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 260;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 333;
        e1.omacron = 556;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 222;
        e1.tcaron = 317;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 222;
        e1.Oacute = 778;
        e1.oacute = 556;
        e1.amacron = 556;
        e1.sacute = 500;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 556;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 299;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 556;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 556;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 556;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 556;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 556;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 556;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 500;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 584;
        e1.odieresis = 556;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 556;
        e1.eth = 556;
        e1.zcaron = 500;
        e1.ncommaaccent = 556;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 333;
        e1.quotedbl = 474;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 722;
        e1.quoteright = 278;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 611;
        e1.at = 975;
        e1.A = 722;
        e1.B = 722;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 556;
        e1.K = 722;
        e1.L = 611;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 584;
        e1.underscore = 556;
        e1.quoteleft = 278;
        e1.a = 556;
        e1.b = 611;
        e1.c = 556;
        e1.d = 611;
        e1.e = 556;
        e1.f = 333;
        e1.g = 611;
        e1.h = 611;
        e1.i = 278;
        e1.j = 278;
        e1.k = 556;
        e1.l = 278;
        e1.m = 889;
        e1.n = 611;
        e1.o = 611;
        e1.p = 611;
        e1.q = 611;
        e1.r = 389;
        e1.s = 556;
        e1.t = 333;
        e1.u = 611;
        e1.v = 556;
        e1.w = 778;
        e1.x = 556;
        e1.y = 556;
        e1.z = 500;
        e1.braceleft = 389;
        e1.bar = 280;
        e1.braceright = 389;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 238;
        e1.quotedblleft = 500;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 611;
        e1.fl = 611;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 556;
        e1.bullet = 350;
        e1.quotesinglbase = 278;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 611;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 611;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 722;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 556;
        e1.scommaaccent = 556;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 611;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 556;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 556;
        e1.scedilla = 556;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 611;
        e1.acircumflex = 556;
        e1.Amacron = 722;
        e1.rcaron = 389;
        e1.ccedilla = 556;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 743;
        e1.Umacron = 722;
        e1.uring = 611;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 584;
        e1.uacute = 611;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 556;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 556;
        e1.nacute = 611;
        e1.umacron = 611;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 280;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 611;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 389;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 611;
        e1.amacron = 556;
        e1.sacute = 556;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 611;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 611;
        e1.igrave = 278;
        e1.ohungarumlaut = 611;
        e1.Eogonek = 667;
        e1.dcroat = 611;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 400;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 611;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 611;
        e1.ntilde = 611;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 611;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 611;
        e1.Ccaron = 722;
        e1.ugrave = 611;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 611;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 556;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 611;
        e1.tcommaaccent = 333;
        e1.logicalnot = 584;
        e1.odieresis = 611;
        e1.udieresis = 611;
        e1.notequal = 549;
        e1.gcommaaccent = 611;
        e1.eth = 611;
        e1.zcaron = 500;
        e1.ncommaaccent = 611;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-BoldOblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 333;
        e1.quotedbl = 474;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 722;
        e1.quoteright = 278;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 611;
        e1.at = 975;
        e1.A = 722;
        e1.B = 722;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 556;
        e1.K = 722;
        e1.L = 611;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 584;
        e1.underscore = 556;
        e1.quoteleft = 278;
        e1.a = 556;
        e1.b = 611;
        e1.c = 556;
        e1.d = 611;
        e1.e = 556;
        e1.f = 333;
        e1.g = 611;
        e1.h = 611;
        e1.i = 278;
        e1.j = 278;
        e1.k = 556;
        e1.l = 278;
        e1.m = 889;
        e1.n = 611;
        e1.o = 611;
        e1.p = 611;
        e1.q = 611;
        e1.r = 389;
        e1.s = 556;
        e1.t = 333;
        e1.u = 611;
        e1.v = 556;
        e1.w = 778;
        e1.x = 556;
        e1.y = 556;
        e1.z = 500;
        e1.braceleft = 389;
        e1.bar = 280;
        e1.braceright = 389;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 238;
        e1.quotedblleft = 500;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 611;
        e1.fl = 611;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 556;
        e1.bullet = 350;
        e1.quotesinglbase = 278;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 611;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 611;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 722;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 556;
        e1.scommaaccent = 556;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 611;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 556;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 556;
        e1.scedilla = 556;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 611;
        e1.acircumflex = 556;
        e1.Amacron = 722;
        e1.rcaron = 389;
        e1.ccedilla = 556;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 743;
        e1.Umacron = 722;
        e1.uring = 611;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 584;
        e1.uacute = 611;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 556;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 556;
        e1.nacute = 611;
        e1.umacron = 611;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 280;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 611;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 389;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 611;
        e1.amacron = 556;
        e1.sacute = 556;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 611;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 611;
        e1.igrave = 278;
        e1.ohungarumlaut = 611;
        e1.Eogonek = 667;
        e1.dcroat = 611;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 400;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 611;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 611;
        e1.ntilde = 611;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 611;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 611;
        e1.Ccaron = 722;
        e1.ugrave = 611;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 611;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 556;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 611;
        e1.tcommaaccent = 333;
        e1.logicalnot = 584;
        e1.odieresis = 611;
        e1.udieresis = 611;
        e1.notequal = 549;
        e1.gcommaaccent = 611;
        e1.eth = 611;
        e1.zcaron = 500;
        e1.ncommaaccent = 611;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1["Helvetica-Oblique"] = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.exclam = 278;
        e1.quotedbl = 355;
        e1.numbersign = 556;
        e1.dollar = 556;
        e1.percent = 889;
        e1.ampersand = 667;
        e1.quoteright = 222;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 389;
        e1.plus = 584;
        e1.comma = 278;
        e1.hyphen = 333;
        e1.period = 278;
        e1.slash = 278;
        e1.zero = 556;
        e1.one = 556;
        e1.two = 556;
        e1.three = 556;
        e1.four = 556;
        e1.five = 556;
        e1.six = 556;
        e1.seven = 556;
        e1.eight = 556;
        e1.nine = 556;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 584;
        e1.equal = 584;
        e1.greater = 584;
        e1.question = 556;
        e1.at = 1015;
        e1.A = 667;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 722;
        e1.I = 278;
        e1.J = 500;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 722;
        e1.O = 778;
        e1.P = 667;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 667;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 944;
        e1.X = 667;
        e1.Y = 667;
        e1.Z = 611;
        e1.bracketleft = 278;
        e1.backslash = 278;
        e1.bracketright = 278;
        e1.asciicircum = 469;
        e1.underscore = 556;
        e1.quoteleft = 222;
        e1.a = 556;
        e1.b = 556;
        e1.c = 500;
        e1.d = 556;
        e1.e = 556;
        e1.f = 278;
        e1.g = 556;
        e1.h = 556;
        e1.i = 222;
        e1.j = 222;
        e1.k = 500;
        e1.l = 222;
        e1.m = 833;
        e1.n = 556;
        e1.o = 556;
        e1.p = 556;
        e1.q = 556;
        e1.r = 333;
        e1.s = 500;
        e1.t = 278;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 500;
        e1.braceleft = 334;
        e1.bar = 260;
        e1.braceright = 334;
        e1.asciitilde = 584;
        e1.exclamdown = 333;
        e1.cent = 556;
        e1.sterling = 556;
        e1.fraction = 167;
        e1.yen = 556;
        e1.florin = 556;
        e1.section = 556;
        e1.currency = 556;
        e1.quotesingle = 191;
        e1.quotedblleft = 333;
        e1.guillemotleft = 556;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 556;
        e1.dagger = 556;
        e1.daggerdbl = 556;
        e1.periodcentered = 278;
        e1.paragraph = 537;
        e1.bullet = 350;
        e1.quotesinglbase = 222;
        e1.quotedblbase = 333;
        e1.quotedblright = 333;
        e1.guillemotright = 556;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 611;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 370;
        e1.Lslash = 556;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 365;
        e1.ae = 889;
        e1.dotlessi = 278;
        e1.lslash = 222;
        e1.oslash = 611;
        e1.oe = 944;
        e1.germandbls = 611;
        e1.Idieresis = 278;
        e1.eacute = 556;
        e1.abreve = 556;
        e1.uhungarumlaut = 556;
        e1.ecaron = 556;
        e1.Ydieresis = 667;
        e1.divide = 584;
        e1.Yacute = 667;
        e1.Acircumflex = 667;
        e1.aacute = 556;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 500;
        e1.ecircumflex = 556;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 556;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 737;
        e1.Emacron = 667;
        e1.ccaron = 500;
        e1.aring = 556;
        e1.Ncommaaccent = 722;
        e1.lacute = 222;
        e1.agrave = 556;
        e1.Tcommaaccent = 611;
        e1.Cacute = 722;
        e1.atilde = 556;
        e1.Edotaccent = 667;
        e1.scaron = 500;
        e1.scedilla = 500;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 556;
        e1.Amacron = 667;
        e1.rcaron = 333;
        e1.ccedilla = 500;
        e1.Zdotaccent = 611;
        e1.Thorn = 667;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 667;
        e1.dcaron = 643;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 333;
        e1.Ograve = 778;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 584;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 556;
        e1.edieresis = 556;
        e1.cacute = 500;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 278;
        e1.plusminus = 584;
        e1.brokenbar = 260;
        e1.registered = 737;
        e1.Gbreve = 778;
        e1.Idotaccent = 278;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 333;
        e1.omacron = 556;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 222;
        e1.tcaron = 317;
        e1.eogonek = 556;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 556;
        e1.zacute = 500;
        e1.iogonek = 222;
        e1.Oacute = 778;
        e1.oacute = 556;
        e1.amacron = 556;
        e1.sacute = 500;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 333;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 556;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 834;
        e1.Scedilla = 667;
        e1.lcaron = 299;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 1e3;
        e1.edotaccent = 556;
        e1.Igrave = 278;
        e1.Imacron = 278;
        e1.Lcaron = 556;
        e1.onehalf = 834;
        e1.lessequal = 549;
        e1.ocircumflex = 556;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 556;
        e1.gbreve = 556;
        e1.onequarter = 834;
        e1.Scaron = 667;
        e1.Scommaaccent = 667;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 556;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 556;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 556;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 778;
        e1.zdotaccent = 500;
        e1.Ecaron = 667;
        e1.Iogonek = 278;
        e1.kcommaaccent = 500;
        e1.minus = 584;
        e1.Icircumflex = 278;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 584;
        e1.odieresis = 556;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 556;
        e1.eth = 556;
        e1.zcaron = 500;
        e1.ncommaaccent = 556;
        e1.onesuperior = 333;
        e1.imacron = 278;
        e1.Euro = 556;
    });
    e1.Symbol = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.universal = 713;
        e1.numbersign = 500;
        e1.existential = 549;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.suchthat = 439;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asteriskmath = 500;
        e1.plus = 549;
        e1.comma = 250;
        e1.minus = 549;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 549;
        e1.equal = 549;
        e1.greater = 549;
        e1.question = 444;
        e1.congruent = 549;
        e1.Alpha = 722;
        e1.Beta = 667;
        e1.Chi = 722;
        e1.Delta = 612;
        e1.Epsilon = 611;
        e1.Phi = 763;
        e1.Gamma = 603;
        e1.Eta = 722;
        e1.Iota = 333;
        e1.theta1 = 631;
        e1.Kappa = 722;
        e1.Lambda = 686;
        e1.Mu = 889;
        e1.Nu = 722;
        e1.Omicron = 722;
        e1.Pi = 768;
        e1.Theta = 741;
        e1.Rho = 556;
        e1.Sigma = 592;
        e1.Tau = 611;
        e1.Upsilon = 690;
        e1.sigma1 = 439;
        e1.Omega = 768;
        e1.Xi = 645;
        e1.Psi = 795;
        e1.Zeta = 611;
        e1.bracketleft = 333;
        e1.therefore = 863;
        e1.bracketright = 333;
        e1.perpendicular = 658;
        e1.underscore = 500;
        e1.radicalex = 500;
        e1.alpha = 631;
        e1.beta = 549;
        e1.chi = 549;
        e1.delta = 494;
        e1.epsilon = 439;
        e1.phi = 521;
        e1.gamma = 411;
        e1.eta = 603;
        e1.iota = 329;
        e1.phi1 = 603;
        e1.kappa = 549;
        e1.lambda = 549;
        e1.mu = 576;
        e1.nu = 521;
        e1.omicron = 549;
        e1.pi = 549;
        e1.theta = 521;
        e1.rho = 549;
        e1.sigma = 603;
        e1.tau = 439;
        e1.upsilon = 576;
        e1.omega1 = 713;
        e1.omega = 686;
        e1.xi = 493;
        e1.psi = 686;
        e1.zeta = 494;
        e1.braceleft = 480;
        e1.bar = 200;
        e1.braceright = 480;
        e1.similar = 549;
        e1.Euro = 750;
        e1.Upsilon1 = 620;
        e1.minute = 247;
        e1.lessequal = 549;
        e1.fraction = 167;
        e1.infinity = 713;
        e1.florin = 500;
        e1.club = 753;
        e1.diamond = 753;
        e1.heart = 753;
        e1.spade = 753;
        e1.arrowboth = 1042;
        e1.arrowleft = 987;
        e1.arrowup = 603;
        e1.arrowright = 987;
        e1.arrowdown = 603;
        e1.degree = 400;
        e1.plusminus = 549;
        e1.second = 411;
        e1.greaterequal = 549;
        e1.multiply = 549;
        e1.proportional = 713;
        e1.partialdiff = 494;
        e1.bullet = 460;
        e1.divide = 549;
        e1.notequal = 549;
        e1.equivalence = 549;
        e1.approxequal = 549;
        e1.ellipsis = 1e3;
        e1.arrowvertex = 603;
        e1.arrowhorizex = 1e3;
        e1.carriagereturn = 658;
        e1.aleph = 823;
        e1.Ifraktur = 686;
        e1.Rfraktur = 795;
        e1.weierstrass = 987;
        e1.circlemultiply = 768;
        e1.circleplus = 768;
        e1.emptyset = 823;
        e1.intersection = 768;
        e1.union = 768;
        e1.propersuperset = 713;
        e1.reflexsuperset = 713;
        e1.notsubset = 713;
        e1.propersubset = 713;
        e1.reflexsubset = 713;
        e1.element = 713;
        e1.notelement = 713;
        e1.angle = 768;
        e1.gradient = 713;
        e1.registerserif = 790;
        e1.copyrightserif = 790;
        e1.trademarkserif = 890;
        e1.product = 823;
        e1.radical = 549;
        e1.dotmath = 250;
        e1.logicalnot = 713;
        e1.logicaland = 603;
        e1.logicalor = 603;
        e1.arrowdblboth = 1042;
        e1.arrowdblleft = 987;
        e1.arrowdblup = 603;
        e1.arrowdblright = 987;
        e1.arrowdbldown = 603;
        e1.lozenge = 494;
        e1.angleleft = 329;
        e1.registersans = 790;
        e1.copyrightsans = 790;
        e1.trademarksans = 786;
        e1.summation = 713;
        e1.parenlefttp = 384;
        e1.parenleftex = 384;
        e1.parenleftbt = 384;
        e1.bracketlefttp = 384;
        e1.bracketleftex = 384;
        e1.bracketleftbt = 384;
        e1.bracelefttp = 494;
        e1.braceleftmid = 494;
        e1.braceleftbt = 494;
        e1.braceex = 494;
        e1.angleright = 329;
        e1.integral = 274;
        e1.integraltp = 686;
        e1.integralex = 686;
        e1.integralbt = 686;
        e1.parenrighttp = 384;
        e1.parenrightex = 384;
        e1.parenrightbt = 384;
        e1.bracketrighttp = 384;
        e1.bracketrightex = 384;
        e1.bracketrightbt = 384;
        e1.bracerighttp = 494;
        e1.bracerightmid = 494;
        e1.bracerightbt = 494;
        e1.apple = 790;
    });
    e1["Times-Roman"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 408;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 564;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 278;
        e1.semicolon = 278;
        e1.less = 564;
        e1.equal = 564;
        e1.greater = 564;
        e1.question = 444;
        e1.at = 921;
        e1.A = 722;
        e1.B = 667;
        e1.C = 667;
        e1.D = 722;
        e1.E = 611;
        e1.F = 556;
        e1.G = 722;
        e1.H = 722;
        e1.I = 333;
        e1.J = 389;
        e1.K = 722;
        e1.L = 611;
        e1.M = 889;
        e1.N = 722;
        e1.O = 722;
        e1.P = 556;
        e1.Q = 722;
        e1.R = 667;
        e1.S = 556;
        e1.T = 611;
        e1.U = 722;
        e1.V = 722;
        e1.W = 944;
        e1.X = 722;
        e1.Y = 722;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 469;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 444;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 500;
        e1.i = 278;
        e1.j = 278;
        e1.k = 500;
        e1.l = 278;
        e1.m = 778;
        e1.n = 500;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 333;
        e1.s = 389;
        e1.t = 278;
        e1.u = 500;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 444;
        e1.braceleft = 480;
        e1.bar = 200;
        e1.braceright = 480;
        e1.asciitilde = 541;
        e1.exclamdown = 333;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 180;
        e1.quotedblleft = 444;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 453;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 444;
        e1.quotedblright = 444;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 444;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 889;
        e1.ordfeminine = 276;
        e1.Lslash = 611;
        e1.Oslash = 722;
        e1.OE = 889;
        e1.ordmasculine = 310;
        e1.ae = 667;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 500;
        e1.Idieresis = 333;
        e1.eacute = 444;
        e1.abreve = 444;
        e1.uhungarumlaut = 500;
        e1.ecaron = 444;
        e1.Ydieresis = 722;
        e1.divide = 564;
        e1.Yacute = 722;
        e1.Acircumflex = 722;
        e1.aacute = 444;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 444;
        e1.Uacute = 722;
        e1.uogonek = 500;
        e1.Edieresis = 611;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 760;
        e1.Emacron = 611;
        e1.ccaron = 444;
        e1.aring = 444;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 444;
        e1.Tcommaaccent = 611;
        e1.Cacute = 667;
        e1.atilde = 444;
        e1.Edotaccent = 611;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 667;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 500;
        e1.acircumflex = 444;
        e1.Amacron = 722;
        e1.rcaron = 333;
        e1.ccedilla = 444;
        e1.Zdotaccent = 611;
        e1.Thorn = 556;
        e1.Omacron = 722;
        e1.Racute = 667;
        e1.Sacute = 556;
        e1.dcaron = 588;
        e1.Umacron = 722;
        e1.uring = 500;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 564;
        e1.uacute = 500;
        e1.Tcaron = 611;
        e1.partialdiff = 476;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 611;
        e1.adieresis = 444;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 500;
        e1.umacron = 500;
        e1.Ncaron = 722;
        e1.Iacute = 333;
        e1.plusminus = 564;
        e1.brokenbar = 200;
        e1.registered = 760;
        e1.Gbreve = 722;
        e1.Idotaccent = 333;
        e1.summation = 600;
        e1.Egrave = 611;
        e1.racute = 333;
        e1.omacron = 500;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 326;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 444;
        e1.zacute = 444;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 444;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 500;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 611;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 344;
        e1.Kcommaaccent = 722;
        e1.Lacute = 611;
        e1.trademark = 980;
        e1.edotaccent = 444;
        e1.Igrave = 333;
        e1.Imacron = 333;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 500;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 611;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 500;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 333;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 667;
        e1.Lcommaaccent = 611;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 722;
        e1.zdotaccent = 444;
        e1.Ecaron = 611;
        e1.Iogonek = 333;
        e1.kcommaaccent = 500;
        e1.minus = 564;
        e1.Icircumflex = 333;
        e1.ncaron = 500;
        e1.tcommaaccent = 278;
        e1.logicalnot = 564;
        e1.odieresis = 500;
        e1.udieresis = 500;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 444;
        e1.ncommaaccent = 500;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-Bold"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 555;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 1e3;
        e1.ampersand = 833;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 570;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 570;
        e1.equal = 570;
        e1.greater = 570;
        e1.question = 500;
        e1.at = 930;
        e1.A = 722;
        e1.B = 667;
        e1.C = 722;
        e1.D = 722;
        e1.E = 667;
        e1.F = 611;
        e1.G = 778;
        e1.H = 778;
        e1.I = 389;
        e1.J = 500;
        e1.K = 778;
        e1.L = 667;
        e1.M = 944;
        e1.N = 722;
        e1.O = 778;
        e1.P = 611;
        e1.Q = 778;
        e1.R = 722;
        e1.S = 556;
        e1.T = 667;
        e1.U = 722;
        e1.V = 722;
        e1.W = 1e3;
        e1.X = 722;
        e1.Y = 722;
        e1.Z = 667;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 581;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 556;
        e1.c = 444;
        e1.d = 556;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 556;
        e1.i = 278;
        e1.j = 333;
        e1.k = 556;
        e1.l = 278;
        e1.m = 833;
        e1.n = 556;
        e1.o = 500;
        e1.p = 556;
        e1.q = 556;
        e1.r = 444;
        e1.s = 389;
        e1.t = 333;
        e1.u = 556;
        e1.v = 500;
        e1.w = 722;
        e1.x = 500;
        e1.y = 500;
        e1.z = 444;
        e1.braceleft = 394;
        e1.bar = 220;
        e1.braceright = 394;
        e1.asciitilde = 520;
        e1.exclamdown = 333;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 278;
        e1.quotedblleft = 500;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 540;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 1e3;
        e1.ordfeminine = 300;
        e1.Lslash = 667;
        e1.Oslash = 778;
        e1.OE = 1e3;
        e1.ordmasculine = 330;
        e1.ae = 722;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 556;
        e1.Idieresis = 389;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 556;
        e1.ecaron = 444;
        e1.Ydieresis = 722;
        e1.divide = 570;
        e1.Yacute = 722;
        e1.Acircumflex = 722;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 500;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 747;
        e1.Emacron = 667;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 667;
        e1.Cacute = 722;
        e1.atilde = 500;
        e1.Edotaccent = 667;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 722;
        e1.Gcommaaccent = 778;
        e1.ucircumflex = 556;
        e1.acircumflex = 500;
        e1.Amacron = 722;
        e1.rcaron = 444;
        e1.ccedilla = 444;
        e1.Zdotaccent = 667;
        e1.Thorn = 611;
        e1.Omacron = 778;
        e1.Racute = 722;
        e1.Sacute = 556;
        e1.dcaron = 672;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 300;
        e1.Ograve = 778;
        e1.Agrave = 722;
        e1.Abreve = 722;
        e1.multiply = 570;
        e1.uacute = 556;
        e1.Tcaron = 667;
        e1.partialdiff = 494;
        e1.ydieresis = 500;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 389;
        e1.plusminus = 570;
        e1.brokenbar = 220;
        e1.registered = 747;
        e1.Gbreve = 778;
        e1.Idotaccent = 389;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 444;
        e1.omacron = 500;
        e1.Zacute = 667;
        e1.Zcaron = 667;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 722;
        e1.lcommaaccent = 278;
        e1.tcaron = 416;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 722;
        e1.Adieresis = 722;
        e1.egrave = 444;
        e1.zacute = 444;
        e1.iogonek = 278;
        e1.Oacute = 778;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 778;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 556;
        e1.twosuperior = 300;
        e1.Odieresis = 778;
        e1.mu = 556;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 667;
        e1.dcroat = 556;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 394;
        e1.Kcommaaccent = 778;
        e1.Lacute = 667;
        e1.trademark = 1e3;
        e1.edotaccent = 444;
        e1.Igrave = 389;
        e1.Imacron = 389;
        e1.Lcaron = 667;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 778;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 722;
        e1.ugrave = 556;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 444;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 722;
        e1.Lcommaaccent = 667;
        e1.Atilde = 722;
        e1.Aogonek = 722;
        e1.Aring = 722;
        e1.Otilde = 778;
        e1.zdotaccent = 444;
        e1.Ecaron = 667;
        e1.Iogonek = 389;
        e1.kcommaaccent = 556;
        e1.minus = 570;
        e1.Icircumflex = 389;
        e1.ncaron = 556;
        e1.tcommaaccent = 333;
        e1.logicalnot = 570;
        e1.odieresis = 500;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 444;
        e1.ncommaaccent = 556;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-BoldItalic"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 389;
        e1.quotedbl = 555;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 570;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 570;
        e1.equal = 570;
        e1.greater = 570;
        e1.question = 500;
        e1.at = 832;
        e1.A = 667;
        e1.B = 667;
        e1.C = 667;
        e1.D = 722;
        e1.E = 667;
        e1.F = 667;
        e1.G = 722;
        e1.H = 778;
        e1.I = 389;
        e1.J = 500;
        e1.K = 667;
        e1.L = 611;
        e1.M = 889;
        e1.N = 722;
        e1.O = 722;
        e1.P = 611;
        e1.Q = 722;
        e1.R = 667;
        e1.S = 556;
        e1.T = 611;
        e1.U = 722;
        e1.V = 667;
        e1.W = 889;
        e1.X = 667;
        e1.Y = 611;
        e1.Z = 611;
        e1.bracketleft = 333;
        e1.backslash = 278;
        e1.bracketright = 333;
        e1.asciicircum = 570;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 333;
        e1.g = 500;
        e1.h = 556;
        e1.i = 278;
        e1.j = 278;
        e1.k = 500;
        e1.l = 278;
        e1.m = 778;
        e1.n = 556;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 389;
        e1.s = 389;
        e1.t = 278;
        e1.u = 556;
        e1.v = 444;
        e1.w = 667;
        e1.x = 500;
        e1.y = 444;
        e1.z = 389;
        e1.braceleft = 348;
        e1.bar = 220;
        e1.braceright = 348;
        e1.asciitilde = 570;
        e1.exclamdown = 389;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 278;
        e1.quotedblleft = 500;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 556;
        e1.fl = 556;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 500;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 500;
        e1.quotedblright = 500;
        e1.guillemotright = 500;
        e1.ellipsis = 1e3;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 1e3;
        e1.AE = 944;
        e1.ordfeminine = 266;
        e1.Lslash = 611;
        e1.Oslash = 722;
        e1.OE = 944;
        e1.ordmasculine = 300;
        e1.ae = 722;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 722;
        e1.germandbls = 500;
        e1.Idieresis = 389;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 556;
        e1.ecaron = 444;
        e1.Ydieresis = 611;
        e1.divide = 570;
        e1.Yacute = 611;
        e1.Acircumflex = 667;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 444;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 556;
        e1.Edieresis = 667;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 747;
        e1.Emacron = 667;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 722;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 611;
        e1.Cacute = 667;
        e1.atilde = 500;
        e1.Edotaccent = 667;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 494;
        e1.Rcaron = 667;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 556;
        e1.acircumflex = 500;
        e1.Amacron = 667;
        e1.rcaron = 389;
        e1.ccedilla = 444;
        e1.Zdotaccent = 611;
        e1.Thorn = 611;
        e1.Omacron = 722;
        e1.Racute = 667;
        e1.Sacute = 556;
        e1.dcaron = 608;
        e1.Umacron = 722;
        e1.uring = 556;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 667;
        e1.Abreve = 667;
        e1.multiply = 570;
        e1.uacute = 556;
        e1.Tcaron = 611;
        e1.partialdiff = 494;
        e1.ydieresis = 444;
        e1.Nacute = 722;
        e1.icircumflex = 278;
        e1.Ecircumflex = 667;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 556;
        e1.umacron = 556;
        e1.Ncaron = 722;
        e1.Iacute = 389;
        e1.plusminus = 570;
        e1.brokenbar = 220;
        e1.registered = 747;
        e1.Gbreve = 722;
        e1.Idotaccent = 389;
        e1.summation = 600;
        e1.Egrave = 667;
        e1.racute = 389;
        e1.omacron = 500;
        e1.Zacute = 611;
        e1.Zcaron = 611;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 366;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 667;
        e1.Adieresis = 667;
        e1.egrave = 444;
        e1.zacute = 389;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 576;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 667;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 556;
        e1.lcaron = 382;
        e1.Kcommaaccent = 667;
        e1.Lacute = 611;
        e1.trademark = 1e3;
        e1.edotaccent = 444;
        e1.Igrave = 389;
        e1.Imacron = 389;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 556;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 667;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 556;
        e1.Scommaaccent = 556;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 556;
        e1.radical = 549;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 722;
        e1.otilde = 500;
        e1.Rcommaaccent = 667;
        e1.Lcommaaccent = 611;
        e1.Atilde = 667;
        e1.Aogonek = 667;
        e1.Aring = 667;
        e1.Otilde = 722;
        e1.zdotaccent = 389;
        e1.Ecaron = 667;
        e1.Iogonek = 389;
        e1.kcommaaccent = 500;
        e1.minus = 606;
        e1.Icircumflex = 389;
        e1.ncaron = 556;
        e1.tcommaaccent = 278;
        e1.logicalnot = 606;
        e1.odieresis = 500;
        e1.udieresis = 556;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 389;
        e1.ncommaaccent = 556;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1["Times-Italic"] = getLookupTableFactory(function(e1) {
        e1.space = 250;
        e1.exclam = 333;
        e1.quotedbl = 420;
        e1.numbersign = 500;
        e1.dollar = 500;
        e1.percent = 833;
        e1.ampersand = 778;
        e1.quoteright = 333;
        e1.parenleft = 333;
        e1.parenright = 333;
        e1.asterisk = 500;
        e1.plus = 675;
        e1.comma = 250;
        e1.hyphen = 333;
        e1.period = 250;
        e1.slash = 278;
        e1.zero = 500;
        e1.one = 500;
        e1.two = 500;
        e1.three = 500;
        e1.four = 500;
        e1.five = 500;
        e1.six = 500;
        e1.seven = 500;
        e1.eight = 500;
        e1.nine = 500;
        e1.colon = 333;
        e1.semicolon = 333;
        e1.less = 675;
        e1.equal = 675;
        e1.greater = 675;
        e1.question = 500;
        e1.at = 920;
        e1.A = 611;
        e1.B = 611;
        e1.C = 667;
        e1.D = 722;
        e1.E = 611;
        e1.F = 611;
        e1.G = 722;
        e1.H = 722;
        e1.I = 333;
        e1.J = 444;
        e1.K = 667;
        e1.L = 556;
        e1.M = 833;
        e1.N = 667;
        e1.O = 722;
        e1.P = 611;
        e1.Q = 722;
        e1.R = 611;
        e1.S = 500;
        e1.T = 556;
        e1.U = 722;
        e1.V = 611;
        e1.W = 833;
        e1.X = 611;
        e1.Y = 556;
        e1.Z = 556;
        e1.bracketleft = 389;
        e1.backslash = 278;
        e1.bracketright = 389;
        e1.asciicircum = 422;
        e1.underscore = 500;
        e1.quoteleft = 333;
        e1.a = 500;
        e1.b = 500;
        e1.c = 444;
        e1.d = 500;
        e1.e = 444;
        e1.f = 278;
        e1.g = 500;
        e1.h = 500;
        e1.i = 278;
        e1.j = 278;
        e1.k = 444;
        e1.l = 278;
        e1.m = 722;
        e1.n = 500;
        e1.o = 500;
        e1.p = 500;
        e1.q = 500;
        e1.r = 389;
        e1.s = 389;
        e1.t = 278;
        e1.u = 500;
        e1.v = 444;
        e1.w = 667;
        e1.x = 444;
        e1.y = 444;
        e1.z = 389;
        e1.braceleft = 400;
        e1.bar = 275;
        e1.braceright = 400;
        e1.asciitilde = 541;
        e1.exclamdown = 389;
        e1.cent = 500;
        e1.sterling = 500;
        e1.fraction = 167;
        e1.yen = 500;
        e1.florin = 500;
        e1.section = 500;
        e1.currency = 500;
        e1.quotesingle = 214;
        e1.quotedblleft = 556;
        e1.guillemotleft = 500;
        e1.guilsinglleft = 333;
        e1.guilsinglright = 333;
        e1.fi = 500;
        e1.fl = 500;
        e1.endash = 500;
        e1.dagger = 500;
        e1.daggerdbl = 500;
        e1.periodcentered = 250;
        e1.paragraph = 523;
        e1.bullet = 350;
        e1.quotesinglbase = 333;
        e1.quotedblbase = 556;
        e1.quotedblright = 556;
        e1.guillemotright = 500;
        e1.ellipsis = 889;
        e1.perthousand = 1e3;
        e1.questiondown = 500;
        e1.grave = 333;
        e1.acute = 333;
        e1.circumflex = 333;
        e1.tilde = 333;
        e1.macron = 333;
        e1.breve = 333;
        e1.dotaccent = 333;
        e1.dieresis = 333;
        e1.ring = 333;
        e1.cedilla = 333;
        e1.hungarumlaut = 333;
        e1.ogonek = 333;
        e1.caron = 333;
        e1.emdash = 889;
        e1.AE = 889;
        e1.ordfeminine = 276;
        e1.Lslash = 556;
        e1.Oslash = 722;
        e1.OE = 944;
        e1.ordmasculine = 310;
        e1.ae = 667;
        e1.dotlessi = 278;
        e1.lslash = 278;
        e1.oslash = 500;
        e1.oe = 667;
        e1.germandbls = 500;
        e1.Idieresis = 333;
        e1.eacute = 444;
        e1.abreve = 500;
        e1.uhungarumlaut = 500;
        e1.ecaron = 444;
        e1.Ydieresis = 556;
        e1.divide = 675;
        e1.Yacute = 556;
        e1.Acircumflex = 611;
        e1.aacute = 500;
        e1.Ucircumflex = 722;
        e1.yacute = 444;
        e1.scommaaccent = 389;
        e1.ecircumflex = 444;
        e1.Uring = 722;
        e1.Udieresis = 722;
        e1.aogonek = 500;
        e1.Uacute = 722;
        e1.uogonek = 500;
        e1.Edieresis = 611;
        e1.Dcroat = 722;
        e1.commaaccent = 250;
        e1.copyright = 760;
        e1.Emacron = 611;
        e1.ccaron = 444;
        e1.aring = 500;
        e1.Ncommaaccent = 667;
        e1.lacute = 278;
        e1.agrave = 500;
        e1.Tcommaaccent = 556;
        e1.Cacute = 667;
        e1.atilde = 500;
        e1.Edotaccent = 611;
        e1.scaron = 389;
        e1.scedilla = 389;
        e1.iacute = 278;
        e1.lozenge = 471;
        e1.Rcaron = 611;
        e1.Gcommaaccent = 722;
        e1.ucircumflex = 500;
        e1.acircumflex = 500;
        e1.Amacron = 611;
        e1.rcaron = 389;
        e1.ccedilla = 444;
        e1.Zdotaccent = 556;
        e1.Thorn = 611;
        e1.Omacron = 722;
        e1.Racute = 611;
        e1.Sacute = 500;
        e1.dcaron = 544;
        e1.Umacron = 722;
        e1.uring = 500;
        e1.threesuperior = 300;
        e1.Ograve = 722;
        e1.Agrave = 611;
        e1.Abreve = 611;
        e1.multiply = 675;
        e1.uacute = 500;
        e1.Tcaron = 556;
        e1.partialdiff = 476;
        e1.ydieresis = 444;
        e1.Nacute = 667;
        e1.icircumflex = 278;
        e1.Ecircumflex = 611;
        e1.adieresis = 500;
        e1.edieresis = 444;
        e1.cacute = 444;
        e1.nacute = 500;
        e1.umacron = 500;
        e1.Ncaron = 667;
        e1.Iacute = 333;
        e1.plusminus = 675;
        e1.brokenbar = 275;
        e1.registered = 760;
        e1.Gbreve = 722;
        e1.Idotaccent = 333;
        e1.summation = 600;
        e1.Egrave = 611;
        e1.racute = 389;
        e1.omacron = 500;
        e1.Zacute = 556;
        e1.Zcaron = 556;
        e1.greaterequal = 549;
        e1.Eth = 722;
        e1.Ccedilla = 667;
        e1.lcommaaccent = 278;
        e1.tcaron = 300;
        e1.eogonek = 444;
        e1.Uogonek = 722;
        e1.Aacute = 611;
        e1.Adieresis = 611;
        e1.egrave = 444;
        e1.zacute = 389;
        e1.iogonek = 278;
        e1.Oacute = 722;
        e1.oacute = 500;
        e1.amacron = 500;
        e1.sacute = 389;
        e1.idieresis = 278;
        e1.Ocircumflex = 722;
        e1.Ugrave = 722;
        e1.Delta = 612;
        e1.thorn = 500;
        e1.twosuperior = 300;
        e1.Odieresis = 722;
        e1.mu = 500;
        e1.igrave = 278;
        e1.ohungarumlaut = 500;
        e1.Eogonek = 611;
        e1.dcroat = 500;
        e1.threequarters = 750;
        e1.Scedilla = 500;
        e1.lcaron = 300;
        e1.Kcommaaccent = 667;
        e1.Lacute = 556;
        e1.trademark = 980;
        e1.edotaccent = 444;
        e1.Igrave = 333;
        e1.Imacron = 333;
        e1.Lcaron = 611;
        e1.onehalf = 750;
        e1.lessequal = 549;
        e1.ocircumflex = 500;
        e1.ntilde = 500;
        e1.Uhungarumlaut = 722;
        e1.Eacute = 611;
        e1.emacron = 444;
        e1.gbreve = 500;
        e1.onequarter = 750;
        e1.Scaron = 500;
        e1.Scommaaccent = 500;
        e1.Ohungarumlaut = 722;
        e1.degree = 400;
        e1.ograve = 500;
        e1.Ccaron = 667;
        e1.ugrave = 500;
        e1.radical = 453;
        e1.Dcaron = 722;
        e1.rcommaaccent = 389;
        e1.Ntilde = 667;
        e1.otilde = 500;
        e1.Rcommaaccent = 611;
        e1.Lcommaaccent = 556;
        e1.Atilde = 611;
        e1.Aogonek = 611;
        e1.Aring = 611;
        e1.Otilde = 722;
        e1.zdotaccent = 389;
        e1.Ecaron = 611;
        e1.Iogonek = 333;
        e1.kcommaaccent = 444;
        e1.minus = 675;
        e1.Icircumflex = 333;
        e1.ncaron = 500;
        e1.tcommaaccent = 278;
        e1.logicalnot = 675;
        e1.odieresis = 500;
        e1.udieresis = 500;
        e1.notequal = 549;
        e1.gcommaaccent = 500;
        e1.eth = 500;
        e1.zcaron = 389;
        e1.ncommaaccent = 500;
        e1.onesuperior = 300;
        e1.imacron = 278;
        e1.Euro = 500;
    });
    e1.ZapfDingbats = getLookupTableFactory(function(e1) {
        e1.space = 278;
        e1.a1 = 974;
        e1.a2 = 961;
        e1.a202 = 974;
        e1.a3 = 980;
        e1.a4 = 719;
        e1.a5 = 789;
        e1.a119 = 790;
        e1.a118 = 791;
        e1.a117 = 690;
        e1.a11 = 960;
        e1.a12 = 939;
        e1.a13 = 549;
        e1.a14 = 855;
        e1.a15 = 911;
        e1.a16 = 933;
        e1.a105 = 911;
        e1.a17 = 945;
        e1.a18 = 974;
        e1.a19 = 755;
        e1.a20 = 846;
        e1.a21 = 762;
        e1.a22 = 761;
        e1.a23 = 571;
        e1.a24 = 677;
        e1.a25 = 763;
        e1.a26 = 760;
        e1.a27 = 759;
        e1.a28 = 754;
        e1.a6 = 494;
        e1.a7 = 552;
        e1.a8 = 537;
        e1.a9 = 577;
        e1.a10 = 692;
        e1.a29 = 786;
        e1.a30 = 788;
        e1.a31 = 788;
        e1.a32 = 790;
        e1.a33 = 793;
        e1.a34 = 794;
        e1.a35 = 816;
        e1.a36 = 823;
        e1.a37 = 789;
        e1.a38 = 841;
        e1.a39 = 823;
        e1.a40 = 833;
        e1.a41 = 816;
        e1.a42 = 831;
        e1.a43 = 923;
        e1.a44 = 744;
        e1.a45 = 723;
        e1.a46 = 749;
        e1.a47 = 790;
        e1.a48 = 792;
        e1.a49 = 695;
        e1.a50 = 776;
        e1.a51 = 768;
        e1.a52 = 792;
        e1.a53 = 759;
        e1.a54 = 707;
        e1.a55 = 708;
        e1.a56 = 682;
        e1.a57 = 701;
        e1.a58 = 826;
        e1.a59 = 815;
        e1.a60 = 789;
        e1.a61 = 789;
        e1.a62 = 707;
        e1.a63 = 687;
        e1.a64 = 696;
        e1.a65 = 689;
        e1.a66 = 786;
        e1.a67 = 787;
        e1.a68 = 713;
        e1.a69 = 791;
        e1.a70 = 785;
        e1.a71 = 791;
        e1.a72 = 873;
        e1.a73 = 761;
        e1.a74 = 762;
        e1.a203 = 762;
        e1.a75 = 759;
        e1.a204 = 759;
        e1.a76 = 892;
        e1.a77 = 892;
        e1.a78 = 788;
        e1.a79 = 784;
        e1.a81 = 438;
        e1.a82 = 138;
        e1.a83 = 277;
        e1.a84 = 415;
        e1.a97 = 392;
        e1.a98 = 392;
        e1.a99 = 668;
        e1.a100 = 668;
        e1.a89 = 390;
        e1.a90 = 390;
        e1.a93 = 317;
        e1.a94 = 317;
        e1.a91 = 276;
        e1.a92 = 276;
        e1.a205 = 509;
        e1.a85 = 509;
        e1.a206 = 410;
        e1.a86 = 410;
        e1.a87 = 234;
        e1.a88 = 234;
        e1.a95 = 334;
        e1.a96 = 334;
        e1.a101 = 732;
        e1.a102 = 544;
        e1.a103 = 544;
        e1.a104 = 910;
        e1.a106 = 667;
        e1.a107 = 760;
        e1.a108 = 760;
        e1.a112 = 776;
        e1.a111 = 595;
        e1.a110 = 694;
        e1.a109 = 626;
        e1.a120 = 788;
        e1.a121 = 788;
        e1.a122 = 788;
        e1.a123 = 788;
        e1.a124 = 788;
        e1.a125 = 788;
        e1.a126 = 788;
        e1.a127 = 788;
        e1.a128 = 788;
        e1.a129 = 788;
        e1.a130 = 788;
        e1.a131 = 788;
        e1.a132 = 788;
        e1.a133 = 788;
        e1.a134 = 788;
        e1.a135 = 788;
        e1.a136 = 788;
        e1.a137 = 788;
        e1.a138 = 788;
        e1.a139 = 788;
        e1.a140 = 788;
        e1.a141 = 788;
        e1.a142 = 788;
        e1.a143 = 788;
        e1.a144 = 788;
        e1.a145 = 788;
        e1.a146 = 788;
        e1.a147 = 788;
        e1.a148 = 788;
        e1.a149 = 788;
        e1.a150 = 788;
        e1.a151 = 788;
        e1.a152 = 788;
        e1.a153 = 788;
        e1.a154 = 788;
        e1.a155 = 788;
        e1.a156 = 788;
        e1.a157 = 788;
        e1.a158 = 788;
        e1.a159 = 788;
        e1.a160 = 894;
        e1.a161 = 838;
        e1.a163 = 1016;
        e1.a164 = 458;
        e1.a196 = 748;
        e1.a165 = 924;
        e1.a192 = 748;
        e1.a166 = 918;
        e1.a167 = 927;
        e1.a168 = 928;
        e1.a169 = 928;
        e1.a170 = 834;
        e1.a171 = 873;
        e1.a172 = 828;
        e1.a173 = 924;
        e1.a162 = 924;
        e1.a174 = 917;
        e1.a175 = 930;
        e1.a176 = 931;
        e1.a177 = 463;
        e1.a178 = 883;
        e1.a179 = 836;
        e1.a193 = 836;
        e1.a180 = 867;
        e1.a199 = 867;
        e1.a181 = 696;
        e1.a200 = 696;
        e1.a182 = 874;
        e1.a201 = 874;
        e1.a183 = 760;
        e1.a184 = 946;
        e1.a197 = 771;
        e1.a185 = 865;
        e1.a194 = 771;
        e1.a198 = 888;
        e1.a186 = 967;
        e1.a195 = 888;
        e1.a187 = 831;
        e1.a188 = 873;
        e1.a189 = 927;
        e1.a190 = 970;
        e1.a191 = 918;
    });
}), qr = getLookupTableFactory(function(e1) {
    e1.Courier = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: -426
    };
    e1["Courier-Bold"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 439
    };
    e1["Courier-Oblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    };
    e1["Courier-BoldOblique"] = {
        ascent: 629,
        descent: -157,
        capHeight: 562,
        xHeight: 426
    };
    e1.Helvetica = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    };
    e1["Helvetica-Bold"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    };
    e1["Helvetica-Oblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 523
    };
    e1["Helvetica-BoldOblique"] = {
        ascent: 718,
        descent: -207,
        capHeight: 718,
        xHeight: 532
    };
    e1["Times-Roman"] = {
        ascent: 683,
        descent: -217,
        capHeight: 662,
        xHeight: 450
    };
    e1["Times-Bold"] = {
        ascent: 683,
        descent: -217,
        capHeight: 676,
        xHeight: 461
    };
    e1["Times-Italic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 653,
        xHeight: 441
    };
    e1["Times-BoldItalic"] = {
        ascent: 683,
        descent: -217,
        capHeight: 669,
        xHeight: 462
    };
    e1.Symbol = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    };
    e1.ZapfDingbats = {
        ascent: Math.NaN,
        descent: Math.NaN,
        capHeight: Math.NaN,
        xHeight: Math.NaN
    };
});
class GlyfTable {
    constructor({ glyfTable: e1, isGlyphLocationsLong: t, locaTable: a, numGlyphs: r }){
        this.glyphs = [];
        const i = new DataView(a.buffer, a.byteOffset, a.byteLength), n = new DataView(e1.buffer, e1.byteOffset, e1.byteLength), s = t ? 4 : 2;
        let o = t ? i.getUint32(0) : 2 * i.getUint16(0), c = 0;
        for(let e1 = 0; e1 < r; e1++){
            c += s;
            const e1 = t ? i.getUint32(c) : 2 * i.getUint16(c);
            if (e1 === o) {
                this.glyphs.push(new Glyph({}));
                continue;
            }
            const a = Glyph.parse(o, n);
            this.glyphs.push(a);
            o = e1;
        }
    }
    getSize() {
        return Math.sumPrecise(this.glyphs.map((e1)=>e1.getSize() + 3 & -4));
    }
    write() {
        const e1 = this.getSize(), t = new DataView(new ArrayBuffer(e1)), a = e1 > 131070, r = a ? 4 : 2, i = new DataView(new ArrayBuffer((this.glyphs.length + 1) * r));
        a ? i.setUint32(0, 0) : i.setUint16(0, 0);
        let n = 0, s = 0;
        for (const e1 of this.glyphs){
            n += e1.write(n, t);
            n = n + 3 & -4;
            s += r;
            a ? i.setUint32(s, n) : i.setUint16(s, n >> 1);
        }
        return {
            isLocationLong: a,
            loca: new Uint8Array(i.buffer),
            glyf: new Uint8Array(t.buffer)
        };
    }
    scale(e1) {
        for(let t = 0, a = this.glyphs.length; t < a; t++)this.glyphs[t].scale(e1[t]);
    }
}
class Glyph {
    constructor({ header: e1 = null, simple: t = null, composites: a = null }){
        this.header = e1;
        this.simple = t;
        this.composites = a;
    }
    static parse(e1, t) {
        const [a, r] = GlyphHeader.parse(e1, t);
        e1 += a;
        if (r.numberOfContours < 0) {
            const a = [];
            for(;;){
                const [r, i] = CompositeGlyph.parse(e1, t);
                e1 += r;
                a.push(i);
                if (!(32 & i.flags)) break;
            }
            return new Glyph({
                header: r,
                composites: a
            });
        }
        const i = SimpleGlyph.parse(e1, t, r.numberOfContours);
        return new Glyph({
            header: r,
            simple: i
        });
    }
    getSize() {
        if (!this.header) return 0;
        const e1 = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map((e1)=>e1.getSize()));
        return this.header.getSize() + e1;
    }
    write(e1, t) {
        if (!this.header) return 0;
        const a = e1;
        e1 += this.header.write(e1, t);
        if (this.simple) e1 += this.simple.write(e1, t);
        else for (const a of this.composites)e1 += a.write(e1, t);
        return e1 - a;
    }
    scale(e1) {
        if (!this.header) return;
        const t = (this.header.xMin + this.header.xMax) / 2;
        this.header.scale(t, e1);
        if (this.simple) this.simple.scale(t, e1);
        else for (const a of this.composites)a.scale(t, e1);
    }
}
class GlyphHeader {
    constructor({ numberOfContours: e1, xMin: t, yMin: a, xMax: r, yMax: i }){
        this.numberOfContours = e1;
        this.xMin = t;
        this.yMin = a;
        this.xMax = r;
        this.yMax = i;
    }
    static parse(e1, t) {
        return [
            10,
            new GlyphHeader({
                numberOfContours: t.getInt16(e1),
                xMin: t.getInt16(e1 + 2),
                yMin: t.getInt16(e1 + 4),
                xMax: t.getInt16(e1 + 6),
                yMax: t.getInt16(e1 + 8)
            })
        ];
    }
    getSize() {
        return 10;
    }
    write(e1, t) {
        t.setInt16(e1, this.numberOfContours);
        t.setInt16(e1 + 2, this.xMin);
        t.setInt16(e1 + 4, this.yMin);
        t.setInt16(e1 + 6, this.xMax);
        t.setInt16(e1 + 8, this.yMax);
        return 10;
    }
    scale(e1, t) {
        this.xMin = Math.round(e1 + (this.xMin - e1) * t);
        this.xMax = Math.round(e1 + (this.xMax - e1) * t);
    }
}
class Contour {
    constructor({ flags: e1, xCoordinates: t, yCoordinates: a }){
        this.xCoordinates = t;
        this.yCoordinates = a;
        this.flags = e1;
    }
}
class SimpleGlyph {
    constructor({ contours: e1, instructions: t }){
        this.contours = e1;
        this.instructions = t;
    }
    static parse(e1, t, a) {
        const r = [];
        for(let i = 0; i < a; i++){
            const a = t.getUint16(e1);
            e1 += 2;
            r.push(a);
        }
        const i = r[a - 1] + 1, n = t.getUint16(e1);
        e1 += 2;
        const s = new Uint8Array(t).slice(e1, e1 + n);
        e1 += n;
        const o = [];
        for(let a = 0; a < i; e1++, a++){
            let r = t.getUint8(e1);
            o.push(r);
            if (8 & r) {
                const i = t.getUint8(++e1);
                r ^= 8;
                for(let e1 = 0; e1 < i; e1++)o.push(r);
                a += i;
            }
        }
        const c = [];
        let l = [], h = [], u = [];
        const d = [];
        let f = 0, g = 0;
        for(let a = 0; a < i; a++){
            const i = o[a];
            if (2 & i) {
                const a = t.getUint8(e1++);
                g += 16 & i ? a : -a;
                l.push(g);
            } else if (16 & i) l.push(g);
            else {
                g += t.getInt16(e1);
                e1 += 2;
                l.push(g);
            }
            if (r[f] === a) {
                f++;
                c.push(l);
                l = [];
            }
        }
        g = 0;
        f = 0;
        for(let a = 0; a < i; a++){
            const i = o[a];
            if (4 & i) {
                const a = t.getUint8(e1++);
                g += 32 & i ? a : -a;
                h.push(g);
            } else if (32 & i) h.push(g);
            else {
                g += t.getInt16(e1);
                e1 += 2;
                h.push(g);
            }
            u.push(1 & i | 64 & i);
            if (r[f] === a) {
                l = c[f];
                f++;
                d.push(new Contour({
                    flags: u,
                    xCoordinates: l,
                    yCoordinates: h
                }));
                h = [];
                u = [];
            }
        }
        return new SimpleGlyph({
            contours: d,
            instructions: s
        });
    }
    getSize() {
        let e1 = 2 * this.contours.length + 2 + this.instructions.length, t = 0, a = 0;
        for (const r of this.contours){
            e1 += r.flags.length;
            for(let i = 0, n = r.xCoordinates.length; i < n; i++){
                const n = r.xCoordinates[i], s = r.yCoordinates[i];
                let o = Math.abs(n - t);
                o > 255 ? e1 += 2 : o > 0 && (e1 += 1);
                t = n;
                o = Math.abs(s - a);
                o > 255 ? e1 += 2 : o > 0 && (e1 += 1);
                a = s;
            }
        }
        return e1;
    }
    write(e1, t) {
        const a = e1, r = [], i = [], n = [];
        let s = 0, o = 0;
        for (const a of this.contours){
            for(let e1 = 0, t = a.xCoordinates.length; e1 < t; e1++){
                let t = a.flags[e1];
                const c = a.xCoordinates[e1];
                let l = c - s;
                if (0 === l) {
                    t |= 16;
                    r.push(0);
                } else {
                    const e1 = Math.abs(l);
                    if (e1 <= 255) {
                        t |= l >= 0 ? 18 : 2;
                        r.push(e1);
                    } else r.push(l);
                }
                s = c;
                const h = a.yCoordinates[e1];
                l = h - o;
                if (0 === l) {
                    t |= 32;
                    i.push(0);
                } else {
                    const e1 = Math.abs(l);
                    if (e1 <= 255) {
                        t |= l >= 0 ? 36 : 4;
                        i.push(e1);
                    } else i.push(l);
                }
                o = h;
                n.push(t);
            }
            t.setUint16(e1, r.length - 1);
            e1 += 2;
        }
        t.setUint16(e1, this.instructions.length);
        e1 += 2;
        if (this.instructions.length) {
            new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1);
            e1 += this.instructions.length;
        }
        for (const a of n)t.setUint8(e1++, a);
        for(let a = 0, i = r.length; a < i; a++){
            const i = r[a], s = n[a];
            if (2 & s) t.setUint8(e1++, i);
            else if (!(16 & s)) {
                t.setInt16(e1, i);
                e1 += 2;
            }
        }
        for(let a = 0, r = i.length; a < r; a++){
            const r = i[a], s = n[a];
            if (4 & s) t.setUint8(e1++, r);
            else if (!(32 & s)) {
                t.setInt16(e1, r);
                e1 += 2;
            }
        }
        return e1 - a;
    }
    scale(e1, t) {
        for (const a of this.contours)if (0 !== a.xCoordinates.length) for(let r = 0, i = a.xCoordinates.length; r < i; r++)a.xCoordinates[r] = Math.round(e1 + (a.xCoordinates[r] - e1) * t);
    }
}
class CompositeGlyph {
    constructor({ flags: e1, glyphIndex: t, argument1: a, argument2: r, transf: i, instructions: n }){
        this.flags = e1;
        this.glyphIndex = t;
        this.argument1 = a;
        this.argument2 = r;
        this.transf = i;
        this.instructions = n;
    }
    static parse(e1, t) {
        const a = e1, r = [];
        let i = t.getUint16(e1);
        const n = t.getUint16(e1 + 2);
        e1 += 4;
        let s, o;
        if (1 & i) {
            if (2 & i) {
                s = t.getInt16(e1);
                o = t.getInt16(e1 + 2);
            } else {
                s = t.getUint16(e1);
                o = t.getUint16(e1 + 2);
            }
            e1 += 4;
            i ^= 1;
        } else {
            if (2 & i) {
                s = t.getInt8(e1);
                o = t.getInt8(e1 + 1);
            } else {
                s = t.getUint8(e1);
                o = t.getUint8(e1 + 1);
            }
            e1 += 2;
        }
        if (8 & i) {
            r.push(t.getUint16(e1));
            e1 += 2;
        } else if (64 & i) {
            r.push(t.getUint16(e1), t.getUint16(e1 + 2));
            e1 += 4;
        } else if (128 & i) {
            r.push(t.getUint16(e1), t.getUint16(e1 + 2), t.getUint16(e1 + 4), t.getUint16(e1 + 6));
            e1 += 8;
        }
        let c = null;
        if (256 & i) {
            const a = t.getUint16(e1);
            e1 += 2;
            c = new Uint8Array(t).slice(e1, e1 + a);
            e1 += a;
        }
        return [
            e1 - a,
            new CompositeGlyph({
                flags: i,
                glyphIndex: n,
                argument1: s,
                argument2: o,
                transf: r,
                instructions: c
            })
        ];
    }
    getSize() {
        let e1 = 4 + 2 * this.transf.length;
        256 & this.flags && (e1 += 2 + this.instructions.length);
        e1 += 2;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e1 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e1 += 2);
        return e1;
    }
    write(e1, t) {
        const a = e1;
        2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
        t.setUint16(e1, this.flags);
        t.setUint16(e1 + 2, this.glyphIndex);
        e1 += 4;
        if (1 & this.flags) {
            if (2 & this.flags) {
                t.setInt16(e1, this.argument1);
                t.setInt16(e1 + 2, this.argument2);
            } else {
                t.setUint16(e1, this.argument1);
                t.setUint16(e1 + 2, this.argument2);
            }
            e1 += 4;
        } else {
            t.setUint8(e1, this.argument1);
            t.setUint8(e1 + 1, this.argument2);
            e1 += 2;
        }
        if (256 & this.flags) {
            t.setUint16(e1, this.instructions.length);
            e1 += 2;
            if (this.instructions.length) {
                new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, e1);
                e1 += this.instructions.length;
            }
        }
        return e1 - a;
    }
    scale(e1, t) {}
}
function writeInt16(e1, t, a) {
    e1[t] = a >> 8 & 255;
    e1[t + 1] = 255 & a;
}
function writeInt32(e1, t, a) {
    e1[t] = a >> 24 & 255;
    e1[t + 1] = a >> 16 & 255;
    e1[t + 2] = a >> 8 & 255;
    e1[t + 3] = 255 & a;
}
function writeData(e1, t, a) {
    if (a instanceof Uint8Array) e1.set(a, t);
    else if ("string" == typeof a) for(let r = 0, i = a.length; r < i; r++)e1[t++] = 255 & a.charCodeAt(r);
    else for (const r of a)e1[t++] = 255 & r;
}
class OpenTypeFileBuilder {
    constructor(e1){
        this.sfnt = e1;
        this.tables = Object.create(null);
    }
    static getSearchParams(e1, t) {
        let a = 1, r = 0;
        for(; (a ^ e1) > a;){
            a <<= 1;
            r++;
        }
        const i = a * t;
        return {
            range: i,
            entry: r,
            rangeShift: t * e1 - i
        };
    }
    toArray() {
        let e1 = this.sfnt;
        const t = this.tables, a = Object.keys(t);
        a.sort();
        const r = a.length;
        let i, n, s, o, c, l = 12 + 16 * r;
        const h = [
            l
        ];
        for(i = 0; i < r; i++){
            o = t[a[i]];
            l += (o.length + 3 & -4) >>> 0;
            h.push(l);
        }
        const u = new Uint8Array(l);
        for(i = 0; i < r; i++){
            o = t[a[i]];
            writeData(u, h[i], o);
        }
        "true" === e1 && (e1 = string32(65536));
        u[0] = 255 & e1.charCodeAt(0);
        u[1] = 255 & e1.charCodeAt(1);
        u[2] = 255 & e1.charCodeAt(2);
        u[3] = 255 & e1.charCodeAt(3);
        writeInt16(u, 4, r);
        const d = OpenTypeFileBuilder.getSearchParams(r, 16);
        writeInt16(u, 6, d.range);
        writeInt16(u, 8, d.entry);
        writeInt16(u, 10, d.rangeShift);
        l = 12;
        for(i = 0; i < r; i++){
            c = a[i];
            u[l] = 255 & c.charCodeAt(0);
            u[l + 1] = 255 & c.charCodeAt(1);
            u[l + 2] = 255 & c.charCodeAt(2);
            u[l + 3] = 255 & c.charCodeAt(3);
            let e1 = 0;
            for(n = h[i], s = h[i + 1]; n < s; n += 4){
                e1 = e1 + readUint32(u, n) >>> 0;
            }
            writeInt32(u, l + 4, e1);
            writeInt32(u, l + 8, h[i]);
            writeInt32(u, l + 12, t[c].length);
            l += 16;
        }
        return u;
    }
    addTable(e1, t) {
        if (e1 in this.tables) throw new Error("Table " + e1 + " already exists");
        this.tables[e1] = t;
    }
}
const Hr = [
    4
], Wr = [
    5
], zr = [
    6
], $r = [
    7
], Gr = [
    8
], Vr = [
    12,
    35
], Kr = [
    14
], Jr = [
    21
], Yr = [
    22
], Zr = [
    30
], Qr = [
    31
];
class Type1CharString {
    constructor(){
        this.width = 0;
        this.lsb = 0;
        this.flexing = !1;
        this.output = [];
        this.stack = [];
    }
    convert(e1, t, a) {
        const r = e1.length;
        let i, n, s, o = !1;
        for(let c = 0; c < r; c++){
            let r = e1[c];
            if (r < 32) {
                12 === r && (r = (r << 8) + e1[++c]);
                switch(r){
                    case 1:
                    case 3:
                    case 9:
                    case 3072:
                    case 3073:
                    case 3074:
                    case 3105:
                        this.stack = [];
                        break;
                    case 4:
                        if (this.flexing) {
                            if (this.stack.length < 1) {
                                o = !0;
                                break;
                            }
                            const e1 = this.stack.pop();
                            this.stack.push(0, e1);
                            break;
                        }
                        o = this.executeCommand(1, Hr);
                        break;
                    case 5:
                        o = this.executeCommand(2, Wr);
                        break;
                    case 6:
                        o = this.executeCommand(1, zr);
                        break;
                    case 7:
                        o = this.executeCommand(1, $r);
                        break;
                    case 8:
                        o = this.executeCommand(6, Gr);
                        break;
                    case 10:
                        if (this.stack.length < 1) {
                            o = !0;
                            break;
                        }
                        s = this.stack.pop();
                        if (!t[s]) {
                            o = !0;
                            break;
                        }
                        o = this.convert(t[s], t, a);
                        break;
                    case 11:
                        return o;
                    case 13:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        i = this.stack.pop();
                        n = this.stack.pop();
                        this.lsb = n;
                        this.width = i;
                        this.stack.push(i, n);
                        o = this.executeCommand(2, Yr);
                        break;
                    case 14:
                        this.output.push(Kr[0]);
                        break;
                    case 21:
                        if (this.flexing) break;
                        o = this.executeCommand(2, Jr);
                        break;
                    case 22:
                        if (this.flexing) {
                            this.stack.push(0);
                            break;
                        }
                        o = this.executeCommand(1, Yr);
                        break;
                    case 30:
                        o = this.executeCommand(4, Zr);
                        break;
                    case 31:
                        o = this.executeCommand(4, Qr);
                        break;
                    case 3078:
                        if (a) {
                            const e1 = this.stack.at(-5);
                            this.seac = this.stack.splice(-4, 4);
                            this.seac[0] += this.lsb - e1;
                            o = this.executeCommand(0, Kr);
                        } else o = this.executeCommand(4, Kr);
                        break;
                    case 3079:
                        if (this.stack.length < 4) {
                            o = !0;
                            break;
                        }
                        this.stack.pop();
                        i = this.stack.pop();
                        const e2 = this.stack.pop();
                        n = this.stack.pop();
                        this.lsb = n;
                        this.width = i;
                        this.stack.push(i, n, e2);
                        o = this.executeCommand(3, Jr);
                        break;
                    case 3084:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        const c1 = this.stack.pop(), l = this.stack.pop();
                        this.stack.push(l / c1);
                        break;
                    case 3088:
                        if (this.stack.length < 2) {
                            o = !0;
                            break;
                        }
                        s = this.stack.pop();
                        const h = this.stack.pop();
                        if (0 === s && 3 === h) {
                            const e1 = this.stack.splice(-17, 17);
                            this.stack.push(e1[2] + e1[0], e1[3] + e1[1], e1[4], e1[5], e1[6], e1[7], e1[8], e1[9], e1[10], e1[11], e1[12], e1[13], e1[14]);
                            o = this.executeCommand(13, Vr, !0);
                            this.flexing = !1;
                            this.stack.push(e1[15], e1[16]);
                        } else 1 === s && 0 === h && (this.flexing = !0);
                        break;
                    case 3089:
                        break;
                    default:
                        warn('Unknown type 1 charstring command of "' + r + '"');
                }
                if (o) break;
            } else {
                r <= 246 ? r -= 139 : r = r <= 250 ? 256 * (r - 247) + e1[++c] + 108 : r <= 254 ? -256 * (r - 251) - e1[++c] - 108 : (255 & e1[++c]) << 24 | (255 & e1[++c]) << 16 | (255 & e1[++c]) << 8 | 255 & e1[++c];
                this.stack.push(r);
            }
        }
        return o;
    }
    executeCommand(e1, t, a) {
        const r = this.stack.length;
        if (e1 > r) return !0;
        const i = r - e1;
        for(let e1 = i; e1 < r; e1++){
            let t = this.stack[e1];
            if (Number.isInteger(t)) this.output.push(28, t >> 8 & 255, 255 & t);
            else {
                t = 65536 * t | 0;
                this.output.push(255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t);
            }
        }
        this.output.push(...t);
        a ? this.stack.splice(i, e1) : this.stack.length = 0;
        return !1;
    }
}
function isHexDigit(e1) {
    return e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102;
}
function decrypt(e1, t, a) {
    if (a >= e1.length) return new Uint8Array(0);
    let r, i, n = 0 | t;
    for(r = 0; r < a; r++)n = 52845 * (e1[r] + n) + 22719 & 65535;
    const s = e1.length - a, o = new Uint8Array(s);
    for(r = a, i = 0; i < s; r++, i++){
        const t = e1[r];
        o[i] = t ^ n >> 8;
        n = 52845 * (t + n) + 22719 & 65535;
    }
    return o;
}
function isSpecial(e1) {
    return 47 === e1 || 91 === e1 || 93 === e1 || 123 === e1 || 125 === e1 || 40 === e1 || 41 === e1;
}
class Type1Parser {
    constructor(e1, t, a){
        if (t) {
            const t = e1.getBytes(), a = !((isHexDigit(t[0]) || isWhiteSpace(t[0])) && isHexDigit(t[1]) && isHexDigit(t[2]) && isHexDigit(t[3]) && isHexDigit(t[4]) && isHexDigit(t[5]) && isHexDigit(t[6]) && isHexDigit(t[7]));
            e1 = new Stream(a ? decrypt(t, 55665, 4) : function decryptAscii(e1, t, a) {
                let r = 0 | t;
                const i = e1.length, n = new Uint8Array(i >>> 1);
                let s, o;
                for(s = 0, o = 0; s < i; s++){
                    const t = e1[s];
                    if (!isHexDigit(t)) continue;
                    s++;
                    let a;
                    for(; s < i && !isHexDigit(a = e1[s]);)s++;
                    if (s < i) {
                        const e1 = parseInt(String.fromCharCode(t, a), 16);
                        n[o++] = e1 ^ r >> 8;
                        r = 52845 * (e1 + r) + 22719 & 65535;
                    }
                }
                return n.slice(a, o);
            }(t, 55665, 4));
        }
        this.seacAnalysisEnabled = !!a;
        this.stream = e1;
        this.nextChar();
    }
    readNumberArray() {
        this.getToken();
        const e1 = [];
        for(;;){
            const t = this.getToken();
            if (null === t || "]" === t || "}" === t) break;
            e1.push(parseFloat(t || 0));
        }
        return e1;
    }
    readNumber() {
        const e1 = this.getToken();
        return parseFloat(e1 || 0);
    }
    readInt() {
        const e1 = this.getToken();
        return 0 | parseInt(e1 || 0, 10);
    }
    readBoolean() {
        return "true" === this.getToken() ? 1 : 0;
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    prevChar() {
        this.stream.skip(-2);
        return this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (-1 === t) return null;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        if (isSpecial(t)) {
            this.nextChar();
            return String.fromCharCode(t);
        }
        let a = "";
        do {
            a += String.fromCharCode(t);
            t = this.nextChar();
        }while (t >= 0 && !isWhiteSpace(t) && !isSpecial(t))
        return a;
    }
    readCharStrings(e1, t) {
        return -1 === t ? e1 : decrypt(e1, 4330, t);
    }
    extractFontProgram(e1) {
        const t = this.stream, a = [], r = [], i = Object.create(null);
        i.lenIV = 4;
        const n = {
            subrs: [],
            charstrings: [],
            properties: {
                privateData: i
            }
        };
        let s, o, c, l;
        for(; null !== (s = this.getToken());)if ("/" === s) {
            s = this.getToken();
            switch(s){
                case "CharStrings":
                    this.getToken();
                    this.getToken();
                    this.getToken();
                    this.getToken();
                    for(;;){
                        s = this.getToken();
                        if (null === s || "end" === s) break;
                        if ("/" !== s) continue;
                        const e1 = this.getToken();
                        o = this.readInt();
                        this.getToken();
                        c = o > 0 ? t.getBytes(o) : new Uint8Array(0);
                        l = n.properties.privateData.lenIV;
                        const a = this.readCharStrings(c, l);
                        this.nextChar();
                        s = this.getToken();
                        "noaccess" === s ? this.getToken() : "/" === s && this.prevChar();
                        r.push({
                            glyph: e1,
                            encoded: a
                        });
                    }
                    break;
                case "Subrs":
                    this.readInt();
                    this.getToken();
                    for(; "dup" === this.getToken();){
                        const e1 = this.readInt();
                        o = this.readInt();
                        this.getToken();
                        c = o > 0 ? t.getBytes(o) : new Uint8Array(0);
                        l = n.properties.privateData.lenIV;
                        const r = this.readCharStrings(c, l);
                        this.nextChar();
                        s = this.getToken();
                        "noaccess" === s && this.getToken();
                        a[e1] = r;
                    }
                    break;
                case "BlueValues":
                case "OtherBlues":
                case "FamilyBlues":
                case "FamilyOtherBlues":
                    const e1 = this.readNumberArray();
                    e1.length > 0 && e1.length, 0;
                    break;
                case "StemSnapH":
                case "StemSnapV":
                    n.properties.privateData[s] = this.readNumberArray();
                    break;
                case "StdHW":
                case "StdVW":
                    n.properties.privateData[s] = this.readNumberArray()[0];
                    break;
                case "BlueShift":
                case "lenIV":
                case "BlueFuzz":
                case "BlueScale":
                case "LanguageGroup":
                    n.properties.privateData[s] = this.readNumber();
                    break;
                case "ExpansionFactor":
                    n.properties.privateData[s] = this.readNumber() || .06;
                    break;
                case "ForceBold":
                    n.properties.privateData[s] = this.readBoolean();
            }
        }
        for (const { encoded: t, glyph: i } of r){
            const r = new Type1CharString, s = r.convert(t, a, this.seacAnalysisEnabled);
            let o = r.output;
            s && (o = [
                14
            ]);
            const c = {
                glyphName: i,
                charstring: o,
                width: r.width,
                lsb: r.lsb,
                seac: r.seac
            };
            ".notdef" === i ? n.charstrings.unshift(c) : n.charstrings.push(c);
            if (e1.builtInEncoding) {
                const t = e1.builtInEncoding.indexOf(i);
                t > -1 && void 0 === e1.widths[t] && t >= e1.firstChar && t <= e1.lastChar && (e1.widths[t] = r.width);
            }
        }
        return n;
    }
    extractFontHeader(e1) {
        let t;
        for(; null !== (t = this.getToken());)if ("/" === t) {
            t = this.getToken();
            switch(t){
                case "FontMatrix":
                    const a = this.readNumberArray();
                    e1.fontMatrix = a;
                    break;
                case "Encoding":
                    const r = this.getToken();
                    let i;
                    if (/^\d+$/.test(r)) {
                        i = [];
                        const e1 = 0 | parseInt(r, 10);
                        this.getToken();
                        for(let a = 0; a < e1; a++){
                            t = this.getToken();
                            for(; "dup" !== t && "def" !== t;){
                                t = this.getToken();
                                if (null === t) return;
                            }
                            if ("def" === t) break;
                            const e1 = this.readInt();
                            this.getToken();
                            const a = this.getToken();
                            i[e1] = a;
                            this.getToken();
                        }
                    } else i = getEncoding(r);
                    e1.builtInEncoding = i;
                    break;
                case "FontBBox":
                    const n = this.readNumberArray();
                    e1.ascent = Math.max(n[3], n[1]);
                    e1.descent = Math.min(n[1], n[3]);
                    e1.ascentScaled = !0;
            }
        }
    }
}
function findBlock(e1, t, a) {
    const r = e1.length, i = t.length, n = r - i;
    let s = a, o = !1;
    for(; s < n;){
        let a = 0;
        for(; a < i && e1[s + a] === t[a];)a++;
        if (a >= i) {
            s += a;
            for(; s < r && isWhiteSpace(e1[s]);)s++;
            o = !0;
            break;
        }
        s++;
    }
    return {
        found: o,
        length: s
    };
}
class Type1Font {
    constructor(e1, t, a){
        let r = a.length1, i = a.length2, n = t.peekBytes(6);
        const s = 128 === n[0] && 1 === n[1];
        if (s) {
            t.skip(6);
            r = n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2];
        }
        const o = function getHeaderBlock(e1, t) {
            const a = [
                101,
                101,
                120,
                101,
                99
            ], r = e1.pos;
            let i, n, s, o;
            try {
                i = e1.getBytes(t);
                n = i.length;
            } catch  {}
            if (n === t) {
                s = findBlock(i, a, t - 2 * a.length);
                if (s.found && s.length === t) return {
                    stream: new Stream(i),
                    length: t
                };
            }
            warn('Invalid "Length1" property in Type1 font -- trying to recover.');
            e1.pos = r;
            for(;;){
                s = findBlock(e1.peekBytes(2048), a, 0);
                if (0 === s.length) break;
                e1.pos += s.length;
                if (s.found) {
                    o = e1.pos - r;
                    break;
                }
            }
            e1.pos = r;
            if (o) return {
                stream: new Stream(e1.getBytes(o)),
                length: o
            };
            warn('Unable to recover "Length1" property in Type1 font -- using as is.');
            return {
                stream: new Stream(e1.getBytes(t)),
                length: t
            };
        }(t, r);
        new Type1Parser(o.stream, !1, pr).extractFontHeader(a);
        if (s) {
            n = t.getBytes(6);
            i = n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2];
        }
        const c = function getEexecBlock(e1, t) {
            const a = e1.getBytes();
            if (0 === a.length) throw new FormatError("getEexecBlock - no font program found.");
            return {
                stream: new Stream(a),
                length: a.length
            };
        }(t), l = new Type1Parser(c.stream, !0, pr).extractFontProgram(a);
        for(const e1 in l.properties)a[e1] = l.properties[e1];
        const h = l.charstrings, u = this.getType2Charstrings(h), d = this.getType2Subrs(l.subrs);
        this.charstrings = h;
        this.data = this.wrap(e1, u, this.charstrings, d, a);
        this.seacs = this.getSeacs(l.charstrings);
    }
    get numGlyphs() {
        return this.charstrings.length + 1;
    }
    getCharset() {
        const e1 = [
            ".notdef"
        ];
        for (const { glyphName: t } of this.charstrings)e1.push(t);
        return e1;
    }
    getGlyphMapping(e1) {
        const t = this.charstrings;
        if (e1.composite) {
            const a = Object.create(null);
            for(let r = 0, i = t.length; r < i; r++){
                a[e1.cMap.charCodeOf(r)] = r + 1;
            }
            return a;
        }
        const a = [
            ".notdef"
        ];
        let r, i;
        for(i = 0; i < t.length; i++)a.push(t[i].glyphName);
        const n = e1.builtInEncoding;
        if (n) {
            r = Object.create(null);
            for(const e1 in n){
                i = a.indexOf(n[e1]);
                i >= 0 && (r[e1] = i);
            }
        }
        return type1FontGlyphMapping(e1, r, a);
    }
    hasGlyphId(e1) {
        if (e1 < 0 || e1 >= this.numGlyphs) return !1;
        if (0 === e1) return !0;
        return this.charstrings[e1 - 1].charstring.length > 0;
    }
    getSeacs(e1) {
        const t = [];
        for(let a = 0, r = e1.length; a < r; a++){
            const r = e1[a];
            r.seac && (t[a + 1] = r.seac);
        }
        return t;
    }
    getType2Charstrings(e1) {
        const t = [];
        for (const a of e1)t.push(a.charstring);
        return t;
    }
    getType2Subrs(e1) {
        let t = 0;
        const a = e1.length;
        t = a < 1133 ? 107 : a < 33769 ? 1131 : 32768;
        const r = [];
        let i;
        for(i = 0; i < t; i++)r.push([
            11
        ]);
        for(i = 0; i < a; i++)r.push(e1[i]);
        return r;
    }
    wrap(e1, t, a, r, i) {
        const n = new CFF;
        n.header = new CFFHeader(1, 0, 4, 4);
        n.names = [
            e1
        ];
        const s = new CFFTopDict;
        s.setByName("version", 391);
        s.setByName("Notice", 392);
        s.setByName("FullName", 393);
        s.setByName("FamilyName", 394);
        s.setByName("Weight", 395);
        s.setByName("Encoding", null);
        s.setByName("FontMatrix", i.fontMatrix);
        s.setByName("FontBBox", i.bbox);
        s.setByName("charset", null);
        s.setByName("CharStrings", null);
        s.setByName("Private", null);
        n.topDict = s;
        const o = new CFFStrings;
        o.add("Version 0.11");
        o.add("See original notice");
        o.add(e1);
        o.add(e1);
        o.add("Medium");
        n.strings = o;
        n.globalSubrIndex = new CFFIndex;
        const c = t.length, l = [
            ".notdef"
        ];
        let h, u;
        for(h = 0; h < c; h++){
            const e1 = a[h].glyphName;
            -1 === vr.indexOf(e1) && o.add(e1);
            l.push(e1);
        }
        n.charset = new CFFCharset(!1, 0, l);
        const d = new CFFIndex;
        d.add([
            139,
            14
        ]);
        for(h = 0; h < c; h++)d.add(t[h]);
        n.charStrings = d;
        const f = new CFFPrivateDict;
        f.setByName("Subrs", null);
        const g = [
            "BlueValues",
            "OtherBlues",
            "FamilyBlues",
            "FamilyOtherBlues",
            "StemSnapH",
            "StemSnapV",
            "BlueShift",
            "BlueFuzz",
            "BlueScale",
            "LanguageGroup",
            "ExpansionFactor",
            "ForceBold",
            "StdHW",
            "StdVW"
        ];
        for(h = 0, u = g.length; h < u; h++){
            const e1 = g[h];
            if (!(e1 in i.privateData)) continue;
            const t = i.privateData[e1];
            if (Array.isArray(t)) for(let e1 = t.length - 1; e1 > 0; e1--)t[e1] -= t[e1 - 1];
            f.setByName(e1, t);
        }
        n.topDict.privateDict = f;
        const p = new CFFIndex;
        for(h = 0, u = r.length; h < u; h++)p.add(r[h]);
        f.subrsIndex = p;
        return new CFFCompiler(n).compile();
    }
}
const ei = [
    [
        57344,
        63743
    ],
    [
        1048576,
        1114109
    ]
], ti = 1e3, ai = [
    "ascent",
    "bbox",
    "black",
    "bold",
    "charProcOperatorList",
    "cssFontInfo",
    "data",
    "defaultVMetrics",
    "defaultWidth",
    "descent",
    "disableFontFace",
    "fallbackName",
    "fontExtraProperties",
    "fontMatrix",
    "isInvalidPDFjsFont",
    "isType3Font",
    "italic",
    "loadedName",
    "mimetype",
    "missingFile",
    "name",
    "remeasure",
    "systemFontInfo",
    "vertical"
], ri = [
    "cMap",
    "composite",
    "defaultEncoding",
    "differences",
    "isMonospace",
    "isSerifFont",
    "isSymbolicFont",
    "seacMap",
    "subtype",
    "toFontChar",
    "toUnicode",
    "type",
    "vmetrics",
    "widths"
];
function adjustWidths(e1) {
    if (!e1.fontMatrix) return;
    if (e1.fontMatrix[0] === t[0]) return;
    const a = .001 / e1.fontMatrix[0], r = e1.widths;
    for(const e1 in r)r[e1] *= a;
    e1.defaultWidth *= a;
}
function amendFallbackToUnicode(e1) {
    if (!e1.fallbackToUnicode) return;
    if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
    const t = [];
    for(const a in e1.fallbackToUnicode)e1.toUnicode.has(a) || (t[a] = e1.fallbackToUnicode[a]);
    t.length > 0 && e1.toUnicode.amend(t);
}
class fonts_Glyph {
    constructor(e1, t, a, r, i, n, s, o, c){
        this.originalCharCode = e1;
        this.fontChar = t;
        this.unicode = a;
        this.accent = r;
        this.width = i;
        this.vmetric = n;
        this.operatorListId = s;
        this.isSpace = o;
        this.isInFont = c;
    }
    get category() {
        return shadow(this, "category", function getCharUnicodeCategory(e1) {
            const t = gr.get(e1);
            if (t) return t;
            const a = e1.match(fr), r = {
                isWhitespace: !!a?.[1],
                isZeroWidthDiacritic: !!a?.[2],
                isInvisibleFormatMark: !!a?.[3]
            };
            gr.set(e1, r);
            return r;
        }(this.unicode), !0);
    }
}
function int16(e1, t) {
    return (e1 << 8) + t;
}
function writeSignedInt16(e1, t, a) {
    e1[t + 1] = a;
    e1[t] = a >>> 8;
}
function signedInt16(e1, t) {
    const a = (e1 << 8) + t;
    return 32768 & a ? a - 65536 : a;
}
function string16(e1) {
    return String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function safeString16(e1) {
    e1 > 32767 ? e1 = 32767 : e1 < -32768 && (e1 = -32768);
    return String.fromCharCode(e1 >> 8 & 255, 255 & e1);
}
function isTrueTypeCollectionFile(e1) {
    return "ttcf" === bytesToString(e1.peekBytes(4));
}
function getFontFileType(e1, { type: t, subtype: a, composite: r }) {
    let i, n;
    if (function isTrueTypeFile(e1) {
        const t = e1.peekBytes(4);
        return 65536 === readUint32(t, 0) || "true" === bytesToString(t);
    }(e1) || isTrueTypeCollectionFile(e1)) i = r ? "CIDFontType2" : "TrueType";
    else if (function isOpenTypeFile(e1) {
        return "OTTO" === bytesToString(e1.peekBytes(4));
    }(e1)) i = r ? "CIDFontType2" : "OpenType";
    else if (function isType1File(e1) {
        const t = e1.peekBytes(2);
        return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1];
    }(e1)) i = r ? "CIDFontType0" : "MMType1" === t ? "MMType1" : "Type1";
    else if (function isCFFFile(e1) {
        const t = e1.peekBytes(4);
        return t[0] >= 1 && t[3] >= 1 && t[3] <= 4;
    }(e1)) if (r) {
        i = "CIDFontType0";
        n = "CIDFontType0C";
    } else {
        i = "MMType1" === t ? "MMType1" : "Type1";
        n = "Type1C";
    }
    else {
        warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
        i = t;
        n = a;
    }
    return [
        i,
        n
    ];
}
function applyStandardFontGlyphMap(e1, t) {
    for(const a in t)e1[+a] = t[a];
}
function buildToFontChar(e1, t, a) {
    const r = [];
    let i;
    for(let a = 0, n = e1.length; a < n; a++){
        i = getUnicodeForGlyph(e1[a], t);
        -1 !== i && (r[a] = i);
    }
    for(const e1 in a){
        i = getUnicodeForGlyph(a[e1], t);
        -1 !== i && (r[+e1] = i);
    }
    return r;
}
function isMacNameRecord(e1) {
    return 1 === e1.platform && 0 === e1.encoding && 0 === e1.language;
}
function isWinNameRecord(e1) {
    return 3 === e1.platform && 1 === e1.encoding && 1033 === e1.language;
}
function convertCidString(e1, t, a = !1) {
    switch(t.length){
        case 1:
            return t.charCodeAt(0);
        case 2:
            return t.charCodeAt(0) << 8 | t.charCodeAt(1);
    }
    const r = `Unsupported CID string (charCode ${e1}): "${t}".`;
    if (a) throw new FormatError(r);
    warn(r);
    return t;
}
function adjustMapping(e1, t, a, r) {
    const i = Object.create(null), n = new Map, s = [], o = new Set;
    let c = 0;
    let l = ei[c][0], h = ei[c][1];
    let u = null;
    for(const f in e1){
        let g = e1[f];
        if (!t(g)) continue;
        if (l > h) {
            c++;
            if (c >= ei.length) {
                warn("Ran out of space in font private use area.");
                break;
            }
            l = ei[c][0];
            h = ei[c][1];
        }
        const p = l++;
        0 === g && (g = a);
        let m = r.get(f);
        if ("string" == typeof m) if (1 === m.length) m = m.codePointAt(0);
        else {
            if (!u) {
                u = new Map;
                for(let e1 = 64256; e1 <= 64335; e1++){
                    const t = String.fromCharCode(e1).normalize("NFKD");
                    t.length > 1 && u.set(t, e1);
                }
            }
            m = u.get(m) || m.codePointAt(0);
        }
        if (m && !(d = m, ei[0][0] <= d && d <= ei[0][1] || ei[1][0] <= d && d <= ei[1][1]) && !o.has(g)) {
            n.set(m, g);
            o.add(g);
        }
        i[p] = g;
        s[f] = p;
    }
    var d;
    return {
        toFontChar: s,
        charCodeToGlyphId: i,
        toUnicodeExtraMap: n,
        nextAvailableFontCharCode: l
    };
}
function createCmapTable(e1, t, a) {
    const r = function getRanges(e1, t, a) {
        const r = [];
        for(const t in e1)e1[t] >= a || r.push({
            fontCharCode: 0 | t,
            glyphId: e1[t]
        });
        if (t) for (const [e1, i] of t)i >= a || r.push({
            fontCharCode: e1,
            glyphId: i
        });
        0 === r.length && r.push({
            fontCharCode: 0,
            glyphId: 0
        });
        r.sort((e1, t)=>e1.fontCharCode - t.fontCharCode);
        const i = [], n = r.length;
        for(let e1 = 0; e1 < n;){
            const t = r[e1].fontCharCode, a = [
                r[e1].glyphId
            ];
            ++e1;
            let s = t;
            for(; e1 < n && s + 1 === r[e1].fontCharCode;){
                a.push(r[e1].glyphId);
                ++s;
                ++e1;
                if (65535 === s) break;
            }
            i.push([
                t,
                s,
                a
            ]);
        }
        return i;
    }(e1, t, a), i = r.at(-1)[1] > 65535 ? 2 : 1;
    let n, s, o, c, l = "\0\0" + string16(i) + "\0\0" + string32(4 + 8 * i);
    for(n = r.length - 1; n >= 0 && !(r[n][0] <= 65535); --n);
    const h = n + 1;
    r[n][0] < 65535 && 65535 === r[n][1] && (r[n][1] = 65534);
    const u = r[n][1] < 65535 ? 1 : 0, d = h + u, f = OpenTypeFileBuilder.getSearchParams(d, 2);
    let g, p, m, b, y = "", w = "", x = "", S = "", k = "", C = 0;
    for(n = 0, s = h; n < s; n++){
        g = r[n];
        p = g[0];
        m = g[1];
        y += string16(p);
        w += string16(m);
        b = g[2];
        let e1 = !0;
        for(o = 1, c = b.length; o < c; ++o)if (b[o] !== b[o - 1] + 1) {
            e1 = !1;
            break;
        }
        if (e1) {
            x += string16(b[0] - p & 65535);
            S += string16(0);
        } else {
            const e1 = 2 * (d - n) + 2 * C;
            C += m - p + 1;
            x += string16(0);
            S += string16(e1);
            for(o = 0, c = b.length; o < c; ++o)k += string16(b[o]);
        }
    }
    if (u > 0) {
        w += "ÿÿ";
        y += "ÿÿ";
        x += "\0";
        S += "\0\0";
    }
    const v = "\0\0" + string16(2 * d) + string16(f.range) + string16(f.entry) + string16(f.rangeShift) + w + "\0\0" + y + x + S + k;
    let F = "", T = "";
    if (i > 1) {
        l += "\0\0\n" + string32(4 + 8 * i + 4 + v.length);
        F = "";
        for(n = 0, s = r.length; n < s; n++){
            g = r[n];
            p = g[0];
            b = g[2];
            let e1 = b[0];
            for(o = 1, c = b.length; o < c; ++o)if (b[o] !== b[o - 1] + 1) {
                m = g[0] + o - 1;
                F += string32(p) + string32(m) + string32(e1);
                p = m + 1;
                e1 = b[o];
            }
            F += string32(p) + string32(g[1]) + string32(e1);
        }
        T = "\0\f\0\0" + string32(F.length + 16) + "\0\0\0\0" + string32(F.length / 12);
    }
    return l + "\0" + string16(v.length + 4) + v + T + F;
}
function createOS2Table(e1, t, a) {
    a ||= {
        unitsPerEm: 0,
        yMax: 0,
        yMin: 0,
        ascent: 0,
        descent: 0
    };
    let r = 0, i = 0, n = 0, s = 0, o = null, c = 0, l = -1;
    if (t) {
        for(let e1 in t){
            e1 |= 0;
            (o > e1 || !o) && (o = e1);
            c < e1 && (c = e1);
            l = getUnicodeRangeFor(e1, l);
            if (l < 32) r |= 1 << l;
            else if (l < 64) i |= 1 << l - 32;
            else if (l < 96) n |= 1 << l - 64;
            else {
                if (!(l < 123)) throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                s |= 1 << l - 96;
            }
        }
        c > 65535 && (c = 65535);
    } else {
        o = 0;
        c = 255;
    }
    const h = e1.bbox || [
        0,
        0,
        0,
        0
    ], u = a.unitsPerEm || (e1.fontMatrix ? 1 / Math.max(...e1.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), d = e1.ascentScaled ? 1 : u / ti, f = a.ascent || Math.round(d * (e1.ascent || h[3]));
    let g = a.descent || Math.round(d * (e1.descent || h[1]));
    g > 0 && e1.descent > 0 && h[1] < 0 && (g = -g);
    const p = a.yMax || f, m = -a.yMin || -g;
    return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e1.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(r) + string32(i) + string32(n) + string32(s) + "*21*" + string16(e1.italicAngle ? 1 : 0) + string16(o || e1.firstChar) + string16(c || e1.lastChar) + string16(f) + string16(g) + "\0d" + string16(p) + string16(m) + "\0\0\0\0\0\0\0\0" + string16(e1.xHeight) + string16(e1.capHeight) + string16(0) + string16(o || e1.firstChar) + "\0";
}
function createPostTable(e1) {
    return "\0\0\0" + string32(Math.floor(65536 * e1.italicAngle)) + "\0\0\0\0" + string32(e1.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e1) {
    return e1.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e1, t) {
    t || (t = [
        [],
        []
    ]);
    const a = [
        t[0][0] || "Original licence",
        t[0][1] || e1,
        t[0][2] || "Unknown",
        t[0][3] || "uniqueID",
        t[0][4] || e1,
        t[0][5] || "Version 0.11",
        t[0][6] || createPostscriptName(e1),
        t[0][7] || "Unknown",
        t[0][8] || "Unknown",
        t[0][9] || "Unknown"
    ], r = [];
    let i, n, s, o, c;
    for(i = 0, n = a.length; i < n; i++){
        c = t[1][i] || a[i];
        const e1 = [];
        for(s = 0, o = c.length; s < o; s++)e1.push(string16(c.charCodeAt(s)));
        r.push(e1.join(""));
    }
    const l = [
        a,
        r
    ], h = [
        "\0",
        "\0"
    ], u = [
        "\0\0",
        "\0"
    ], d = [
        "\0\0",
        "\t"
    ], f = a.length * h.length;
    let g = "\0\0" + string16(f) + string16(12 * f + 6), p = 0;
    for(i = 0, n = h.length; i < n; i++){
        const e1 = l[i];
        for(s = 0, o = e1.length; s < o; s++){
            c = e1[s];
            g += h[i] + u[i] + d[i] + string16(s) + string16(c.length) + string16(p);
            p += c.length;
        }
    }
    g += a.join("") + r.join("");
    return g;
}
class Font {
    constructor(e1, t, a, r){
        this.name = e1;
        this.psName = null;
        this.mimetype = null;
        this.disableFontFace = r.disableFontFace;
        this.fontExtraProperties = r.fontExtraProperties;
        this.loadedName = a.loadedName;
        this.isType3Font = a.isType3Font;
        this.missingFile = !1;
        this.cssFontInfo = a.cssFontInfo;
        this._charsCache = Object.create(null);
        this._glyphCache = Object.create(null);
        let i = !!(a.flags & br);
        if (!i && !a.isSimulatedFlags) {
            const t = e1.replaceAll(/[,_]/g, "-").split("-", 1)[0], a = Pr();
            for (const e1 of t.split("+"))if (a[e1]) {
                i = !0;
                break;
            }
        }
        this.isSerifFont = i;
        this.isSymbolicFont = !!(a.flags & yr);
        this.isMonospace = !!(a.flags & mr);
        let { type: n, subtype: s } = a;
        this.type = n;
        this.subtype = s;
        this.systemFontInfo = a.systemFontInfo;
        const o = e1.match(/^InvalidPDFjsFont_(.*)_\d+$/);
        this.isInvalidPDFjsFont = !!o;
        this.isInvalidPDFjsFont ? this.fallbackName = o[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
        if (this.systemFontInfo?.guessFallback) {
            this.systemFontInfo.guessFallback = !1;
            this.systemFontInfo.css += `,${this.fallbackName}`;
        }
        this.differences = a.differences;
        this.widths = a.widths;
        this.defaultWidth = a.defaultWidth;
        this.composite = a.composite;
        this.cMap = a.cMap;
        this.capHeight = a.capHeight / ti;
        this.ascent = a.ascent / ti;
        this.descent = a.descent / ti;
        this.lineHeight = this.ascent - this.descent;
        this.fontMatrix = a.fontMatrix;
        this.bbox = a.bbox;
        this.defaultEncoding = a.defaultEncoding;
        this.toUnicode = a.toUnicode;
        this.toFontChar = [];
        if ("Type3" === a.type) {
            for(let e1 = 0; e1 < 256; e1++)this.toFontChar[e1] = this.differences[e1] || a.defaultEncoding[e1];
            return;
        }
        this.cidEncoding = a.cidEncoding || "";
        this.vertical = !!a.vertical;
        if (this.vertical) {
            this.vmetrics = a.vmetrics;
            this.defaultVMetrics = a.defaultVMetrics;
        }
        if (!t || t.isEmpty) {
            t && warn('Font file is empty in "' + e1 + '" (' + this.loadedName + ")");
            this.fallbackToSystemFont(a);
            return;
        }
        [n, s] = getFontFileType(t, a);
        n === this.type && s === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${n}/${s}.`);
        let c;
        try {
            switch(n){
                case "MMType1":
                    info("MMType1 font (" + e1 + "), falling back to Type1.");
                case "Type1":
                case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const r = "Type1C" === s || "CIDFontType0C" === s ? new CFFFont(t, a) : new Type1Font(e1, t, a);
                    adjustWidths(a);
                    c = this.convert(e1, r, a);
                    break;
                case "OpenType":
                case "TrueType":
                case "CIDFontType2":
                    this.mimetype = "font/opentype";
                    c = this.checkAndRepair(e1, t, a);
                    adjustWidths(a);
                    this.isOpenType && (n = "OpenType");
                    break;
                default:
                    throw new FormatError(`Font ${n} is not supported`);
            }
        } catch (e1) {
            warn(e1);
            this.fallbackToSystemFont(a);
            return;
        }
        amendFallbackToUnicode(a);
        this.data = c;
        this.type = n;
        this.subtype = s;
        this.fontMatrix = a.fontMatrix;
        this.widths = a.widths;
        this.defaultWidth = a.defaultWidth;
        this.toUnicode = a.toUnicode;
        this.seacMap = a.seacMap;
    }
    get renderer() {
        return shadow(this, "renderer", FontRendererFactory.create(this, pr));
    }
    exportData() {
        const e1 = this.fontExtraProperties ? [
            ...ai,
            ...ri
        ] : ai, t = Object.create(null);
        for (const a of e1){
            const e1 = this[a];
            void 0 !== e1 && (t[a] = e1);
        }
        return t;
    }
    fallbackToSystemFont(e1) {
        this.missingFile = !0;
        const { name: t, type: a } = this;
        let r = normalizeFontName(t);
        const i = Rr(), n = Er(), s = !!i[r], o = !(!n[r] || !i[n[r]]);
        r = i[r] || n[r] || r;
        const c = qr()[r];
        if (c) {
            isNaN(this.ascent) && (this.ascent = c.ascent / ti);
            isNaN(this.descent) && (this.descent = c.descent / ti);
            isNaN(this.capHeight) && (this.capHeight = c.capHeight / ti);
        }
        this.bold = /bold/gi.test(r);
        this.italic = /oblique|italic/gi.test(r);
        this.black = /Black/g.test(t);
        const l = /Narrow/g.test(t);
        this.remeasure = (!s || l) && Object.keys(this.widths).length > 0;
        if ((s || o) && "CIDFontType2" === a && this.cidEncoding.startsWith("Identity-")) {
            const a = e1.cidToGidMap, r = [];
            applyStandardFontGlyphMap(r, jr());
            /Arial-?Black/i.test(t) ? applyStandardFontGlyphMap(r, _r()) : /Calibri/i.test(t) && applyStandardFontGlyphMap(r, Ur());
            if (a) {
                for(const e1 in r){
                    const t = r[e1];
                    void 0 !== a[t] && (r[+e1] = a[t]);
                }
                a.length !== this.toUnicode.length && e1.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e1, t) {
                    const i = r[e1];
                    void 0 === a[i] && (r[+e1] = t);
                });
            }
            this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e1, t) {
                r[+e1] = t;
            });
            this.toFontChar = r;
            this.toUnicode = new ToUnicodeMap(r);
        } else if (/Symbol/i.test(r)) this.toFontChar = buildToFontChar(or, lr(), this.differences);
        else if (/Dingbats/i.test(r)) this.toFontChar = buildToFontChar(cr, hr(), this.differences);
        else if (s || o) {
            const e1 = buildToFontChar(this.defaultEncoding, lr(), this.differences);
            "CIDFontType2" !== a || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t, a) {
                e1[+t] = a;
            });
            this.toFontChar = e1;
        } else {
            const e1 = lr(), a = [];
            this.toUnicode.forEach((t, r)=>{
                if (!this.composite) {
                    const a = getUnicodeForGlyph(this.differences[t] || this.defaultEncoding[t], e1);
                    -1 !== a && (r = a);
                }
                a[+t] = r;
            });
            this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t) && applyStandardFontGlyphMap(a, jr());
            this.toFontChar = a;
        }
        amendFallbackToUnicode(e1);
        this.loadedName = r.split("-", 1)[0];
    }
    checkAndRepair(e1, t, a) {
        const r = [
            "OS/2",
            "cmap",
            "head",
            "hhea",
            "hmtx",
            "maxp",
            "name",
            "post",
            "loca",
            "glyf",
            "fpgm",
            "prep",
            "cvt ",
            "CFF "
        ];
        function readTables(e1, t) {
            const a = Object.create(null);
            a["OS/2"] = null;
            a.cmap = null;
            a.head = null;
            a.hhea = null;
            a.hmtx = null;
            a.maxp = null;
            a.name = null;
            a.post = null;
            for(let i = 0; i < t; i++){
                const t = readTableEntry(e1);
                r.includes(t.tag) && 0 !== t.length && (a[t.tag] = t);
            }
            return a;
        }
        function readTableEntry(e1) {
            const t = e1.getString(4), a = e1.getInt32() >>> 0, r = e1.getInt32() >>> 0, i = e1.getInt32() >>> 0, n = e1.pos;
            e1.pos = e1.start || 0;
            e1.skip(r);
            const s = e1.getBytes(i);
            e1.pos = n;
            if ("head" === t) {
                s[8] = s[9] = s[10] = s[11] = 0;
                s[17] |= 32;
            }
            return {
                tag: t,
                checksum: a,
                length: i,
                offset: r,
                data: s
            };
        }
        function readOpenTypeHeader(e1) {
            return {
                version: e1.getString(4),
                numTables: e1.getUint16(),
                searchRange: e1.getUint16(),
                entrySelector: e1.getUint16(),
                rangeShift: e1.getUint16()
            };
        }
        function sanitizeGlyph(e1, t, a, r, i, n) {
            const s = {
                length: 0,
                sizeOfInstructions: 0
            };
            if (t < 0 || t >= e1.length || a > e1.length || a - t <= 12) return s;
            const o = e1.subarray(t, a), c = signedInt16(o[2], o[3]), l = signedInt16(o[4], o[5]), h = signedInt16(o[6], o[7]), u = signedInt16(o[8], o[9]);
            if (c > h) {
                writeSignedInt16(o, 2, h);
                writeSignedInt16(o, 6, c);
            }
            if (l > u) {
                writeSignedInt16(o, 4, u);
                writeSignedInt16(o, 8, l);
            }
            const d = signedInt16(o[0], o[1]);
            if (d < 0) {
                if (d < -1) return s;
                r.set(o, i);
                s.length = o.length;
                return s;
            }
            let f, g = 10, p = 0;
            for(f = 0; f < d; f++){
                p = (o[g] << 8 | o[g + 1]) + 1;
                g += 2;
            }
            const m = g, b = o[g] << 8 | o[g + 1];
            s.sizeOfInstructions = b;
            g += 2 + b;
            const y = g;
            let w = 0;
            for(f = 0; f < p; f++){
                const e1 = o[g++];
                192 & e1 && (o[g - 1] = 63 & e1);
                let t = 2;
                2 & e1 ? t = 1 : 16 & e1 && (t = 0);
                let a = 2;
                4 & e1 ? a = 1 : 32 & e1 && (a = 0);
                const r = t + a;
                w += r;
                if (8 & e1) {
                    const e1 = o[g++];
                    0 === e1 && (o[g - 1] ^= 8);
                    f += e1;
                    w += e1 * r;
                }
            }
            if (0 === w) return s;
            let x = g + w;
            if (x > o.length) return s;
            if (!n && b > 0) {
                r.set(o.subarray(0, m), i);
                r.set([
                    0,
                    0
                ], i + m);
                r.set(o.subarray(y, x), i + m + 2);
                x -= b;
                o.length - x > 3 && (x = x + 3 & -4);
                s.length = x;
                return s;
            }
            if (o.length - x > 3) {
                x = x + 3 & -4;
                r.set(o.subarray(0, x), i);
                s.length = x;
                return s;
            }
            r.set(o, i);
            s.length = o.length;
            return s;
        }
        function readNameTable(e1) {
            const a = (t.start || 0) + e1.offset;
            t.pos = a;
            const r = [
                [],
                []
            ], i = [], n = e1.length, s = a + n;
            if (0 !== t.getUint16() || n < 6) return [
                r,
                i
            ];
            const o = t.getUint16(), c = t.getUint16();
            let l, h;
            for(l = 0; l < o && t.pos + 12 <= s; l++){
                const e1 = {
                    platform: t.getUint16(),
                    encoding: t.getUint16(),
                    language: t.getUint16(),
                    name: t.getUint16(),
                    length: t.getUint16(),
                    offset: t.getUint16()
                };
                (isMacNameRecord(e1) || isWinNameRecord(e1)) && i.push(e1);
            }
            for(l = 0, h = i.length; l < h; l++){
                const e1 = i[l];
                if (e1.length <= 0) continue;
                const n = a + c + e1.offset;
                if (n + e1.length > s) continue;
                t.pos = n;
                const o = e1.name;
                if (e1.encoding) {
                    let a = "";
                    for(let r = 0, i = e1.length; r < i; r += 2)a += String.fromCharCode(t.getUint16());
                    r[1][o] = a;
                } else r[0][o] = t.getString(e1.length);
            }
            return [
                r,
                i
            ];
        }
        const i = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -2,
            -2,
            -2,
            0,
            0,
            -2,
            -5,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -999,
            0,
            1,
            0,
            -1,
            -2,
            0,
            -1,
            -2,
            -1,
            -1,
            0,
            -1,
            -1,
            0,
            0,
            -999,
            -999,
            -1,
            -1,
            -1,
            -1,
            -2,
            -999,
            -2,
            -2,
            -999,
            0,
            -2,
            -2,
            0,
            0,
            -2,
            0,
            -2,
            0,
            0,
            0,
            -2,
            -1,
            -1,
            1,
            1,
            0,
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            -1,
            0,
            -1,
            -1,
            0,
            -999,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            -2,
            -999,
            -999,
            -999,
            -999,
            -999,
            -1,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            0,
            -1,
            -1,
            -999,
            -2,
            -2,
            0,
            0,
            -1,
            -2,
            -2,
            0,
            0,
            0,
            -1,
            -1,
            -1,
            -2
        ];
        function sanitizeTTProgram(e1, t) {
            let a, r, n, s, o, c = e1.data, l = 0, h = 0, u = 0;
            const d = [], f = [], g = [];
            let p = t.tooComplexToFollowFunctions, m = !1, b = 0, y = 0;
            for(let e1 = c.length; l < e1;){
                const e1 = c[l++];
                if (64 === e1) {
                    r = c[l++];
                    if (m || y) l += r;
                    else for(a = 0; a < r; a++)d.push(c[l++]);
                } else if (65 === e1) {
                    r = c[l++];
                    if (m || y) l += 2 * r;
                    else for(a = 0; a < r; a++){
                        n = c[l++];
                        d.push(n << 8 | c[l++]);
                    }
                } else if (176 == (248 & e1)) {
                    r = e1 - 176 + 1;
                    if (m || y) l += r;
                    else for(a = 0; a < r; a++)d.push(c[l++]);
                } else if (184 == (248 & e1)) {
                    r = e1 - 184 + 1;
                    if (m || y) l += 2 * r;
                    else for(a = 0; a < r; a++){
                        n = c[l++];
                        d.push(signedInt16(n, c[l++]));
                    }
                } else if (43 !== e1 || p) if (44 !== e1 || p) {
                    if (45 === e1) if (m) {
                        m = !1;
                        h = l;
                    } else {
                        o = f.pop();
                        if (!o) {
                            warn("TT: ENDF bad stack");
                            t.hintsValid = !1;
                            return;
                        }
                        s = g.pop();
                        c = o.data;
                        l = o.i;
                        t.functionsStackDeltas[s] = d.length - o.stackTop;
                    }
                    else if (137 === e1) {
                        if (m || y) {
                            warn("TT: nested IDEFs not allowed");
                            p = !0;
                        }
                        m = !0;
                        u = l;
                    } else if (88 === e1) ++b;
                    else if (27 === e1) y = b;
                    else if (89 === e1) {
                        y === b && (y = 0);
                        --b;
                    } else if (28 === e1 && !m && !y) {
                        const e1 = d.at(-1);
                        e1 > 0 && (l += e1 - 1);
                    }
                } else {
                    if (m || y) {
                        warn("TT: nested FDEFs not allowed");
                        p = !0;
                    }
                    m = !0;
                    u = l;
                    s = d.pop();
                    t.functionsDefined[s] = {
                        data: c,
                        i: l
                    };
                }
                else if (!m && !y) {
                    s = d.at(-1);
                    if (isNaN(s)) info("TT: CALL empty stack (or invalid entry).");
                    else {
                        t.functionsUsed[s] = !0;
                        if (s in t.functionsStackDeltas) {
                            const e1 = d.length + t.functionsStackDeltas[s];
                            if (e1 < 0) {
                                warn("TT: CALL invalid functions stack delta.");
                                t.hintsValid = !1;
                                return;
                            }
                            d.length = e1;
                        } else if (s in t.functionsDefined && !g.includes(s)) {
                            f.push({
                                data: c,
                                i: l,
                                stackTop: d.length - 1
                            });
                            g.push(s);
                            o = t.functionsDefined[s];
                            if (!o) {
                                warn("TT: CALL non-existent function");
                                t.hintsValid = !1;
                                return;
                            }
                            c = o.data;
                            l = o.i;
                        }
                    }
                }
                if (!m && !y) {
                    let t = 0;
                    e1 <= 142 ? t = i[e1] : e1 >= 192 && e1 <= 223 ? t = -1 : e1 >= 224 && (t = -2);
                    if (e1 >= 113 && e1 <= 117) {
                        r = d.pop();
                        isNaN(r) || (t = 2 * -r);
                    }
                    for(; t < 0 && d.length > 0;){
                        d.pop();
                        t++;
                    }
                    for(; t > 0;){
                        d.push(NaN);
                        t--;
                    }
                }
            }
            t.tooComplexToFollowFunctions = p;
            const w = [
                c
            ];
            l > c.length && w.push(new Uint8Array(l - c.length));
            if (u > h) {
                warn("TT: complementing a missing function tail");
                w.push(new Uint8Array([
                    34,
                    45
                ]));
            }
            !function foldTTTable(e1, t) {
                if (t.length > 1) {
                    let a, r, i = 0;
                    for(a = 0, r = t.length; a < r; a++)i += t[a].length;
                    i = i + 3 & -4;
                    const n = new Uint8Array(i);
                    let s = 0;
                    for(a = 0, r = t.length; a < r; a++){
                        n.set(t[a], s);
                        s += t[a].length;
                    }
                    e1.data = n;
                    e1.length = i;
                }
            }(e1, w);
        }
        let n, s, o, c;
        if (isTrueTypeCollectionFile(t = new Stream(new Uint8Array(t.getBytes())))) {
            const e1 = function readTrueTypeCollectionData(e1, t) {
                const { numFonts: a, offsetTable: r } = function readTrueTypeCollectionHeader(e1) {
                    const t = e1.getString(4);
                    assert("ttcf" === t, "Must be a TrueType Collection font.");
                    const a = e1.getUint16(), r = e1.getUint16(), i = e1.getInt32() >>> 0, n = [];
                    for(let t = 0; t < i; t++)n.push(e1.getInt32() >>> 0);
                    const s = {
                        ttcTag: t,
                        majorVersion: a,
                        minorVersion: r,
                        numFonts: i,
                        offsetTable: n
                    };
                    switch(a){
                        case 1:
                            return s;
                        case 2:
                            s.dsigTag = e1.getInt32() >>> 0;
                            s.dsigLength = e1.getInt32() >>> 0;
                            s.dsigOffset = e1.getInt32() >>> 0;
                            return s;
                    }
                    throw new FormatError(`Invalid TrueType Collection majorVersion: ${a}.`);
                }(e1), i = t.split("+");
                let n;
                for(let s = 0; s < a; s++){
                    e1.pos = (e1.start || 0) + r[s];
                    const a = readOpenTypeHeader(e1), o = readTables(e1, a.numTables);
                    if (!o.name) throw new FormatError('TrueType Collection font must contain a "name" table.');
                    const [c] = readNameTable(o.name);
                    for(let e1 = 0, r = c.length; e1 < r; e1++)for(let r = 0, s = c[e1].length; r < s; r++){
                        const s = c[e1][r]?.replaceAll(/\s/g, "");
                        if (s) {
                            if (s === t) return {
                                header: a,
                                tables: o
                            };
                            if (!(i.length < 2)) for (const e1 of i)s === e1 && (n = {
                                name: e1,
                                header: a,
                                tables: o
                            });
                        }
                    }
                }
                if (n) {
                    warn(`TrueType Collection does not contain "${t}" font, falling back to "${n.name}" font instead.`);
                    return {
                        header: n.header,
                        tables: n.tables
                    };
                }
                throw new FormatError(`TrueType Collection does not contain "${t}" font.`);
            }(t, this.name);
            n = e1.header;
            s = e1.tables;
        } else {
            n = readOpenTypeHeader(t);
            s = readTables(t, n.numTables);
        }
        const l = !s["CFF "];
        if (l) {
            if (!s.loca) throw new FormatError('Required "loca" table is not found');
            if (!s.glyf) {
                warn('Required "glyf" table is not found -- trying to recover.');
                s.glyf = {
                    tag: "glyf",
                    data: new Uint8Array(0)
                };
            }
            this.isOpenType = !1;
        } else {
            const t = a.composite && (a.cidToGidMap?.length > 0 || !(a.cMap instanceof IdentityCMap));
            if ("OTTO" === n.version && !t || !s.head || !s.hhea || !s.maxp || !s.post) {
                c = new Stream(s["CFF "].data);
                o = new CFFFont(c, a);
                return this.convert(e1, o, a);
            }
            delete s.glyf;
            delete s.loca;
            delete s.fpgm;
            delete s.prep;
            delete s["cvt "];
            this.isOpenType = !0;
        }
        if (!s.maxp) throw new FormatError('Required "maxp" table is not found');
        t.pos = (t.start || 0) + s.maxp.offset;
        let h = t.getInt32();
        const u = t.getUint16();
        if (65536 !== h && 20480 !== h) {
            if (6 === s.maxp.length) h = 20480;
            else {
                if (!(s.maxp.length >= 32)) throw new FormatError('"maxp" table has a wrong version number');
                h = 65536;
            }
            !function writeUint32(e1, t, a) {
                e1[t + 3] = 255 & a;
                e1[t + 2] = a >>> 8;
                e1[t + 1] = a >>> 16;
                e1[t] = a >>> 24;
            }(s.maxp.data, 0, h);
        }
        if (a.scaleFactors?.length === u && l) {
            const { scaleFactors: e1 } = a, t = int16(s.head.data[50], s.head.data[51]), r = new GlyfTable({
                glyfTable: s.glyf.data,
                isGlyphLocationsLong: t,
                locaTable: s.loca.data,
                numGlyphs: u
            });
            r.scale(e1);
            const { glyf: i, loca: n, isLocationLong: o } = r.write();
            s.glyf.data = i;
            s.loca.data = n;
            if (o !== !!t) {
                s.head.data[50] = 0;
                s.head.data[51] = o ? 1 : 0;
            }
            const c = s.hmtx.data;
            for(let t = 0; t < u; t++){
                const a = 4 * t, r = Math.round(e1[t] * int16(c[a], c[a + 1]));
                c[a] = r >> 8 & 255;
                c[a + 1] = 255 & r;
                writeSignedInt16(c, a + 2, Math.round(e1[t] * signedInt16(c[a + 2], c[a + 3])));
            }
        }
        let d = u + 1, f = !0;
        if (d > 65535) {
            f = !1;
            d = u;
            warn("Not enough space in glyfs to duplicate first glyph.");
        }
        let g = 0, p = 0;
        if (h >= 65536 && s.maxp.length >= 32) {
            t.pos += 8;
            if (t.getUint16() > 2) {
                s.maxp.data[14] = 0;
                s.maxp.data[15] = 2;
            }
            t.pos += 4;
            g = t.getUint16();
            t.pos += 4;
            p = t.getUint16();
        }
        s.maxp.data[4] = d >> 8;
        s.maxp.data[5] = 255 & d;
        const m = function sanitizeTTPrograms(e1, t, a, r) {
            const i = {
                functionsDefined: [],
                functionsUsed: [],
                functionsStackDeltas: [],
                tooComplexToFollowFunctions: !1,
                hintsValid: !0
            };
            e1 && sanitizeTTProgram(e1, i);
            t && sanitizeTTProgram(t, i);
            e1 && function checkInvalidFunctions(e1, t) {
                if (!e1.tooComplexToFollowFunctions) if (e1.functionsDefined.length > t) {
                    warn("TT: more functions defined than expected");
                    e1.hintsValid = !1;
                } else for(let a = 0, r = e1.functionsUsed.length; a < r; a++){
                    if (a > t) {
                        warn("TT: invalid function id: " + a);
                        e1.hintsValid = !1;
                        return;
                    }
                    if (e1.functionsUsed[a] && !e1.functionsDefined[a]) {
                        warn("TT: undefined function: " + a);
                        e1.hintsValid = !1;
                        return;
                    }
                }
            }(i, r);
            if (a && 1 & a.length) {
                const e1 = new Uint8Array(a.length + 1);
                e1.set(a.data);
                a.data = e1;
            }
            return i.hintsValid;
        }(s.fpgm, s.prep, s["cvt "], g);
        if (!m) {
            delete s.fpgm;
            delete s.prep;
            delete s["cvt "];
        }
        !function sanitizeMetrics(e1, t, a, r, i, n) {
            if (!t) {
                a && (a.data = null);
                return;
            }
            e1.pos = (e1.start || 0) + t.offset;
            e1.pos += 4;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            e1.pos += 2;
            const s = e1.getUint16();
            e1.pos += 8;
            e1.pos += 2;
            let o = e1.getUint16();
            if (0 !== s) {
                if (!(2 & int16(r.data[44], r.data[45]))) {
                    t.data[22] = 0;
                    t.data[23] = 0;
                }
            }
            if (o > i) {
                info(`The numOfMetrics (${o}) should not be greater than the numGlyphs (${i}).`);
                o = i;
                t.data[34] = (65280 & o) >> 8;
                t.data[35] = 255 & o;
            }
            const c = i - o - (a.length - 4 * o >> 1);
            if (c > 0) {
                const e1 = new Uint8Array(a.length + 2 * c);
                e1.set(a.data);
                if (n) {
                    e1[a.length] = a.data[2];
                    e1[a.length + 1] = a.data[3];
                }
                a.data = e1;
            }
        }(t, s.hhea, s.hmtx, s.head, d, f);
        if (!s.head) throw new FormatError('Required "head" table is not found');
        !function sanitizeHead(e1, t, a) {
            const r = e1.data, i = function int32(e1, t, a, r) {
                return (e1 << 24) + (t << 16) + (a << 8) + r;
            }(r[0], r[1], r[2], r[3]);
            if (i >> 16 != 1) {
                info("Attempting to fix invalid version in head table: " + i);
                r[0] = 0;
                r[1] = 1;
                r[2] = 0;
                r[3] = 0;
            }
            const n = int16(r[50], r[51]);
            if (n < 0 || n > 1) {
                info("Attempting to fix invalid indexToLocFormat in head table: " + n);
                const e1 = t + 1;
                if (a === e1 << 1) {
                    r[50] = 0;
                    r[51] = 0;
                } else {
                    if (a !== e1 << 2) throw new FormatError("Could not fix indexToLocFormat: " + n);
                    r[50] = 0;
                    r[51] = 1;
                }
            }
        }(s.head, u, l ? s.loca.length : 0);
        let b = Object.create(null);
        if (l) {
            const e1 = int16(s.head.data[50], s.head.data[51]), t = function sanitizeGlyphLocations(e1, t, a, r, i, n, s) {
                let o, c, l;
                if (r) {
                    o = 4;
                    c = function fontItemDecodeLong(e1, t) {
                        return e1[t] << 24 | e1[t + 1] << 16 | e1[t + 2] << 8 | e1[t + 3];
                    };
                    l = function fontItemEncodeLong(e1, t, a) {
                        e1[t] = a >>> 24 & 255;
                        e1[t + 1] = a >> 16 & 255;
                        e1[t + 2] = a >> 8 & 255;
                        e1[t + 3] = 255 & a;
                    };
                } else {
                    o = 2;
                    c = function fontItemDecode(e1, t) {
                        return e1[t] << 9 | e1[t + 1] << 1;
                    };
                    l = function fontItemEncode(e1, t, a) {
                        e1[t] = a >> 9 & 255;
                        e1[t + 1] = a >> 1 & 255;
                    };
                }
                const h = n ? a + 1 : a, u = o * (1 + h), d = new Uint8Array(u);
                d.set(e1.data.subarray(0, u));
                e1.data = d;
                const f = t.data, g = f.length, p = new Uint8Array(g);
                let m, b;
                const y = [];
                for(m = 0, b = 0; m < a + 1; m++, b += o){
                    let e1 = c(d, b);
                    e1 > g && (e1 = g);
                    y.push({
                        index: m,
                        offset: e1,
                        endOffset: 0
                    });
                }
                y.sort((e1, t)=>e1.offset - t.offset);
                for(m = 0; m < a; m++)y[m].endOffset = y[m + 1].offset;
                y.sort((e1, t)=>e1.index - t.index);
                for(m = 0; m < a; m++){
                    const { offset: e1, endOffset: t } = y[m];
                    if (0 !== e1 || 0 !== t) break;
                    const a = y[m + 1].offset;
                    if (0 !== a) {
                        y[m].endOffset = a;
                        break;
                    }
                }
                const w = y.at(-2);
                0 !== w.offset && 0 === w.endOffset && (w.endOffset = g);
                const x = Object.create(null);
                let S = 0;
                l(d, 0, S);
                for(m = 0, b = o; m < a; m++, b += o){
                    const e1 = sanitizeGlyph(f, y[m].offset, y[m].endOffset, p, S, i), t = e1.length;
                    0 === t && (x[m] = !0);
                    e1.sizeOfInstructions > s && (s = e1.sizeOfInstructions);
                    S += t;
                    l(d, b, S);
                }
                if (0 === S) {
                    const e1 = new Uint8Array([
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        49,
                        0
                    ]);
                    for(m = 0, b = o; m < h; m++, b += o)l(d, b, e1.length);
                    t.data = e1;
                } else if (n) {
                    const a = c(d, o);
                    if (p.length > a + S) t.data = p.subarray(0, a + S);
                    else {
                        t.data = new Uint8Array(a + S);
                        t.data.set(p.subarray(0, S));
                    }
                    t.data.set(p.subarray(0, a), S);
                    l(e1.data, d.length - o, S + a);
                } else t.data = p.subarray(0, S);
                return {
                    missingGlyphs: x,
                    maxSizeOfInstructions: s
                };
            }(s.loca, s.glyf, u, e1, m, f, p);
            b = t.missingGlyphs;
            if (h >= 65536 && s.maxp.length >= 32) {
                s.maxp.data[26] = t.maxSizeOfInstructions >> 8;
                s.maxp.data[27] = 255 & t.maxSizeOfInstructions;
            }
        }
        if (!s.hhea) throw new FormatError('Required "hhea" table is not found');
        if (0 === s.hhea.data[10] && 0 === s.hhea.data[11]) {
            s.hhea.data[10] = 255;
            s.hhea.data[11] = 255;
        }
        const y = {
            unitsPerEm: int16(s.head.data[18], s.head.data[19]),
            yMax: signedInt16(s.head.data[42], s.head.data[43]),
            yMin: signedInt16(s.head.data[38], s.head.data[39]),
            ascent: signedInt16(s.hhea.data[4], s.hhea.data[5]),
            descent: signedInt16(s.hhea.data[6], s.hhea.data[7]),
            lineGap: signedInt16(s.hhea.data[8], s.hhea.data[9])
        };
        this.ascent = y.ascent / y.unitsPerEm;
        this.descent = y.descent / y.unitsPerEm;
        this.lineGap = y.lineGap / y.unitsPerEm;
        if (this.cssFontInfo?.lineHeight) {
            this.lineHeight = this.cssFontInfo.metrics.lineHeight;
            this.lineGap = this.cssFontInfo.metrics.lineGap;
        } else this.lineHeight = this.ascent - this.descent + this.lineGap;
        s.post && function readPostScriptTable(e1, a, r) {
            const i = (t.start || 0) + e1.offset;
            t.pos = i;
            const n = i + e1.length, s = t.getInt32();
            t.skip(28);
            let o, c, l = !0;
            switch(s){
                case 65536:
                    o = xr;
                    break;
                case 131072:
                    const e2 = t.getUint16();
                    if (e2 !== r) {
                        l = !1;
                        break;
                    }
                    const i1 = [];
                    for(c = 0; c < e2; ++c){
                        const e1 = t.getUint16();
                        if (e1 >= 32768) {
                            l = !1;
                            break;
                        }
                        i1.push(e1);
                    }
                    if (!l) break;
                    const h = [], u = [];
                    for(; t.pos < n;){
                        const e1 = t.getByte();
                        u.length = e1;
                        for(c = 0; c < e1; ++c)u[c] = String.fromCharCode(t.getByte());
                        h.push(u.join(""));
                    }
                    o = [];
                    for(c = 0; c < e2; ++c){
                        const e1 = i1[c];
                        e1 < 258 ? o.push(xr[e1]) : o.push(h[e1 - 258]);
                    }
                    break;
                case 196608:
                    break;
                default:
                    warn("Unknown/unsupported post table version " + s);
                    l = !1;
                    a.defaultEncoding && (o = a.defaultEncoding);
            }
            a.glyphNames = o;
            return l;
        }(s.post, a, u);
        s.post = {
            tag: "post",
            data: createPostTable(a)
        };
        const w = Object.create(null);
        function hasGlyph(e1) {
            return !b[e1];
        }
        if (a.composite) {
            const e1 = a.cidToGidMap || [], t = 0 === e1.length;
            a.cMap.forEach(function(a, r) {
                "string" == typeof r && (r = convertCidString(a, r, !0));
                if (r > 65535) throw new FormatError("Max size of CID is 65,535");
                let i = -1;
                t ? i = r : void 0 !== e1[r] && (i = e1[r]);
                i >= 0 && i < u && hasGlyph(i) && (w[a] = i);
            });
        } else {
            const e1 = function readCmapTable(e1, t, a, r) {
                if (!e1) {
                    warn("No cmap table available.");
                    return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: !1
                    };
                }
                let i, n = (t.start || 0) + e1.offset;
                t.pos = n;
                t.skip(2);
                const s = t.getUint16();
                let o, c = !1;
                for(let e1 = 0; e1 < s; e1++){
                    const i = t.getUint16(), n = t.getUint16(), l = t.getInt32() >>> 0;
                    let h = !1;
                    if (o?.platformId !== i || o?.encodingId !== n) {
                        if (0 !== i || 0 !== n && 1 !== n && 3 !== n) if (1 === i && 0 === n) h = !0;
                        else if (3 !== i || 1 !== n || !r && o) {
                            if (a && 3 === i && 0 === n) {
                                h = !0;
                                let a = !0;
                                if (e1 < s - 1) {
                                    const e1 = t.peekBytes(2);
                                    int16(e1[0], e1[1]) < i && (a = !1);
                                }
                                a && (c = !0);
                            }
                        } else {
                            h = !0;
                            a || (c = !0);
                        }
                        else h = !0;
                        h && (o = {
                            platformId: i,
                            encodingId: n,
                            offset: l
                        });
                        if (c) break;
                    }
                }
                o && (t.pos = n + o.offset);
                if (!o || -1 === t.peekByte()) {
                    warn("Could not find a preferred cmap table.");
                    return {
                        platformId: -1,
                        encodingId: -1,
                        mappings: [],
                        hasShortCmap: !1
                    };
                }
                const l = t.getUint16();
                let h = !1;
                const u = [];
                let d, f;
                if (0 === l) {
                    t.skip(4);
                    for(d = 0; d < 256; d++){
                        const e1 = t.getByte();
                        e1 && u.push({
                            charCode: d,
                            glyphId: e1
                        });
                    }
                    h = !0;
                } else if (2 === l) {
                    t.skip(4);
                    const e1 = [];
                    let a = 0;
                    for(let r = 0; r < 256; r++){
                        const r = t.getUint16() >> 3;
                        e1.push(r);
                        a = Math.max(r, a);
                    }
                    const r = [];
                    for(let e1 = 0; e1 <= a; e1++)r.push({
                        firstCode: t.getUint16(),
                        entryCount: t.getUint16(),
                        idDelta: signedInt16(t.getByte(), t.getByte()),
                        idRangePos: t.pos + t.getUint16()
                    });
                    for(let a = 0; a < 256; a++)if (0 === e1[a]) {
                        t.pos = r[0].idRangePos + 2 * a;
                        f = t.getUint16();
                        u.push({
                            charCode: a,
                            glyphId: f
                        });
                    } else {
                        const i = r[e1[a]];
                        for(d = 0; d < i.entryCount; d++){
                            const e1 = (a << 8) + d + i.firstCode;
                            t.pos = i.idRangePos + 2 * d;
                            f = t.getUint16();
                            0 !== f && (f = (f + i.idDelta) % 65536);
                            u.push({
                                charCode: e1,
                                glyphId: f
                            });
                        }
                    }
                } else if (4 === l) {
                    t.skip(4);
                    const e1 = t.getUint16() >> 1;
                    t.skip(6);
                    const a = [];
                    let r;
                    for(r = 0; r < e1; r++)a.push({
                        end: t.getUint16()
                    });
                    t.skip(2);
                    for(r = 0; r < e1; r++)a[r].start = t.getUint16();
                    for(r = 0; r < e1; r++)a[r].delta = t.getUint16();
                    let s, o = 0;
                    for(r = 0; r < e1; r++){
                        i = a[r];
                        const n = t.getUint16();
                        if (n) {
                            s = (n >> 1) - (e1 - r);
                            i.offsetIndex = s;
                            o = Math.max(o, s + i.end - i.start + 1);
                        } else i.offsetIndex = -1;
                    }
                    const c = [];
                    for(d = 0; d < o; d++)c.push(t.getUint16());
                    for(r = 0; r < e1; r++){
                        i = a[r];
                        n = i.start;
                        const e1 = i.end, t = i.delta;
                        s = i.offsetIndex;
                        for(d = n; d <= e1; d++)if (65535 !== d) {
                            f = s < 0 ? d : c[s + d - n];
                            f = f + t & 65535;
                            u.push({
                                charCode: d,
                                glyphId: f
                            });
                        }
                    }
                } else if (6 === l) {
                    t.skip(4);
                    const e1 = t.getUint16(), a = t.getUint16();
                    for(d = 0; d < a; d++){
                        f = t.getUint16();
                        const a = e1 + d;
                        u.push({
                            charCode: a,
                            glyphId: f
                        });
                    }
                } else {
                    if (12 !== l) {
                        warn("cmap table has unsupported format: " + l);
                        return {
                            platformId: -1,
                            encodingId: -1,
                            mappings: [],
                            hasShortCmap: !1
                        };
                    }
                    {
                        t.skip(10);
                        const e1 = t.getInt32() >>> 0;
                        for(d = 0; d < e1; d++){
                            const e1 = t.getInt32() >>> 0, a = t.getInt32() >>> 0;
                            let r = t.getInt32() >>> 0;
                            for(let t = e1; t <= a; t++)u.push({
                                charCode: t,
                                glyphId: r++
                            });
                        }
                    }
                }
                u.sort((e1, t)=>e1.charCode - t.charCode);
                const g = [], p = new Set;
                for (const e1 of u){
                    const { charCode: t } = e1;
                    if (!p.has(t)) {
                        p.add(t);
                        g.push(e1);
                    }
                }
                return {
                    platformId: o.platformId,
                    encodingId: o.encodingId,
                    mappings: g,
                    hasShortCmap: h
                };
            }(s.cmap, t, this.isSymbolicFont, a.hasEncoding), r = e1.platformId, i = e1.encodingId, n = e1.mappings;
            let o = [], c = !1;
            !a.hasEncoding || "MacRomanEncoding" !== a.baseEncodingName && "WinAnsiEncoding" !== a.baseEncodingName || (o = getEncoding(a.baseEncodingName));
            if (a.hasEncoding && !this.isSymbolicFont && (3 === r && 1 === i || 1 === r && 0 === i)) {
                const e1 = lr();
                for(let t = 0; t < 256; t++){
                    let s;
                    s = void 0 !== this.differences[t] ? this.differences[t] : o.length && "" !== o[t] ? o[t] : nr[t];
                    if (!s) continue;
                    const c = recoverGlyphName(s, e1);
                    let l;
                    3 === r && 1 === i ? l = e1[c] : 1 === r && 0 === i && (l = ir.indexOf(c));
                    if (void 0 === l) {
                        if (!a.glyphNames && a.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                            const e1 = this.toUnicode.get(t);
                            e1 && (l = e1.codePointAt(0));
                        }
                        if (void 0 === l) continue;
                    }
                    for (const e1 of n)if (e1.charCode === l) {
                        w[t] = e1.glyphId;
                        break;
                    }
                }
            } else if (0 === r) {
                for (const e1 of n)w[e1.charCode] = e1.glyphId;
                c = !0;
            } else if (3 === r && 0 === i) for (const e1 of n){
                let t = e1.charCode;
                t >= 61440 && t <= 61695 && (t &= 255);
                w[t] = e1.glyphId;
            }
            else for (const e1 of n)w[e1.charCode] = e1.glyphId;
            if (a.glyphNames && (o.length || this.differences.length)) for(let e1 = 0; e1 < 256; ++e1){
                if (!c && void 0 !== w[e1]) continue;
                const t = this.differences[e1] || o[e1];
                if (!t) continue;
                const r = a.glyphNames.indexOf(t);
                r > 0 && hasGlyph(r) && (w[e1] = r);
            }
        }
        0 === w.length && (w[0] = 0);
        let x = d - 1;
        f || (x = 0);
        if (!a.cssFontInfo) {
            const e1 = adjustMapping(w, hasGlyph, x, this.toUnicode);
            this.toFontChar = e1.toFontChar;
            s.cmap = {
                tag: "cmap",
                data: createCmapTable(e1.charCodeToGlyphId, e1.toUnicodeExtraMap, d)
            };
            s["OS/2"] && function validateOS2Table(e1, t) {
                t.pos = (t.start || 0) + e1.offset;
                const a = t.getUint16();
                t.skip(60);
                const r = t.getUint16();
                if (a < 4 && 768 & r) return !1;
                if (t.getUint16() > t.getUint16()) return !1;
                t.skip(6);
                if (0 === t.getUint16()) return !1;
                e1.data[8] = e1.data[9] = 0;
                return !0;
            }(s["OS/2"], t) || (s["OS/2"] = {
                tag: "OS/2",
                data: createOS2Table(a, e1.charCodeToGlyphId, y)
            });
        }
        if (!l) try {
            c = new Stream(s["CFF "].data);
            o = new CFFParser(c, a, pr).parse();
            o.duplicateFirstGlyph();
            const e1 = new CFFCompiler(o);
            s["CFF "].data = e1.compile();
        } catch  {
            warn("Failed to compile font " + a.loadedName);
        }
        if (s.name) {
            const [t, r] = readNameTable(s.name);
            s.name.data = createNameTable(e1, t);
            this.psName = t[0][6] || null;
            a.composite || function adjustTrueTypeToUnicode(e1, t, a) {
                if (e1.isInternalFont) return;
                if (e1.hasIncludedToUnicodeMap) return;
                if (e1.hasEncoding) return;
                if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
                if (!t) return;
                if (0 === a.length) return;
                if (e1.defaultEncoding === sr) return;
                for (const e1 of a)if (!isWinNameRecord(e1)) return;
                const r = sr, i = [], n = lr();
                for(const e1 in r){
                    const t = r[e1];
                    if ("" === t) continue;
                    const a = n[t];
                    void 0 !== a && (i[e1] = String.fromCharCode(a));
                }
                i.length > 0 && e1.toUnicode.amend(i);
            }(a, this.isSymbolicFont, r);
        } else s.name = {
            tag: "name",
            data: createNameTable(this.name)
        };
        const S = new OpenTypeFileBuilder(n.version);
        for(const e1 in s)S.addTable(e1, s[e1].data);
        return S.toArray();
    }
    convert(e1, a, r) {
        r.fixedPitch = !1;
        r.builtInEncoding && function adjustType1ToUnicode(e1, t) {
            if (e1.isInternalFont) return;
            if (e1.hasIncludedToUnicodeMap) return;
            if (t === e1.defaultEncoding) return;
            if (e1.toUnicode instanceof IdentityToUnicodeMap) return;
            const a = [], r = lr();
            for(const i in t){
                if (e1.hasEncoding && (e1.baseEncodingName || void 0 !== e1.differences[i])) continue;
                const n = getUnicodeForGlyph(t[i], r);
                -1 !== n && (a[i] = String.fromCharCode(n));
            }
            a.length > 0 && e1.toUnicode.amend(a);
        }(r, r.builtInEncoding);
        let i = 1;
        a instanceof CFFFont && (i = a.numGlyphs - 1);
        const n = a.getGlyphMapping(r);
        let s = null, o = n, c = null;
        if (!r.cssFontInfo) {
            s = adjustMapping(n, a.hasGlyphId.bind(a), i, this.toUnicode);
            this.toFontChar = s.toFontChar;
            o = s.charCodeToGlyphId;
            c = s.toUnicodeExtraMap;
        }
        const l = a.numGlyphs;
        function getCharCodes(e1, t) {
            let a = null;
            for(const r in e1)t === e1[r] && (a ||= []).push(0 | r);
            return a;
        }
        function createCharCode(e1, t) {
            for(const a in e1)if (t === e1[a]) return 0 | a;
            s.charCodeToGlyphId[s.nextAvailableFontCharCode] = t;
            return s.nextAvailableFontCharCode++;
        }
        const h = a.seacs;
        if (s && h?.length) {
            const e1 = r.fontMatrix || t, i = a.getCharset(), o = Object.create(null);
            for(let t in h){
                t |= 0;
                const a = h[t], r = nr[a[2]], c = nr[a[3]], l = i.indexOf(r), u = i.indexOf(c);
                if (l < 0 || u < 0) continue;
                const d = {
                    x: a[0] * e1[0] + a[1] * e1[2] + e1[4],
                    y: a[0] * e1[1] + a[1] * e1[3] + e1[5]
                }, f = getCharCodes(n, t);
                if (f) for (const e1 of f){
                    const t = s.charCodeToGlyphId, a = createCharCode(t, l), r = createCharCode(t, u);
                    o[e1] = {
                        baseFontCharCode: a,
                        accentFontCharCode: r,
                        accentOffset: d
                    };
                }
            }
            r.seacMap = o;
        }
        const u = r.fontMatrix ? 1 / Math.max(...r.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, d = new OpenTypeFileBuilder("OTTO");
        d.addTable("CFF ", a.data);
        d.addTable("OS/2", createOS2Table(r, o));
        d.addTable("cmap", createCmapTable(o, c, l));
        d.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(u) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(r.descent) + "ÿ" + safeString16(r.ascent) + string16(r.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
        d.addTable("hhea", "\0\0\0" + safeString16(r.ascent) + safeString16(r.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(r.capHeight) + safeString16(Math.tan(r.italicAngle) * r.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(l));
        d.addTable("hmtx", function fontFieldsHmtx() {
            const e1 = a.charstrings, t = a.cff ? a.cff.widths : null;
            let r = "\0\0\0\0";
            for(let a = 1, i = l; a < i; a++){
                let i = 0;
                if (e1) {
                    const t = e1[a - 1];
                    i = "width" in t ? t.width : 0;
                } else t && (i = Math.ceil(t[a] || 0));
                r += string16(i) + string16(0);
            }
            return r;
        }());
        d.addTable("maxp", "\0\0P\0" + string16(l));
        d.addTable("name", createNameTable(e1));
        d.addTable("post", createPostTable(r));
        return d.toArray();
    }
    get _spaceWidth() {
        const e1 = [
            "space",
            "minus",
            "one",
            "i",
            "I"
        ];
        let t;
        for (const a of e1){
            if (a in this.widths) {
                t = this.widths[a];
                break;
            }
            const e1 = lr()[a];
            let r = 0;
            if (this.composite && this.cMap.contains(e1)) {
                r = this.cMap.lookup(e1);
                "string" == typeof r && (r = convertCidString(e1, r));
            }
            !r && this.toUnicode && (r = this.toUnicode.charCodeOf(e1));
            r <= 0 && (r = e1);
            t = this.widths[r];
            if (t) break;
        }
        return shadow(this, "_spaceWidth", t || this.defaultWidth);
    }
    _charToGlyph(e1, t = !1) {
        let a, r, i, n = this._glyphCache[e1];
        if (n?.isSpace === t) return n;
        let s = e1;
        if (this.cMap?.contains(e1)) {
            s = this.cMap.lookup(e1);
            "string" == typeof s && (s = convertCidString(e1, s));
        }
        r = this.widths[s];
        "number" != typeof r && (r = this.defaultWidth);
        const o = this.vmetrics?.[s];
        let c = this.toUnicode.get(e1) || e1;
        "number" == typeof c && (c = String.fromCharCode(c));
        let l = void 0 !== this.toFontChar[e1];
        a = this.toFontChar[e1] || e1;
        if (this.missingFile) {
            const t = this.differences[e1] || this.defaultEncoding[e1];
            if ((".notdef" === t || "" === t) && "Type1" === this.type) {
                a = 32;
                if ("" === t) {
                    r ||= this._spaceWidth;
                    c = String.fromCharCode(a);
                }
            }
            a = function mapSpecialUnicodeValues(e1) {
                return e1 >= 65520 && e1 <= 65535 ? 0 : e1 >= 62976 && e1 <= 63743 ? ur()[e1] || e1 : 173 === e1 ? 45 : e1;
            }(a);
        }
        this.isType3Font && (i = a);
        let h = null;
        if (this.seacMap?.[e1]) {
            l = !0;
            const t = this.seacMap[e1];
            a = t.baseFontCharCode;
            h = {
                fontChar: String.fromCodePoint(t.accentFontCharCode),
                offset: t.accentOffset
            };
        }
        let u = "";
        "number" == typeof a && (a <= 1114111 ? u = String.fromCodePoint(a) : warn(`charToGlyph - invalid fontCharCode: ${a}`));
        if (this.missingFile && this.vertical && 1 === u.length) {
            const e1 = Sr()[u.charCodeAt(0)];
            e1 && (u = c = String.fromCharCode(e1));
        }
        n = new fonts_Glyph(e1, u, c, h, r, o, i, t, l);
        return this._glyphCache[e1] = n;
    }
    charsToGlyphs(e1) {
        let t = this._charsCache[e1];
        if (t) return t;
        t = [];
        if (this.cMap) {
            const a = Object.create(null), r = e1.length;
            let i = 0;
            for(; i < r;){
                this.cMap.readCharCode(e1, i, a);
                const { charcode: r, length: n } = a;
                i += n;
                const s = this._charToGlyph(r, 1 === n && 32 === e1.charCodeAt(i - 1));
                t.push(s);
            }
        } else for(let a = 0, r = e1.length; a < r; ++a){
            const r = e1.charCodeAt(a), i = this._charToGlyph(r, 32 === r);
            t.push(i);
        }
        return this._charsCache[e1] = t;
    }
    getCharPositions(e1) {
        const t = [];
        if (this.cMap) {
            const a = Object.create(null);
            let r = 0;
            for(; r < e1.length;){
                this.cMap.readCharCode(e1, r, a);
                const i = a.length;
                t.push([
                    r,
                    r + i
                ]);
                r += i;
            }
        } else for(let a = 0, r = e1.length; a < r; ++a)t.push([
            a,
            a + 1
        ]);
        return t;
    }
    get glyphCacheValues() {
        return Object.values(this._glyphCache);
    }
    encodeString(e1) {
        const t = [], a = [], hasCurrentBufErrors = ()=>t.length % 2 == 1, r = this.toUnicode instanceof IdentityToUnicodeMap ? (e1)=>this.toUnicode.charCodeOf(e1) : (e1)=>this.toUnicode.charCodeOf(String.fromCodePoint(e1));
        for(let i = 0, n = e1.length; i < n; i++){
            const n = e1.codePointAt(i);
            n > 55295 && (n < 57344 || n > 65533) && i++;
            if (this.toUnicode) {
                const e1 = r(n);
                if (-1 !== e1) {
                    if (hasCurrentBufErrors()) {
                        t.push(a.join(""));
                        a.length = 0;
                    }
                    for(let t = (this.cMap ? this.cMap.getCharCodeLength(e1) : 1) - 1; t >= 0; t--)a.push(String.fromCharCode(e1 >> 8 * t & 255));
                    continue;
                }
            }
            if (!hasCurrentBufErrors()) {
                t.push(a.join(""));
                a.length = 0;
            }
            a.push(String.fromCodePoint(n));
        }
        t.push(a.join(""));
        return t;
    }
}
class ErrorFont {
    constructor(e1){
        this.error = e1;
        this.loadedName = "g_font_error";
        this.missingFile = !0;
    }
    charsToGlyphs() {
        return [];
    }
    encodeString(e1) {
        return [
            e1
        ];
    }
    exportData() {
        return {
            error: this.error
        };
    }
}
const ii = 2, ni = 3, si = 4, oi = 5, ci = 6, li = 7;
class Pattern {
    constructor(){
        unreachable("Cannot initialize Pattern.");
    }
    static parseShading(e1, t, a, r, i, n) {
        const s = e1 instanceof BaseStream ? e1.dict : e1, o = s.get("ShadingType");
        try {
            switch(o){
                case ii:
                case ni:
                    return new RadialAxialShading(s, t, a, r, i, n);
                case si:
                case oi:
                case ci:
                case li:
                    return new MeshShading(e1, t, a, r, i, n);
                default:
                    throw new FormatError("Unsupported ShadingType: " + o);
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(e1);
            return new DummyShading;
        }
    }
}
class BaseShading {
    static SMALL_NUMBER = 1e-6;
    getIR() {
        unreachable("Abstract method `getIR` called.");
    }
}
class RadialAxialShading extends BaseShading {
    constructor(e1, t, a, r, i, n){
        super();
        this.shadingType = e1.get("ShadingType");
        let s = 0;
        this.shadingType === ii ? s = 4 : this.shadingType === ni && (s = 6);
        this.coordsArr = e1.getArray("Coords");
        if (!isNumberArray(this.coordsArr, s)) throw new FormatError("RadialAxialShading: Invalid /Coords array.");
        const o = ColorSpaceUtils.parse({
            cs: e1.getRaw("CS") || e1.getRaw("ColorSpace"),
            xref: t,
            resources: a,
            pdfFunctionFactory: r,
            globalColorSpaceCache: i,
            localColorSpaceCache: n
        });
        this.bbox = lookupNormalRect(e1.getArray("BBox"), null);
        let c = 0, l = 1;
        const h = e1.getArray("Domain");
        isNumberArray(h, 2) && ([c, l] = h);
        let u = !1, d = !1;
        const f = e1.getArray("Extend");
        (function isBooleanArray(e1, t) {
            return Array.isArray(e1) && (null === t || e1.length === t) && e1.every((e1)=>"boolean" == typeof e1);
        })(f, 2) && ([u, d] = f);
        if (!(this.shadingType !== ni || u && d)) {
            const [e1, t, a, r, i, n] = this.coordsArr, s = Math.hypot(e1 - r, t - i);
            a <= n + s && n <= a + s && warn("Unsupported radial gradient.");
        }
        this.extendStart = u;
        this.extendEnd = d;
        const g = e1.getRaw("Function"), p = r.create(g, !0), m = (l - c) / 840, b = this.colorStops = [];
        if (c >= l || m <= 0) {
            info("Bad shading domain.");
            return;
        }
        const y = new Float32Array(o.numComps), w = new Float32Array(1);
        let x = 0;
        w[0] = c;
        p(w, 0, y, 0);
        const S = new Uint8ClampedArray(3);
        o.getRgb(y, 0, S);
        let [k, C, v] = S;
        b.push([
            0,
            Util.makeHexColor(k, C, v)
        ]);
        let F = 1;
        w[0] = c + m;
        p(w, 0, y, 0);
        o.getRgb(y, 0, S);
        let [T, O, M] = S, D = T - k + 1, R = O - C + 1, N = M - v + 1, E = T - k - 1, L = O - C - 1, j = M - v - 1;
        for(let e1 = 2; e1 < 840; e1++){
            w[0] = c + e1 * m;
            p(w, 0, y, 0);
            o.getRgb(y, 0, S);
            const [t, a, r] = S, i = e1 - x;
            D = Math.min(D, (t - k + 1) / i);
            R = Math.min(R, (a - C + 1) / i);
            N = Math.min(N, (r - v + 1) / i);
            E = Math.max(E, (t - k - 1) / i);
            L = Math.max(L, (a - C - 1) / i);
            j = Math.max(j, (r - v - 1) / i);
            if (!(E <= D && L <= R && j <= N)) {
                const e1 = Util.makeHexColor(T, O, M);
                b.push([
                    F / 840,
                    e1
                ]);
                D = t - T + 1;
                R = a - O + 1;
                N = r - M + 1;
                E = t - T - 1;
                L = a - O - 1;
                j = r - M - 1;
                x = F;
                k = T;
                C = O;
                v = M;
            }
            F = e1;
            T = t;
            O = a;
            M = r;
        }
        b.push([
            1,
            Util.makeHexColor(T, O, M)
        ]);
        let _ = "transparent";
        e1.has("Background") && (_ = o.getRgbHex(e1.get("Background"), 0));
        if (!u) {
            b.unshift([
                0,
                _
            ]);
            b[1][0] += BaseShading.SMALL_NUMBER;
        }
        if (!d) {
            b.at(-1)[0] -= BaseShading.SMALL_NUMBER;
            b.push([
                1,
                _
            ]);
        }
        this.colorStops = b;
    }
    getIR() {
        const { coordsArr: e1, shadingType: t } = this;
        let a, r, i, n, s;
        if (t === ii) {
            r = [
                e1[0],
                e1[1]
            ];
            i = [
                e1[2],
                e1[3]
            ];
            n = null;
            s = null;
            a = "axial";
        } else if (t === ni) {
            r = [
                e1[0],
                e1[1]
            ];
            i = [
                e1[3],
                e1[4]
            ];
            n = e1[2];
            s = e1[5];
            a = "radial";
        } else unreachable(`getPattern type unknown: ${t}`);
        return [
            "RadialAxial",
            a,
            this.bbox,
            this.colorStops,
            r,
            i,
            n,
            s
        ];
    }
}
class MeshStreamReader {
    constructor(e1, t){
        this.stream = e1;
        this.context = t;
        this.buffer = 0;
        this.bufferLength = 0;
        const a = t.numComps;
        this.tmpCompsBuf = new Float32Array(a);
        const r = t.colorSpace.numComps;
        this.tmpCsCompsBuf = t.colorFn ? new Float32Array(r) : this.tmpCompsBuf;
    }
    get hasData() {
        if (this.stream.end) return this.stream.pos < this.stream.end;
        if (this.bufferLength > 0) return !0;
        const e1 = this.stream.getByte();
        if (e1 < 0) return !1;
        this.buffer = e1;
        this.bufferLength = 8;
        return !0;
    }
    readBits(e1) {
        const { stream: t } = this;
        let { buffer: a, bufferLength: r } = this;
        if (32 === e1) {
            if (0 === r) return t.getInt32() >>> 0;
            a = a << 24 | t.getByte() << 16 | t.getByte() << 8 | t.getByte();
            const e1 = t.getByte();
            this.buffer = e1 & (1 << r) - 1;
            return (a << 8 - r | (255 & e1) >> r) >>> 0;
        }
        if (8 === e1 && 0 === r) return t.getByte();
        for(; r < e1;){
            a = a << 8 | t.getByte();
            r += 8;
        }
        r -= e1;
        this.bufferLength = r;
        this.buffer = a & (1 << r) - 1;
        return a >> r;
    }
    align() {
        this.buffer = 0;
        this.bufferLength = 0;
    }
    readFlag() {
        return this.readBits(this.context.bitsPerFlag);
    }
    readCoordinate() {
        const { bitsPerCoordinate: e1, decode: t } = this.context, a = this.readBits(e1), r = this.readBits(e1), i = e1 < 32 ? 1 / ((1 << e1) - 1) : 2.3283064365386963e-10;
        return [
            a * i * (t[1] - t[0]) + t[0],
            r * i * (t[3] - t[2]) + t[2]
        ];
    }
    readComponents() {
        const { bitsPerComponent: e1, colorFn: t, colorSpace: a, decode: r, numComps: i } = this.context, n = e1 < 32 ? 1 / ((1 << e1) - 1) : 2.3283064365386963e-10, s = this.tmpCompsBuf;
        for(let t = 0, a = 4; t < i; t++, a += 2){
            const i = this.readBits(e1);
            s[t] = i * n * (r[a + 1] - r[a]) + r[a];
        }
        const o = this.tmpCsCompsBuf;
        t?.(s, 0, o, 0);
        return a.getRgb(o, 0);
    }
}
let hi = Object.create(null);
function getB(e1) {
    return hi[e1] ||= function buildB(e1) {
        const t = [];
        for(let a = 0; a <= e1; a++){
            const r = a / e1, i = 1 - r;
            t.push(new Float32Array([
                i ** 3,
                3 * r * i ** 2,
                3 * r ** 2 * i,
                r ** 3
            ]));
        }
        return t;
    }(e1);
}
class MeshShading extends BaseShading {
    static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
    static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
    static TRIANGLE_DENSITY = 20;
    constructor(e1, t, a, r, i, n){
        super();
        if (!(e1 instanceof BaseStream)) throw new FormatError("Mesh data is not a stream");
        const s = e1.dict;
        this.shadingType = s.get("ShadingType");
        this.bbox = lookupNormalRect(s.getArray("BBox"), null);
        const o = ColorSpaceUtils.parse({
            cs: s.getRaw("CS") || s.getRaw("ColorSpace"),
            xref: t,
            resources: a,
            pdfFunctionFactory: r,
            globalColorSpaceCache: i,
            localColorSpaceCache: n
        });
        this.background = s.has("Background") ? o.getRgb(s.get("Background"), 0) : null;
        const c = s.getRaw("Function"), l = c ? r.create(c, !0) : null;
        this.coords = [];
        this.colors = [];
        this.figures = [];
        const h = {
            bitsPerCoordinate: s.get("BitsPerCoordinate"),
            bitsPerComponent: s.get("BitsPerComponent"),
            bitsPerFlag: s.get("BitsPerFlag"),
            decode: s.getArray("Decode"),
            colorFn: l,
            colorSpace: o,
            numComps: l ? 1 : o.numComps
        }, u = new MeshStreamReader(e1, h);
        let d = !1;
        switch(this.shadingType){
            case si:
                this._decodeType4Shading(u);
                break;
            case oi:
                const e2 = 0 | s.get("VerticesPerRow");
                if (e2 < 2) throw new FormatError("Invalid VerticesPerRow");
                this._decodeType5Shading(u, e2);
                break;
            case ci:
                this._decodeType6Shading(u);
                d = !0;
                break;
            case li:
                this._decodeType7Shading(u);
                d = !0;
                break;
            default:
                unreachable("Unsupported mesh type.");
        }
        if (d) {
            this._updateBounds();
            for(let e1 = 0, t = this.figures.length; e1 < t; e1++)this._buildFigureFromPatch(e1);
        }
        this._updateBounds();
        this._packData();
    }
    _decodeType4Shading(e1) {
        const t = this.coords, a = this.colors, r = [], i = [];
        let n = 0;
        for(; e1.hasData;){
            const s = e1.readFlag(), o = e1.readCoordinate(), c = e1.readComponents();
            if (0 === n) {
                if (!(0 <= s && s <= 2)) throw new FormatError("Unknown type4 flag");
                switch(s){
                    case 0:
                        n = 3;
                        break;
                    case 1:
                        i.push(i.at(-2), i.at(-1));
                        n = 1;
                        break;
                    case 2:
                        i.push(i.at(-3), i.at(-1));
                        n = 1;
                }
                r.push(s);
            }
            i.push(t.length);
            t.push(o);
            a.push(c);
            n--;
            e1.align();
        }
        this.figures.push({
            type: "triangles",
            coords: new Int32Array(i),
            colors: new Int32Array(i)
        });
    }
    _decodeType5Shading(e1, t) {
        const a = this.coords, r = this.colors, i = [];
        for(; e1.hasData;){
            const t = e1.readCoordinate(), n = e1.readComponents();
            i.push(a.length);
            a.push(t);
            r.push(n);
        }
        this.figures.push({
            type: "lattice",
            coords: new Int32Array(i),
            colors: new Int32Array(i),
            verticesPerRow: t
        });
    }
    _decodeType6Shading(e1) {
        const t = this.coords, a = this.colors, r = new Int32Array(16), i = new Int32Array(4);
        for(; e1.hasData;){
            const n = e1.readFlag();
            if (!(0 <= n && n <= 3)) throw new FormatError("Unknown type6 flag");
            const s = t.length;
            for(let a = 0, r = 0 !== n ? 8 : 12; a < r; a++)t.push(e1.readCoordinate());
            const o = a.length;
            for(let t = 0, r = 0 !== n ? 2 : 4; t < r; t++)a.push(e1.readComponents());
            let c, l, h, u;
            switch(n){
                case 0:
                    r[12] = s + 3;
                    r[13] = s + 4;
                    r[14] = s + 5;
                    r[15] = s + 6;
                    r[8] = s + 2;
                    r[11] = s + 7;
                    r[4] = s + 1;
                    r[7] = s + 8;
                    r[0] = s;
                    r[1] = s + 11;
                    r[2] = s + 10;
                    r[3] = s + 9;
                    i[2] = o + 1;
                    i[3] = o + 2;
                    i[0] = o;
                    i[1] = o + 3;
                    break;
                case 1:
                    c = r[12];
                    l = r[13];
                    h = r[14];
                    u = r[15];
                    r[12] = u;
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = h;
                    r[11] = s + 3;
                    r[4] = l;
                    r[7] = s + 4;
                    r[0] = c;
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    c = i[2];
                    l = i[3];
                    i[2] = l;
                    i[3] = o;
                    i[0] = c;
                    i[1] = o + 1;
                    break;
                case 2:
                    c = r[15];
                    l = r[11];
                    r[12] = r[3];
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = r[7];
                    r[11] = s + 3;
                    r[4] = l;
                    r[7] = s + 4;
                    r[0] = c;
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    c = i[3];
                    i[2] = i[1];
                    i[3] = o;
                    i[0] = c;
                    i[1] = o + 1;
                    break;
                case 3:
                    r[12] = r[0];
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = r[1];
                    r[11] = s + 3;
                    r[4] = r[2];
                    r[7] = s + 4;
                    r[0] = r[3];
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    i[2] = i[0];
                    i[3] = o;
                    i[0] = i[1];
                    i[1] = o + 1;
            }
            r[5] = t.length;
            t.push([
                (-4 * t[r[0]][0] - t[r[15]][0] + 6 * (t[r[4]][0] + t[r[1]][0]) - 2 * (t[r[12]][0] + t[r[3]][0]) + 3 * (t[r[13]][0] + t[r[7]][0])) / 9,
                (-4 * t[r[0]][1] - t[r[15]][1] + 6 * (t[r[4]][1] + t[r[1]][1]) - 2 * (t[r[12]][1] + t[r[3]][1]) + 3 * (t[r[13]][1] + t[r[7]][1])) / 9
            ]);
            r[6] = t.length;
            t.push([
                (-4 * t[r[3]][0] - t[r[12]][0] + 6 * (t[r[2]][0] + t[r[7]][0]) - 2 * (t[r[0]][0] + t[r[15]][0]) + 3 * (t[r[4]][0] + t[r[14]][0])) / 9,
                (-4 * t[r[3]][1] - t[r[12]][1] + 6 * (t[r[2]][1] + t[r[7]][1]) - 2 * (t[r[0]][1] + t[r[15]][1]) + 3 * (t[r[4]][1] + t[r[14]][1])) / 9
            ]);
            r[9] = t.length;
            t.push([
                (-4 * t[r[12]][0] - t[r[3]][0] + 6 * (t[r[8]][0] + t[r[13]][0]) - 2 * (t[r[0]][0] + t[r[15]][0]) + 3 * (t[r[11]][0] + t[r[1]][0])) / 9,
                (-4 * t[r[12]][1] - t[r[3]][1] + 6 * (t[r[8]][1] + t[r[13]][1]) - 2 * (t[r[0]][1] + t[r[15]][1]) + 3 * (t[r[11]][1] + t[r[1]][1])) / 9
            ]);
            r[10] = t.length;
            t.push([
                (-4 * t[r[15]][0] - t[r[0]][0] + 6 * (t[r[11]][0] + t[r[14]][0]) - 2 * (t[r[12]][0] + t[r[3]][0]) + 3 * (t[r[2]][0] + t[r[8]][0])) / 9,
                (-4 * t[r[15]][1] - t[r[0]][1] + 6 * (t[r[11]][1] + t[r[14]][1]) - 2 * (t[r[12]][1] + t[r[3]][1]) + 3 * (t[r[2]][1] + t[r[8]][1])) / 9
            ]);
            this.figures.push({
                type: "patch",
                coords: new Int32Array(r),
                colors: new Int32Array(i)
            });
        }
    }
    _decodeType7Shading(e1) {
        const t = this.coords, a = this.colors, r = new Int32Array(16), i = new Int32Array(4);
        for(; e1.hasData;){
            const n = e1.readFlag();
            if (!(0 <= n && n <= 3)) throw new FormatError("Unknown type7 flag");
            const s = t.length;
            for(let a = 0, r = 0 !== n ? 12 : 16; a < r; a++)t.push(e1.readCoordinate());
            const o = a.length;
            for(let t = 0, r = 0 !== n ? 2 : 4; t < r; t++)a.push(e1.readComponents());
            let c, l, h, u;
            switch(n){
                case 0:
                    r[12] = s + 3;
                    r[13] = s + 4;
                    r[14] = s + 5;
                    r[15] = s + 6;
                    r[8] = s + 2;
                    r[9] = s + 13;
                    r[10] = s + 14;
                    r[11] = s + 7;
                    r[4] = s + 1;
                    r[5] = s + 12;
                    r[6] = s + 15;
                    r[7] = s + 8;
                    r[0] = s;
                    r[1] = s + 11;
                    r[2] = s + 10;
                    r[3] = s + 9;
                    i[2] = o + 1;
                    i[3] = o + 2;
                    i[0] = o;
                    i[1] = o + 3;
                    break;
                case 1:
                    c = r[12];
                    l = r[13];
                    h = r[14];
                    u = r[15];
                    r[12] = u;
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = h;
                    r[9] = s + 9;
                    r[10] = s + 10;
                    r[11] = s + 3;
                    r[4] = l;
                    r[5] = s + 8;
                    r[6] = s + 11;
                    r[7] = s + 4;
                    r[0] = c;
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    c = i[2];
                    l = i[3];
                    i[2] = l;
                    i[3] = o;
                    i[0] = c;
                    i[1] = o + 1;
                    break;
                case 2:
                    c = r[15];
                    l = r[11];
                    r[12] = r[3];
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = r[7];
                    r[9] = s + 9;
                    r[10] = s + 10;
                    r[11] = s + 3;
                    r[4] = l;
                    r[5] = s + 8;
                    r[6] = s + 11;
                    r[7] = s + 4;
                    r[0] = c;
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    c = i[3];
                    i[2] = i[1];
                    i[3] = o;
                    i[0] = c;
                    i[1] = o + 1;
                    break;
                case 3:
                    r[12] = r[0];
                    r[13] = s + 0;
                    r[14] = s + 1;
                    r[15] = s + 2;
                    r[8] = r[1];
                    r[9] = s + 9;
                    r[10] = s + 10;
                    r[11] = s + 3;
                    r[4] = r[2];
                    r[5] = s + 8;
                    r[6] = s + 11;
                    r[7] = s + 4;
                    r[0] = r[3];
                    r[1] = s + 7;
                    r[2] = s + 6;
                    r[3] = s + 5;
                    i[2] = i[0];
                    i[3] = o;
                    i[0] = i[1];
                    i[1] = o + 1;
            }
            this.figures.push({
                type: "patch",
                coords: new Int32Array(r),
                colors: new Int32Array(i)
            });
        }
    }
    _buildFigureFromPatch(e1) {
        const t = this.figures[e1];
        assert("patch" === t.type, "Unexpected patch mesh figure");
        const a = this.coords, r = this.colors, i = t.coords, n = t.colors, s = Math.min(a[i[0]][0], a[i[3]][0], a[i[12]][0], a[i[15]][0]), o = Math.min(a[i[0]][1], a[i[3]][1], a[i[12]][1], a[i[15]][1]), c = Math.max(a[i[0]][0], a[i[3]][0], a[i[12]][0], a[i[15]][0]), l = Math.max(a[i[0]][1], a[i[3]][1], a[i[12]][1], a[i[15]][1]);
        let h = Math.ceil((c - s) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
        h = MathClamp(h, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        let u = Math.ceil((l - o) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
        u = MathClamp(u, MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
        const d = h + 1, f = new Int32Array((u + 1) * d), g = new Int32Array((u + 1) * d);
        let p = 0;
        const m = new Uint8Array(3), b = new Uint8Array(3), y = r[n[0]], w = r[n[1]], x = r[n[2]], S = r[n[3]], k = getB(u), C = getB(h);
        for(let e1 = 0; e1 <= u; e1++){
            m[0] = (y[0] * (u - e1) + x[0] * e1) / u | 0;
            m[1] = (y[1] * (u - e1) + x[1] * e1) / u | 0;
            m[2] = (y[2] * (u - e1) + x[2] * e1) / u | 0;
            b[0] = (w[0] * (u - e1) + S[0] * e1) / u | 0;
            b[1] = (w[1] * (u - e1) + S[1] * e1) / u | 0;
            b[2] = (w[2] * (u - e1) + S[2] * e1) / u | 0;
            for(let t = 0; t <= h; t++, p++){
                if (!(0 !== e1 && e1 !== u || 0 !== t && t !== h)) continue;
                let n = 0, s = 0, o = 0;
                for(let r = 0; r <= 3; r++)for(let c = 0; c <= 3; c++, o++){
                    const l = k[e1][r] * C[t][c];
                    n += a[i[o]][0] * l;
                    s += a[i[o]][1] * l;
                }
                f[p] = a.length;
                a.push([
                    n,
                    s
                ]);
                g[p] = r.length;
                const c = new Uint8Array(3);
                c[0] = (m[0] * (h - t) + b[0] * t) / h | 0;
                c[1] = (m[1] * (h - t) + b[1] * t) / h | 0;
                c[2] = (m[2] * (h - t) + b[2] * t) / h | 0;
                r.push(c);
            }
        }
        f[0] = i[0];
        g[0] = n[0];
        f[h] = i[3];
        g[h] = n[1];
        f[d * u] = i[12];
        g[d * u] = n[2];
        f[d * u + h] = i[15];
        g[d * u + h] = n[3];
        this.figures[e1] = {
            type: "lattice",
            coords: f,
            colors: g,
            verticesPerRow: d
        };
    }
    _updateBounds() {
        let e1 = this.coords[0][0], t = this.coords[0][1], a = e1, r = t;
        for(let i = 1, n = this.coords.length; i < n; i++){
            const n = this.coords[i][0], s = this.coords[i][1];
            e1 = e1 > n ? n : e1;
            t = t > s ? s : t;
            a = a < n ? n : a;
            r = r < s ? s : r;
        }
        this.bounds = [
            e1,
            t,
            a,
            r
        ];
    }
    _packData() {
        let e1, t, a, r;
        const i = this.coords, n = new Float32Array(2 * i.length);
        for(e1 = 0, a = 0, t = i.length; e1 < t; e1++){
            const t = i[e1];
            n[a++] = t[0];
            n[a++] = t[1];
        }
        this.coords = n;
        const s = this.colors, o = new Uint8Array(3 * s.length);
        for(e1 = 0, a = 0, t = s.length; e1 < t; e1++){
            const t = s[e1];
            o[a++] = t[0];
            o[a++] = t[1];
            o[a++] = t[2];
        }
        this.colors = o;
        const c = this.figures;
        for(e1 = 0, t = c.length; e1 < t; e1++){
            const t = c[e1], i = t.coords, n = t.colors;
            for(a = 0, r = i.length; a < r; a++){
                i[a] *= 2;
                n[a] *= 3;
            }
        }
    }
    getIR() {
        const { bounds: e1 } = this;
        if (e1[2] - e1[0] == 0 || e1[3] - e1[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e1}].`);
        return [
            "Mesh",
            this.shadingType,
            this.coords,
            this.colors,
            this.figures,
            e1,
            this.bbox,
            this.background
        ];
    }
}
class DummyShading extends BaseShading {
    getIR() {
        return [
            "Dummy"
        ];
    }
}
function getTilingPatternIR(e1, t, a) {
    const r = lookupMatrix(t.getArray("Matrix"), la), i = lookupNormalRect(t.getArray("BBox"), null);
    if (!i || i[2] - i[0] == 0 || i[3] - i[1] == 0) throw new FormatError("Invalid getTilingPatternIR /BBox array.");
    const n = t.get("XStep");
    if ("number" != typeof n) throw new FormatError("Invalid getTilingPatternIR /XStep value.");
    const s = t.get("YStep");
    if ("number" != typeof s) throw new FormatError("Invalid getTilingPatternIR /YStep value.");
    const o = t.get("PaintType");
    if (!Number.isInteger(o)) throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
    const c = t.get("TilingType");
    if (!Number.isInteger(c)) throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
    return [
        "TilingPattern",
        a,
        e1,
        r,
        i,
        n,
        s,
        o,
        c
    ];
}
const ui = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.54657,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .73293,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .9121,
    .86943,
    .79795,
    .88198,
    .77958,
    .70864,
    .81055,
    .90399,
    .88653,
    .96017,
    .82577,
    .77892,
    .78257,
    .97507,
    1.54657,
    .97507,
    .85284,
    .89552,
    .90176,
    .88762,
    .8785,
    .75241,
    .8785,
    .90518,
    .95015,
    .77618,
    .8785,
    .88401,
    .91916,
    .86304,
    .88401,
    .91488,
    .8785,
    .8801,
    .8785,
    .8785,
    .91343,
    .7173,
    1.04106,
    .8785,
    .85075,
    .95794,
    .82616,
    .85162,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.12401,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .73293,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .9121,
    .86943,
    .86943,
    .86943,
    .86943,
    .86943,
    .85284,
    .87508,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .88762,
    .8715,
    .75241,
    .90518,
    .90518,
    .90518,
    .90518,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .8785,
    .8801,
    .8801,
    .8801,
    .8801,
    .8801,
    .90747,
    .89049,
    .8785,
    .8785,
    .8785,
    .8785,
    .85162,
    .8785,
    .85162,
    .83908,
    .88762,
    .83908,
    .88762,
    .83908,
    .88762,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .73293,
    .75241,
    .87289,
    .83016,
    .88506,
    .93125,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .73133,
    .90518,
    .81921,
    .77618,
    .81921,
    .77618,
    .81921,
    .77618,
    1,
    1,
    .87356,
    .8785,
    .91075,
    .89608,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76229,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .79468,
    .91926,
    .88175,
    .70823,
    .94903,
    .9121,
    .8785,
    1,
    1,
    .9121,
    .8785,
    .87802,
    .88656,
    .8785,
    .86943,
    .8801,
    .86943,
    .8801,
    .86943,
    .8801,
    .87402,
    .89291,
    .77958,
    .91343,
    1,
    1,
    .77958,
    .91343,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    .70864,
    .7173,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .90399,
    .8785,
    .96017,
    .95794,
    .77892,
    .85162,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .88762,
    .77539,
    .8715,
    .87508,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70674,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.06303,
    .83908,
    .80352,
    .57184,
    .6965,
    .56289,
    .82001,
    .56029,
    .81235,
    1.02988,
    .83908,
    .7762,
    .68156,
    .80367,
    .73133,
    .78257,
    .87356,
    .86943,
    .95958,
    .75727,
    .89019,
    1.04924,
    .9121,
    .7648,
    .86943,
    .87356,
    .79795,
    .78275,
    .81055,
    .77892,
    .9762,
    .82577,
    .99819,
    .84896,
    .95958,
    .77892,
    .96108,
    1.01407,
    .89049,
    1.02988,
    .94211,
    .96108,
    .8936,
    .84021,
    .87842,
    .96399,
    .79109,
    .89049,
    1.00813,
    1.02988,
    .86077,
    .87445,
    .92099,
    .84723,
    .86513,
    .8801,
    .75638,
    .85714,
    .78216,
    .79586,
    .87965,
    .94211,
    .97747,
    .78287,
    .97926,
    .84971,
    1.02988,
    .94211,
    .8801,
    .94211,
    .84971,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90264,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90518,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90548,
    1,
    1,
    1,
    1,
    1,
    1,
    .96017,
    .95794,
    .96017,
    .95794,
    .96017,
    .95794,
    .77892,
    .85162,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .92794,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71143,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .93835,
    .83406,
    .91133,
    .84107,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.31006,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], di = {
    lineHeight: 1.2207,
    lineGap: .2207
}, fi = [
    1.3877,
    1,
    1,
    1,
    .97801,
    .92482,
    .89552,
    .91133,
    .81988,
    .97566,
    .98152,
    .93548,
    .93548,
    1.2798,
    .85284,
    .92794,
    1,
    .96134,
    1.56239,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .82845,
    .82845,
    .85284,
    .85284,
    .85284,
    .75859,
    .92138,
    .83908,
    .7762,
    .71805,
    .87289,
    .73133,
    .7514,
    .81921,
    .87356,
    .95958,
    .59526,
    .75727,
    .69225,
    1.04924,
    .90872,
    .85938,
    .79795,
    .87068,
    .77958,
    .69766,
    .81055,
    .90399,
    .88653,
    .96068,
    .82577,
    .77892,
    .78257,
    .97507,
    1.529,
    .97507,
    .85284,
    .89552,
    .90176,
    .94908,
    .86411,
    .74012,
    .86411,
    .88323,
    .95015,
    .86411,
    .86331,
    .88401,
    .91916,
    .86304,
    .88401,
    .9039,
    .86331,
    .86331,
    .86411,
    .86411,
    .90464,
    .70852,
    1.04106,
    .86331,
    .84372,
    .95794,
    .82616,
    .84548,
    .79492,
    .88331,
    1.69808,
    .88331,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.7801,
    .89552,
    1.24487,
    1.13254,
    1.19129,
    .96839,
    .85284,
    .68787,
    .70645,
    .85592,
    .90747,
    1.01466,
    1.0088,
    .90323,
    1,
    1.07463,
    1,
    .91056,
    .75806,
    1.19118,
    .96839,
    .78864,
    .82845,
    .84133,
    .75859,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .83908,
    .77539,
    .71805,
    .73133,
    .73133,
    .73133,
    .73133,
    .95958,
    .95958,
    .95958,
    .95958,
    .88506,
    .90872,
    .85938,
    .85938,
    .85938,
    .85938,
    .85938,
    .85284,
    .87068,
    .90399,
    .90399,
    .90399,
    .90399,
    .77892,
    .79795,
    .90807,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .94908,
    .85887,
    .74012,
    .88323,
    .88323,
    .88323,
    .88323,
    .88401,
    .88401,
    .88401,
    .88401,
    .8785,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .86331,
    .90747,
    .89049,
    .86331,
    .86331,
    .86331,
    .86331,
    .84548,
    .86411,
    .84548,
    .83908,
    .94908,
    .83908,
    .94908,
    .83908,
    .94908,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .71805,
    .74012,
    .87289,
    .79538,
    .88506,
    .92726,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .73133,
    .88323,
    .81921,
    .86411,
    .81921,
    .86411,
    .81921,
    .86411,
    1,
    1,
    .87356,
    .86331,
    .91075,
    .8777,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .95958,
    .88401,
    .76467,
    .90167,
    .59526,
    .91916,
    1,
    1,
    .86304,
    .69225,
    .88401,
    1,
    1,
    .70424,
    .77312,
    .91926,
    .88175,
    .70823,
    .94903,
    .90872,
    .86331,
    1,
    1,
    .90872,
    .86331,
    .86906,
    .88116,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .85938,
    .86331,
    .87402,
    .86549,
    .77958,
    .90464,
    1,
    1,
    .77958,
    .90464,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    .69766,
    .70852,
    1,
    1,
    .81055,
    .75841,
    .81055,
    1.06452,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .90399,
    .86331,
    .96068,
    .95794,
    .77892,
    .84548,
    .77892,
    .78257,
    .79492,
    .78257,
    .79492,
    .78257,
    .79492,
    .9297,
    .56892,
    .83908,
    .94908,
    .77539,
    .85887,
    .87068,
    .89049,
    1,
    1,
    .81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    .70088,
    .98387,
    .94721,
    1.33431,
    1.45894,
    .95161,
    1.48387,
    .83908,
    .80352,
    .57118,
    .6965,
    .56347,
    .79179,
    .55853,
    .80346,
    1.02988,
    .83908,
    .7762,
    .67174,
    .86036,
    .73133,
    .78257,
    .87356,
    .86441,
    .95958,
    .75727,
    .89019,
    1.04924,
    .90872,
    .74889,
    .85938,
    .87891,
    .79795,
    .7957,
    .81055,
    .77892,
    .97447,
    .82577,
    .97466,
    .87179,
    .95958,
    .77892,
    .94252,
    .95612,
    .8753,
    1.02988,
    .92733,
    .94252,
    .87411,
    .84021,
    .8728,
    .95612,
    .74081,
    .8753,
    1.02189,
    1.02988,
    .84814,
    .87445,
    .91822,
    .84723,
    .85668,
    .86331,
    .81344,
    .87581,
    .76422,
    .82046,
    .96057,
    .92733,
    .99375,
    .78022,
    .95452,
    .86015,
    1.02988,
    .92733,
    .86331,
    .92733,
    .86015,
    .73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90631,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88323,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85174,
    1,
    1,
    1,
    1,
    1,
    1,
    .96068,
    .95794,
    .96068,
    .95794,
    .96068,
    .95794,
    .77892,
    .84548,
    1,
    1,
    .89552,
    .90527,
    1,
    .90363,
    .92794,
    .92794,
    .92794,
    .89807,
    .87012,
    .87012,
    .87012,
    .89552,
    .89552,
    1.42259,
    .71094,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    .97171,
    1.4956,
    2.2807,
    .92972,
    .83406,
    .91133,
    .83326,
    .91133,
    1,
    1,
    1,
    .72021,
    1,
    1.23108,
    .83489,
    .88525,
    .88525,
    .81499,
    .90616,
    1.81055,
    .90527,
    1.81055,
    1.3107,
    1.53711,
    .94434,
    1.08696,
    1,
    .95018,
    .77192,
    .85284,
    .90747,
    1.17534,
    .69825,
    .9716,
    1.37077,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90727,
    .90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], gi = {
    lineHeight: 1.2207,
    lineGap: .2207
}, pi = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39543,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .72346,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89249,
    .84118,
    .77452,
    .85374,
    .75186,
    .67789,
    .79776,
    .88844,
    .85066,
    .94309,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.38313,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .9245,
    .9245,
    .83203,
    .9245,
    .85865,
    1.09842,
    .9245,
    .9245,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .94959,
    .9245,
    .92274,
    .9245,
    .9245,
    1.02933,
    .77832,
    1.20562,
    .9245,
    .8916,
    .98986,
    .86621,
    .89453,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.16359,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .72346,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89249,
    .84118,
    .84118,
    .84118,
    .84118,
    .84118,
    .85284,
    .84557,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .9245,
    .84843,
    .83203,
    .85865,
    .85865,
    .85865,
    .85865,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .9245,
    .92274,
    .92274,
    .92274,
    .92274,
    .92274,
    .90747,
    .86651,
    .9245,
    .9245,
    .9245,
    .9245,
    .89453,
    .9245,
    .89453,
    .8675,
    .9245,
    .8675,
    .9245,
    .8675,
    .9245,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .72346,
    .83203,
    .85193,
    .8875,
    .86477,
    .99034,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .73206,
    .85865,
    .81105,
    .9245,
    .81105,
    .9245,
    .81105,
    .9245,
    1,
    1,
    .86275,
    .9245,
    .90872,
    .93591,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77896,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .9375,
    .98156,
    .93407,
    .77261,
    1.11429,
    .89249,
    .9245,
    1,
    1,
    .89249,
    .9245,
    .92534,
    .86698,
    .9245,
    .84118,
    .92274,
    .84118,
    .92274,
    .84118,
    .92274,
    .8667,
    .86291,
    .75186,
    1.02933,
    1,
    1,
    .75186,
    1.02933,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    .67789,
    .77832,
    1,
    1,
    .79776,
    .97655,
    .79776,
    1.23023,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .88844,
    .9245,
    .94309,
    .98986,
    .7306,
    .89453,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .9245,
    .76318,
    .84843,
    .84557,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67009,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .8675,
    .90861,
    .6192,
    .7363,
    .64824,
    .82411,
    .56321,
    .85696,
    1.23516,
    .8675,
    .81552,
    .7286,
    .84134,
    .73206,
    .76659,
    .86275,
    .84369,
    .90685,
    .77892,
    .85871,
    1.02638,
    .89249,
    .75828,
    .84118,
    .85984,
    .77452,
    .76466,
    .79776,
    .7306,
    .90782,
    .77818,
    .903,
    .87291,
    .90685,
    .7306,
    .99058,
    1.03667,
    .94635,
    1.23516,
    .9849,
    .99058,
    .92393,
    .8916,
    .942,
    1.03667,
    .75026,
    .94635,
    1.0297,
    1.23516,
    .90918,
    .94048,
    .98217,
    .89746,
    .84153,
    .92274,
    .82507,
    .88832,
    .84438,
    .88178,
    1.03525,
    .9849,
    1.00225,
    .78086,
    .97248,
    .89404,
    1.23516,
    .9849,
    .92274,
    .9849,
    .89404,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89693,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .85865,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .90933,
    1,
    1,
    1,
    1,
    1,
    1,
    .94309,
    .98986,
    .94309,
    .98986,
    .94309,
    .98986,
    .7306,
    .89453,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .68994,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .97858,
    .82616,
    .91133,
    .83437,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90572,
    1.81055,
    .90749,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85284,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], mi = {
    lineHeight: 1.2207,
    lineGap: .2207
}, bi = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    .89552,
    .91133,
    .80395,
    1.02269,
    1.15601,
    .91056,
    .91056,
    1.2798,
    .85284,
    .89807,
    1,
    .90861,
    1.39016,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .91133,
    .96309,
    .96309,
    .85284,
    .85284,
    .85284,
    .83319,
    .88071,
    .8675,
    .81552,
    .73834,
    .85193,
    .73206,
    .7522,
    .81105,
    .86275,
    .90685,
    .6377,
    .77892,
    .75593,
    1.02638,
    .89385,
    .85122,
    .77452,
    .86503,
    .75186,
    .68887,
    .79776,
    .88844,
    .85066,
    .94258,
    .77818,
    .7306,
    .76659,
    1.10369,
    1.39016,
    1.10369,
    1.06139,
    .89552,
    .8739,
    .86128,
    .94469,
    .8457,
    .94469,
    .89464,
    1.09842,
    .84636,
    .94469,
    1.03297,
    1.07692,
    .90918,
    1.03297,
    .95897,
    .94469,
    .9482,
    .94469,
    .94469,
    1.04692,
    .78223,
    1.20562,
    .94469,
    .90332,
    .98986,
    .86621,
    .90527,
    .79004,
    .94152,
    1.77256,
    .94152,
    .85284,
    .97801,
    .89552,
    .91133,
    .89552,
    .91133,
    1.91729,
    .89552,
    1.17889,
    1.13254,
    1.08707,
    .92098,
    .85284,
    .68787,
    .71353,
    .84737,
    .90747,
    1.0088,
    1.0044,
    .87683,
    1,
    1.09091,
    1,
    .92229,
    .739,
    1.15642,
    .92098,
    .76288,
    .80504,
    .80972,
    .75859,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .8675,
    .76318,
    .73834,
    .73206,
    .73206,
    .73206,
    .73206,
    .90685,
    .90685,
    .90685,
    .90685,
    .86477,
    .89385,
    .85122,
    .85122,
    .85122,
    .85122,
    .85122,
    .85284,
    .85311,
    .88844,
    .88844,
    .88844,
    .88844,
    .7306,
    .77452,
    .86331,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .86128,
    .8693,
    .8457,
    .89464,
    .89464,
    .89464,
    .89464,
    .82601,
    .82601,
    .82601,
    .82601,
    .94469,
    .94469,
    .9482,
    .9482,
    .9482,
    .9482,
    .9482,
    .90747,
    .86651,
    .94469,
    .94469,
    .94469,
    .94469,
    .90527,
    .94469,
    .90527,
    .8675,
    .86128,
    .8675,
    .86128,
    .8675,
    .86128,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .73834,
    .8457,
    .85193,
    .92454,
    .86477,
    .9921,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .73206,
    .89464,
    .81105,
    .84636,
    .81105,
    .84636,
    .81105,
    .84636,
    1,
    1,
    .86275,
    .94469,
    .90872,
    .95786,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    .82601,
    .90685,
    1.03297,
    .90685,
    .82601,
    .77741,
    1.05611,
    .6377,
    1.07692,
    1,
    1,
    .90918,
    .75593,
    1.03297,
    1,
    1,
    .76032,
    .90452,
    .98156,
    1.11842,
    .77261,
    1.11429,
    .89385,
    .94469,
    1,
    1,
    .89385,
    .94469,
    .95877,
    .86901,
    .94469,
    .85122,
    .9482,
    .85122,
    .9482,
    .85122,
    .9482,
    .8667,
    .90016,
    .75186,
    1.04692,
    1,
    1,
    .75186,
    1.04692,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    .68887,
    .78223,
    1,
    1,
    .79776,
    .92188,
    .79776,
    1.23023,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .88844,
    .94469,
    .94258,
    .98986,
    .7306,
    .90527,
    .7306,
    .76659,
    .79004,
    .76659,
    .79004,
    .76659,
    .79004,
    1.09231,
    .54873,
    .8675,
    .86128,
    .76318,
    .8693,
    .85311,
    .86651,
    1,
    1,
    .79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    .67742,
    .96334,
    .93695,
    1.35191,
    1.40909,
    .95161,
    1.48387,
    .86686,
    .90861,
    .62267,
    .74359,
    .65649,
    .85498,
    .56963,
    .88254,
    1.23516,
    .8675,
    .81552,
    .75443,
    .84503,
    .73206,
    .76659,
    .86275,
    .85122,
    .90685,
    .77892,
    .85746,
    1.02638,
    .89385,
    .75657,
    .85122,
    .86275,
    .77452,
    .74171,
    .79776,
    .7306,
    .95165,
    .77818,
    .89772,
    .88831,
    .90685,
    .7306,
    .98142,
    1.02191,
    .96576,
    1.23516,
    .99018,
    .98142,
    .9236,
    .89258,
    .94035,
    1.02191,
    .78848,
    .96576,
    .9561,
    1.23516,
    .90918,
    .92578,
    .95424,
    .89746,
    .83969,
    .9482,
    .80113,
    .89442,
    .85208,
    .86155,
    .98022,
    .99018,
    1.00452,
    .81209,
    .99247,
    .89181,
    1.23516,
    .99018,
    .9482,
    .99018,
    .89181,
    .73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .88844,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89464,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96766,
    1,
    1,
    1,
    1,
    1,
    1,
    .94258,
    .98986,
    .94258,
    .98986,
    .94258,
    .98986,
    .7306,
    .90527,
    1,
    1,
    .89552,
    .90527,
    1,
    .90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    .89552,
    .89552,
    1.42259,
    .69043,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    .99331,
    .82616,
    .91133,
    .84286,
    .91133,
    1,
    1,
    1,
    .70508,
    1,
    1.23108,
    .79801,
    .84426,
    .84426,
    .774,
    .90527,
    1.81055,
    .90527,
    1.81055,
    1.28809,
    1.55469,
    .94434,
    1.07806,
    1,
    .97094,
    .7589,
    .85284,
    .90747,
    1.19658,
    .69825,
    .97622,
    1.33512,
    .90747,
    .90747,
    .85356,
    .90747,
    .90747,
    1.44947,
    .85284,
    .8941,
    .8941,
    .70572,
    .8,
    .70572,
    .70572,
    .70572,
    .70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99862,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    .91027,
    1,
    1,
    1,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1.07185,
    .99413,
    .96334,
    1.08065,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], yi = {
    lineHeight: 1.2207,
    lineGap: .2207
}, wi = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.03374,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00042,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.03828,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00034,
    .99977,
    1,
    .99997,
    1.00026,
    1.00078,
    1.00036,
    .99973,
    1.00013,
    1.0006,
    .99977,
    .99977,
    .99988,
    .85148,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    1.00069,
    1.00022,
    .99977,
    1.00001,
    .99984,
    1.00026,
    1.00001,
    1.00024,
    1.00001,
    .9999,
    1,
    1.0006,
    1.00001,
    1.00041,
    .99962,
    1.00026,
    1.0006,
    .99995,
    1.00041,
    .99942,
    .99973,
    .99927,
    1.00082,
    .99902,
    1.00026,
    1.00087,
    1.0006,
    1.00069,
    .99973,
    .99867,
    .99973,
    .9993,
    1.00026,
    1.00049,
    1.00056,
    1,
    .99988,
    .99935,
    .99995,
    .99954,
    1.00055,
    .99945,
    1.00032,
    1.0006,
    .99995,
    1.00026,
    .99995,
    1.00032,
    1.00001,
    1.00008,
    .99971,
    1.00019,
    .9994,
    1.00001,
    1.0006,
    1.00044,
    .99973,
    1.00023,
    1.00047,
    1,
    .99942,
    .99561,
    .99989,
    1.00035,
    .99977,
    1.00035,
    .99977,
    1.00019,
    .99944,
    1.00001,
    1.00021,
    .99926,
    1.00035,
    1.00035,
    .99942,
    1.00048,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .99989,
    1.00057,
    1.00001,
    .99936,
    1.00052,
    1.00012,
    .99996,
    1.00043,
    1,
    1.00035,
    .9994,
    .99976,
    1.00035,
    .99973,
    1.00052,
    1.00041,
    1.00119,
    1.00037,
    .99973,
    1.00002,
    .99986,
    1.00041,
    1.00041,
    .99902,
    .9996,
    1.00034,
    .99999,
    1.00026,
    .99999,
    1.00026,
    .99973,
    1.00052,
    .99973,
    1,
    .99973,
    1.00041,
    1.00075,
    .9994,
    1.0003,
    .99999,
    1,
    1.00041,
    .99955,
    1,
    .99915,
    .99973,
    .99973,
    1.00026,
    1.00119,
    .99955,
    .99973,
    1.0006,
    .99911,
    1.0006,
    1.00026,
    .99972,
    1.00026,
    .99902,
    1.00041,
    .99973,
    .99999,
    1,
    1,
    1.00038,
    1.0005,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    1.00047,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], xi = {
    lineHeight: 1.2,
    lineGap: .2
}, Si = [
    .76116,
    1,
    1,
    1.0006,
    .99998,
    .99974,
    .99973,
    .99973,
    .99982,
    .99977,
    1.00087,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    .9999,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    .99973,
    .99977,
    1.00026,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    .99998,
    1.0006,
    .99998,
    1.00003,
    .99973,
    .99998,
    .99973,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    .99973,
    1.0006,
    .99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99959,
    .99973,
    .99998,
    1.00026,
    .99973,
    1.00022,
    .99973,
    .99973,
    1,
    .99959,
    1.00077,
    .99959,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.00077,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .99973,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    .99977,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    1.00026,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    1.0044,
    .99977,
    1.00026,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99971,
    .99973,
    .99973,
    1.0006,
    .99977,
    .99973,
    .99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.01011,
    1.00026,
    .99999,
    1.00026,
    1.0006,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .9993,
    .9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    .99977,
    .99959,
    .99977,
    .99959,
    .99977,
    .99959,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00026,
    .99998,
    1.00026,
    .8121,
    1.00026,
    .99998,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    .99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    .99973,
    .99977,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    .99973,
    1.00026,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99977,
    1,
    1,
    1.00026,
    .99969,
    .99972,
    .99981,
    .9998,
    1.0006,
    .99977,
    .99977,
    1.00022,
    .91155,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    .99977,
    1.00001,
    .99999,
    .99977,
    .99966,
    1.00022,
    1.00032,
    1.00001,
    .99944,
    1.00026,
    1.00001,
    .99968,
    1.00001,
    1.00047,
    1,
    1.0006,
    1.00001,
    .99981,
    1.00101,
    1.00026,
    1.0006,
    .99948,
    .99981,
    1.00064,
    .99973,
    .99942,
    1.00101,
    1.00061,
    1.00026,
    1.00069,
    1.0006,
    1.00014,
    .99973,
    1.01322,
    .99973,
    1.00065,
    1.00026,
    1.00012,
    .99923,
    1,
    1.00064,
    1.00076,
    .99948,
    1.00055,
    1.00063,
    1.00007,
    .99943,
    1.0006,
    .99948,
    1.00026,
    .99948,
    .99943,
    1.00001,
    1.00001,
    1.00029,
    1.00038,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    .99973,
    .99978,
    1.00001,
    1.00057,
    .99989,
    .99967,
    .99964,
    .99967,
    .99977,
    .99999,
    .99977,
    1.00038,
    .99977,
    1.00001,
    .99973,
    1.00066,
    .99967,
    .99967,
    1.00041,
    .99998,
    .99999,
    .99977,
    1.00022,
    .99967,
    1.00001,
    .99977,
    1.00026,
    .99964,
    1.00031,
    1.00001,
    .99999,
    .99999,
    1,
    1.00023,
    1,
    1,
    .99999,
    1.00035,
    1.00001,
    .99999,
    .99973,
    .99977,
    .99999,
    1.00058,
    .99973,
    .99973,
    .99955,
    .9995,
    1.00026,
    1.00026,
    1.00032,
    .99989,
    1.00034,
    .99999,
    1.00026,
    1.00026,
    1.00026,
    .99973,
    .45998,
    .99973,
    1.00026,
    .99973,
    1.00001,
    .99999,
    .99982,
    .99994,
    .99996,
    1,
    1.00042,
    1.00044,
    1.00029,
    1.00023,
    .99973,
    .99973,
    1.00026,
    .99949,
    1.00002,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    .99975,
    1.00026,
    1.00026,
    1.00032,
    .98685,
    .99973,
    1.00026,
    1,
    1,
    .99966,
    1.00044,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    .99973,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00106,
    .99999,
    .99998,
    .99998,
    .99999,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1,
    .99973,
    .99971,
    .99978,
    1,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00098,
    1,
    1,
    1,
    1.00049,
    1,
    1,
    .99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    .99561,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .99972,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ai = {
    lineHeight: 1.35,
    lineGap: .2
}, ki = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.0288,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    .99946,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.06311,
    .99973,
    1.00024,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00041,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .89547,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    1.00001,
    1,
    1.00054,
    .99977,
    1.00084,
    1.00007,
    .99973,
    1.00013,
    .99924,
    1.00001,
    1.00001,
    .99945,
    .91221,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00001,
    .99999,
    .99977,
    .99933,
    1.00022,
    1.00054,
    1.00001,
    1.00065,
    1.00026,
    1.00001,
    1.0001,
    1.00001,
    1.00052,
    1,
    1.0006,
    1.00001,
    .99945,
    .99897,
    .99968,
    .99924,
    1.00036,
    .99945,
    .99949,
    1,
    1.0006,
    .99897,
    .99918,
    .99968,
    .99911,
    .99924,
    1,
    .99962,
    1.01487,
    1,
    1.0005,
    .99973,
    1.00012,
    1.00043,
    1,
    .99995,
    .99994,
    1.00036,
    .99947,
    1.00019,
    1.00063,
    1.00025,
    .99924,
    1.00036,
    .99973,
    1.00036,
    1.00025,
    1.00001,
    1.00001,
    1.00027,
    1.0001,
    1.00068,
    1.00001,
    1.0006,
    1.0006,
    1,
    1.00008,
    .99957,
    .99972,
    .9994,
    .99954,
    .99975,
    1.00051,
    1.00001,
    1.00019,
    1.00001,
    1.0001,
    .99986,
    1.00001,
    1.00001,
    1.00038,
    .99954,
    .99954,
    .9994,
    1.00066,
    .99999,
    .99977,
    1.00022,
    1.00054,
    1.00001,
    .99977,
    1.00026,
    .99975,
    1.0001,
    1.00001,
    .99993,
    .9995,
    .99955,
    1.00016,
    .99978,
    .99974,
    1.00019,
    1.00022,
    .99955,
    1.00053,
    .99973,
    1.00089,
    1.00005,
    .99967,
    1.00048,
    .99973,
    1.00002,
    1.00034,
    .99973,
    .99973,
    .99964,
    1.00006,
    1.00066,
    .99947,
    .99973,
    .98894,
    .99973,
    1,
    .44898,
    1,
    .99946,
    1,
    1.00039,
    1.00082,
    .99991,
    .99991,
    .99985,
    1.00022,
    1.00023,
    1.00061,
    1.00006,
    .99966,
    .99973,
    .99973,
    .99973,
    1.00019,
    1.0008,
    1,
    .99924,
    .99924,
    .99924,
    .99983,
    1.00044,
    .99973,
    .99964,
    .98332,
    1,
    .99973,
    1,
    1,
    .99962,
    .99895,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    1.00423,
    .99925,
    .99999,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00049,
    1,
    1.00245,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    1.00003,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .99998,
    .99998,
    .99998,
    .99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ci = {
    lineHeight: 1.35,
    lineGap: .2
}, vi = [
    .76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    .99973,
    .99973,
    .99982,
    1.00001,
    1.00043,
    .99998,
    .99998,
    .99959,
    1.00003,
    1.0006,
    .99998,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    .99973,
    .99987,
    1.00001,
    1.00001,
    .99977,
    .99977,
    1.00001,
    1.00026,
    1.00022,
    .99977,
    1.0006,
    1,
    1.00001,
    .99973,
    .99999,
    .99977,
    1.00022,
    1.00001,
    1.00022,
    .99977,
    1.00001,
    1.00026,
    .99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    .99949,
    .99973,
    .99998,
    .99973,
    .99973,
    1,
    .99973,
    .99973,
    1.0006,
    .99973,
    .99973,
    .99924,
    .99924,
    1,
    .99924,
    .99999,
    .99973,
    .99973,
    .99973,
    .99973,
    .99998,
    1,
    1.0006,
    .99973,
    1,
    .99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    .99998,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0009,
    .99973,
    .99998,
    1.00025,
    .99968,
    .99973,
    1.00003,
    1.00025,
    .60299,
    1.00024,
    1.06409,
    1,
    1,
    .99998,
    1,
    .9998,
    1.0006,
    .99998,
    1,
    .99936,
    .99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    .99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99977,
    .99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    .99977,
    .99977,
    .99977,
    .99977,
    1.00001,
    1.00001,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99982,
    1,
    .99973,
    .99973,
    .99973,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    .99973,
    1.06409,
    1.00026,
    .99973,
    .99973,
    .99973,
    .99973,
    1,
    .99973,
    1,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1,
    .99977,
    1.04596,
    .99977,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00001,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    .99924,
    1.0006,
    1.0006,
    1.00019,
    1.00034,
    1,
    .99924,
    1.00001,
    1,
    1,
    .99973,
    .99924,
    .99973,
    .99924,
    .99973,
    1.02572,
    .99973,
    1.00005,
    .99973,
    .99924,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99999,
    .9998,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1.00022,
    .99973,
    1,
    1.00016,
    .99977,
    .99998,
    .99977,
    .99998,
    .99977,
    .99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    .84533,
    1.00026,
    1.0006,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    .99977,
    .99973,
    1.00016,
    .99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    .99924,
    .99973,
    1.00001,
    .99973,
    1,
    .99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99998,
    .99928,
    1,
    .99977,
    1.00013,
    1.00055,
    .99947,
    .99945,
    .99941,
    .99924,
    1.00001,
    1.00001,
    1.0004,
    .91621,
    1.00001,
    1.00026,
    .99977,
    1.00022,
    1.0006,
    1.00001,
    1.00005,
    .99999,
    .99977,
    1.00015,
    1.00022,
    .99977,
    1.00001,
    .99973,
    1.00026,
    1.00001,
    1.00019,
    1.00001,
    .99946,
    1,
    1.0006,
    1.00001,
    .99978,
    1.00045,
    .99973,
    .99924,
    1.00023,
    .99978,
    .99966,
    1,
    1.00065,
    1.00045,
    1.00019,
    .99973,
    .99973,
    .99924,
    1,
    1,
    .96499,
    1,
    1.00055,
    .99973,
    1.00008,
    1.00027,
    1,
    .9997,
    .99995,
    1.00023,
    .99933,
    1.00019,
    1.00015,
    1.00031,
    .99924,
    1.00023,
    .99973,
    1.00023,
    1.00031,
    1.00001,
    .99928,
    1.00029,
    1.00092,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    1,
    .99988,
    .99975,
    1,
    1.00082,
    .99561,
    .9996,
    1.00035,
    1.00001,
    .99962,
    1.00001,
    1.00092,
    .99964,
    1.00001,
    .99963,
    .99999,
    1.00035,
    1.00035,
    1.00082,
    .99962,
    .99999,
    .99977,
    1.00022,
    1.00035,
    1.00001,
    .99977,
    1.00026,
    .9996,
    .99967,
    1.00001,
    1.00034,
    1.00074,
    1.00054,
    1.00053,
    1.00063,
    .99971,
    .99962,
    1.00035,
    .99975,
    .99977,
    .99973,
    1.00043,
    .99953,
    1.0007,
    .99915,
    .99973,
    1.00008,
    .99892,
    1.00073,
    1.00073,
    1.00114,
    .99915,
    1.00073,
    .99955,
    .99973,
    1.00092,
    .99973,
    1,
    .99998,
    1,
    1.0003,
    1,
    1.00043,
    1.00001,
    .99969,
    1.0003,
    1,
    1.00035,
    1.00001,
    .9995,
    1,
    1.00092,
    .99973,
    .99973,
    .99973,
    1.0007,
    .9995,
    1,
    .99924,
    1.0006,
    .99924,
    .99972,
    1.00062,
    .99973,
    1.00114,
    1.00073,
    1,
    .99955,
    1,
    1,
    1.00047,
    .99968,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00016,
    .99977,
    1.00001,
    1,
    1,
    1,
    .99973,
    1,
    1,
    .99955,
    .99924,
    .99924,
    .99924,
    .99924,
    .99998,
    .99998,
    .99998,
    .99973,
    .99973,
    .99972,
    1,
    1,
    1.00267,
    .99999,
    .99998,
    .99998,
    1,
    .99998,
    1.66475,
    1,
    .99973,
    .99973,
    1.00023,
    .99973,
    .99971,
    .99925,
    1.00023,
    1,
    .99991,
    .99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    .8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    .99915,
    1.00031,
    1.00031,
    .99999,
    1.00003,
    .99999,
    .99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    .99999,
    1,
    .99861,
    .99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    .95317,
    .99999,
    .99999,
    .99999,
    .99999,
    1.40483,
    1,
    .99977,
    1.00054,
    1,
    1,
    .99953,
    .99962,
    1.00042,
    .9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Fi = {
    lineHeight: 1.2,
    lineGap: .2
}, Ii = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    719,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    785,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    385,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    465,
    722,
    333,
    853,
    906,
    474,
    825,
    927,
    838,
    278,
    722,
    722,
    601,
    719,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    644,
    778,
    722,
    667,
    600,
    611,
    667,
    821,
    667,
    809,
    802,
    278,
    667,
    615,
    451,
    611,
    278,
    582,
    615,
    610,
    556,
    606,
    475,
    460,
    611,
    541,
    278,
    558,
    556,
    612,
    556,
    445,
    611,
    766,
    619,
    520,
    684,
    446,
    582,
    715,
    576,
    753,
    845,
    278,
    582,
    611,
    582,
    845,
    667,
    669,
    885,
    567,
    711,
    667,
    278,
    276,
    556,
    1094,
    1062,
    875,
    610,
    722,
    622,
    719,
    722,
    719,
    722,
    567,
    712,
    667,
    904,
    626,
    719,
    719,
    610,
    702,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    622,
    854,
    667,
    730,
    703,
    1005,
    1019,
    870,
    979,
    719,
    711,
    1031,
    719,
    556,
    618,
    615,
    417,
    635,
    556,
    709,
    497,
    615,
    615,
    500,
    635,
    740,
    604,
    611,
    604,
    611,
    556,
    490,
    556,
    875,
    556,
    615,
    581,
    833,
    844,
    729,
    854,
    615,
    552,
    854,
    583,
    556,
    556,
    611,
    417,
    552,
    556,
    278,
    281,
    278,
    969,
    906,
    611,
    500,
    615,
    556,
    604,
    778,
    611,
    487,
    447,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1094,
    556,
    885,
    489,
    1115,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], Ti = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Oi = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    740,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    782,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    396,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    722,
    333,
    854,
    906,
    473,
    844,
    930,
    847,
    278,
    722,
    722,
    610,
    671,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    657,
    778,
    718,
    667,
    590,
    611,
    667,
    822,
    667,
    829,
    781,
    278,
    667,
    620,
    479,
    611,
    278,
    591,
    620,
    621,
    556,
    610,
    479,
    492,
    611,
    558,
    278,
    566,
    556,
    603,
    556,
    450,
    611,
    712,
    605,
    532,
    664,
    409,
    591,
    704,
    578,
    773,
    834,
    278,
    591,
    611,
    591,
    834,
    667,
    667,
    886,
    614,
    719,
    667,
    278,
    278,
    556,
    1094,
    1042,
    854,
    622,
    719,
    677,
    719,
    722,
    708,
    722,
    614,
    722,
    667,
    927,
    643,
    719,
    719,
    615,
    687,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    677,
    781,
    667,
    729,
    708,
    979,
    989,
    854,
    1e3,
    708,
    719,
    1042,
    729,
    556,
    619,
    604,
    534,
    618,
    556,
    736,
    510,
    611,
    611,
    507,
    622,
    740,
    604,
    611,
    611,
    611,
    556,
    889,
    556,
    885,
    556,
    646,
    583,
    889,
    935,
    707,
    854,
    594,
    552,
    865,
    589,
    556,
    556,
    611,
    469,
    563,
    556,
    278,
    278,
    278,
    969,
    906,
    611,
    507,
    619,
    556,
    611,
    778,
    611,
    575,
    467,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1104,
    556,
    885,
    516,
    1146,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    999,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
], Mi = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Di = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    625,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    733,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    281,
    556,
    400,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    615,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    354,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    789,
    846,
    389,
    794,
    865,
    775,
    222,
    667,
    667,
    570,
    671,
    667,
    611,
    722,
    778,
    278,
    667,
    667,
    833,
    722,
    648,
    778,
    725,
    667,
    600,
    611,
    667,
    837,
    667,
    831,
    761,
    278,
    667,
    570,
    439,
    555,
    222,
    550,
    570,
    571,
    500,
    556,
    439,
    463,
    555,
    542,
    222,
    500,
    492,
    548,
    500,
    447,
    556,
    670,
    573,
    486,
    603,
    374,
    550,
    652,
    546,
    728,
    779,
    222,
    550,
    556,
    550,
    779,
    667,
    667,
    843,
    544,
    708,
    667,
    278,
    278,
    500,
    1066,
    982,
    844,
    589,
    715,
    639,
    724,
    667,
    651,
    667,
    544,
    704,
    667,
    917,
    614,
    715,
    715,
    589,
    686,
    833,
    722,
    778,
    725,
    667,
    722,
    611,
    639,
    795,
    667,
    727,
    673,
    920,
    923,
    805,
    886,
    651,
    694,
    1022,
    682,
    556,
    562,
    522,
    493,
    553,
    556,
    688,
    465,
    556,
    556,
    472,
    564,
    686,
    550,
    556,
    556,
    556,
    500,
    833,
    500,
    835,
    500,
    572,
    518,
    830,
    851,
    621,
    736,
    526,
    492,
    752,
    534,
    556,
    556,
    556,
    378,
    496,
    500,
    222,
    222,
    222,
    910,
    828,
    556,
    472,
    565,
    500,
    556,
    778,
    556,
    492,
    339,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1083,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    998,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    584,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], Bi = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ri = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    615,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    735,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    292,
    556,
    334,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    604,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    375,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    784,
    838,
    384,
    774,
    855,
    752,
    222,
    667,
    667,
    551,
    668,
    667,
    611,
    722,
    778,
    278,
    667,
    668,
    833,
    722,
    650,
    778,
    722,
    667,
    618,
    611,
    667,
    798,
    667,
    835,
    748,
    278,
    667,
    578,
    446,
    556,
    222,
    547,
    578,
    575,
    500,
    557,
    446,
    441,
    556,
    556,
    222,
    500,
    500,
    576,
    500,
    448,
    556,
    690,
    569,
    482,
    617,
    395,
    547,
    648,
    525,
    713,
    781,
    222,
    547,
    556,
    547,
    781,
    667,
    667,
    865,
    542,
    719,
    667,
    278,
    278,
    500,
    1057,
    1010,
    854,
    583,
    722,
    635,
    719,
    667,
    656,
    667,
    542,
    677,
    667,
    923,
    604,
    719,
    719,
    583,
    656,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    635,
    760,
    667,
    740,
    667,
    917,
    938,
    792,
    885,
    656,
    719,
    1010,
    722,
    556,
    573,
    531,
    365,
    583,
    556,
    669,
    458,
    559,
    559,
    438,
    583,
    688,
    552,
    556,
    542,
    556,
    500,
    458,
    500,
    823,
    500,
    573,
    521,
    802,
    823,
    625,
    719,
    521,
    510,
    750,
    542,
    556,
    556,
    556,
    365,
    510,
    500,
    222,
    278,
    222,
    906,
    812,
    556,
    438,
    559,
    500,
    552,
    778,
    556,
    489,
    411,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1073,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
], Ni = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
], Ei = [
    1.36898,
    1,
    1,
    .72706,
    .80479,
    .83734,
    .98894,
    .99793,
    .9897,
    .93884,
    .86209,
    .94292,
    .94292,
    1.16661,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.19137,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .99793,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .72851,
    .78966,
    .90838,
    .83637,
    .82391,
    .96376,
    .80061,
    .86275,
    .8768,
    .95407,
    1.0258,
    .73901,
    .85022,
    .83655,
    1.0156,
    .95546,
    .92179,
    .87107,
    .92179,
    .82114,
    .8096,
    .89713,
    .94438,
    .95353,
    .94083,
    .91905,
    .90406,
    .9446,
    .94292,
    1.18777,
    .94292,
    1.02058,
    .89903,
    .90088,
    .94938,
    .97898,
    .81093,
    .97571,
    .94938,
    1.024,
    .9577,
    .95933,
    .98621,
    1.0474,
    .97455,
    .98981,
    .9672,
    .95933,
    .9446,
    .97898,
    .97407,
    .97646,
    .78036,
    1.10208,
    .95442,
    .95298,
    .97579,
    .9332,
    .94039,
    .938,
    .80687,
    1.01149,
    .80687,
    1.02058,
    .80479,
    .99793,
    .99793,
    .99793,
    .99793,
    1.01149,
    1.00872,
    .90088,
    .91882,
    1.0213,
    .8361,
    1.02058,
    .62295,
    .54324,
    .89022,
    1.08595,
    1,
    1,
    .90088,
    1,
    .97455,
    .93582,
    .90088,
    1,
    1.05686,
    .8361,
    .99642,
    .99642,
    .99642,
    .72851,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .90838,
    .868,
    .82391,
    .80061,
    .80061,
    .80061,
    .80061,
    1.0258,
    1.0258,
    1.0258,
    1.0258,
    .97484,
    .95546,
    .92179,
    .92179,
    .92179,
    .92179,
    .92179,
    1.02058,
    .92179,
    .94438,
    .94438,
    .94438,
    .94438,
    .90406,
    .86958,
    .98225,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .94938,
    .9031,
    .81093,
    .94938,
    .94938,
    .94938,
    .94938,
    .98621,
    .98621,
    .98621,
    .98621,
    .93969,
    .95933,
    .9446,
    .9446,
    .9446,
    .9446,
    .9446,
    1.08595,
    .9446,
    .95442,
    .95442,
    .95442,
    .95442,
    .94039,
    .97898,
    .94039,
    .90838,
    .94938,
    .90838,
    .94938,
    .90838,
    .94938,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .82391,
    .81093,
    .96376,
    .84313,
    .97484,
    .97571,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .80061,
    .94938,
    .8768,
    .9577,
    .8768,
    .9577,
    .8768,
    .9577,
    1,
    1,
    .95407,
    .95933,
    .97069,
    .95933,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    1.0258,
    .98621,
    .887,
    1.01591,
    .73901,
    1.0474,
    1,
    1,
    .97455,
    .83655,
    .98981,
    1,
    1,
    .83655,
    .73977,
    .83655,
    .73903,
    .84638,
    1.033,
    .95546,
    .95933,
    1,
    1,
    .95546,
    .95933,
    .8271,
    .95417,
    .95933,
    .92179,
    .9446,
    .92179,
    .9446,
    .92179,
    .9446,
    .936,
    .91964,
    .82114,
    .97646,
    1,
    1,
    .82114,
    .97646,
    .8096,
    .78036,
    .8096,
    .78036,
    1,
    1,
    .8096,
    .78036,
    1,
    1,
    .89713,
    .77452,
    .89713,
    1.10208,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94438,
    .95442,
    .94083,
    .97579,
    .90406,
    .94039,
    .90406,
    .9446,
    .938,
    .9446,
    .938,
    .9446,
    .938,
    1,
    .99793,
    .90838,
    .94938,
    .868,
    .9031,
    .92179,
    .9446,
    1,
    1,
    .89713,
    1.10208,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90989,
    .9358,
    .91945,
    .83181,
    .75261,
    .87992,
    .82976,
    .96034,
    .83689,
    .97268,
    1.0078,
    .90838,
    .83637,
    .8019,
    .90157,
    .80061,
    .9446,
    .95407,
    .92436,
    1.0258,
    .85022,
    .97153,
    1.0156,
    .95546,
    .89192,
    .92179,
    .92361,
    .87107,
    .96318,
    .89713,
    .93704,
    .95638,
    .91905,
    .91709,
    .92796,
    1.0258,
    .93704,
    .94836,
    1.0373,
    .95933,
    1.0078,
    .95871,
    .94836,
    .96174,
    .92601,
    .9498,
    .98607,
    .95776,
    .95933,
    1.05453,
    1.0078,
    .98275,
    .9314,
    .95617,
    .91701,
    1.05993,
    .9446,
    .78367,
    .9553,
    1,
    .86832,
    1.0128,
    .95871,
    .99394,
    .87548,
    .96361,
    .86774,
    1.0078,
    .95871,
    .9446,
    .95871,
    .86774,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .94083,
    .97579,
    .94083,
    .97579,
    .94083,
    .97579,
    .90406,
    .94039,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .93582,
    .93582,
    .93582,
    1,
    .908,
    .908,
    .918,
    .94219,
    .94219,
    .96544,
    1,
    1.285,
    1,
    1,
    .81079,
    .81079,
    1,
    1,
    .74854,
    1,
    1,
    1,
    1,
    .99793,
    1,
    1,
    1,
    .65,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.17173,
    1,
    .80535,
    .76169,
    1.02058,
    1.0732,
    1.05486,
    1,
    1,
    1.30692,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.16161,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Pi = {
    lineHeight: 1.2,
    lineGap: .2
}, ji = [
    1.36898,
    1,
    1,
    .66227,
    .80779,
    .81625,
    .97276,
    .97276,
    .97733,
    .92222,
    .83266,
    .94292,
    .94292,
    1.16148,
    1.02058,
    .93582,
    .96694,
    .93582,
    1.17337,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .97276,
    .78076,
    .78076,
    1.02058,
    1.02058,
    1.02058,
    .71541,
    .76813,
    .85576,
    .80591,
    .80729,
    .94299,
    .77512,
    .83655,
    .86523,
    .92222,
    .98621,
    .71743,
    .81698,
    .79726,
    .98558,
    .92222,
    .90637,
    .83809,
    .90637,
    .80729,
    .76463,
    .86275,
    .90699,
    .91605,
    .9154,
    .85308,
    .85458,
    .90531,
    .94292,
    1.21296,
    .94292,
    1.02058,
    .89903,
    1.18616,
    .99613,
    .91677,
    .78216,
    .91677,
    .90083,
    .98796,
    .9135,
    .92168,
    .95381,
    .98981,
    .95298,
    .95381,
    .93459,
    .92168,
    .91513,
    .92004,
    .91677,
    .95077,
    .748,
    1.04502,
    .91677,
    .92061,
    .94236,
    .89544,
    .89364,
    .9,
    .80687,
    .8578,
    .80687,
    1.02058,
    .80779,
    .97276,
    .97276,
    .97276,
    .97276,
    .8578,
    .99973,
    1.18616,
    .91339,
    1.08074,
    .82891,
    1.02058,
    .55509,
    .71526,
    .89022,
    1.08595,
    1,
    1,
    1.18616,
    1,
    .96736,
    .93582,
    1.18616,
    1,
    1.04864,
    .82711,
    .99043,
    .99043,
    .99043,
    .71541,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .85576,
    .845,
    .80729,
    .77512,
    .77512,
    .77512,
    .77512,
    .98621,
    .98621,
    .98621,
    .98621,
    .95961,
    .92222,
    .90637,
    .90637,
    .90637,
    .90637,
    .90637,
    1.02058,
    .90251,
    .90699,
    .90699,
    .90699,
    .90699,
    .85458,
    .83659,
    .94951,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .99613,
    .85811,
    .78216,
    .90083,
    .90083,
    .90083,
    .90083,
    .95381,
    .95381,
    .95381,
    .95381,
    .9135,
    .92168,
    .91513,
    .91513,
    .91513,
    .91513,
    .91513,
    1.08595,
    .91677,
    .91677,
    .91677,
    .91677,
    .91677,
    .89364,
    .92332,
    .89364,
    .85576,
    .99613,
    .85576,
    .99613,
    .85576,
    .99613,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .80729,
    .78216,
    .94299,
    .76783,
    .95961,
    .91677,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .77512,
    .90083,
    .86523,
    .9135,
    .86523,
    .9135,
    .86523,
    .9135,
    1,
    1,
    .92222,
    .92168,
    .92222,
    .92168,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .98621,
    .95381,
    .86036,
    .97096,
    .71743,
    .98981,
    1,
    1,
    .95298,
    .79726,
    .95381,
    1,
    1,
    .79726,
    .6894,
    .79726,
    .74321,
    .81691,
    1.0006,
    .92222,
    .92168,
    1,
    1,
    .92222,
    .92168,
    .79464,
    .92098,
    .92168,
    .90637,
    .91513,
    .90637,
    .91513,
    .90637,
    .91513,
    .909,
    .87514,
    .80729,
    .95077,
    1,
    1,
    .80729,
    .95077,
    .76463,
    .748,
    .76463,
    .748,
    1,
    1,
    .76463,
    .748,
    1,
    1,
    .86275,
    .72651,
    .86275,
    1.04502,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .90699,
    .91677,
    .9154,
    .94236,
    .85458,
    .89364,
    .85458,
    .90531,
    .9,
    .90531,
    .9,
    .90531,
    .9,
    1,
    .97276,
    .85576,
    .99613,
    .845,
    .85811,
    .90251,
    .91677,
    1,
    1,
    .86275,
    1.04502,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.00899,
    1.30628,
    .85576,
    .80178,
    .66862,
    .7927,
    .69323,
    .88127,
    .72459,
    .89711,
    .95381,
    .85576,
    .80591,
    .7805,
    .94729,
    .77512,
    .90531,
    .92222,
    .90637,
    .98621,
    .81698,
    .92655,
    .98558,
    .92222,
    .85359,
    .90637,
    .90976,
    .83809,
    .94523,
    .86275,
    .83509,
    .93157,
    .85308,
    .83392,
    .92346,
    .98621,
    .83509,
    .92886,
    .91324,
    .92168,
    .95381,
    .90646,
    .92886,
    .90557,
    .86847,
    .90276,
    .91324,
    .86842,
    .92168,
    .99531,
    .95381,
    .9224,
    .85408,
    .92699,
    .86847,
    1.0051,
    .91513,
    .80487,
    .93481,
    1,
    .88159,
    1.05214,
    .90646,
    .97355,
    .81539,
    .89398,
    .85923,
    .95381,
    .90646,
    .91513,
    .90646,
    .85923,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9154,
    .94236,
    .9154,
    .94236,
    .9154,
    .94236,
    .85458,
    .89364,
    .96694,
    1,
    .89903,
    1,
    1,
    1,
    .91782,
    .91782,
    .91782,
    1,
    .896,
    .896,
    .896,
    .9332,
    .9332,
    .95973,
    1,
    1.26,
    1,
    1,
    .80479,
    .80178,
    1,
    1,
    .85633,
    1,
    1,
    1,
    1,
    .97276,
    1,
    1,
    1,
    .698,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.14542,
    1,
    .79199,
    .78694,
    1.02058,
    1.03493,
    1.05486,
    1,
    1,
    1.23026,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.20006,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], _i = {
    lineHeight: 1.2,
    lineGap: .2
}, Xi = [
    1.36898,
    1,
    1,
    .65507,
    .84943,
    .85639,
    .88465,
    .88465,
    .86936,
    .88307,
    .86948,
    .85283,
    .85283,
    1.06383,
    1.02058,
    .75945,
    .9219,
    .75945,
    1.17337,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .88465,
    .75945,
    .75945,
    1.02058,
    1.02058,
    1.02058,
    .69046,
    .70926,
    .85158,
    .77812,
    .76852,
    .89591,
    .70466,
    .76125,
    .80094,
    .86822,
    .83864,
    .728,
    .77212,
    .79475,
    .93637,
    .87514,
    .8588,
    .76013,
    .8588,
    .72421,
    .69866,
    .77598,
    .85991,
    .80811,
    .87832,
    .78112,
    .77512,
    .8562,
    1.0222,
    1.18417,
    1.0222,
    1.27014,
    .89903,
    1.15012,
    .93859,
    .94399,
    .846,
    .94399,
    .81453,
    1.0186,
    .94219,
    .96017,
    1.03075,
    1.02175,
    .912,
    1.03075,
    .96998,
    .96017,
    .93859,
    .94399,
    .94399,
    .95493,
    .746,
    1.12658,
    .94578,
    .91,
    .979,
    .882,
    .882,
    .83,
    .85034,
    .83537,
    .85034,
    1.02058,
    .70869,
    .88465,
    .88465,
    .88465,
    .88465,
    .83537,
    .90083,
    1.15012,
    .9161,
    .94565,
    .73541,
    1.02058,
    .53609,
    .69353,
    .79519,
    1.08595,
    1,
    1,
    1.15012,
    1,
    .91974,
    .75945,
    1.15012,
    1,
    .9446,
    .73361,
    .9005,
    .9005,
    .9005,
    .62864,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .85158,
    .773,
    .76852,
    .70466,
    .70466,
    .70466,
    .70466,
    .83864,
    .83864,
    .83864,
    .83864,
    .90561,
    .87514,
    .8588,
    .8588,
    .8588,
    .8588,
    .8588,
    1.02058,
    .85751,
    .85991,
    .85991,
    .85991,
    .85991,
    .77512,
    .76013,
    .88075,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    .8075,
    .846,
    .81453,
    .81453,
    .81453,
    .81453,
    .82424,
    .82424,
    .82424,
    .82424,
    .9278,
    .96017,
    .93859,
    .93859,
    .93859,
    .93859,
    .93859,
    1.08595,
    .8562,
    .94578,
    .94578,
    .94578,
    .94578,
    .882,
    .94578,
    .882,
    .85158,
    .93859,
    .85158,
    .93859,
    .85158,
    .93859,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .76852,
    .846,
    .89591,
    .8544,
    .90561,
    .94399,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .70466,
    .81453,
    .80094,
    .94219,
    .80094,
    .94219,
    .80094,
    .94219,
    1,
    1,
    .86822,
    .96017,
    .86822,
    .96017,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    .82424,
    .83864,
    1.03075,
    .83864,
    .82424,
    .81402,
    1.02738,
    .728,
    1.02175,
    1,
    1,
    .912,
    .79475,
    1.03075,
    1,
    1,
    .79475,
    .83911,
    .79475,
    .66266,
    .80553,
    1.06676,
    .87514,
    .96017,
    1,
    1,
    .87514,
    .96017,
    .86865,
    .87396,
    .96017,
    .8588,
    .93859,
    .8588,
    .93859,
    .8588,
    .93859,
    .867,
    .84759,
    .72421,
    .95493,
    1,
    1,
    .72421,
    .95493,
    .69866,
    .746,
    .69866,
    .746,
    1,
    1,
    .69866,
    .746,
    1,
    1,
    .77598,
    .88417,
    .77598,
    1.12658,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .85991,
    .94578,
    .87832,
    .979,
    .77512,
    .882,
    .77512,
    .8562,
    .83,
    .8562,
    .83,
    .8562,
    .83,
    1,
    .88465,
    .85158,
    .93859,
    .773,
    .8075,
    .85751,
    .8562,
    1,
    1,
    .77598,
    1.12658,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15313,
    1.15012,
    1.15012,
    1.15012,
    1.08106,
    1.03901,
    .85158,
    .77025,
    .62264,
    .7646,
    .65351,
    .86026,
    .69461,
    .89947,
    1.03075,
    .85158,
    .77812,
    .76449,
    .88836,
    .70466,
    .8562,
    .86822,
    .8588,
    .83864,
    .77212,
    .85308,
    .93637,
    .87514,
    .82352,
    .8588,
    .85701,
    .76013,
    .89058,
    .77598,
    .8156,
    .82565,
    .78112,
    .77899,
    .89386,
    .83864,
    .8156,
    .9486,
    .92388,
    .96186,
    1.03075,
    .91123,
    .9486,
    .93298,
    .878,
    .93942,
    .92388,
    .84596,
    .96186,
    .95119,
    1.03075,
    .922,
    .88787,
    .95829,
    .88,
    .93559,
    .93859,
    .78815,
    .93758,
    1,
    .89217,
    1.03737,
    .91123,
    .93969,
    .77487,
    .85769,
    .86799,
    1.03075,
    .91123,
    .93859,
    .91123,
    .86799,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87832,
    .979,
    .87832,
    .979,
    .87832,
    .979,
    .77512,
    .882,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .87321,
    .87321,
    .87321,
    1,
    1.027,
    1.027,
    1.027,
    .86847,
    .86847,
    .79121,
    1,
    1.124,
    1,
    1,
    .73572,
    .73572,
    1,
    1,
    .85034,
    1,
    1,
    1,
    1,
    .88465,
    1,
    1,
    1,
    .669,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04828,
    1,
    .74948,
    .75187,
    1.02058,
    .98391,
    1.02119,
    1,
    1,
    1.06233,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05233,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], qi = {
    lineHeight: 1.2,
    lineGap: .2
}, Hi = [
    1.36898,
    1,
    1,
    .76305,
    .82784,
    .94935,
    .89364,
    .92241,
    .89073,
    .90706,
    .98472,
    .85283,
    .85283,
    1.0664,
    1.02058,
    .74505,
    .9219,
    .74505,
    1.23456,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .92241,
    .74505,
    .74505,
    1.02058,
    1.02058,
    1.02058,
    .73002,
    .72601,
    .91755,
    .8126,
    .80314,
    .92222,
    .73764,
    .79726,
    .83051,
    .90284,
    .86023,
    .74,
    .8126,
    .84869,
    .96518,
    .91115,
    .8858,
    .79761,
    .8858,
    .74498,
    .73914,
    .81363,
    .89591,
    .83659,
    .89633,
    .85608,
    .8111,
    .90531,
    1.0222,
    1.22736,
    1.0222,
    1.27014,
    .89903,
    .90088,
    .86667,
    1.0231,
    .896,
    1.01411,
    .90083,
    1.05099,
    1.00512,
    .99793,
    1.05326,
    1.09377,
    .938,
    1.06226,
    1.00119,
    .99793,
    .98714,
    1.0231,
    1.01231,
    .98196,
    .792,
    1.19137,
    .99074,
    .962,
    1.01915,
    .926,
    .942,
    .856,
    .85034,
    .92006,
    .85034,
    1.02058,
    .69067,
    .92241,
    .92241,
    .92241,
    .92241,
    .92006,
    .9332,
    .90088,
    .91882,
    .93484,
    .75339,
    1.02058,
    .56866,
    .54324,
    .79519,
    1.08595,
    1,
    1,
    .90088,
    1,
    .95325,
    .74505,
    .90088,
    1,
    .97198,
    .75339,
    .91009,
    .91009,
    .91009,
    .66466,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .91755,
    .788,
    .80314,
    .73764,
    .73764,
    .73764,
    .73764,
    .86023,
    .86023,
    .86023,
    .86023,
    .92915,
    .91115,
    .8858,
    .8858,
    .8858,
    .8858,
    .8858,
    1.02058,
    .8858,
    .89591,
    .89591,
    .89591,
    .89591,
    .8111,
    .79611,
    .89713,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86667,
    .86936,
    .896,
    .90083,
    .90083,
    .90083,
    .90083,
    .84224,
    .84224,
    .84224,
    .84224,
    .97276,
    .99793,
    .98714,
    .98714,
    .98714,
    .98714,
    .98714,
    1.08595,
    .89876,
    .99074,
    .99074,
    .99074,
    .99074,
    .942,
    1.0231,
    .942,
    .91755,
    .86667,
    .91755,
    .86667,
    .91755,
    .86667,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .80314,
    .896,
    .92222,
    .93372,
    .92915,
    1.01411,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .73764,
    .90083,
    .83051,
    1.00512,
    .83051,
    1.00512,
    .83051,
    1.00512,
    1,
    1,
    .90284,
    .99793,
    .90976,
    .99793,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    .84224,
    .86023,
    1.05326,
    .86023,
    .84224,
    .82873,
    1.07469,
    .74,
    1.09377,
    1,
    1,
    .938,
    .84869,
    1.06226,
    1,
    1,
    .84869,
    .83704,
    .84869,
    .81441,
    .85588,
    1.08927,
    .91115,
    .99793,
    1,
    1,
    .91115,
    .99793,
    .91887,
    .90991,
    .99793,
    .8858,
    .98714,
    .8858,
    .98714,
    .8858,
    .98714,
    .894,
    .91434,
    .74498,
    .98196,
    1,
    1,
    .74498,
    .98196,
    .73914,
    .792,
    .73914,
    .792,
    1,
    1,
    .73914,
    .792,
    1,
    1,
    .81363,
    .904,
    .81363,
    1.19137,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89591,
    .99074,
    .89633,
    1.01915,
    .8111,
    .942,
    .8111,
    .90531,
    .856,
    .90531,
    .856,
    .90531,
    .856,
    1,
    .92241,
    .91755,
    .86667,
    .788,
    .86936,
    .8858,
    .89876,
    1,
    1,
    .81363,
    1.19137,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90088,
    .90388,
    1.03901,
    .92138,
    .78105,
    .7154,
    .86169,
    .80513,
    .94007,
    .82528,
    .98612,
    1.06226,
    .91755,
    .8126,
    .81884,
    .92819,
    .73764,
    .90531,
    .90284,
    .8858,
    .86023,
    .8126,
    .91172,
    .96518,
    .91115,
    .83089,
    .8858,
    .87791,
    .79761,
    .89297,
    .81363,
    .88157,
    .89992,
    .85608,
    .81992,
    .94307,
    .86023,
    .88157,
    .95308,
    .98699,
    .99793,
    1.06226,
    .95817,
    .95308,
    .97358,
    .928,
    .98088,
    .98699,
    .92761,
    .99793,
    .96017,
    1.06226,
    .986,
    .944,
    .95978,
    .938,
    .96705,
    .98714,
    .80442,
    .98972,
    1,
    .89762,
    1.04552,
    .95817,
    .99007,
    .87064,
    .91879,
    .88888,
    1.06226,
    .95817,
    .98714,
    .95817,
    .88888,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .89633,
    1.01915,
    .8111,
    .942,
    .9219,
    1,
    .89903,
    1,
    1,
    1,
    .93173,
    .93173,
    .93173,
    1,
    1.06304,
    1.06304,
    1.06904,
    .89903,
    .89903,
    .80549,
    1,
    1.156,
    1,
    1,
    .76575,
    .76575,
    1,
    1,
    .72458,
    1,
    1,
    1,
    1,
    .92241,
    1,
    1,
    1,
    .619,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.07257,
    1,
    .74705,
    .71119,
    1.02058,
    1.024,
    1.02119,
    1,
    1,
    1.1536,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05638,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Wi = {
    lineHeight: 1.2,
    lineGap: .2
}, zi = [
    1.76738,
    1,
    1,
    .99297,
    .9824,
    1.04016,
    1.06497,
    1.03424,
    .97529,
    1.17647,
    1.23203,
    1.1085,
    1.1085,
    1.16939,
    1.2107,
    .9754,
    1.21408,
    .9754,
    1.59578,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    .81378,
    .81378,
    1.2107,
    1.2107,
    1.2107,
    .71703,
    .97847,
    .97363,
    .88776,
    .8641,
    1.02096,
    .79795,
    .85132,
    .914,
    1.06085,
    1.1406,
    .8007,
    .89858,
    .83693,
    1.14889,
    1.09398,
    .97489,
    .92094,
    .97489,
    .90399,
    .84041,
    .95923,
    1.00135,
    1,
    1.06467,
    .98243,
    .90996,
    .99361,
    1.1085,
    1.56942,
    1.1085,
    1.2107,
    .74627,
    .94282,
    .96752,
    1.01519,
    .86304,
    1.01359,
    .97278,
    1.15103,
    1.01359,
    .98561,
    1.02285,
    1.02285,
    1.00527,
    1.02285,
    1.0302,
    .99041,
    1.0008,
    1.01519,
    1.01359,
    1.02258,
    .79104,
    1.16862,
    .99041,
    .97454,
    1.02511,
    .99298,
    .96752,
    .95801,
    .94856,
    1.16579,
    .94856,
    1.2107,
    .9824,
    1.03424,
    1.03424,
    1,
    1.03424,
    1.16579,
    .8727,
    1.3871,
    1.18622,
    1.10818,
    1.04478,
    1.2107,
    1.18622,
    .75155,
    .94994,
    1.28826,
    1.21408,
    1.21408,
    .91056,
    1,
    .91572,
    .9754,
    .64663,
    1.18328,
    1.24866,
    1.04478,
    1.14169,
    1.15749,
    1.17389,
    .71703,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .93506,
    .8641,
    .79795,
    .79795,
    .79795,
    .79795,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.02096,
    1.09398,
    .97426,
    .97426,
    .97426,
    .97426,
    .97426,
    1.2107,
    .97489,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .90996,
    .92094,
    1.02798,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .96752,
    .93136,
    .86304,
    .97278,
    .97278,
    .97278,
    .97278,
    1.02285,
    1.02285,
    1.02285,
    1.02285,
    .97122,
    .99041,
    1,
    1,
    1,
    1,
    1,
    1.28826,
    1.0008,
    .99041,
    .99041,
    .99041,
    .99041,
    .96752,
    1.01519,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .97363,
    .96752,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    .8641,
    .86304,
    1.02096,
    1.03057,
    1.02096,
    1.03517,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .79795,
    .97278,
    .914,
    1.01359,
    .914,
    1.01359,
    .914,
    1.01359,
    1,
    1,
    1.06085,
    .98561,
    1.06085,
    1.00879,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    .97138,
    1.08692,
    .8007,
    1.02285,
    1,
    1,
    1.00527,
    .83693,
    1.02285,
    1,
    1,
    .83693,
    .9455,
    .83693,
    .90418,
    .83693,
    1.13005,
    1.09398,
    .99041,
    1,
    1,
    1.09398,
    .99041,
    .96692,
    1.09251,
    .99041,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .97489,
    1.0008,
    .93994,
    .97931,
    .90399,
    1.02258,
    1,
    1,
    .90399,
    1.02258,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    .84041,
    .79104,
    1,
    1,
    .95923,
    1.07034,
    .95923,
    1.16862,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.00135,
    .99041,
    1.06467,
    1.02511,
    .90996,
    .96752,
    .90996,
    .99361,
    .95801,
    .99361,
    .95801,
    .99361,
    .95801,
    1.07733,
    1.03424,
    .97363,
    .96752,
    .93506,
    .93136,
    .97489,
    1.0008,
    1,
    1,
    .95923,
    1.16862,
    1.15103,
    1.15103,
    1.01173,
    1.03959,
    .75953,
    .81378,
    .79912,
    1.15103,
    1.21994,
    .95161,
    .87815,
    1.01149,
    .81525,
    .7676,
    .98167,
    1.01134,
    1.02546,
    .84097,
    1.03089,
    1.18102,
    .97363,
    .88776,
    .85134,
    .97826,
    .79795,
    .99361,
    1.06085,
    .97489,
    1.1406,
    .89858,
    1.0388,
    1.14889,
    1.09398,
    .86039,
    .97489,
    1.0595,
    .92094,
    .94793,
    .95923,
    .90996,
    .99346,
    .98243,
    1.02112,
    .95493,
    1.1406,
    .90996,
    1.03574,
    1.02597,
    1.0008,
    1.18102,
    1.06628,
    1.03574,
    1.0192,
    1.01932,
    1.00886,
    .97531,
    1.0106,
    1.0008,
    1.13189,
    1.18102,
    1.02277,
    .98683,
    1.0016,
    .99561,
    1.07237,
    1.0008,
    .90434,
    .99921,
    .93803,
    .8965,
    1.23085,
    1.06628,
    1.04983,
    .96268,
    1.0499,
    .98439,
    1.18102,
    1.06628,
    1.0008,
    1.06628,
    .98439,
    .79795,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09466,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .97278,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.02065,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    .90996,
    .96752,
    1,
    1.21408,
    .89903,
    1,
    1,
    .75155,
    1.04394,
    1.04394,
    1.04394,
    1.04394,
    .98633,
    .98633,
    .98633,
    .73047,
    .73047,
    1.20642,
    .91211,
    1.25635,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.12454,
    .93503,
    1.03424,
    1.19687,
    1.03424,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15749,
    1.15749,
    1.15749,
    1.10948,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.16897,
    1,
    .96085,
    .90137,
    1.2107,
    1.18416,
    1.13973,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21172,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18874,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.09193,
    1.09193,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], $i = {
    lineHeight: 1.33008,
    lineGap: 0
}, Gi = [
    1.76738,
    1,
    1,
    .98946,
    1.03959,
    1.04016,
    1.02809,
    1.036,
    .97639,
    1.10953,
    1.23203,
    1.11144,
    1.11144,
    1.16939,
    1.21237,
    .9754,
    1.21261,
    .9754,
    1.59754,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    .81378,
    .81378,
    1.21237,
    1.21237,
    1.21237,
    .73541,
    .97847,
    .97363,
    .89723,
    .87897,
    1.0426,
    .79429,
    .85292,
    .91149,
    1.05815,
    1.1406,
    .79631,
    .90128,
    .83853,
    1.04396,
    1.10615,
    .97552,
    .94436,
    .97552,
    .88641,
    .80527,
    .96083,
    1.00135,
    1,
    1.06777,
    .9817,
    .91142,
    .99361,
    1.11144,
    1.57293,
    1.11144,
    1.21237,
    .74627,
    1.31818,
    1.06585,
    .97042,
    .83055,
    .97042,
    .93503,
    1.1261,
    .97042,
    .97922,
    1.14236,
    .94552,
    1.01054,
    1.14236,
    1.02471,
    .97922,
    .94165,
    .97042,
    .97042,
    1.0276,
    .78929,
    1.1261,
    .97922,
    .95874,
    1.02197,
    .98507,
    .96752,
    .97168,
    .95107,
    1.16579,
    .95107,
    1.21237,
    1.03959,
    1.036,
    1.036,
    1,
    1.036,
    1.16579,
    .87357,
    1.31818,
    1.18754,
    1.26781,
    1.05356,
    1.21237,
    1.18622,
    .79487,
    .94994,
    1.29004,
    1.24047,
    1.24047,
    1.31818,
    1,
    .91484,
    .9754,
    1.31818,
    1.1349,
    1.24866,
    1.05356,
    1.13934,
    1.15574,
    1.17389,
    .73541,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .97363,
    .94385,
    .87897,
    .79429,
    .79429,
    .79429,
    .79429,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.0426,
    1.10615,
    .97552,
    .97552,
    .97552,
    .97552,
    .97552,
    1.21237,
    .97552,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    .91142,
    .94436,
    .98721,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    .96705,
    .83055,
    .93503,
    .93503,
    .93503,
    .93503,
    1.14236,
    1.14236,
    1.14236,
    1.14236,
    .93125,
    .97922,
    .94165,
    .94165,
    .94165,
    .94165,
    .94165,
    1.29004,
    .94165,
    .97922,
    .97922,
    .97922,
    .97922,
    .96752,
    .97042,
    .96752,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .97363,
    1.06585,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    .87897,
    .83055,
    1.0426,
    1.0033,
    1.0426,
    .97042,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .79429,
    .93503,
    .91149,
    .97042,
    .91149,
    .97042,
    .91149,
    .97042,
    1,
    1,
    1.05815,
    .97922,
    1.05815,
    .97922,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    .97441,
    1.04302,
    .79631,
    1.01582,
    1,
    1,
    1.01054,
    .83853,
    1.14236,
    1,
    1,
    .83853,
    1.09125,
    .83853,
    .90418,
    .83853,
    1.19508,
    1.10615,
    .97922,
    1,
    1,
    1.10615,
    .97922,
    1.01034,
    1.10466,
    .97922,
    .97552,
    .94165,
    .97552,
    .94165,
    .97552,
    .94165,
    .91602,
    .91981,
    .88641,
    1.0276,
    1,
    1,
    .88641,
    1.0276,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    .80527,
    .78929,
    1,
    1,
    .96083,
    1.05403,
    .95923,
    1.16862,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.00135,
    .97922,
    1.06777,
    1.02197,
    .91142,
    .96752,
    .91142,
    .99361,
    .97168,
    .99361,
    .97168,
    .99361,
    .97168,
    1.23199,
    1.036,
    .97363,
    1.06585,
    .94385,
    .96705,
    .97552,
    .94165,
    1,
    1,
    .96083,
    1.1261,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    .95161,
    1.27126,
    1.00811,
    .83284,
    .77702,
    .99137,
    .95253,
    1.0347,
    .86142,
    1.07205,
    1.14236,
    .97363,
    .89723,
    .86869,
    1.09818,
    .79429,
    .99361,
    1.05815,
    .97552,
    1.1406,
    .90128,
    1.06662,
    1.04396,
    1.10615,
    .84918,
    .97552,
    1.04694,
    .94436,
    .98015,
    .96083,
    .91142,
    1.00356,
    .9817,
    1.01945,
    .98999,
    1.1406,
    .91142,
    1.04961,
    .9898,
    1.00639,
    1.14236,
    1.07514,
    1.04961,
    .99607,
    1.02897,
    1.008,
    .9898,
    .95134,
    1.00639,
    1.11121,
    1.14236,
    1.00518,
    .97981,
    1.02186,
    1,
    1.08578,
    .94165,
    .99314,
    .98387,
    .93028,
    .93377,
    1.35125,
    1.07514,
    1.10687,
    .93491,
    1.04232,
    1.00351,
    1.14236,
    1.07514,
    .94165,
    1.07514,
    1.00351,
    .79429,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09097,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .93503,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .96609,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    .91142,
    .96752,
    1,
    1.21261,
    .89903,
    1,
    1,
    .75155,
    1.04745,
    1.04745,
    1.04745,
    1.04394,
    .98633,
    .98633,
    .98633,
    .72959,
    .72959,
    1.20502,
    .91406,
    1.26514,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    .96039,
    1.24633,
    1,
    1.09125,
    .93327,
    1.03336,
    1.16541,
    1.036,
    1,
    1,
    1,
    .771,
    1,
    1,
    1.15574,
    1.15574,
    1.15574,
    1.15574,
    .86364,
    .94434,
    .86279,
    .94434,
    .86224,
    1,
    1,
    1.16798,
    1,
    .96085,
    .90068,
    1.21237,
    1.18416,
    1.13904,
    .69825,
    .9716,
    2.10339,
    1.29004,
    1.29004,
    1.21339,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18775,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.13269,
    1.13269,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Vi = {
    lineHeight: 1.33008,
    lineGap: 0
}, Ki = [
    1.76738,
    1,
    1,
    .98946,
    1.14763,
    1.05365,
    1.06234,
    .96927,
    .92586,
    1.15373,
    1.18414,
    .91349,
    .91349,
    1.07403,
    1.17308,
    .78383,
    1.20088,
    .78383,
    1.42531,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78383,
    .78383,
    1.17308,
    1.17308,
    1.17308,
    .77349,
    .94565,
    .94729,
    .85944,
    .88506,
    .9858,
    .74817,
    .80016,
    .88449,
    .98039,
    .95782,
    .69238,
    .89898,
    .83231,
    .98183,
    1.03989,
    .96924,
    .86237,
    .96924,
    .80595,
    .74524,
    .86091,
    .95402,
    .94143,
    .98448,
    .8858,
    .83089,
    .93285,
    1.0949,
    1.39016,
    1.0949,
    1.45994,
    .74627,
    1.04839,
    .97454,
    .97454,
    .87207,
    .97454,
    .87533,
    1.06151,
    .97454,
    1.00176,
    1.16484,
    1.08132,
    .98047,
    1.16484,
    1.02989,
    1.01054,
    .96225,
    .97454,
    .97454,
    1.06598,
    .79004,
    1.16344,
    1.00351,
    .94629,
    .9973,
    .91016,
    .96777,
    .9043,
    .91082,
    .92481,
    .91082,
    1.17308,
    .95748,
    .96927,
    .96927,
    1,
    .96927,
    .92481,
    .80597,
    1.04839,
    1.23393,
    1.1781,
    .9245,
    1.17308,
    1.20808,
    .63218,
    .94261,
    1.24822,
    1.09971,
    1.09971,
    1.04839,
    1,
    .85273,
    .78032,
    1.04839,
    1.09971,
    1.22326,
    .9245,
    1.09836,
    1.13525,
    1.15222,
    .70424,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .94729,
    .85498,
    .88506,
    .74817,
    .74817,
    .74817,
    .74817,
    .95782,
    .95782,
    .95782,
    .95782,
    .9858,
    1.03989,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.17308,
    .96924,
    .95402,
    .95402,
    .95402,
    .95402,
    .83089,
    .86237,
    .88409,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .97454,
    .92916,
    .87207,
    .87533,
    .87533,
    .87533,
    .87533,
    .93146,
    .93146,
    .93146,
    .93146,
    .93854,
    1.01054,
    .96225,
    .96225,
    .96225,
    .96225,
    .96225,
    1.24822,
    .8761,
    1.00351,
    1.00351,
    1.00351,
    1.00351,
    .96777,
    .97454,
    .96777,
    .94729,
    .97454,
    .94729,
    .97454,
    .94729,
    .97454,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .88506,
    .87207,
    .9858,
    .95391,
    .9858,
    .97454,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .74817,
    .87533,
    .88449,
    .97454,
    .88449,
    .97454,
    .88449,
    .97454,
    1,
    1,
    .98039,
    1.00176,
    .98039,
    1.00176,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    .93146,
    .95782,
    1.16484,
    .95782,
    .93146,
    .84421,
    1.12761,
    .69238,
    1.08132,
    1,
    1,
    .98047,
    .83231,
    1.16484,
    1,
    1,
    .84723,
    1.04861,
    .84723,
    .78755,
    .83231,
    1.23736,
    1.03989,
    1.01054,
    1,
    1,
    1.03989,
    1.01054,
    .9857,
    1.03849,
    1.01054,
    .96924,
    .96225,
    .96924,
    .96225,
    .96924,
    .96225,
    .92383,
    .90171,
    .80595,
    1.06598,
    1,
    1,
    .80595,
    1.06598,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    .74524,
    .79004,
    1,
    1,
    .86091,
    1.02759,
    .85771,
    1.16344,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .95402,
    1.00351,
    .98448,
    .9973,
    .83089,
    .96777,
    .83089,
    .93285,
    .9043,
    .93285,
    .9043,
    .93285,
    .9043,
    1.31868,
    .96927,
    .94729,
    .97454,
    .85498,
    .92916,
    .96924,
    .8761,
    1,
    1,
    .86091,
    1.16344,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    .81965,
    .81965,
    .94729,
    .78032,
    .71022,
    .90883,
    .84171,
    .99877,
    .77596,
    1.05734,
    1.2,
    .94729,
    .85944,
    .82791,
    .9607,
    .74817,
    .93285,
    .98039,
    .96924,
    .95782,
    .89898,
    .98316,
    .98183,
    1.03989,
    .78614,
    .96924,
    .97642,
    .86237,
    .86075,
    .86091,
    .83089,
    .90082,
    .8858,
    .97296,
    1.01284,
    .95782,
    .83089,
    1.0976,
    1.04,
    1.03342,
    1.2,
    1.0675,
    1.0976,
    .98205,
    1.03809,
    1.05097,
    1.04,
    .95364,
    1.03342,
    1.05401,
    1.2,
    1.02148,
    1.0119,
    1.04724,
    1.0127,
    1.02732,
    .96225,
    .8965,
    .97783,
    .93574,
    .94818,
    1.30679,
    1.0675,
    1.11826,
    .99821,
    1.0557,
    1.0326,
    1.2,
    1.0675,
    .96225,
    1.0675,
    1.0326,
    .74817,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03754,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .87533,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .98705,
    1,
    1,
    1,
    1,
    1,
    1,
    .98448,
    .9973,
    .98448,
    .9973,
    .98448,
    .9973,
    .83089,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    .94945,
    .94945,
    .94945,
    .94945,
    1.12317,
    1.12317,
    1.12317,
    .67603,
    .67603,
    1.15621,
    .73584,
    1.21191,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87709,
    .96927,
    1.01473,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.09836,
    1.09836,
    1.09836,
    1.01522,
    .86321,
    .94434,
    .8649,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86438,
    1.17308,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.96791,
    1.24822,
    1.24822,
    1.17308,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.17984,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10742,
    1.10742,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Ji = {
    lineHeight: 1.33008,
    lineGap: 0
}, Yi = [
    1.76738,
    1,
    1,
    .98594,
    1.02285,
    1.10454,
    1.06234,
    .96927,
    .92037,
    1.19985,
    1.2046,
    .90616,
    .90616,
    1.07152,
    1.1714,
    .78032,
    1.20088,
    .78032,
    1.40246,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .96927,
    .78032,
    .78032,
    1.1714,
    1.1714,
    1.1714,
    .80597,
    .94084,
    .96706,
    .85944,
    .85734,
    .97093,
    .75842,
    .79936,
    .88198,
    .9831,
    .95782,
    .71387,
    .86969,
    .84636,
    1.07796,
    1.03584,
    .96924,
    .83968,
    .96924,
    .82826,
    .79649,
    .85771,
    .95132,
    .93119,
    .98965,
    .88433,
    .8287,
    .93365,
    1.08612,
    1.3638,
    1.08612,
    1.45786,
    .74627,
    .80499,
    .91484,
    1.05707,
    .92383,
    1.05882,
    .9403,
    1.12654,
    1.05882,
    1.01756,
    1.09011,
    1.09011,
    .99414,
    1.09011,
    1.034,
    1.01756,
    1.05356,
    1.05707,
    1.05882,
    1.04399,
    .84863,
    1.21968,
    1.01756,
    .95801,
    1.00068,
    .91797,
    .96777,
    .9043,
    .90351,
    .92105,
    .90351,
    1.1714,
    .85337,
    .96927,
    .96927,
    .99912,
    .96927,
    .92105,
    .80597,
    1.2434,
    1.20808,
    1.05937,
    .90957,
    1.1714,
    1.20808,
    .75155,
    .94261,
    1.24644,
    1.09971,
    1.09971,
    .84751,
    1,
    .85273,
    .78032,
    .61584,
    1.05425,
    1.17914,
    .90957,
    1.08665,
    1.11593,
    1.14169,
    .73381,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .96706,
    .86035,
    .85734,
    .75842,
    .75842,
    .75842,
    .75842,
    .95782,
    .95782,
    .95782,
    .95782,
    .97093,
    1.03584,
    .96924,
    .96924,
    .96924,
    .96924,
    .96924,
    1.1714,
    .96924,
    .95132,
    .95132,
    .95132,
    .95132,
    .8287,
    .83968,
    .89049,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .91484,
    .93575,
    .92383,
    .9403,
    .9403,
    .9403,
    .9403,
    .8717,
    .8717,
    .8717,
    .8717,
    1.00527,
    1.01756,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.24644,
    .95923,
    1.01756,
    1.01756,
    1.01756,
    1.01756,
    .96777,
    1.05707,
    .96777,
    .96706,
    .91484,
    .96706,
    .91484,
    .96706,
    .91484,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .85734,
    .92383,
    .97093,
    1.0969,
    .97093,
    1.05882,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .75842,
    .9403,
    .88198,
    1.05882,
    .88198,
    1.05882,
    .88198,
    1.05882,
    1,
    1,
    .9831,
    1.01756,
    .9831,
    1.01756,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    .8717,
    .95782,
    1.09011,
    .95782,
    .8717,
    .84784,
    1.11551,
    .71387,
    1.09011,
    1,
    1,
    .99414,
    .84636,
    1.09011,
    1,
    1,
    .84636,
    1.0536,
    .84636,
    .94298,
    .84636,
    1.23297,
    1.03584,
    1.01756,
    1,
    1,
    1.03584,
    1.01756,
    1.00323,
    1.03444,
    1.01756,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .96924,
    1.05356,
    .93066,
    .98293,
    .82826,
    1.04399,
    1,
    1,
    .82826,
    1.04399,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    .79649,
    .84863,
    1,
    1,
    .85771,
    1.17318,
    .85771,
    1.21968,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .95132,
    1.01756,
    .98965,
    1.00068,
    .8287,
    .96777,
    .8287,
    .93365,
    .9043,
    .93365,
    .9043,
    .93365,
    .9043,
    1.08571,
    .96927,
    .96706,
    .91484,
    .86035,
    .93575,
    .96924,
    .95923,
    1,
    1,
    .85771,
    1.21968,
    1.11437,
    1.11437,
    .93109,
    .91202,
    .60411,
    .84164,
    .55572,
    1.01173,
    .97361,
    .81818,
    .81818,
    .96635,
    .78032,
    .72727,
    .92366,
    .98601,
    1.03405,
    .77968,
    1.09799,
    1.2,
    .96706,
    .85944,
    .85638,
    .96491,
    .75842,
    .93365,
    .9831,
    .96924,
    .95782,
    .86969,
    .94152,
    1.07796,
    1.03584,
    .78437,
    .96924,
    .98715,
    .83968,
    .83491,
    .85771,
    .8287,
    .94492,
    .88433,
    .9287,
    1.0098,
    .95782,
    .8287,
    1.0625,
    .98248,
    1.03424,
    1.2,
    1.01071,
    1.0625,
    .95246,
    1.03809,
    1.04912,
    .98248,
    1.00221,
    1.03424,
    1.05443,
    1.2,
    1.04785,
    .99609,
    1.00169,
    1.05176,
    .99346,
    1.05356,
    .9087,
    1.03004,
    .95542,
    .93117,
    1.23362,
    1.01071,
    1.07831,
    1.02512,
    1.05205,
    1.03502,
    1.2,
    1.01071,
    1.05356,
    1.01071,
    1.03502,
    .75842,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03719,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    .9403,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04021,
    1,
    1,
    1,
    1,
    1,
    1,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .98965,
    1.00068,
    .8287,
    .96777,
    1,
    1.20088,
    .89903,
    1,
    1,
    .75155,
    1.03077,
    1.03077,
    1.03077,
    1.03077,
    1.13196,
    1.13196,
    1.13196,
    .67428,
    .67428,
    1.16039,
    .73291,
    1.20996,
    1.22135,
    1.06483,
    .94868,
    .94868,
    .95996,
    1.24633,
    1,
    1.07497,
    .87796,
    .96927,
    1.01518,
    .96927,
    1,
    1,
    1,
    .77295,
    1,
    1,
    1.10539,
    1.10539,
    1.11358,
    1.06967,
    .86279,
    .94434,
    .86279,
    .94434,
    .86182,
    1,
    1,
    1.083,
    1,
    .91578,
    .86507,
    1.1714,
    1.18416,
    1.14589,
    .69825,
    .97622,
    1.9697,
    1.24822,
    1.24822,
    1.17238,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    .99862,
    .99862,
    1,
    .87025,
    .87025,
    .87025,
    .87025,
    1.18083,
    1.42603,
    1,
    1.42603,
    1.42603,
    .99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10938,
    1.10938,
    1,
    1,
    1,
    1.05425,
    1.09971,
    1.09971,
    1.09971,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
], Zi = {
    lineHeight: 1.33008,
    lineGap: 0
}, Qi = getLookupTableFactory(function(e1) {
    e1["MyriadPro-Regular"] = e1["PdfJS-Fallback-Regular"] = {
        name: "LiberationSans-Regular",
        factors: Hi,
        baseWidths: Ri,
        baseMapping: Ni,
        metrics: Wi
    };
    e1["MyriadPro-Bold"] = e1["PdfJS-Fallback-Bold"] = {
        name: "LiberationSans-Bold",
        factors: Ei,
        baseWidths: Ii,
        baseMapping: Ti,
        metrics: Pi
    };
    e1["MyriadPro-It"] = e1["MyriadPro-Italic"] = e1["PdfJS-Fallback-Italic"] = {
        name: "LiberationSans-Italic",
        factors: Xi,
        baseWidths: Di,
        baseMapping: Bi,
        metrics: qi
    };
    e1["MyriadPro-BoldIt"] = e1["MyriadPro-BoldItalic"] = e1["PdfJS-Fallback-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: ji,
        baseWidths: Oi,
        baseMapping: Mi,
        metrics: _i
    };
    e1.ArialMT = e1.Arial = e1["Arial-Regular"] = {
        name: "LiberationSans-Regular",
        baseWidths: Ri,
        baseMapping: Ni
    };
    e1["Arial-BoldMT"] = e1["Arial-Bold"] = {
        name: "LiberationSans-Bold",
        baseWidths: Ii,
        baseMapping: Ti
    };
    e1["Arial-ItalicMT"] = e1["Arial-Italic"] = {
        name: "LiberationSans-Italic",
        baseWidths: Di,
        baseMapping: Bi
    };
    e1["Arial-BoldItalicMT"] = e1["Arial-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        baseWidths: Oi,
        baseMapping: Mi
    };
    e1["Calibri-Regular"] = {
        name: "LiberationSans-Regular",
        factors: bi,
        baseWidths: Ri,
        baseMapping: Ni,
        metrics: yi
    };
    e1["Calibri-Bold"] = {
        name: "LiberationSans-Bold",
        factors: ui,
        baseWidths: Ii,
        baseMapping: Ti,
        metrics: di
    };
    e1["Calibri-Italic"] = {
        name: "LiberationSans-Italic",
        factors: pi,
        baseWidths: Di,
        baseMapping: Bi,
        metrics: mi
    };
    e1["Calibri-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: fi,
        baseWidths: Oi,
        baseMapping: Mi,
        metrics: gi
    };
    e1["Segoeui-Regular"] = {
        name: "LiberationSans-Regular",
        factors: Yi,
        baseWidths: Ri,
        baseMapping: Ni,
        metrics: Zi
    };
    e1["Segoeui-Bold"] = {
        name: "LiberationSans-Bold",
        factors: zi,
        baseWidths: Ii,
        baseMapping: Ti,
        metrics: $i
    };
    e1["Segoeui-Italic"] = {
        name: "LiberationSans-Italic",
        factors: Ki,
        baseWidths: Di,
        baseMapping: Bi,
        metrics: Ji
    };
    e1["Segoeui-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Gi,
        baseWidths: Oi,
        baseMapping: Mi,
        metrics: Vi
    };
    e1["Helvetica-Regular"] = e1.Helvetica = {
        name: "LiberationSans-Regular",
        factors: vi,
        baseWidths: Ri,
        baseMapping: Ni,
        metrics: Fi
    };
    e1["Helvetica-Bold"] = {
        name: "LiberationSans-Bold",
        factors: wi,
        baseWidths: Ii,
        baseMapping: Ti,
        metrics: xi
    };
    e1["Helvetica-Italic"] = {
        name: "LiberationSans-Italic",
        factors: ki,
        baseWidths: Di,
        baseMapping: Bi,
        metrics: Ci
    };
    e1["Helvetica-BoldItalic"] = {
        name: "LiberationSans-BoldItalic",
        factors: Si,
        baseWidths: Oi,
        baseMapping: Mi,
        metrics: Ai
    };
});
function getXfaFontName(e1) {
    const t = normalizeFontName(e1);
    return Qi()[t];
}
function getXfaFontDict(e1) {
    const t = function getXfaFontWidths(e1) {
        const t = getXfaFontName(e1);
        if (!t) return null;
        const { baseWidths: a, baseMapping: r, factors: i } = t, n = i ? a.map((e1, t)=>e1 * i[t]) : a;
        let s, o = -2;
        const c = [];
        for (const [e1, t] of r.map((e1, t)=>[
                e1,
                t
            ]).sort(([e1], [t])=>e1 - t))if (-1 !== e1) if (e1 === o + 1) {
            s.push(n[t]);
            o += 1;
        } else {
            o = e1;
            s = [
                n[t]
            ];
            c.push(e1, s);
        }
        return c;
    }(e1), a = new Dict(null);
    a.set("BaseFont", Name.get(e1));
    a.set("Type", Name.get("Font"));
    a.set("Subtype", Name.get("CIDFontType2"));
    a.set("Encoding", Name.get("Identity-H"));
    a.set("CIDToGIDMap", Name.get("Identity"));
    a.set("W", t);
    a.set("FirstChar", t[0]);
    a.set("LastChar", t.at(-2) + t.at(-1).length - 1);
    const r = new Dict(null);
    a.set("FontDescriptor", r);
    const i = new Dict(null);
    i.set("Ordering", "Identity");
    i.set("Registry", "Adobe");
    i.set("Supplement", 0);
    a.set("CIDSystemInfo", i);
    return a;
}
class PostScriptParser {
    constructor(e1){
        this.lexer = e1;
        this.operators = [];
        this.token = null;
        this.prev = null;
    }
    nextToken() {
        this.prev = this.token;
        this.token = this.lexer.getToken();
    }
    accept(e1) {
        if (this.token.type === e1) {
            this.nextToken();
            return !0;
        }
        return !1;
    }
    expect(e1) {
        if (this.accept(e1)) return !0;
        throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e1}.`);
    }
    parse() {
        this.nextToken();
        this.expect(en.LBRACE);
        this.parseBlock();
        this.expect(en.RBRACE);
        return this.operators;
    }
    parseBlock() {
        for(;;)if (this.accept(en.NUMBER)) this.operators.push(this.prev.value);
        else if (this.accept(en.OPERATOR)) this.operators.push(this.prev.value);
        else {
            if (!this.accept(en.LBRACE)) return;
            this.parseCondition();
        }
    }
    parseCondition() {
        const e1 = this.operators.length;
        this.operators.push(null, null);
        this.parseBlock();
        this.expect(en.RBRACE);
        if (this.accept(en.IF)) {
            this.operators[e1] = this.operators.length;
            this.operators[e1 + 1] = "jz";
        } else {
            if (!this.accept(en.LBRACE)) throw new FormatError("PS Function: error parsing conditional.");
            {
                const t = this.operators.length;
                this.operators.push(null, null);
                const a = this.operators.length;
                this.parseBlock();
                this.expect(en.RBRACE);
                this.expect(en.IFELSE);
                this.operators[t] = this.operators.length;
                this.operators[t + 1] = "j";
                this.operators[e1] = a;
                this.operators[e1 + 1] = "jz";
            }
        }
    }
}
const en = {
    LBRACE: 0,
    RBRACE: 1,
    NUMBER: 2,
    OPERATOR: 3,
    IF: 4,
    IFELSE: 5
};
class PostScriptToken {
    static get opCache() {
        return shadow(this, "opCache", Object.create(null));
    }
    constructor(e1, t){
        this.type = e1;
        this.value = t;
    }
    static getOperator(e1) {
        return PostScriptToken.opCache[e1] ||= new PostScriptToken(en.OPERATOR, e1);
    }
    static get LBRACE() {
        return shadow(this, "LBRACE", new PostScriptToken(en.LBRACE, "{"));
    }
    static get RBRACE() {
        return shadow(this, "RBRACE", new PostScriptToken(en.RBRACE, "}"));
    }
    static get IF() {
        return shadow(this, "IF", new PostScriptToken(en.IF, "IF"));
    }
    static get IFELSE() {
        return shadow(this, "IFELSE", new PostScriptToken(en.IFELSE, "IFELSE"));
    }
}
class PostScriptLexer {
    constructor(e1){
        this.stream = e1;
        this.nextChar();
        this.strBuf = [];
    }
    nextChar() {
        return this.currentChar = this.stream.getByte();
    }
    getToken() {
        let e1 = !1, t = this.currentChar;
        for(;;){
            if (t < 0) return aa;
            if (e1) 10 !== t && 13 !== t || (e1 = !1);
            else if (37 === t) e1 = !0;
            else if (!isWhiteSpace(t)) break;
            t = this.nextChar();
        }
        switch(0 | t){
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 43:
            case 45:
            case 46:
                return new PostScriptToken(en.NUMBER, this.getNumber());
            case 123:
                this.nextChar();
                return PostScriptToken.LBRACE;
            case 125:
                this.nextChar();
                return PostScriptToken.RBRACE;
        }
        const a = this.strBuf;
        a.length = 0;
        a[0] = String.fromCharCode(t);
        for(; (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122);)a.push(String.fromCharCode(t));
        const r = a.join("");
        switch(r.toLowerCase()){
            case "if":
                return PostScriptToken.IF;
            case "ifelse":
                return PostScriptToken.IFELSE;
            default:
                return PostScriptToken.getOperator(r);
        }
    }
    getNumber() {
        let e1 = this.currentChar;
        const t = this.strBuf;
        t.length = 0;
        t[0] = String.fromCharCode(e1);
        for(; (e1 = this.nextChar()) >= 0 && (e1 >= 48 && e1 <= 57 || 45 === e1 || 46 === e1);)t.push(String.fromCharCode(e1));
        const a = parseFloat(t.join(""));
        if (isNaN(a)) throw new FormatError(`Invalid floating point number: ${a}`);
        return a;
    }
}
class BaseLocalCache {
    constructor(e1){
        this._onlyRefs = !0 === e1?.onlyRefs;
        if (!this._onlyRefs) {
            this._nameRefMap = new Map;
            this._imageMap = new Map;
        }
        this._imageCache = new RefSetCache;
    }
    getByName(e1) {
        this._onlyRefs && unreachable("Should not call `getByName` method.");
        const t = this._nameRefMap.get(e1);
        return t ? this.getByRef(t) : this._imageMap.get(e1) || null;
    }
    getByRef(e1) {
        return this._imageCache.get(e1) || null;
    }
    set(e1, t, a) {
        unreachable("Abstract method `set` called.");
    }
}
class LocalImageCache extends BaseLocalCache {
    set(e1, t = null, a) {
        if ("string" != typeof e1) throw new Error('LocalImageCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e1, t);
            this._imageCache.put(t, a);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, a);
    }
}
class LocalColorSpaceCache extends BaseLocalCache {
    set(e1 = null, t = null, a) {
        if ("string" != typeof e1 && !t) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            null !== e1 && this._nameRefMap.set(e1, t);
            this._imageCache.put(t, a);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, a);
    }
}
class LocalFunctionCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, a) {
        if (!t) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, a);
    }
}
class LocalGStateCache extends BaseLocalCache {
    set(e1, t = null, a) {
        if ("string" != typeof e1) throw new Error('LocalGStateCache.set - expected "name" argument.');
        if (t) {
            if (this._imageCache.has(t)) return;
            this._nameRefMap.set(e1, t);
            this._imageCache.put(t, a);
        } else this._imageMap.has(e1) || this._imageMap.set(e1, a);
    }
}
class LocalTilingPatternCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, a) {
        if (!t) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, a);
    }
}
class RegionalImageCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, a) {
        if (!t) throw new Error('RegionalImageCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, a);
    }
}
class GlobalColorSpaceCache extends BaseLocalCache {
    constructor(e1){
        super({
            onlyRefs: !0
        });
    }
    set(e1 = null, t, a) {
        if (!t) throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
        this._imageCache.has(t) || this._imageCache.put(t, a);
    }
    clear() {
        this._imageCache.clear();
    }
}
class GlobalImageCache {
    static NUM_PAGES_THRESHOLD = 2;
    static MIN_IMAGES_TO_CACHE = 10;
    static MAX_BYTE_SIZE = 5e7;
    #H = new RefSet;
    constructor(){
        this._refCache = new RefSetCache;
        this._imageCache = new RefSetCache;
    }
    get #W() {
        let e1 = 0;
        for (const t of this._imageCache)e1 += t.byteSize;
        return e1;
    }
    get #z() {
        return !(this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#W < GlobalImageCache.MAX_BYTE_SIZE);
    }
    shouldCache(e1, t) {
        let a = this._refCache.get(e1);
        if (!a) {
            a = new Set;
            this._refCache.put(e1, a);
        }
        a.add(t);
        return !(a.size < GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e1) && this.#z);
    }
    addDecodeFailed(e1) {
        this.#H.put(e1);
    }
    hasDecodeFailed(e1) {
        return this.#H.has(e1);
    }
    addByteSize(e1, t) {
        const a = this._imageCache.get(e1);
        a && (a.byteSize || (a.byteSize = t));
    }
    getData(e1, t) {
        const a = this._refCache.get(e1);
        if (!a) return null;
        if (a.size < GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
        const r = this._imageCache.get(e1);
        if (!r) return null;
        a.add(t);
        return r;
    }
    setData(e1, t) {
        if (!this._refCache.has(e1)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
        this._imageCache.has(e1) || (this.#z ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e1, t));
    }
    clear(e1 = !1) {
        if (!e1) {
            this.#H.clear();
            this._refCache.clear();
        }
        this._imageCache.clear();
    }
}
class PDFFunctionFactory {
    constructor({ xref: e1, isEvalSupported: t = !0 }){
        this.xref = e1;
        this.isEvalSupported = !1 !== t;
    }
    create(e1, t = !1) {
        let a, r;
        e1 instanceof Ref ? a = e1 : e1 instanceof Dict ? a = e1.objId : e1 instanceof BaseStream && (a = e1.dict?.objId);
        if (a) {
            const e1 = this._localFunctionCache.getByRef(a);
            if (e1) return e1;
        }
        const i = this.xref.fetchIfRef(e1);
        if (Array.isArray(i)) {
            if (!t) throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
            r = PDFFunction.parseArray(this, i);
        } else r = PDFFunction.parse(this, i);
        a && this._localFunctionCache.set(null, a, r);
        return r;
    }
    get _localFunctionCache() {
        return shadow(this, "_localFunctionCache", new LocalFunctionCache);
    }
}
function toNumberArray(e1) {
    return Array.isArray(e1) ? isNumberArray(e1, null) ? e1 : e1.map((e1)=>+e1) : null;
}
class PDFFunction {
    static getSampleArray(e1, t, a, r) {
        let i, n, s = 1;
        for(i = 0, n = e1.length; i < n; i++)s *= e1[i];
        s *= t;
        const o = new Array(s);
        let c = 0, l = 0;
        const h = 1 / (2 ** a - 1), u = r.getBytes((s * a + 7) / 8);
        let d = 0;
        for(i = 0; i < s; i++){
            for(; c < a;){
                l <<= 8;
                l |= u[d++];
                c += 8;
            }
            c -= a;
            o[i] = (l >> c) * h;
            l &= (1 << c) - 1;
        }
        return o;
    }
    static parse(e1, t) {
        const a = t.dict || t;
        switch(a.get("FunctionType")){
            case 0:
                return this.constructSampled(e1, t, a);
            case 1:
                break;
            case 2:
                return this.constructInterpolated(e1, a);
            case 3:
                return this.constructStiched(e1, a);
            case 4:
                return this.constructPostScript(e1, t, a);
        }
        throw new FormatError("Unknown type of function");
    }
    static parseArray(e1, t) {
        const { xref: a } = e1, r = [];
        for (const i of t)r.push(this.parse(e1, a.fetchIfRef(i)));
        return function(e1, t, a, i) {
            for(let n = 0, s = r.length; n < s; n++)r[n](e1, t, a, i + n);
        };
    }
    static constructSampled(e1, t, a) {
        function toMultiArray(e1) {
            const t = e1.length, a = [];
            let r = 0;
            for(let i = 0; i < t; i += 2)a[r++] = [
                e1[i],
                e1[i + 1]
            ];
            return a;
        }
        function interpolate(e1, t, a, r, i) {
            return r + (i - r) / (a - t) * (e1 - t);
        }
        let r = toNumberArray(a.getArray("Domain")), i = toNumberArray(a.getArray("Range"));
        if (!r || !i) throw new FormatError("No domain or range");
        const n = r.length / 2, s = i.length / 2;
        r = toMultiArray(r);
        i = toMultiArray(i);
        const o = toNumberArray(a.getArray("Size")), c = a.get("BitsPerSample"), l = a.get("Order") || 1;
        1 !== l && info("No support for cubic spline interpolation: " + l);
        let h = toNumberArray(a.getArray("Encode"));
        if (h) h = toMultiArray(h);
        else {
            h = [];
            for(let e1 = 0; e1 < n; ++e1)h.push([
                0,
                o[e1] - 1
            ]);
        }
        let u = toNumberArray(a.getArray("Decode"));
        u = u ? toMultiArray(u) : i;
        const d = this.getSampleArray(o, s, c, t);
        return function constructSampledFn(e1, t, a, c) {
            const l = 1 << n, f = new Float64Array(l).fill(1), g = new Uint32Array(l);
            let p, m, b = s, y = 1;
            for(p = 0; p < n; ++p){
                const a = r[p][0], i = r[p][1];
                let n = interpolate(MathClamp(e1[t + p], a, i), a, i, h[p][0], h[p][1]);
                const s = o[p];
                n = MathClamp(n, 0, s - 1);
                const c = n < s - 1 ? Math.floor(n) : n - 1, u = c + 1 - n, d = n - c, w = c * b, x = w + b;
                for(m = 0; m < l; m++)if (m & y) {
                    f[m] *= d;
                    g[m] += x;
                } else {
                    f[m] *= u;
                    g[m] += w;
                }
                b *= s;
                y <<= 1;
            }
            for(m = 0; m < s; ++m){
                let e1 = 0;
                for(p = 0; p < l; p++)e1 += d[g[p] + m] * f[p];
                e1 = interpolate(e1, 0, 1, u[m][0], u[m][1]);
                a[c + m] = MathClamp(e1, i[m][0], i[m][1]);
            }
        };
    }
    static constructInterpolated(e1, t) {
        const a = toNumberArray(t.getArray("C0")) || [
            0
        ], r = toNumberArray(t.getArray("C1")) || [
            1
        ], i = t.get("N"), n = [];
        for(let e1 = 0, t = a.length; e1 < t; ++e1)n.push(r[e1] - a[e1]);
        const s = n.length;
        return function constructInterpolatedFn(e1, t, r, o) {
            const c = 1 === i ? e1[t] : e1[t] ** i;
            for(let e1 = 0; e1 < s; ++e1)r[o + e1] = a[e1] + c * n[e1];
        };
    }
    static constructStiched(e1, t) {
        const a = toNumberArray(t.getArray("Domain"));
        if (!a) throw new FormatError("No domain");
        if (1 !== a.length / 2) throw new FormatError("Bad domain for stiched function");
        const { xref: r } = e1, i = [];
        for (const a of t.get("Functions"))i.push(this.parse(e1, r.fetchIfRef(a)));
        const n = toNumberArray(t.getArray("Bounds")), s = toNumberArray(t.getArray("Encode")), o = new Float32Array(1);
        return function constructStichedFn(e1, t, r, c) {
            const l = MathClamp(e1[t], a[0], a[1]), h = n.length;
            let u;
            for(u = 0; u < h && !(l < n[u]); ++u);
            let d = a[0];
            u > 0 && (d = n[u - 1]);
            let f = a[1];
            u < n.length && (f = n[u]);
            const g = s[2 * u], p = s[2 * u + 1];
            o[0] = d === f ? g : g + (l - d) * (p - g) / (f - d);
            i[u](o, 0, r, c);
        };
    }
    static constructPostScript(e1, t, a) {
        const r = toNumberArray(a.getArray("Domain")), i = toNumberArray(a.getArray("Range"));
        if (!r) throw new FormatError("No domain.");
        if (!i) throw new FormatError("No range.");
        const n = new PostScriptLexer(t), s = new PostScriptParser(n).parse();
        if (e1.isEvalSupported && FeatureTest.isEvalSupported) {
            const e1 = (new PostScriptCompiler).compile(s, r, i);
            if (e1) return new Function("src", "srcOffset", "dest", "destOffset", e1);
        }
        info("Unable to compile PS function");
        const o = i.length >> 1, c = r.length >> 1, l = new PostScriptEvaluator(s), h = Object.create(null);
        let u = 8192;
        const d = new Float32Array(c);
        return function constructPostScriptFn(e1, t, a, r) {
            let n, s, f = "";
            const g = d;
            for(n = 0; n < c; n++){
                s = e1[t + n];
                g[n] = s;
                f += s + "_";
            }
            const p = h[f];
            if (void 0 !== p) {
                a.set(p, r);
                return;
            }
            const m = new Float32Array(o), b = l.execute(g), y = b.length - o;
            for(n = 0; n < o; n++){
                s = b[y + n];
                let e1 = i[2 * n];
                if (s < e1) s = e1;
                else {
                    e1 = i[2 * n + 1];
                    s > e1 && (s = e1);
                }
                m[n] = s;
            }
            if (u > 0) {
                u--;
                h[f] = m;
            }
            a.set(m, r);
        };
    }
}
function isPDFFunction(e1) {
    let t;
    if (e1 instanceof Dict) t = e1;
    else {
        if (!(e1 instanceof BaseStream)) return !1;
        t = e1.dict;
    }
    return t.has("FunctionType");
}
class PostScriptStack {
    static MAX_STACK_SIZE = 100;
    constructor(e1){
        this.stack = e1 ? Array.from(e1) : [];
    }
    push(e1) {
        if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        this.stack.push(e1);
    }
    pop() {
        if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
        return this.stack.pop();
    }
    copy(e1) {
        if (this.stack.length + e1 >= PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
        const t = this.stack;
        for(let a = t.length - e1, r = e1 - 1; r >= 0; r--, a++)t.push(t[a]);
    }
    index(e1) {
        this.push(this.stack[this.stack.length - e1 - 1]);
    }
    roll(e1, t) {
        const a = this.stack, r = a.length - e1, i = a.length - 1, n = r + (t - Math.floor(t / e1) * e1);
        for(let e1 = r, t = i; e1 < t; e1++, t--){
            const r = a[e1];
            a[e1] = a[t];
            a[t] = r;
        }
        for(let e1 = r, t = n - 1; e1 < t; e1++, t--){
            const r = a[e1];
            a[e1] = a[t];
            a[t] = r;
        }
        for(let e1 = n, t = i; e1 < t; e1++, t--){
            const r = a[e1];
            a[e1] = a[t];
            a[t] = r;
        }
    }
}
class PostScriptEvaluator {
    constructor(e1){
        this.operators = e1;
    }
    execute(e1) {
        const t = new PostScriptStack(e1);
        let a = 0;
        const r = this.operators, i = r.length;
        let n, s, o;
        for(; a < i;){
            n = r[a++];
            if ("number" != typeof n) switch(n){
                case "jz":
                    o = t.pop();
                    s = t.pop();
                    s || (a = o);
                    break;
                case "j":
                    s = t.pop();
                    a = s;
                    break;
                case "abs":
                    s = t.pop();
                    t.push(Math.abs(s));
                    break;
                case "add":
                    o = t.pop();
                    s = t.pop();
                    t.push(s + o);
                    break;
                case "and":
                    o = t.pop();
                    s = t.pop();
                    "boolean" == typeof s && "boolean" == typeof o ? t.push(s && o) : t.push(s & o);
                    break;
                case "atan":
                    o = t.pop();
                    s = t.pop();
                    s = Math.atan2(s, o) / Math.PI * 180;
                    s < 0 && (s += 360);
                    t.push(s);
                    break;
                case "bitshift":
                    o = t.pop();
                    s = t.pop();
                    s > 0 ? t.push(s << o) : t.push(s >> o);
                    break;
                case "ceiling":
                    s = t.pop();
                    t.push(Math.ceil(s));
                    break;
                case "copy":
                    s = t.pop();
                    t.copy(s);
                    break;
                case "cos":
                    s = t.pop();
                    t.push(Math.cos(s % 360 / 180 * Math.PI));
                    break;
                case "cvi":
                    s = 0 | t.pop();
                    t.push(s);
                    break;
                case "cvr":
                    break;
                case "div":
                    o = t.pop();
                    s = t.pop();
                    t.push(s / o);
                    break;
                case "dup":
                    t.copy(1);
                    break;
                case "eq":
                    o = t.pop();
                    s = t.pop();
                    t.push(s === o);
                    break;
                case "exch":
                    t.roll(2, 1);
                    break;
                case "exp":
                    o = t.pop();
                    s = t.pop();
                    t.push(s ** o);
                    break;
                case "false":
                    t.push(!1);
                    break;
                case "floor":
                    s = t.pop();
                    t.push(Math.floor(s));
                    break;
                case "ge":
                    o = t.pop();
                    s = t.pop();
                    t.push(s >= o);
                    break;
                case "gt":
                    o = t.pop();
                    s = t.pop();
                    t.push(s > o);
                    break;
                case "idiv":
                    o = t.pop();
                    s = t.pop();
                    t.push(s / o | 0);
                    break;
                case "index":
                    s = t.pop();
                    t.index(s);
                    break;
                case "le":
                    o = t.pop();
                    s = t.pop();
                    t.push(s <= o);
                    break;
                case "ln":
                    s = t.pop();
                    t.push(Math.log(s));
                    break;
                case "log":
                    s = t.pop();
                    t.push(Math.log10(s));
                    break;
                case "lt":
                    o = t.pop();
                    s = t.pop();
                    t.push(s < o);
                    break;
                case "mod":
                    o = t.pop();
                    s = t.pop();
                    t.push(s % o);
                    break;
                case "mul":
                    o = t.pop();
                    s = t.pop();
                    t.push(s * o);
                    break;
                case "ne":
                    o = t.pop();
                    s = t.pop();
                    t.push(s !== o);
                    break;
                case "neg":
                    s = t.pop();
                    t.push(-s);
                    break;
                case "not":
                    s = t.pop();
                    "boolean" == typeof s ? t.push(!s) : t.push(~s);
                    break;
                case "or":
                    o = t.pop();
                    s = t.pop();
                    "boolean" == typeof s && "boolean" == typeof o ? t.push(s || o) : t.push(s | o);
                    break;
                case "pop":
                    t.pop();
                    break;
                case "roll":
                    o = t.pop();
                    s = t.pop();
                    t.roll(s, o);
                    break;
                case "round":
                    s = t.pop();
                    t.push(Math.round(s));
                    break;
                case "sin":
                    s = t.pop();
                    t.push(Math.sin(s % 360 / 180 * Math.PI));
                    break;
                case "sqrt":
                    s = t.pop();
                    t.push(Math.sqrt(s));
                    break;
                case "sub":
                    o = t.pop();
                    s = t.pop();
                    t.push(s - o);
                    break;
                case "true":
                    t.push(!0);
                    break;
                case "truncate":
                    s = t.pop();
                    s = s < 0 ? Math.ceil(s) : Math.floor(s);
                    t.push(s);
                    break;
                case "xor":
                    o = t.pop();
                    s = t.pop();
                    "boolean" == typeof s && "boolean" == typeof o ? t.push(s !== o) : t.push(s ^ o);
                    break;
                default:
                    throw new FormatError(`Unknown operator ${n}`);
            }
            else t.push(n);
        }
        return t.stack;
    }
}
class AstNode {
    constructor(e1){
        this.type = e1;
    }
    visit(e1) {
        unreachable("abstract method");
    }
}
class AstArgument extends AstNode {
    constructor(e1, t, a){
        super("args");
        this.index = e1;
        this.min = t;
        this.max = a;
    }
    visit(e1) {
        e1.visitArgument(this);
    }
}
class AstLiteral extends AstNode {
    constructor(e1){
        super("literal");
        this.number = e1;
        this.min = e1;
        this.max = e1;
    }
    visit(e1) {
        e1.visitLiteral(this);
    }
}
class AstBinaryOperation extends AstNode {
    constructor(e1, t, a, r, i){
        super("binary");
        this.op = e1;
        this.arg1 = t;
        this.arg2 = a;
        this.min = r;
        this.max = i;
    }
    visit(e1) {
        e1.visitBinaryOperation(this);
    }
}
class AstMin extends AstNode {
    constructor(e1, t){
        super("max");
        this.arg = e1;
        this.min = e1.min;
        this.max = t;
    }
    visit(e1) {
        e1.visitMin(this);
    }
}
class AstVariable extends AstNode {
    constructor(e1, t, a){
        super("var");
        this.index = e1;
        this.min = t;
        this.max = a;
    }
    visit(e1) {
        e1.visitVariable(this);
    }
}
class AstVariableDefinition extends AstNode {
    constructor(e1, t){
        super("definition");
        this.variable = e1;
        this.arg = t;
    }
    visit(e1) {
        e1.visitVariableDefinition(this);
    }
}
class ExpressionBuilderVisitor {
    constructor(){
        this.parts = [];
    }
    visitArgument(e1) {
        this.parts.push("Math.max(", e1.min, ", Math.min(", e1.max, ", src[srcOffset + ", e1.index, "]))");
    }
    visitVariable(e1) {
        this.parts.push("v", e1.index);
    }
    visitLiteral(e1) {
        this.parts.push(e1.number);
    }
    visitBinaryOperation(e1) {
        this.parts.push("(");
        e1.arg1.visit(this);
        this.parts.push(" ", e1.op, " ");
        e1.arg2.visit(this);
        this.parts.push(")");
    }
    visitVariableDefinition(e1) {
        this.parts.push("var ");
        e1.variable.visit(this);
        this.parts.push(" = ");
        e1.arg.visit(this);
        this.parts.push(";");
    }
    visitMin(e1) {
        this.parts.push("Math.min(");
        e1.arg.visit(this);
        this.parts.push(", ", e1.max, ")");
    }
    toString() {
        return this.parts.join("");
    }
}
function buildAddOperation(e1, t) {
    return "literal" === t.type && 0 === t.number ? e1 : "literal" === e1.type && 0 === e1.number ? t : "literal" === t.type && "literal" === e1.type ? new AstLiteral(e1.number + t.number) : new AstBinaryOperation("+", e1, t, e1.min + t.min, e1.max + t.max);
}
function buildMulOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return new AstLiteral(0);
        if (1 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number * t.number);
    }
    if ("literal" === e1.type) {
        if (0 === e1.number) return new AstLiteral(0);
        if (1 === e1.number) return t;
    }
    const a = Math.min(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max), r = Math.max(e1.min * t.min, e1.min * t.max, e1.max * t.min, e1.max * t.max);
    return new AstBinaryOperation("*", e1, t, a, r);
}
function buildSubOperation(e1, t) {
    if ("literal" === t.type) {
        if (0 === t.number) return e1;
        if ("literal" === e1.type) return new AstLiteral(e1.number - t.number);
    }
    return "binary" === t.type && "-" === t.op && "literal" === e1.type && 1 === e1.number && "literal" === t.arg1.type && 1 === t.arg1.number ? t.arg2 : new AstBinaryOperation("-", e1, t, e1.min - t.max, e1.max - t.min);
}
function buildMinOperation(e1, t) {
    return e1.min >= t ? new AstLiteral(t) : e1.max <= t ? e1 : new AstMin(e1, t);
}
class PostScriptCompiler {
    compile(e1, t, a) {
        const r = [], i = [], n = t.length >> 1, s = a.length >> 1;
        let o, c, l, h, u, d, f, g, p = 0;
        for(let e1 = 0; e1 < n; e1++)r.push(new AstArgument(e1, t[2 * e1], t[2 * e1 + 1]));
        for(let t = 0, a = e1.length; t < a; t++){
            g = e1[t];
            if ("number" != typeof g) switch(g){
                case "add":
                    if (r.length < 2) return null;
                    h = r.pop();
                    l = r.pop();
                    r.push(buildAddOperation(l, h));
                    break;
                case "cvr":
                    if (r.length < 1) return null;
                    break;
                case "mul":
                    if (r.length < 2) return null;
                    h = r.pop();
                    l = r.pop();
                    r.push(buildMulOperation(l, h));
                    break;
                case "sub":
                    if (r.length < 2) return null;
                    h = r.pop();
                    l = r.pop();
                    r.push(buildSubOperation(l, h));
                    break;
                case "exch":
                    if (r.length < 2) return null;
                    u = r.pop();
                    d = r.pop();
                    r.push(u, d);
                    break;
                case "pop":
                    if (r.length < 1) return null;
                    r.pop();
                    break;
                case "index":
                    if (r.length < 1) return null;
                    l = r.pop();
                    if ("literal" !== l.type) return null;
                    o = l.number;
                    if (o < 0 || !Number.isInteger(o) || r.length < o) return null;
                    u = r[r.length - o - 1];
                    if ("literal" === u.type || "var" === u.type) {
                        r.push(u);
                        break;
                    }
                    f = new AstVariable(p++, u.min, u.max);
                    r[r.length - o - 1] = f;
                    r.push(f);
                    i.push(new AstVariableDefinition(f, u));
                    break;
                case "dup":
                    if (r.length < 1) return null;
                    if ("number" == typeof e1[t + 1] && "gt" === e1[t + 2] && e1[t + 3] === t + 7 && "jz" === e1[t + 4] && "pop" === e1[t + 5] && e1[t + 6] === e1[t + 1]) {
                        l = r.pop();
                        r.push(buildMinOperation(l, e1[t + 1]));
                        t += 6;
                        break;
                    }
                    u = r.at(-1);
                    if ("literal" === u.type || "var" === u.type) {
                        r.push(u);
                        break;
                    }
                    f = new AstVariable(p++, u.min, u.max);
                    r[r.length - 1] = f;
                    r.push(f);
                    i.push(new AstVariableDefinition(f, u));
                    break;
                case "roll":
                    if (r.length < 2) return null;
                    h = r.pop();
                    l = r.pop();
                    if ("literal" !== h.type || "literal" !== l.type) return null;
                    c = h.number;
                    o = l.number;
                    if (o <= 0 || !Number.isInteger(o) || !Number.isInteger(c) || r.length < o) return null;
                    c = (c % o + o) % o;
                    if (0 === c) break;
                    r.push(...r.splice(r.length - o, o - c));
                    break;
                default:
                    return null;
            }
            else r.push(new AstLiteral(g));
        }
        if (r.length !== s) return null;
        const m = [];
        for (const e1 of i){
            const t = new ExpressionBuilderVisitor;
            e1.visit(t);
            m.push(t.toString());
        }
        for(let e1 = 0, t = r.length; e1 < t; e1++){
            const t = r[e1], i = new ExpressionBuilderVisitor;
            t.visit(i);
            const n = a[2 * e1], s = a[2 * e1 + 1], o = [
                i.toString()
            ];
            if (n > t.min) {
                o.unshift("Math.max(", n, ", ");
                o.push(")");
            }
            if (s < t.max) {
                o.unshift("Math.min(", s, ", ");
                o.push(")");
            }
            o.unshift("dest[destOffset + ", e1, "] = ");
            o.push(";");
            m.push(o.join(""));
        }
        return m.join("\n");
    }
}
const tn = [
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "S",
    "B",
    "S",
    "WS",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "B",
    "B",
    "S",
    "WS",
    "ON",
    "ON",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ES",
    "CS",
    "ES",
    "CS",
    "CS",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "CS",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "CS",
    "ON",
    "ET",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "ON",
    "ON",
    "BN",
    "ON",
    "ON",
    "ET",
    "ET",
    "EN",
    "EN",
    "ON",
    "L",
    "ON",
    "ON",
    "ON",
    "EN",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L"
], an = [
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ON",
    "ON",
    "AL",
    "ET",
    "ET",
    "AL",
    "CS",
    "AL",
    "ON",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ET",
    "AN",
    "AN",
    "AL",
    "AL",
    "AL",
    "NSM",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL"
];
function isOdd(e1) {
    return !!(1 & e1);
}
function isEven(e1) {
    return !(1 & e1);
}
function findUnequal(e1, t, a) {
    let r, i;
    for(r = t, i = e1.length; r < i; ++r)if (e1[r] !== a) return r;
    return r;
}
function reverseValues(e1, t, a) {
    for(let r = t, i = a - 1; r < i; ++r, --i){
        const t = e1[r];
        e1[r] = e1[i];
        e1[i] = t;
    }
}
function createBidiText(e1, t, a = !1) {
    let r = "ltr";
    a ? r = "ttb" : t || (r = "rtl");
    return {
        str: e1,
        dir: r
    };
}
const rn = [], nn = [];
function bidi(e1, t = -1, a = !1) {
    let r = !0;
    const i = e1.length;
    if (0 === i || a) return createBidiText(e1, r, a);
    rn.length = i;
    nn.length = i;
    let n, s, o = 0;
    for(n = 0; n < i; ++n){
        rn[n] = e1.charAt(n);
        const t = e1.charCodeAt(n);
        let a = "L";
        if (t <= 255) a = tn[t];
        else if (1424 <= t && t <= 1524) a = "R";
        else if (1536 <= t && t <= 1791) {
            a = an[255 & t];
            a || warn("Bidi: invalid Unicode character " + t.toString(16));
        } else (1792 <= t && t <= 2220 || 64336 <= t && t <= 65023 || 65136 <= t && t <= 65279) && (a = "AL");
        "R" !== a && "AL" !== a && "AN" !== a || o++;
        nn[n] = a;
    }
    if (0 === o) {
        r = !0;
        return createBidiText(e1, r);
    }
    if (-1 === t) if (o / i < .3 && i > 4) {
        r = !0;
        t = 0;
    } else {
        r = !1;
        t = 1;
    }
    const c = [];
    for(n = 0; n < i; ++n)c[n] = t;
    const l = isOdd(t) ? "R" : "L", h = l, u = h;
    let d, f = h;
    for(n = 0; n < i; ++n)"NSM" === nn[n] ? nn[n] = f : f = nn[n];
    f = h;
    for(n = 0; n < i; ++n){
        d = nn[n];
        "EN" === d ? nn[n] = "AL" === f ? "AN" : "EN" : "R" !== d && "L" !== d && "AL" !== d || (f = d);
    }
    for(n = 0; n < i; ++n){
        d = nn[n];
        "AL" === d && (nn[n] = "R");
    }
    for(n = 1; n < i - 1; ++n){
        "ES" === nn[n] && "EN" === nn[n - 1] && "EN" === nn[n + 1] && (nn[n] = "EN");
        "CS" !== nn[n] || "EN" !== nn[n - 1] && "AN" !== nn[n - 1] || nn[n + 1] !== nn[n - 1] || (nn[n] = nn[n - 1]);
    }
    for(n = 0; n < i; ++n)if ("EN" === nn[n]) {
        for(let e1 = n - 1; e1 >= 0 && "ET" === nn[e1]; --e1)nn[e1] = "EN";
        for(let e1 = n + 1; e1 < i && "ET" === nn[e1]; ++e1)nn[e1] = "EN";
    }
    for(n = 0; n < i; ++n){
        d = nn[n];
        "WS" !== d && "ES" !== d && "ET" !== d && "CS" !== d || (nn[n] = "ON");
    }
    f = h;
    for(n = 0; n < i; ++n){
        d = nn[n];
        "EN" === d ? nn[n] = "L" === f ? "L" : "EN" : "R" !== d && "L" !== d || (f = d);
    }
    for(n = 0; n < i; ++n)if ("ON" === nn[n]) {
        const e1 = findUnequal(nn, n + 1, "ON");
        let t = h;
        n > 0 && (t = nn[n - 1]);
        let a = u;
        e1 + 1 < i && (a = nn[e1 + 1]);
        "L" !== t && (t = "R");
        "L" !== a && (a = "R");
        t === a && nn.fill(t, n, e1);
        n = e1 - 1;
    }
    for(n = 0; n < i; ++n)"ON" === nn[n] && (nn[n] = l);
    for(n = 0; n < i; ++n){
        d = nn[n];
        isEven(c[n]) ? "R" === d ? c[n] += 1 : "AN" !== d && "EN" !== d || (c[n] += 2) : "L" !== d && "AN" !== d && "EN" !== d || (c[n] += 1);
    }
    let g, p = -1, m = 99;
    for(n = 0, s = c.length; n < s; ++n){
        g = c[n];
        p < g && (p = g);
        m > g && isOdd(g) && (m = g);
    }
    for(g = p; g >= m; --g){
        let e1 = -1;
        for(n = 0, s = c.length; n < s; ++n)if (c[n] < g) {
            if (e1 >= 0) {
                reverseValues(rn, e1, n);
                e1 = -1;
            }
        } else e1 < 0 && (e1 = n);
        e1 >= 0 && reverseValues(rn, e1, c.length);
    }
    for(n = 0, s = rn.length; n < s; ++n){
        const e1 = rn[n];
        "<" !== e1 && ">" !== e1 || (rn[n] = "");
    }
    return createBidiText(rn.join(""), r);
}
const sn = {
    style: "normal",
    weight: "normal"
}, on = {
    style: "normal",
    weight: "bold"
}, cn = {
    style: "italic",
    weight: "normal"
}, ln = {
    style: "italic",
    weight: "bold"
}, hn = new Map([
    [
        "Times-Roman",
        {
            local: [
                "Times New Roman",
                "Times-Roman",
                "Times",
                "Liberation Serif",
                "Nimbus Roman",
                "Nimbus Roman L",
                "Tinos",
                "Thorndale",
                "TeX Gyre Termes",
                "FreeSerif",
                "Linux Libertine O",
                "Libertinus Serif",
                "DejaVu Serif",
                "Bitstream Vera Serif",
                "Ubuntu"
            ],
            style: sn,
            ultimate: "serif"
        }
    ],
    [
        "Times-Bold",
        {
            alias: "Times-Roman",
            style: on,
            ultimate: "serif"
        }
    ],
    [
        "Times-Italic",
        {
            alias: "Times-Roman",
            style: cn,
            ultimate: "serif"
        }
    ],
    [
        "Times-BoldItalic",
        {
            alias: "Times-Roman",
            style: ln,
            ultimate: "serif"
        }
    ],
    [
        "Helvetica",
        {
            local: [
                "Helvetica",
                "Helvetica Neue",
                "Arial",
                "Arial Nova",
                "Liberation Sans",
                "Arimo",
                "Nimbus Sans",
                "Nimbus Sans L",
                "A030",
                "TeX Gyre Heros",
                "FreeSans",
                "DejaVu Sans",
                "Albany",
                "Bitstream Vera Sans",
                "Arial Unicode MS",
                "Microsoft Sans Serif",
                "Apple Symbols",
                "Cantarell"
            ],
            path: "LiberationSans-Regular.ttf",
            style: sn,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Bold",
        {
            alias: "Helvetica",
            path: "LiberationSans-Bold.ttf",
            style: on,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-Oblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-Italic.ttf",
            style: cn,
            ultimate: "sans-serif"
        }
    ],
    [
        "Helvetica-BoldOblique",
        {
            alias: "Helvetica",
            path: "LiberationSans-BoldItalic.ttf",
            style: ln,
            ultimate: "sans-serif"
        }
    ],
    [
        "Courier",
        {
            local: [
                "Courier",
                "Courier New",
                "Liberation Mono",
                "Nimbus Mono",
                "Nimbus Mono L",
                "Cousine",
                "Cumberland",
                "TeX Gyre Cursor",
                "FreeMono",
                "Linux Libertine Mono O",
                "Libertinus Mono"
            ],
            style: sn,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Bold",
        {
            alias: "Courier",
            style: on,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-Oblique",
        {
            alias: "Courier",
            style: cn,
            ultimate: "monospace"
        }
    ],
    [
        "Courier-BoldOblique",
        {
            alias: "Courier",
            style: ln,
            ultimate: "monospace"
        }
    ],
    [
        "ArialBlack",
        {
            local: [
                "Arial Black"
            ],
            style: {
                style: "normal",
                weight: "900"
            },
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialBlack-Bold",
        {
            alias: "ArialBlack"
        }
    ],
    [
        "ArialBlack-Italic",
        {
            alias: "ArialBlack",
            style: {
                style: "italic",
                weight: "900"
            },
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "ArialBlack-BoldItalic",
        {
            alias: "ArialBlack-Italic"
        }
    ],
    [
        "ArialNarrow",
        {
            local: [
                "Arial Narrow",
                "Liberation Sans Narrow",
                "Helvetica Condensed",
                "Nimbus Sans Narrow",
                "TeX Gyre Heros Cn"
            ],
            style: sn,
            fallback: "Helvetica"
        }
    ],
    [
        "ArialNarrow-Bold",
        {
            alias: "ArialNarrow",
            style: on,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "ArialNarrow-Italic",
        {
            alias: "ArialNarrow",
            style: cn,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "ArialNarrow-BoldItalic",
        {
            alias: "ArialNarrow",
            style: ln,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Calibri",
        {
            local: [
                "Calibri",
                "Carlito"
            ],
            style: sn,
            fallback: "Helvetica"
        }
    ],
    [
        "Calibri-Bold",
        {
            alias: "Calibri",
            style: on,
            fallback: "Helvetica-Bold"
        }
    ],
    [
        "Calibri-Italic",
        {
            alias: "Calibri",
            style: cn,
            fallback: "Helvetica-Oblique"
        }
    ],
    [
        "Calibri-BoldItalic",
        {
            alias: "Calibri",
            style: ln,
            fallback: "Helvetica-BoldOblique"
        }
    ],
    [
        "Wingdings",
        {
            local: [
                "Wingdings",
                "URW Dingbats"
            ],
            style: sn
        }
    ],
    [
        "Wingdings-Regular",
        {
            alias: "Wingdings"
        }
    ],
    [
        "Wingdings-Bold",
        {
            alias: "Wingdings"
        }
    ]
]), un = new Map([
    [
        "Arial-Black",
        "ArialBlack"
    ]
]);
function getFamilyName(e1) {
    const t = new Set([
        "thin",
        "extralight",
        "ultralight",
        "demilight",
        "semilight",
        "light",
        "book",
        "regular",
        "normal",
        "medium",
        "demibold",
        "semibold",
        "bold",
        "extrabold",
        "ultrabold",
        "black",
        "heavy",
        "extrablack",
        "ultrablack",
        "roman",
        "italic",
        "oblique",
        "ultracondensed",
        "extracondensed",
        "condensed",
        "semicondensed",
        "normal",
        "semiexpanded",
        "expanded",
        "extraexpanded",
        "ultraexpanded",
        "bolditalic"
    ]);
    return e1.split(/[- ,+]+/g).filter((e1)=>!t.has(e1.toLowerCase())).join(" ");
}
function generateFont({ alias: e1, local: t, path: a, fallback: r, style: i, ultimate: n }, s, o, c = !0, l = !0, h = "") {
    const u = {
        style: null,
        ultimate: null
    };
    if (t) {
        const e1 = h ? ` ${h}` : "";
        for (const a of t)s.push(`local(${a}${e1})`);
    }
    if (e1) {
        const t = hn.get(e1), n = h || function getStyleToAppend(e1) {
            switch(e1){
                case on:
                    return "Bold";
                case cn:
                    return "Italic";
                case ln:
                    return "Bold Italic";
                default:
                    if ("bold" === e1?.weight) return "Bold";
                    if ("italic" === e1?.style) return "Italic";
            }
            return "";
        }(i);
        Object.assign(u, generateFont(t, s, o, c && !r, l && !a, n));
    }
    i && (u.style = i);
    n && (u.ultimate = n);
    if (c && r) {
        const e1 = hn.get(r), { ultimate: t } = generateFont(e1, s, o, c, l && !a, h);
        u.ultimate ||= t;
    }
    l && a && o && s.push(`url(${o}${a})`);
    return u;
}
function getFontSubstitution(e1, t, a, r, i, n) {
    if (r.startsWith("InvalidPDFjsFont_")) return null;
    "TrueType" !== n && "Type1" !== n || !/^[A-Z]{6}\+/.test(r) || (r = r.slice(7));
    const s = r = normalizeFontName(r);
    let o = e1.get(s);
    if (o) return o;
    let c = hn.get(r);
    if (!c) {
        for (const [e1, t] of un)if (r.startsWith(e1)) {
            r = `${t}${r.substring(e1.length)}`;
            c = hn.get(r);
            break;
        }
    }
    let l = !1;
    if (!c) {
        c = hn.get(i);
        l = !0;
    }
    const h = `${t.getDocId()}_s${t.createFontId()}`;
    if (!c) {
        if (!validateFontName(r)) {
            warn(`Cannot substitute the font because of its name: ${r}`);
            e1.set(s, null);
            return null;
        }
        const t = /bold/gi.test(r), a = /oblique|italic/gi.test(r), i = t && a && ln || t && on || a && cn || sn;
        o = {
            css: `"${getFamilyName(r)}",${h}`,
            guessFallback: !0,
            loadedName: h,
            baseFontName: r,
            src: `local(${r})`,
            style: i
        };
        e1.set(s, o);
        return o;
    }
    const u = [];
    l && validateFontName(r) && u.push(`local(${r})`);
    const { style: d, ultimate: f } = generateFont(c, u, a), g = null === f, p = g ? "" : `,${f}`;
    o = {
        css: `"${getFamilyName(r)}",${h}${p}`,
        guessFallback: g,
        loadedName: h,
        baseFontName: r,
        src: u.join(","),
        style: d
    };
    e1.set(s, o);
    return o;
}
const dn = 3285377520, fn = 4294901760, gn = 65535;
class MurmurHash3_64 {
    constructor(e1){
        this.h1 = e1 ? 4294967295 & e1 : dn;
        this.h2 = e1 ? 4294967295 & e1 : dn;
    }
    update(e1) {
        let t, a;
        if ("string" == typeof e1) {
            t = new Uint8Array(2 * e1.length);
            a = 0;
            for(let r = 0, i = e1.length; r < i; r++){
                const i = e1.charCodeAt(r);
                if (i <= 255) t[a++] = i;
                else {
                    t[a++] = i >>> 8;
                    t[a++] = 255 & i;
                }
            }
        } else {
            if (!ArrayBuffer.isView(e1)) throw new Error("Invalid data format, must be a string or TypedArray.");
            t = e1.slice();
            a = t.byteLength;
        }
        const r = a >> 2, i = a - 4 * r, n = new Uint32Array(t.buffer, 0, r);
        let s = 0, o = 0, c = this.h1, l = this.h2;
        const h = 3432918353, u = 461845907, d = 11601, f = 13715;
        for(let e1 = 0; e1 < r; e1++)if (1 & e1) {
            s = n[e1];
            s = s * h & fn | s * d & gn;
            s = s << 15 | s >>> 17;
            s = s * u & fn | s * f & gn;
            c ^= s;
            c = c << 13 | c >>> 19;
            c = 5 * c + 3864292196;
        } else {
            o = n[e1];
            o = o * h & fn | o * d & gn;
            o = o << 15 | o >>> 17;
            o = o * u & fn | o * f & gn;
            l ^= o;
            l = l << 13 | l >>> 19;
            l = 5 * l + 3864292196;
        }
        s = 0;
        switch(i){
            case 3:
                s ^= t[4 * r + 2] << 16;
            case 2:
                s ^= t[4 * r + 1] << 8;
            case 1:
                s ^= t[4 * r];
                s = s * h & fn | s * d & gn;
                s = s << 15 | s >>> 17;
                s = s * u & fn | s * f & gn;
                1 & r ? c ^= s : l ^= s;
        }
        this.h1 = c;
        this.h2 = l;
    }
    hexdigest() {
        let e1 = this.h1, t = this.h2;
        e1 ^= t >>> 1;
        e1 = 3981806797 * e1 & fn | 36045 * e1 & gn;
        t = 4283543511 * t & fn | (2950163797 * (t << 16 | e1 >>> 16) & fn) >>> 16;
        e1 ^= t >>> 1;
        e1 = 444984403 * e1 & fn | 60499 * e1 & gn;
        t = 3301882366 * t & fn | (3120437893 * (t << 16 | e1 >>> 16) & fn) >>> 16;
        e1 ^= t >>> 1;
        return (e1 >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
    }
}
function resizeImageMask(e1, t, a, r, i, n) {
    const s = i * n;
    let o;
    o = t <= 8 ? new Uint8Array(s) : t <= 16 ? new Uint16Array(s) : new Uint32Array(s);
    const c = a / i, l = r / n;
    let h, u, d, f, g = 0;
    const p = new Uint16Array(i), m = a;
    for(h = 0; h < i; h++)p[h] = Math.floor(h * c);
    for(h = 0; h < n; h++){
        d = Math.floor(h * l) * m;
        for(u = 0; u < i; u++){
            f = d + p[u];
            o[g++] = e1[f];
        }
    }
    return o;
}
class PDFImage {
    constructor({ xref: e1, res: t, image: a, isInline: r = !1, smask: i = null, mask: n = null, isMask: s = !1, pdfFunctionFactory: o, globalColorSpaceCache: c, localColorSpaceCache: l }){
        this.image = a;
        const h = a.dict, u = h.get("F", "Filter");
        let d;
        if (u instanceof Name) d = u.name;
        else if (Array.isArray(u)) {
            const t = e1.fetchIfRef(u[0]);
            t instanceof Name && (d = t.name);
        }
        switch(d){
            case "JPXDecode":
                ({ width: a.width, height: a.height, componentsCount: a.numComps, bitsPerComponent: a.bitsPerComponent } = JpxImage.parseImageProperties(a.stream));
                a.stream.reset();
                const e2 = ImageResizer.getReducePowerForJPX(a.width, a.height, a.numComps);
                this.jpxDecoderOptions = {
                    numComponents: 0,
                    isIndexedColormap: !1,
                    smaskInData: h.has("SMaskInData"),
                    reducePower: e2
                };
                if (e2) {
                    const t = 2 ** e2;
                    a.width = Math.ceil(a.width / t);
                    a.height = Math.ceil(a.height / t);
                }
                break;
            case "JBIG2Decode":
                a.bitsPerComponent = 1;
                a.numComps = 1;
        }
        let f = h.get("W", "Width"), g = h.get("H", "Height");
        if (Number.isInteger(a.width) && a.width > 0 && Number.isInteger(a.height) && a.height > 0 && (a.width !== f || a.height !== g)) {
            warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
            f = a.width;
            g = a.height;
        } else {
            const e1 = "number" == typeof f && f > 0, t = "number" == typeof g && g > 0;
            if (!e1 || !t) {
                if (!a.fallbackDims) throw new FormatError(`Invalid image width: ${f} or height: ${g}`);
                warn("PDFImage - using the Width/Height of the parent image, for SMask/Mask data.");
                e1 || (f = a.fallbackDims.width);
                t || (g = a.fallbackDims.height);
            }
        }
        this.width = f;
        this.height = g;
        this.interpolate = h.get("I", "Interpolate");
        this.imageMask = h.get("IM", "ImageMask") || !1;
        this.matte = h.get("Matte") || !1;
        let p = a.bitsPerComponent;
        if (!p) {
            p = h.get("BPC", "BitsPerComponent");
            if (!p) {
                if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
                p = 1;
            }
        }
        this.bpc = p;
        if (!this.imageMask) {
            let i = h.getRaw("CS") || h.getRaw("ColorSpace");
            const n = !!i;
            if (n) this.jpxDecoderOptions?.smaskInData && (i = Name.get("DeviceRGBA"));
            else if (this.jpxDecoderOptions) i = Name.get("DeviceRGBA");
            else switch(a.numComps){
                case 1:
                    i = Name.get("DeviceGray");
                    break;
                case 3:
                    i = Name.get("DeviceRGB");
                    break;
                case 4:
                    i = Name.get("DeviceCMYK");
                    break;
                default:
                    throw new Error(`Images with ${a.numComps} color components not supported.`);
            }
            this.colorSpace = ColorSpaceUtils.parse({
                cs: i,
                xref: e1,
                resources: r ? t : null,
                pdfFunctionFactory: o,
                globalColorSpaceCache: c,
                localColorSpaceCache: l
            });
            this.numComps = this.colorSpace.numComps;
            if (this.jpxDecoderOptions) {
                this.jpxDecoderOptions.numComponents = n ? this.numComps : 0;
                this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name;
            }
        }
        this.decode = h.getArray("D", "Decode");
        this.needsDecode = !1;
        if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p) || s && !ColorSpace.isDefaultDecode(this.decode, 1))) {
            this.needsDecode = !0;
            const e1 = (1 << p) - 1;
            this.decodeCoefficients = [];
            this.decodeAddends = [];
            const t = "Indexed" === this.colorSpace?.name;
            for(let a = 0, r = 0; a < this.decode.length; a += 2, ++r){
                const i = this.decode[a], n = this.decode[a + 1];
                this.decodeCoefficients[r] = t ? (n - i) / e1 : n - i;
                this.decodeAddends[r] = t ? i : e1 * i;
            }
        }
        if (i) {
            i.fallbackDims ??= {
                width: f,
                height: g
            };
            this.smask = new PDFImage({
                xref: e1,
                res: t,
                image: i,
                isInline: r,
                pdfFunctionFactory: o,
                globalColorSpaceCache: c,
                localColorSpaceCache: l
            });
        } else if (n) if (n instanceof BaseStream) {
            if (n.dict.get("IM", "ImageMask")) {
                n.fallbackDims ??= {
                    width: f,
                    height: g
                };
                this.mask = new PDFImage({
                    xref: e1,
                    res: t,
                    image: n,
                    isInline: r,
                    isMask: !0,
                    pdfFunctionFactory: o,
                    globalColorSpaceCache: c,
                    localColorSpaceCache: l
                });
            } else warn("Ignoring /Mask in image without /ImageMask.");
        } else this.mask = n;
    }
    static async buildImage({ xref: e1, res: t, image: a, isInline: r = !1, pdfFunctionFactory: i, globalColorSpaceCache: n, localColorSpaceCache: s }) {
        const o = a;
        let c = null, l = null;
        const h = a.dict.get("SMask"), u = a.dict.get("Mask");
        h ? h instanceof BaseStream ? c = h : warn("Unsupported /SMask format.") : u && (u instanceof BaseStream || Array.isArray(u) ? l = u : warn("Unsupported /Mask format."));
        return new PDFImage({
            xref: e1,
            res: t,
            image: o,
            isInline: r,
            smask: c,
            mask: l,
            pdfFunctionFactory: i,
            globalColorSpaceCache: n,
            localColorSpaceCache: s
        });
    }
    static async createMask({ image: e1, isOffscreenCanvasSupported: t = !1 }) {
        const { dict: a } = e1, r = a.get("W", "Width"), i = a.get("H", "Height"), n = a.get("I", "Interpolate"), s = a.getArray("D", "Decode"), o = s?.[0] > 0, c = (r + 7 >> 3) * i, l = e1.getBytes(c), h = 1 === r && 1 === i && o === (0 === l.length || !!(128 & l[0]));
        if (h) return {
            isSingleOpaquePixel: h
        };
        if (t) {
            if (ImageResizer.needsToBeResized(r, i)) {
                const e1 = new Uint8ClampedArray(r * i * 4);
                convertBlackAndWhiteToRGBA({
                    src: l,
                    dest: e1,
                    width: r,
                    height: i,
                    nonBlackColor: 0,
                    inverseDecode: o
                });
                return ImageResizer.createImage({
                    kind: v,
                    data: e1,
                    width: r,
                    height: i,
                    interpolate: n
                });
            }
            const e1 = new OffscreenCanvas(r, i), t = e1.getContext("2d"), a = t.createImageData(r, i);
            convertBlackAndWhiteToRGBA({
                src: l,
                dest: a.data,
                width: r,
                height: i,
                nonBlackColor: 0,
                inverseDecode: o
            });
            t.putImageData(a, 0, 0);
            return {
                data: null,
                width: r,
                height: i,
                interpolate: n,
                bitmap: e1.transferToImageBitmap()
            };
        }
        const u = l.byteLength;
        let d;
        if (e1 instanceof DecodeStream && (!o || c === u)) d = l;
        else if (o) {
            d = new Uint8Array(c);
            d.set(l);
            d.fill(255, u);
        } else d = new Uint8Array(l);
        if (o) for(let e1 = 0; e1 < u; e1++)d[e1] ^= 255;
        return {
            data: d,
            width: r,
            height: i,
            interpolate: n
        };
    }
    get drawWidth() {
        return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
    }
    get drawHeight() {
        return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
    }
    decodeBuffer(e1) {
        const t = this.bpc, a = this.numComps, r = this.decodeAddends, i = this.decodeCoefficients, n = (1 << t) - 1;
        let s, o;
        if (1 === t) {
            for(s = 0, o = e1.length; s < o; s++)e1[s] = +!e1[s];
            return;
        }
        let c = 0;
        for(s = 0, o = this.width * this.height; s < o; s++)for(let t = 0; t < a; t++){
            e1[c] = MathClamp(r[t] + e1[c] * i[t], 0, n);
            c++;
        }
    }
    getComponents(e1) {
        const t = this.bpc;
        if (8 === t) return e1;
        const a = this.width, r = this.height, i = this.numComps, n = a * r * i;
        let s, o = 0;
        s = t <= 8 ? new Uint8Array(n) : t <= 16 ? new Uint16Array(n) : new Uint32Array(n);
        const c = a * i, l = (1 << t) - 1;
        let h, u, d = 0;
        if (1 === t) {
            let t, a, i;
            for(let n = 0; n < r; n++){
                a = d + (-8 & c);
                i = d + c;
                for(; d < a;){
                    u = e1[o++];
                    s[d] = u >> 7 & 1;
                    s[d + 1] = u >> 6 & 1;
                    s[d + 2] = u >> 5 & 1;
                    s[d + 3] = u >> 4 & 1;
                    s[d + 4] = u >> 3 & 1;
                    s[d + 5] = u >> 2 & 1;
                    s[d + 6] = u >> 1 & 1;
                    s[d + 7] = 1 & u;
                    d += 8;
                }
                if (d < i) {
                    u = e1[o++];
                    t = 128;
                    for(; d < i;){
                        s[d++] = +!!(u & t);
                        t >>= 1;
                    }
                }
            }
        } else {
            let a = 0;
            u = 0;
            for(d = 0, h = n; d < h; ++d){
                if (d % c == 0) {
                    u = 0;
                    a = 0;
                }
                for(; a < t;){
                    u = u << 8 | e1[o++];
                    a += 8;
                }
                const r = a - t;
                let i = u >> r;
                i < 0 ? i = 0 : i > l && (i = l);
                s[d] = i;
                u &= (1 << r) - 1;
                a = r;
            }
        }
        return s;
    }
    async fillOpacity(e1, t, a, r, i) {
        const n = this.smask, s = this.mask;
        let o, c, l, h, u, d;
        if (n) {
            c = n.width;
            l = n.height;
            o = new Uint8ClampedArray(c * l);
            await n.fillGrayBuffer(o);
            c === t && l === a || (o = resizeImageMask(o, n.bpc, c, l, t, a));
        } else if (s) if (s instanceof PDFImage) {
            c = s.width;
            l = s.height;
            o = new Uint8ClampedArray(c * l);
            s.numComps = 1;
            await s.fillGrayBuffer(o);
            for(h = 0, u = c * l; h < u; ++h)o[h] = 255 - o[h];
            c === t && l === a || (o = resizeImageMask(o, s.bpc, c, l, t, a));
        } else {
            if (!Array.isArray(s)) throw new FormatError("Unknown mask format.");
            {
                o = new Uint8ClampedArray(t * a);
                const e1 = this.numComps;
                for(h = 0, u = t * a; h < u; ++h){
                    let t = 0;
                    const a = h * e1;
                    for(d = 0; d < e1; ++d){
                        const e1 = i[a + d], r = 2 * d;
                        if (e1 < s[r] || e1 > s[r + 1]) {
                            t = 255;
                            break;
                        }
                    }
                    o[h] = t;
                }
            }
        }
        if (o) for(h = 0, d = 3, u = t * r; h < u; ++h, d += 4)e1[d] = o[h];
        else for(h = 0, d = 3, u = t * r; h < u; ++h, d += 4)e1[d] = 255;
    }
    undoPreblend(e1, t, a) {
        const r = this.smask?.matte;
        if (!r) return;
        const i = this.colorSpace.getRgb(r, 0), n = i[0], s = i[1], o = i[2], c = t * a * 4;
        for(let t = 0; t < c; t += 4){
            const a = e1[t + 3];
            if (0 === a) {
                e1[t] = 255;
                e1[t + 1] = 255;
                e1[t + 2] = 255;
                continue;
            }
            const r = 255 / a;
            e1[t] = (e1[t] - n) * r + n;
            e1[t + 1] = (e1[t + 1] - s) * r + s;
            e1[t + 2] = (e1[t + 2] - o) * r + o;
        }
    }
    async createImageData(e1 = !1, t = !1) {
        const a = this.drawWidth, r = this.drawHeight, i = {
            width: a,
            height: r,
            interpolate: this.interpolate,
            kind: 0,
            data: null
        }, n = this.numComps, s = this.width, o = this.height, c = this.bpc, l = s * n * c + 7 >> 3, h = t && ImageResizer.needsToBeResized(a, r);
        if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
            i.kind = v;
            const e1 = i.data = await this.getImageBytes(o * s * 4, {});
            return t ? h ? ImageResizer.createImage(i, !1) : this.createBitmap(v, a, r, e1) : i;
        }
        if (!e1) {
            let e1;
            "DeviceGray" === this.colorSpace.name && 1 === c ? e1 = k : "DeviceRGB" !== this.colorSpace.name || 8 !== c || this.needsDecode || (e1 = C);
            if (e1 && !this.smask && !this.mask && a === s && r === o) {
                const n = await this.#$(s, o);
                if (n) return n;
                const c = await this.getImageBytes(o * l, {});
                if (t) return h ? ImageResizer.createImage({
                    data: c,
                    kind: e1,
                    width: a,
                    height: r,
                    interpolate: this.interpolate
                }, this.needsDecode) : this.createBitmap(e1, s, o, c);
                i.kind = e1;
                i.data = c;
                if (this.needsDecode) {
                    assert(e1 === k, "PDFImage.createImageData: The image must be grayscale.");
                    const t = i.data;
                    for(let e1 = 0, a = t.length; e1 < a; e1++)t[e1] ^= 255;
                }
                return i;
            }
            if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                let e1 = o * l;
                if (t && !h) {
                    let t = !1;
                    switch(this.colorSpace.name){
                        case "DeviceGray":
                            e1 *= 4;
                            t = !0;
                            break;
                        case "DeviceRGB":
                            e1 = e1 / 3 * 4;
                            t = !0;
                            break;
                        case "DeviceCMYK":
                            t = !0;
                    }
                    if (t) {
                        const t = await this.#$(a, r);
                        if (t) return t;
                        const i = await this.getImageBytes(e1, {
                            drawWidth: a,
                            drawHeight: r,
                            forceRGBA: !0
                        });
                        return this.createBitmap(v, a, r, i);
                    }
                } else switch(this.colorSpace.name){
                    case "DeviceGray":
                        e1 *= 3;
                    case "DeviceRGB":
                    case "DeviceCMYK":
                        i.kind = C;
                        i.data = await this.getImageBytes(e1, {
                            drawWidth: a,
                            drawHeight: r,
                            forceRGB: !0
                        });
                        return h ? ImageResizer.createImage(i) : i;
                }
            }
        }
        const u = await this.getImageBytes(o * l, {
            internal: !0
        }), d = 0 | u.length / l * r / o, f = this.getComponents(u);
        let g, p, m, b, y, w;
        if (t && !h) {
            m = new OffscreenCanvas(a, r);
            b = m.getContext("2d");
            y = b.createImageData(a, r);
            w = y.data;
        }
        i.kind = v;
        if (e1 || this.smask || this.mask) {
            t && !h || (w = new Uint8ClampedArray(a * r * 4));
            g = 1;
            p = !0;
            await this.fillOpacity(w, a, r, d, f);
        } else {
            if (!t || h) {
                i.kind = C;
                w = new Uint8ClampedArray(a * r * 3);
                g = 0;
            } else {
                new Uint32Array(w.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
                g = 1;
            }
            p = !1;
        }
        this.needsDecode && this.decodeBuffer(f);
        this.colorSpace.fillRgb(w, s, o, a, r, d, c, f, g);
        p && this.undoPreblend(w, a, d);
        if (t && !h) {
            b.putImageData(y, 0, 0);
            return {
                data: null,
                width: a,
                height: r,
                bitmap: m.transferToImageBitmap(),
                interpolate: this.interpolate
            };
        }
        i.data = w;
        return h ? ImageResizer.createImage(i) : i;
    }
    async fillGrayBuffer(e1) {
        const t = this.numComps;
        if (1 !== t) throw new FormatError(`Reading gray scale from a color image: ${t}`);
        const a = this.width, r = this.height, i = this.bpc, n = a * t * i + 7 >> 3, s = await this.getImageBytes(r * n, {
            internal: !0
        }), o = this.getComponents(s);
        let c, l;
        if (1 === i) {
            l = a * r;
            if (this.needsDecode) for(c = 0; c < l; ++c)e1[c] = o[c] - 1 & 255;
            else for(c = 0; c < l; ++c)e1[c] = 255 & -o[c];
            return;
        }
        this.needsDecode && this.decodeBuffer(o);
        l = a * r;
        const h = 255 / ((1 << i) - 1);
        for(c = 0; c < l; ++c)e1[c] = h * o[c];
    }
    createBitmap(e1, t, a, r) {
        const i = new OffscreenCanvas(t, a), n = i.getContext("2d");
        let s;
        if (e1 === v) s = new ImageData(r, t, a);
        else {
            s = n.createImageData(t, a);
            convertToRGBA({
                kind: e1,
                src: r,
                dest: new Uint32Array(s.data.buffer),
                width: t,
                height: a,
                inverseDecode: this.needsDecode
            });
        }
        n.putImageData(s, 0, 0);
        return {
            data: null,
            width: t,
            height: a,
            bitmap: i.transferToImageBitmap(),
            interpolate: this.interpolate
        };
    }
    async #$(e1, t) {
        const a = await this.image.getTransferableImage();
        return a ? {
            data: null,
            width: e1,
            height: t,
            bitmap: a,
            interpolate: this.interpolate
        } : null;
    }
    async getImageBytes(e1, { drawWidth: t, drawHeight: a, forceRGBA: r = !1, forceRGB: i = !1, internal: n = !1 }) {
        this.image.reset();
        this.image.drawWidth = t || this.width;
        this.image.drawHeight = a || this.height;
        this.image.forceRGBA = !!r;
        this.image.forceRGB = !!i;
        const s = await this.image.getImageData(e1, this.jpxDecoderOptions);
        if (n || this.image instanceof DecodeStream) return s;
        assert(s instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
        return new Uint8Array(s);
    }
}
const pn = Object.freeze({
    maxImageSize: -1,
    disableFontFace: !1,
    ignoreErrors: !1,
    isEvalSupported: !0,
    isOffscreenCanvasSupported: !1,
    isImageDecoderSupported: !1,
    canvasMaxAreaInBytes: -1,
    fontExtraProperties: !1,
    useSystemFonts: !0,
    useWasm: !0,
    useWorkerFetch: !0,
    cMapUrl: null,
    iccUrl: null,
    standardFontDataUrl: null,
    wasmUrl: null
}), mn = 1, bn = 2, yn = Promise.resolve();
function normalizeBlendMode(e1, t = !1) {
    if (Array.isArray(e1)) {
        for (const t of e1){
            const e1 = normalizeBlendMode(t, !0);
            if (e1) return e1;
        }
        warn(`Unsupported blend mode Array: ${e1}`);
        return "source-over";
    }
    if (!(e1 instanceof Name)) return t ? null : "source-over";
    switch(e1.name){
        case "Normal":
        case "Compatible":
            return "source-over";
        case "Multiply":
            return "multiply";
        case "Screen":
            return "screen";
        case "Overlay":
            return "overlay";
        case "Darken":
            return "darken";
        case "Lighten":
            return "lighten";
        case "ColorDodge":
            return "color-dodge";
        case "ColorBurn":
            return "color-burn";
        case "HardLight":
            return "hard-light";
        case "SoftLight":
            return "soft-light";
        case "Difference":
            return "difference";
        case "Exclusion":
            return "exclusion";
        case "Hue":
            return "hue";
        case "Saturation":
            return "saturation";
        case "Color":
            return "color";
        case "Luminosity":
            return "luminosity";
    }
    if (t) return null;
    warn(`Unsupported blend mode: ${e1.name}`);
    return "source-over";
}
function addCachedImageOps(e1, { objId: t, fn: a, args: r, optionalContent: i, hasMask: n }) {
    t && e1.addDependency(t);
    e1.addImageOps(a, r, i, n);
    a === Dt && r[0]?.count > 0 && r[0].count++;
}
class TimeSlotManager {
    static TIME_SLOT_DURATION_MS = 20;
    static CHECK_TIME_EVERY = 100;
    constructor(){
        this.reset();
    }
    check() {
        if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) return !1;
        this.checked = 0;
        return this.endTime <= Date.now();
    }
    reset() {
        this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
        this.checked = 0;
    }
}
class PartialEvaluator {
    constructor({ xref: e1, handler: t, pageIndex: a, idFactory: r, fontCache: i, builtInCMapCache: n, standardFontDataCache: s, globalColorSpaceCache: o, globalImageCache: c, systemFontCache: l, options: h = null }){
        this.xref = e1;
        this.handler = t;
        this.pageIndex = a;
        this.idFactory = r;
        this.fontCache = i;
        this.builtInCMapCache = n;
        this.standardFontDataCache = s;
        this.globalColorSpaceCache = o;
        this.globalImageCache = c;
        this.systemFontCache = l;
        this.options = h || pn;
        this.type3FontRefs = null;
        this._regionalImageCache = new RegionalImageCache;
        this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
    }
    get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.options.isEvalSupported
        }));
    }
    get parsingType3Font() {
        return !!this.type3FontRefs;
    }
    clone(e1 = null) {
        const t = Object.create(this);
        t.options = Object.assign(Object.create(null), this.options, e1);
        return t;
    }
    hasBlendModes(e1, t) {
        if (!(e1 instanceof Dict)) return !1;
        if (e1.objId && t.has(e1.objId)) return !1;
        const a = new RefSet(t);
        e1.objId && a.put(e1.objId);
        const r = [
            e1
        ], i = this.xref;
        for(; r.length;){
            const e1 = r.shift(), t = e1.get("ExtGState");
            if (t instanceof Dict) for (let e1 of t.getRawValues()){
                if (e1 instanceof Ref) {
                    if (a.has(e1)) continue;
                    try {
                        e1 = i.fetch(e1);
                    } catch (t) {
                        a.put(e1);
                        info(`hasBlendModes - ignoring ExtGState: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof Dict)) continue;
                e1.objId && a.put(e1.objId);
                const t = e1.get("BM");
                if (t instanceof Name) {
                    if ("Normal" !== t.name) return !0;
                } else if (void 0 !== t && Array.isArray(t)) {
                    for (const e1 of t)if (e1 instanceof Name && "Normal" !== e1.name) return !0;
                }
            }
            const n = e1.get("XObject");
            if (n instanceof Dict) for (let e1 of n.getRawValues()){
                if (e1 instanceof Ref) {
                    if (a.has(e1)) continue;
                    try {
                        e1 = i.fetch(e1);
                    } catch (t) {
                        a.put(e1);
                        info(`hasBlendModes - ignoring XObject: "${t}".`);
                        continue;
                    }
                }
                if (!(e1 instanceof BaseStream)) continue;
                e1.dict.objId && a.put(e1.dict.objId);
                const t = e1.dict.get("Resources");
                if (t instanceof Dict && (!t.objId || !a.has(t.objId))) {
                    r.push(t);
                    t.objId && a.put(t.objId);
                }
            }
        }
        for (const e1 of a)t.put(e1);
        return !1;
    }
    async fetchBuiltInCMap(e1) {
        const t = this.builtInCMapCache.get(e1);
        if (t) return t;
        let a;
        a = this.options.useWorkerFetch ? {
            cMapData: await fetchBinaryData(`${this.options.cMapUrl}${e1}.bcmap`),
            isCompressed: !0
        } : await this.handler.sendWithPromise("FetchBinaryData", {
            type: "cMapReaderFactory",
            name: e1
        });
        this.builtInCMapCache.set(e1, a);
        return a;
    }
    async fetchStandardFontData(e1) {
        const t = this.standardFontDataCache.get(e1);
        if (t) return new Stream(t);
        if (this.options.useSystemFonts && "Symbol" !== e1 && "ZapfDingbats" !== e1) return null;
        const a = Nr()[e1];
        let r;
        try {
            r = this.options.useWorkerFetch ? await fetchBinaryData(`${this.options.standardFontDataUrl}${a}`) : await this.handler.sendWithPromise("FetchBinaryData", {
                type: "standardFontDataFactory",
                filename: a
            });
        } catch (e1) {
            warn(e1);
            return null;
        }
        this.standardFontDataCache.set(e1, r);
        return new Stream(r);
    }
    async buildFormXObject(e1, t, a, r, i, n, s, o) {
        const { dict: c } = t, l = lookupMatrix(c.getArray("Matrix"), null), h = lookupNormalRect(c.getArray("BBox"), null);
        let u, d;
        c.has("OC") && (u = await this.parseMarkedContentProps(c.get("OC"), e1));
        void 0 !== u && r.addOp(St, [
            "OC",
            u
        ]);
        const f = c.get("Group");
        if (f) {
            d = {
                matrix: l,
                bbox: h,
                smask: a,
                isolated: !1,
                knockout: !1
            };
            let t = null;
            if (isName(f.get("S"), "Transparency")) {
                d.isolated = f.get("I") || !1;
                d.knockout = f.get("K") || !1;
                if (f.has("CS")) {
                    const a = this._getColorSpace(f.getRaw("CS"), e1, s);
                    t = a instanceof ColorSpace ? a : await this._handleColorSpace(a);
                }
            }
            if (a?.backdrop) {
                t ||= ColorSpaceUtils.rgb;
                a.backdrop = t.getRgbHex(a.backdrop, 0);
            }
            r.addOp(It, [
                d
            ]);
        }
        const g = [
            l && new Float32Array(l),
            !f && h && new Float32Array(h) || null
        ];
        r.addOp(vt, g);
        const p = c.get("Resources");
        await this.getOperatorList({
            stream: t,
            task: i,
            resources: p instanceof Dict ? p : e1,
            operatorList: r,
            initialState: n,
            prevRefs: o
        });
        r.addOp(Ft, []);
        f && r.addOp(Tt, [
            d
        ]);
        void 0 !== u && r.addOp(At, []);
    }
    _sendImgData(e1, t, a = !1) {
        const r = t ? [
            t.bitmap || t.data.buffer
        ] : null;
        return this.parsingType3Font || a ? this.handler.send("commonobj", [
            e1,
            "Image",
            t
        ], r) : this.handler.send("obj", [
            e1,
            this.pageIndex,
            "Image",
            t
        ], r);
    }
    async buildPaintImageXObject({ resources: e1, image: t, isInline: a = !1, operatorList: r, cacheKey: i, localImageCache: n, localColorSpaceCache: s }) {
        const { maxImageSize: o, ignoreErrors: c, isOffscreenCanvasSupported: l } = this.options, { dict: h } = t, u = h.objId, d = h.get("W", "Width"), f = h.get("H", "Height");
        if (!d || "number" != typeof d || !f || "number" != typeof f) {
            warn("Image dimensions are missing, or not numbers.");
            return;
        }
        if (-1 !== o && d * f > o) {
            const e1 = "Image exceeded maximum allowed size and was removed.";
            if (!c) throw new Error(e1);
            warn(e1);
            return;
        }
        let g;
        h.has("OC") && (g = await this.parseMarkedContentProps(h.get("OC"), e1));
        let p, m, b;
        if (h.get("IM", "ImageMask") || !1) {
            p = await PDFImage.createMask({
                image: t,
                isOffscreenCanvasSupported: l && !this.parsingType3Font
            });
            if (p.isSingleOpaquePixel) {
                m = jt;
                b = [];
                r.addImageOps(m, b, g);
                if (i) {
                    const e1 = {
                        fn: m,
                        args: b,
                        optionalContent: g
                    };
                    n.set(i, u, e1);
                    u && this._regionalImageCache.set(null, u, e1);
                }
                return;
            }
            if (this.parsingType3Font) {
                b = function compileType3Glyph({ data: e1, width: t, height: a }) {
                    if (t > 1e3 || a > 1e3) return null;
                    const r = new Uint8Array([
                        0,
                        2,
                        4,
                        0,
                        1,
                        0,
                        5,
                        4,
                        8,
                        10,
                        0,
                        8,
                        0,
                        2,
                        1,
                        0
                    ]), i = t + 1, n = new Uint8Array(i * (a + 1));
                    let s, o, c;
                    const l = t + 7 & -8, h = new Uint8Array(l * a);
                    let u = 0;
                    for (const t of e1){
                        let e1 = 128;
                        for(; e1 > 0;){
                            h[u++] = t & e1 ? 0 : 255;
                            e1 >>= 1;
                        }
                    }
                    let d = 0;
                    u = 0;
                    if (0 !== h[u]) {
                        n[0] = 1;
                        ++d;
                    }
                    for(o = 1; o < t; o++){
                        if (h[u] !== h[u + 1]) {
                            n[o] = h[u] ? 2 : 1;
                            ++d;
                        }
                        u++;
                    }
                    if (0 !== h[u]) {
                        n[o] = 2;
                        ++d;
                    }
                    for(s = 1; s < a; s++){
                        u = s * l;
                        c = s * i;
                        if (h[u - l] !== h[u]) {
                            n[c] = h[u] ? 1 : 8;
                            ++d;
                        }
                        let e1 = (h[u] ? 4 : 0) + (h[u - l] ? 8 : 0);
                        for(o = 1; o < t; o++){
                            e1 = (e1 >> 2) + (h[u + 1] ? 4 : 0) + (h[u - l + 1] ? 8 : 0);
                            if (r[e1]) {
                                n[c + o] = r[e1];
                                ++d;
                            }
                            u++;
                        }
                        if (h[u - l] !== h[u]) {
                            n[c + o] = h[u] ? 2 : 4;
                            ++d;
                        }
                        if (d > 1e3) return null;
                    }
                    u = l * (a - 1);
                    c = s * i;
                    if (0 !== h[u]) {
                        n[c] = 8;
                        ++d;
                    }
                    for(o = 1; o < t; o++){
                        if (h[u] !== h[u + 1]) {
                            n[c + o] = h[u] ? 4 : 8;
                            ++d;
                        }
                        u++;
                    }
                    if (0 !== h[u]) {
                        n[c + o] = 4;
                        ++d;
                    }
                    if (d > 1e3) return null;
                    const f = new Int32Array([
                        0,
                        i,
                        -1,
                        0,
                        -i,
                        0,
                        0,
                        0,
                        1
                    ]), g = [], { a: p, b: m, c: b, d: y, e: w, f: x } = (new DOMMatrix).scaleSelf(1 / t, -1 / a).translateSelf(0, -a);
                    for(s = 0; d && s <= a; s++){
                        let e1 = s * i;
                        const a = e1 + t;
                        for(; e1 < a && !n[e1];)e1++;
                        if (e1 === a) continue;
                        let r = e1 % i, o = s;
                        g.push(Ht, p * r + b * o + w, m * r + y * o + x);
                        const c = e1;
                        let l = n[e1];
                        do {
                            const t = f[l];
                            do {
                                e1 += t;
                            }while (!n[e1])
                            const a = n[e1];
                            if (5 !== a && 10 !== a) {
                                l = a;
                                n[e1] = 0;
                            } else {
                                l = a & 51 * l >> 4;
                                n[e1] &= l >> 2 | l << 2;
                            }
                            r = e1 % i;
                            o = e1 / i | 0;
                            g.push(Wt, p * r + b * o + w, m * r + y * o + x);
                            n[e1] || --d;
                        }while (c !== e1)
                        --s;
                    }
                    return [
                        qt,
                        [
                            new Float32Array(g)
                        ],
                        new Float32Array([
                            0,
                            0,
                            t,
                            a
                        ])
                    ];
                }(p);
                if (b) {
                    r.addImageOps(_t, b, g);
                    return;
                }
                warn("Cannot compile Type3 glyph.");
                r.addImageOps(Dt, [
                    p
                ], g);
                return;
            }
            const e1 = `mask_${this.idFactory.createObjId()}`;
            r.addDependency(e1);
            p.dataLen = p.bitmap ? p.width * p.height * 4 : p.data.length;
            this._sendImgData(e1, p);
            m = Dt;
            b = [
                {
                    data: e1,
                    width: p.width,
                    height: p.height,
                    interpolate: p.interpolate,
                    count: 1
                }
            ];
            r.addImageOps(m, b, g);
            if (i) {
                const t = {
                    objId: e1,
                    fn: m,
                    args: b,
                    optionalContent: g
                };
                n.set(i, u, t);
                u && this._regionalImageCache.set(null, u, t);
            }
            return;
        }
        const y = h.has("SMask") || h.has("Mask");
        if (a && d + f < 200 && !y) {
            try {
                const i = new PDFImage({
                    xref: this.xref,
                    res: e1,
                    image: t,
                    isInline: a,
                    pdfFunctionFactory: this._pdfFunctionFactory,
                    globalColorSpaceCache: this.globalColorSpaceCache,
                    localColorSpaceCache: s
                });
                p = await i.createImageData(!0, !1);
                r.addImageOps(Nt, [
                    p
                ], g);
            } catch (e1) {
                const t = `Unable to decode inline image: "${e1}".`;
                if (!c) throw new Error(t);
                warn(t);
            }
            return;
        }
        let w = `img_${this.idFactory.createObjId()}`, x = !1, S = null;
        if (this.parsingType3Font) w = `${this.idFactory.getDocId()}_type3_${w}`;
        else if (i && u) {
            x = this.globalImageCache.shouldCache(u, this.pageIndex);
            if (x) {
                assert(!a, "Cannot cache an inline image globally.");
                w = `${this.idFactory.getDocId()}_${w}`;
            }
        }
        r.addDependency(w);
        m = Rt;
        b = [
            w,
            d,
            f
        ];
        r.addImageOps(m, b, g, y);
        if (x) {
            S = {
                objId: w,
                fn: m,
                args: b,
                optionalContent: g,
                hasMask: y,
                byteSize: 0
            };
            if (this.globalImageCache.hasDecodeFailed(u)) {
                this.globalImageCache.setData(u, S);
                this._sendImgData(w, null, x);
                return;
            }
            if (d * f > 25e4 || y) {
                const e1 = await this.handler.sendWithPromise("commonobj", [
                    w,
                    "CopyLocalImage",
                    {
                        imageRef: u
                    }
                ]);
                if (e1) {
                    this.globalImageCache.setData(u, S);
                    this.globalImageCache.addByteSize(u, e1);
                    return;
                }
            }
        }
        PDFImage.buildImage({
            xref: this.xref,
            res: e1,
            image: t,
            isInline: a,
            pdfFunctionFactory: this._pdfFunctionFactory,
            globalColorSpaceCache: this.globalColorSpaceCache,
            localColorSpaceCache: s
        }).then(async (e1)=>{
            p = await e1.createImageData(!1, l);
            p.dataLen = p.bitmap ? p.width * p.height * 4 : p.data.length;
            p.ref = u;
            x && this.globalImageCache.addByteSize(u, p.dataLen);
            return this._sendImgData(w, p, x);
        }).catch((e1)=>{
            warn(`Unable to decode image "${w}": "${e1}".`);
            u && this.globalImageCache.addDecodeFailed(u);
            return this._sendImgData(w, null, x);
        });
        if (i) {
            const e1 = {
                objId: w,
                fn: m,
                args: b,
                optionalContent: g,
                hasMask: y
            };
            n.set(i, u, e1);
            if (u) {
                this._regionalImageCache.set(null, u, e1);
                if (x) {
                    assert(S, "The global cache-data must be available.");
                    this.globalImageCache.setData(u, S);
                }
            }
        }
    }
    handleSMask(e1, t, a, r, i, n, s) {
        const o = e1.get("G"), c = {
            subtype: e1.get("S").name,
            backdrop: e1.get("BC")
        }, l = e1.get("TR");
        if (isPDFFunction(l)) {
            const e1 = this._pdfFunctionFactory.create(l), t = new Uint8Array(256), a = new Float32Array(1);
            for(let r = 0; r < 256; r++){
                a[0] = r / 255;
                e1(a, 0, a, 0);
                t[r] = 255 * a[0] | 0;
            }
            c.transferMap = t;
        }
        return this.buildFormXObject(t, o, c, a, r, i.state.clone({
            newPath: !0
        }), n, s);
    }
    handleTransferFunction(e1) {
        let t;
        if (Array.isArray(e1)) t = e1;
        else {
            if (!isPDFFunction(e1)) return null;
            t = [
                e1
            ];
        }
        const a = [];
        let r = 0, i = 0;
        for (const e1 of t){
            const t = this.xref.fetchIfRef(e1);
            r++;
            if (isName(t, "Identity")) {
                a.push(null);
                continue;
            }
            if (!isPDFFunction(t)) return null;
            const n = this._pdfFunctionFactory.create(t), s = new Uint8Array(256), o = new Float32Array(1);
            for(let e1 = 0; e1 < 256; e1++){
                o[0] = e1 / 255;
                n(o, 0, o, 0);
                s[e1] = 255 * o[0] | 0;
            }
            a.push(s);
            i++;
        }
        return 1 !== r && 4 !== r || 0 === i ? null : a;
    }
    handleTilingType(e1, t, a, r, i, n, s, o) {
        const c = new OperatorList, l = Dict.merge({
            xref: this.xref,
            dictArray: [
                i.get("Resources"),
                a
            ]
        });
        return this.getOperatorList({
            stream: r,
            task: s,
            resources: l,
            operatorList: c
        }).then(function() {
            const a = c.getIR(), r = getTilingPatternIR(a, i, t);
            n.addDependencies(c.dependencies);
            n.addOp(e1, r);
            i.objId && o.set(null, i.objId, {
                operatorListIR: a,
                dict: i
            });
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`handleTilingType - ignoring pattern: "${e1}".`);
            }
        });
    }
    async handleSetFont(e1, t, a, r, i, n, s = null, o = null) {
        const c = t?.[0] instanceof Name ? t[0].name : null, l = await this.loadFont(c, a, e1, i, s, o);
        l.font.isType3Font && r.addDependencies(l.type3Dependencies);
        n.font = l.font;
        l.send(this.handler);
        return l.loadedName;
    }
    handleText(e1, t) {
        const a = t.font, r = a.charsToGlyphs(e1);
        if (a.data) {
            (!!(t.textRenderingMode & S) || "Pattern" === t.fillColorSpace.name || a.disableFontFace) && PartialEvaluator.buildFontPaths(a, r, this.handler, this.options);
        }
        return r;
    }
    ensureStateFont(e1) {
        if (e1.font) return;
        const t = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
        if (!this.options.ignoreErrors) throw t;
        warn(`ensureStateFont: "${t}".`);
    }
    async setGState({ resources: e1, gState: t, operatorList: a, cacheKey: r, task: i, stateManager: n, localGStateCache: s, localColorSpaceCache: o, seenRefs: c }) {
        const l = t.objId;
        let h = !0;
        const u = [];
        let d = Promise.resolve();
        for (const [r, s] of t)switch(r){
            case "Type":
                break;
            case "LW":
                if ("number" != typeof s) {
                    warn(`Invalid LW (line width): ${s}`);
                    break;
                }
                u.push([
                    r,
                    Math.abs(s)
                ]);
                break;
            case "LC":
            case "LJ":
            case "ML":
            case "D":
            case "RI":
            case "FL":
            case "CA":
            case "ca":
                u.push([
                    r,
                    s
                ]);
                break;
            case "Font":
                h = !1;
                d = d.then(()=>this.handleSetFont(e1, null, s[0], a, i, n.state).then(function(e1) {
                        a.addDependency(e1);
                        u.push([
                            r,
                            [
                                e1,
                                s[1]
                            ]
                        ]);
                    }));
                break;
            case "BM":
                u.push([
                    r,
                    normalizeBlendMode(s)
                ]);
                break;
            case "SMask":
                if (isName(s, "None")) {
                    u.push([
                        r,
                        !1
                    ]);
                    break;
                }
                if (s instanceof Dict) {
                    h = !1;
                    d = d.then(()=>this.handleSMask(s, e1, a, i, n, o, c));
                    u.push([
                        r,
                        !0
                    ]);
                } else warn("Unsupported SMask type");
                break;
            case "TR":
                const t = this.handleTransferFunction(s);
                u.push([
                    r,
                    t
                ]);
                break;
            case "OP":
            case "op":
            case "OPM":
            case "BG":
            case "BG2":
            case "UCR":
            case "UCR2":
            case "TR2":
            case "HT":
            case "SM":
            case "SA":
            case "AIS":
            case "TK":
                info("graphic state operator " + r);
                break;
            default:
                info("Unknown graphic state operator " + r);
        }
        await d;
        u.length > 0 && a.addOp(ge, [
            u
        ]);
        h && s.set(r, l, u);
    }
    loadFont(e1, t, a, r, i = null, n = null) {
        const errorFont = async ()=>new TranslatedFont({
                loadedName: "g_font_error",
                font: new ErrorFont(`Font "${e1}" is not available.`),
                dict: t
            });
        let s;
        if (t) t instanceof Ref && (s = t);
        else {
            const t = a.get("Font");
            t && (s = t.getRaw(e1));
        }
        if (s) {
            if (this.type3FontRefs?.has(s)) return errorFont();
            if (this.fontCache.has(s)) return this.fontCache.get(s);
            try {
                t = this.xref.fetchIfRef(s);
            } catch (e1) {
                warn(`loadFont - lookup failed: "${e1}".`);
            }
        }
        if (!(t instanceof Dict)) {
            if (!this.options.ignoreErrors && !this.parsingType3Font) {
                warn(`Font "${e1}" is not available.`);
                return errorFont();
            }
            warn(`Font "${e1}" is not available -- attempting to fallback to a default font.`);
            t = i || PartialEvaluator.fallbackFontDict;
        }
        if (t.cacheKey && this.fontCache.has(t.cacheKey)) return this.fontCache.get(t.cacheKey);
        const { promise: o, resolve: c } = Promise.withResolvers();
        let l;
        try {
            l = this.preEvaluateFont(t);
            l.cssFontInfo = n;
        } catch (e1) {
            warn(`loadFont - preEvaluateFont failed: "${e1}".`);
            return errorFont();
        }
        const { descriptor: h, hash: u } = l, d = s instanceof Ref;
        let f;
        if (u && h instanceof Dict) {
            const e1 = h.fontAliases ||= Object.create(null);
            if (e1[u]) {
                const t = e1[u].aliasRef;
                if (d && t && this.fontCache.has(t)) {
                    this.fontCache.putAlias(s, t);
                    return this.fontCache.get(s);
                }
            } else e1[u] = {
                fontID: this.idFactory.createFontId()
            };
            d && (e1[u].aliasRef = s);
            f = e1[u].fontID;
        } else f = this.idFactory.createFontId();
        assert(f?.startsWith("f"), 'The "fontID" must be (correctly) defined.');
        if (d) this.fontCache.put(s, o);
        else {
            t.cacheKey = `cacheKey_${f}`;
            this.fontCache.put(t.cacheKey, o);
        }
        t.loadedName = `${this.idFactory.getDocId()}_${f}`;
        this.translateFont(l).then(async (e1)=>{
            const i = new TranslatedFont({
                loadedName: t.loadedName,
                font: e1,
                dict: t
            });
            if (e1.isType3Font) try {
                await i.loadType3Data(this, a, r);
            } catch (e1) {
                throw new Error(`Type3 font load error: ${e1}`);
            }
            c(i);
        }).catch((e1)=>{
            warn(`loadFont - translateFont failed: "${e1}".`);
            c(new TranslatedFont({
                loadedName: t.loadedName,
                font: new ErrorFont(e1?.message),
                dict: t
            }));
        });
        return o;
    }
    buildPath(e1, t, a) {
        const { pathMinMax: r, pathBuffer: i } = a;
        switch(0 | e1){
            case Ce:
                {
                    const e1 = a.currentPointX = t[0], n = a.currentPointY = t[1], s = t[2], o = t[3], c = e1 + s, l = n + o;
                    0 === s || 0 === o ? i.push(Ht, e1, n, Wt, c, l, $t) : i.push(Ht, e1, n, Wt, c, n, Wt, c, l, Wt, e1, l, $t);
                    Util.rectBoundingBox(e1, n, c, l, r);
                    break;
                }
            case ye:
                {
                    const e1 = a.currentPointX = t[0], n = a.currentPointY = t[1];
                    i.push(Ht, e1, n);
                    Util.pointBoundingBox(e1, n, r);
                    break;
                }
            case we:
                {
                    const e1 = a.currentPointX = t[0], n = a.currentPointY = t[1];
                    i.push(Wt, e1, n);
                    Util.pointBoundingBox(e1, n, r);
                    break;
                }
            case xe:
                {
                    const e1 = a.currentPointX, n = a.currentPointY, [s, o, c, l, h, u] = t;
                    a.currentPointX = h;
                    a.currentPointY = u;
                    i.push(zt, s, o, c, l, h, u);
                    Util.bezierBoundingBox(e1, n, s, o, c, l, h, u, r);
                    break;
                }
            case Se:
                {
                    const e1 = a.currentPointX, n = a.currentPointY, [s, o, c, l] = t;
                    a.currentPointX = c;
                    a.currentPointY = l;
                    i.push(zt, e1, n, s, o, c, l);
                    Util.bezierBoundingBox(e1, n, e1, n, s, o, c, l, r);
                    break;
                }
            case Ae:
                {
                    const e1 = a.currentPointX, n = a.currentPointY, [s, o, c, l] = t;
                    a.currentPointX = c;
                    a.currentPointY = l;
                    i.push(zt, s, o, c, l, c, l);
                    Util.bezierBoundingBox(e1, n, s, o, c, l, c, l, r);
                    break;
                }
            case ke:
                i.push($t);
        }
    }
    _getColorSpace(e1, t, a) {
        return ColorSpaceUtils.parse({
            cs: e1,
            xref: this.xref,
            resources: t,
            pdfFunctionFactory: this._pdfFunctionFactory,
            globalColorSpaceCache: this.globalColorSpaceCache,
            localColorSpaceCache: a,
            asyncIfNotCached: !0
        });
    }
    async _handleColorSpace(e1) {
        try {
            return await e1;
        } catch (e1) {
            if (e1 instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`_handleColorSpace - ignoring ColorSpace: "${e1}".`);
                return null;
            }
            throw e1;
        }
    }
    parseShading({ shading: e1, resources: t, localColorSpaceCache: a, localShadingPatternCache: r }) {
        let i, n = r.get(e1);
        if (n) return n;
        try {
            i = Pattern.parseShading(e1, this.xref, t, this._pdfFunctionFactory, this.globalColorSpaceCache, a).getIR();
        } catch (t) {
            if (t instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`parseShading - ignoring shading: "${t}".`);
                r.set(e1, null);
                return null;
            }
            throw t;
        }
        n = `pattern_${this.idFactory.createObjId()}`;
        this.parsingType3Font && (n = `${this.idFactory.getDocId()}_type3_${n}`);
        r.set(e1, n);
        this.parsingType3Font ? this.handler.send("commonobj", [
            n,
            "Pattern",
            i
        ]) : this.handler.send("obj", [
            n,
            this.pageIndex,
            "Pattern",
            i
        ]);
        return n;
    }
    handleColorN(e1, t, a, r, i, n, s, o, c, l) {
        const h = a.pop();
        if (h instanceof Name) {
            const u = i.getRaw(h.name), d = u instanceof Ref && c.getByRef(u);
            if (d) try {
                const i = r.base ? r.base.getRgbHex(a, 0) : null, n = getTilingPatternIR(d.operatorListIR, d.dict, i);
                e1.addOp(t, n);
                return;
            } catch  {}
            const f = this.xref.fetchIfRef(u);
            if (f) {
                const i = f instanceof BaseStream ? f.dict : f, h = i.get("PatternType");
                if (h === mn) {
                    const o = r.base ? r.base.getRgbHex(a, 0) : null;
                    return this.handleTilingType(t, o, n, f, i, e1, s, c);
                }
                if (h === bn) {
                    const a = i.get("Shading"), r = this.parseShading({
                        shading: a,
                        resources: n,
                        localColorSpaceCache: o,
                        localShadingPatternCache: l
                    });
                    if (r) {
                        const a = lookupMatrix(i.getArray("Matrix"), null);
                        e1.addOp(t, [
                            "Shading",
                            r,
                            a
                        ]);
                    }
                    return;
                }
                throw new FormatError(`Unknown PatternType: ${h}`);
            }
        }
        throw new FormatError(`Unknown PatternName: ${h}`);
    }
    _parseVisibilityExpression(e1, t, a) {
        if (++t > 10) {
            warn("Visibility expression is too deeply nested");
            return;
        }
        const r = e1.length, i = this.xref.fetchIfRef(e1[0]);
        if (!(r < 2) && i instanceof Name) {
            switch(i.name){
                case "And":
                case "Or":
                case "Not":
                    a.push(i.name);
                    break;
                default:
                    warn(`Invalid operator ${i.name} in visibility expression`);
                    return;
            }
            for(let i = 1; i < r; i++){
                const r = e1[i], n = this.xref.fetchIfRef(r);
                if (Array.isArray(n)) {
                    const e1 = [];
                    a.push(e1);
                    this._parseVisibilityExpression(n, t, e1);
                } else r instanceof Ref && a.push(r.toString());
            }
        } else warn("Invalid visibility expression");
    }
    async parseMarkedContentProps(e1, t) {
        let a;
        if (e1 instanceof Name) {
            a = t.get("Properties").get(e1.name);
        } else {
            if (!(e1 instanceof Dict)) throw new FormatError("Optional content properties malformed.");
            a = e1;
        }
        const r = a.get("Type")?.name;
        if ("OCG" === r) return {
            type: r,
            id: a.objId
        };
        if ("OCMD" === r) {
            const e1 = a.get("VE");
            if (Array.isArray(e1)) {
                const t = [];
                this._parseVisibilityExpression(e1, 0, t);
                if (t.length > 0) return {
                    type: "OCMD",
                    expression: t
                };
            }
            const t = a.get("OCGs");
            if (Array.isArray(t) || t instanceof Dict) {
                const e1 = [];
                if (Array.isArray(t)) for (const a of t)e1.push(a.toString());
                else e1.push(t.objId);
                return {
                    type: r,
                    ids: e1,
                    policy: a.get("P") instanceof Name ? a.get("P").name : null,
                    expression: null
                };
            }
            if (t instanceof Ref) return {
                type: r,
                id: t.toString()
            };
        }
        return null;
    }
    getOperatorList({ stream: e1, task: t, resources: a, operatorList: r, initialState: i = null, fallbackFontDict: n = null, prevRefs: s = null }) {
        const o = e1.dict?.objId, c = new RefSet(s);
        if (o) {
            if (s?.has(o)) throw new Error(`getOperatorList - ignoring circular reference: ${o}`);
            c.put(o);
        }
        a ||= Dict.empty;
        i ||= new EvalState;
        if (!r) throw new Error('getOperatorList: missing "operatorList" parameter');
        const l = this, h = this.xref, u = new LocalImageCache, d = new LocalColorSpaceCache, f = new LocalGStateCache, g = new LocalTilingPatternCache, p = new Map, m = a.get("XObject") || Dict.empty, b = a.get("Pattern") || Dict.empty, y = new StateManager(i), w = new EvaluatorPreprocessor(e1, h, y), x = new TimeSlotManager;
        function closePendingRestoreOPS(e1) {
            for(let e1 = 0, t = w.savedStatesDepth; e1 < t; e1++)r.addOp(me, []);
        }
        return new Promise(function promiseBody(e1, i) {
            const next = function(t) {
                Promise.all([
                    t,
                    r.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, i);
                    } catch (e1) {
                        i(e1);
                    }
                }, i);
            };
            t.ensureNotTerminated();
            x.reset();
            const s = {};
            let o, S, k, C, v, F;
            for(; !(o = x.check());){
                s.args = null;
                if (!w.read(s)) break;
                let e1 = s.args, i = s.fn;
                switch(0 | i){
                    case bt:
                        F = e1[0] instanceof Name;
                        v = e1[0].name;
                        if (F) {
                            const t = u.getByName(v);
                            if (t) {
                                addCachedImageOps(r, t);
                                e1 = null;
                                continue;
                            }
                        }
                        next(new Promise(function(e1, i) {
                            if (!F) throw new FormatError("XObject must be referred to by name.");
                            let n = m.getRaw(v);
                            if (n instanceof Ref) {
                                const t = u.getByRef(n) || l._regionalImageCache.getByRef(n) || l.globalImageCache.getData(n, l.pageIndex);
                                if (t) {
                                    addCachedImageOps(r, t);
                                    e1();
                                    return;
                                }
                                n = h.fetch(n);
                            }
                            if (!(n instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                            const s = n.dict.get("Subtype");
                            if (!(s instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                            if ("Form" !== s.name) if ("Image" !== s.name) {
                                if ("PS" !== s.name) throw new FormatError(`Unhandled XObject subtype ${s.name}`);
                                info("Ignored XObject subtype PS");
                                e1();
                            } else l.buildPaintImageXObject({
                                resources: a,
                                image: n,
                                operatorList: r,
                                cacheKey: v,
                                localImageCache: u,
                                localColorSpaceCache: d
                            }).then(e1, i);
                            else {
                                y.save();
                                l.buildFormXObject(a, n, null, r, t, y.state.clone({
                                    newPath: !0
                                }), d, c).then(function() {
                                    y.restore();
                                    e1();
                                }, i);
                            }
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!l.options.ignoreErrors) throw e1;
                                warn(`getOperatorList - ignoring XObject: "${e1}".`);
                            }
                        }));
                        return;
                    case qe:
                        const s1 = e1[1];
                        next(l.handleSetFont(a, e1, null, r, t, y.state, n).then(function(e1) {
                            r.addDependency(e1);
                            r.addOp(qe, [
                                e1,
                                s1
                            ]);
                        }));
                        return;
                    case mt:
                        const o = e1[0].cacheKey;
                        if (o) {
                            const t = u.getByName(o);
                            if (t) {
                                addCachedImageOps(r, t);
                                e1 = null;
                                continue;
                            }
                        }
                        next(l.buildPaintImageXObject({
                            resources: a,
                            image: e1[0],
                            isInline: !0,
                            operatorList: r,
                            cacheKey: o,
                            localImageCache: u,
                            localColorSpaceCache: d
                        }));
                        return;
                    case Ke:
                        if (!y.state.font) {
                            l.ensureStateFont(y.state);
                            continue;
                        }
                        e1[0] = l.handleText(e1[0], y.state);
                        break;
                    case Je:
                        if (!y.state.font) {
                            l.ensureStateFont(y.state);
                            continue;
                        }
                        const w1 = [], x = y.state;
                        for (const t of e1[0])"string" == typeof t ? w1.push(...l.handleText(t, x)) : "number" == typeof t && w1.push(t);
                        e1[0] = w1;
                        i = Ke;
                        break;
                    case Ye:
                        if (!y.state.font) {
                            l.ensureStateFont(y.state);
                            continue;
                        }
                        r.addOp(Ve);
                        e1[0] = l.handleText(e1[0], y.state);
                        i = Ke;
                        break;
                    case Ze:
                        if (!y.state.font) {
                            l.ensureStateFont(y.state);
                            continue;
                        }
                        r.addOp(Ve);
                        r.addOp(_e, [
                            e1.shift()
                        ]);
                        r.addOp(je, [
                            e1.shift()
                        ]);
                        e1[0] = l.handleText(e1[0], y.state);
                        i = Ke;
                        break;
                    case He:
                        y.state.textRenderingMode = e1[0];
                        break;
                    case at:
                        {
                            const t = l._getColorSpace(e1[0], a, d);
                            if (t instanceof ColorSpace) {
                                y.state.fillColorSpace = t;
                                continue;
                            }
                            next(l._handleColorSpace(t).then((e1)=>{
                                y.state.fillColorSpace = e1 || ColorSpaceUtils.gray;
                            }));
                            return;
                        }
                    case tt:
                        {
                            const t = l._getColorSpace(e1[0], a, d);
                            if (t instanceof ColorSpace) {
                                y.state.strokeColorSpace = t;
                                continue;
                            }
                            next(l._handleColorSpace(t).then((e1)=>{
                                y.state.strokeColorSpace = e1 || ColorSpaceUtils.gray;
                            }));
                            return;
                        }
                    case nt:
                        C = y.state.fillColorSpace;
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ];
                        i = ht;
                        break;
                    case rt:
                        C = y.state.strokeColorSpace;
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ];
                        i = lt;
                        break;
                    case ct:
                        y.state.fillColorSpace = ColorSpaceUtils.gray;
                        e1 = [
                            ColorSpaceUtils.gray.getRgbHex(e1, 0)
                        ];
                        i = ht;
                        break;
                    case ot:
                        y.state.strokeColorSpace = ColorSpaceUtils.gray;
                        e1 = [
                            ColorSpaceUtils.gray.getRgbHex(e1, 0)
                        ];
                        i = lt;
                        break;
                    case dt:
                        y.state.fillColorSpace = ColorSpaceUtils.cmyk;
                        e1 = [
                            ColorSpaceUtils.cmyk.getRgbHex(e1, 0)
                        ];
                        i = ht;
                        break;
                    case ut:
                        y.state.strokeColorSpace = ColorSpaceUtils.cmyk;
                        e1 = [
                            ColorSpaceUtils.cmyk.getRgbHex(e1, 0)
                        ];
                        i = lt;
                        break;
                    case ht:
                        y.state.fillColorSpace = ColorSpaceUtils.rgb;
                        e1 = [
                            ColorSpaceUtils.rgb.getRgbHex(e1, 0)
                        ];
                        break;
                    case lt:
                        y.state.strokeColorSpace = ColorSpaceUtils.rgb;
                        e1 = [
                            ColorSpaceUtils.rgb.getRgbHex(e1, 0)
                        ];
                        break;
                    case st:
                        C = y.state.patternFillColorSpace;
                        if (!C) {
                            if (isNumberArray(e1, null)) {
                                e1 = [
                                    ColorSpaceUtils.gray.getRgbHex(e1, 0)
                                ];
                                i = ht;
                                break;
                            }
                            e1 = [];
                            i = Xt;
                            break;
                        }
                        if ("Pattern" === C.name) {
                            next(l.handleColorN(r, st, e1, C, b, a, t, d, g, p));
                            return;
                        }
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ];
                        i = ht;
                        break;
                    case it:
                        C = y.state.patternStrokeColorSpace;
                        if (!C) {
                            if (isNumberArray(e1, null)) {
                                e1 = [
                                    ColorSpaceUtils.gray.getRgbHex(e1, 0)
                                ];
                                i = lt;
                                break;
                            }
                            e1 = [];
                            i = Ut;
                            break;
                        }
                        if ("Pattern" === C.name) {
                            next(l.handleColorN(r, it, e1, C, b, a, t, d, g, p));
                            return;
                        }
                        e1 = [
                            C.getRgbHex(e1, 0)
                        ];
                        i = lt;
                        break;
                    case ft:
                        let T;
                        try {
                            const t = a.get("Shading");
                            if (!t) throw new FormatError("No shading resource found");
                            T = t.get(e1[0].name);
                            if (!T) throw new FormatError("No shading object found");
                        } catch (e1) {
                            if (e1 instanceof AbortException) continue;
                            if (l.options.ignoreErrors) {
                                warn(`getOperatorList - ignoring Shading: "${e1}".`);
                                continue;
                            }
                            throw e1;
                        }
                        const O = l.parseShading({
                            shading: T,
                            resources: a,
                            localColorSpaceCache: d,
                            localShadingPatternCache: p
                        });
                        if (!O) continue;
                        e1 = [
                            O
                        ];
                        i = ft;
                        break;
                    case ge:
                        F = e1[0] instanceof Name;
                        v = e1[0].name;
                        if (F) {
                            const t = f.getByName(v);
                            if (t) {
                                t.length > 0 && r.addOp(ge, [
                                    t
                                ]);
                                e1 = null;
                                continue;
                            }
                        }
                        next(new Promise(function(e1, i) {
                            if (!F) throw new FormatError("GState must be referred to by name.");
                            const n = a.get("ExtGState");
                            if (!(n instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                            const s = n.get(v);
                            if (!(s instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                            l.setGState({
                                resources: a,
                                gState: s,
                                operatorList: r,
                                cacheKey: v,
                                task: t,
                                stateManager: y,
                                localGStateCache: f,
                                localColorSpaceCache: d,
                                seenRefs: c
                            }).then(e1, i);
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!l.options.ignoreErrors) throw e1;
                                warn(`getOperatorList - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                        return;
                    case oe:
                        {
                            const [t] = e1;
                            if ("number" != typeof t) {
                                warn(`Invalid setLineWidth: ${t}`);
                                continue;
                            }
                            e1[0] = Math.abs(t);
                            break;
                        }
                    case ue:
                        {
                            const t = e1[1];
                            if ("number" != typeof t) {
                                warn(`Invalid setDash: ${t}`);
                                continue;
                            }
                            const a = e1[0];
                            if (!Array.isArray(a)) {
                                warn(`Invalid setDash: ${a}`);
                                continue;
                            }
                            a.some((e1)=>"number" != typeof e1) && (e1[0] = a.filter((e1)=>"number" == typeof e1));
                            break;
                        }
                    case ye:
                    case we:
                    case xe:
                    case Se:
                    case Ae:
                    case ke:
                    case Ce:
                        l.buildPath(i, e1, y.state);
                        continue;
                    case ve:
                    case Fe:
                    case Ie:
                    case Te:
                    case Oe:
                    case Me:
                    case De:
                    case Be:
                    case Re:
                        {
                            const { state: { pathBuffer: e1, pathMinMax: t } } = y;
                            i !== Fe && i !== De && i !== Be || e1.push($t);
                            if (0 === e1.length) r.addOp(_t, [
                                i,
                                [
                                    null
                                ],
                                null
                            ]);
                            else {
                                r.addOp(_t, [
                                    i,
                                    [
                                        new Float32Array(e1)
                                    ],
                                    t.slice()
                                ]);
                                e1.length = 0;
                                t.set([
                                    1 / 0,
                                    1 / 0,
                                    -1 / 0,
                                    -1 / 0
                                ], 0);
                            }
                            continue;
                        }
                    case Ge:
                        r.addOp(i, [
                            new Float32Array(e1)
                        ]);
                        continue;
                    case yt:
                    case wt:
                    case kt:
                    case Ct:
                        continue;
                    case St:
                        if (!(e1[0] instanceof Name)) {
                            warn(`Expected name for beginMarkedContentProps arg0=${e1[0]}`);
                            r.addOp(St, [
                                "OC",
                                null
                            ]);
                            continue;
                        }
                        if ("OC" === e1[0].name) {
                            next(l.parseMarkedContentProps(e1[1], a).then((e1)=>{
                                r.addOp(St, [
                                    "OC",
                                    e1
                                ]);
                            }).catch((e1)=>{
                                if (!(e1 instanceof AbortException)) {
                                    if (!l.options.ignoreErrors) throw e1;
                                    warn(`getOperatorList - ignoring beginMarkedContentProps: "${e1}".`);
                                    r.addOp(St, [
                                        "OC",
                                        null
                                    ]);
                                }
                            }));
                            return;
                        }
                        e1 = [
                            e1[0].name,
                            e1[1] instanceof Dict ? e1[1].get("MCID") : null
                        ];
                        break;
                    default:
                        if (null !== e1) {
                            for(S = 0, k = e1.length; S < k && !(e1[S] instanceof Dict); S++);
                            if (S < k) {
                                warn("getOperatorList - ignoring operator: " + i);
                                continue;
                            }
                        }
                }
                r.addOp(i, e1);
            }
            if (o) next(yn);
            else {
                closePendingRestoreOPS();
                e1();
            }
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`getOperatorList - ignoring errors during "${t.name}" task: "${e1}".`);
                closePendingRestoreOPS();
            }
        });
    }
    getTextContent({ stream: e1, task: a, resources: r, stateManager: i = null, includeMarkedContent: n = !1, sink: s, seenStyles: o = new Set, viewBox: c, lang: l = null, markedContentData: h = null, disableNormalization: u = !1, keepWhiteSpace: d = !1, prevRefs: f = null, intersector: g = null }) {
        const p = e1.dict?.objId, m = new RefSet(f);
        if (p) {
            if (f?.has(p)) throw new Error(`getTextContent - ignoring circular reference: ${p}`);
            m.put(p);
        }
        r ||= Dict.empty;
        i ||= new StateManager(new TextState);
        n && (h ||= {
            level: 0
        });
        const b = {
            items: [],
            styles: Object.create(null),
            lang: l
        }, y = {
            initialized: !1,
            str: [],
            totalWidth: 0,
            totalHeight: 0,
            width: 0,
            height: 0,
            vertical: !1,
            prevTransform: null,
            textAdvanceScale: 0,
            spaceInFlowMin: 0,
            spaceInFlowMax: 0,
            trackingSpaceMin: 1 / 0,
            negativeSpaceMax: -1 / 0,
            notASpace: -1 / 0,
            transform: null,
            fontName: null,
            hasEOL: !1
        }, w = [
            " ",
            " "
        ];
        let x = 0;
        function saveLastChar(e1) {
            const t = (x + 1) % 2, a = " " !== w[x] && " " === w[t];
            w[x] = e1;
            x = t;
            return !d && a;
        }
        function shouldAddWhitepsace() {
            return !d && " " !== w[x] && " " === w[(x + 1) % 2];
        }
        function resetLastChars() {
            w[0] = w[1] = " ";
            x = 0;
        }
        const S = this, k = this.xref, C = [];
        let v = null;
        const F = new LocalImageCache, T = new LocalGStateCache, O = new EvaluatorPreprocessor(e1, k, i);
        let M;
        function pushWhitespace({ width: e1 = 0, height: t = 0, transform: a = y.prevTransform, fontName: r = y.fontName }) {
            g?.addExtraChar(" ");
            b.items.push({
                str: " ",
                dir: "ltr",
                width: e1,
                height: t,
                transform: a,
                fontName: r,
                hasEOL: !1
            });
        }
        function getCurrentTextTransform() {
            const e1 = M.font, a = [
                M.fontSize * M.textHScale,
                0,
                0,
                M.fontSize,
                0,
                M.textRise
            ];
            if (e1.isType3Font && (M.fontSize <= 1 || e1.isCharBBox) && !isArrayEqual(M.fontMatrix, t)) {
                const t = e1.bbox[3] - e1.bbox[1];
                t > 0 && (a[3] *= t * M.fontMatrix[3]);
            }
            return Util.transform(M.ctm, Util.transform(M.textMatrix, a));
        }
        function ensureTextContentItem() {
            if (y.initialized) return y;
            const { font: e1, loadedName: t } = M;
            if (!o.has(t)) {
                o.add(t);
                b.styles[t] = {
                    fontFamily: e1.fallbackName,
                    ascent: e1.ascent,
                    descent: e1.descent,
                    vertical: e1.vertical
                };
                if (S.options.fontExtraProperties && e1.systemFontInfo) {
                    const a = b.styles[t];
                    a.fontSubstitution = e1.systemFontInfo.css;
                    a.fontSubstitutionLoadedName = e1.systemFontInfo.loadedName;
                }
            }
            y.fontName = t;
            const a = y.transform = getCurrentTextTransform();
            if (e1.vertical) {
                y.width = y.totalWidth = Math.hypot(a[0], a[1]);
                y.height = y.totalHeight = 0;
                y.vertical = !0;
            } else {
                y.width = y.totalWidth = 0;
                y.height = y.totalHeight = Math.hypot(a[2], a[3]);
                y.vertical = !1;
            }
            const r = Math.hypot(M.textLineMatrix[0], M.textLineMatrix[1]), i = Math.hypot(M.ctm[0], M.ctm[1]);
            y.textAdvanceScale = i * r;
            const { fontSize: n } = M;
            y.trackingSpaceMin = .102 * n;
            y.notASpace = .03 * n;
            y.negativeSpaceMax = -.2 * n;
            y.spaceInFlowMin = .102 * n;
            y.spaceInFlowMax = .6 * n;
            y.hasEOL = !1;
            y.initialized = !0;
            return y;
        }
        function updateAdvanceScale() {
            if (!y.initialized) return;
            const e1 = Math.hypot(M.textLineMatrix[0], M.textLineMatrix[1]), t = Math.hypot(M.ctm[0], M.ctm[1]) * e1;
            if (t !== y.textAdvanceScale) {
                if (y.vertical) {
                    y.totalHeight += y.height * y.textAdvanceScale;
                    y.height = 0;
                } else {
                    y.totalWidth += y.width * y.textAdvanceScale;
                    y.width = 0;
                }
                y.textAdvanceScale = t;
            }
        }
        function runBidiTransform(e1) {
            let t = e1.str.join("");
            u || (t = function normalizeUnicode(e1) {
                if (!Qt) {
                    Qt = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                    ea = new Map([
                        [
                            "ﬅ",
                            "ſt"
                        ]
                    ]);
                }
                return e1.replaceAll(Qt, (e1, t, a)=>t ? t.normalize("NFKC") : ea.get(a));
            }(t));
            const a = bidi(t, -1, e1.vertical);
            return {
                str: a.str,
                dir: a.dir,
                width: Math.abs(e1.totalWidth),
                height: Math.abs(e1.totalHeight),
                transform: e1.transform,
                fontName: e1.fontName,
                hasEOL: e1.hasEOL
            };
        }
        async function handleSetFont(e1, i) {
            const n = await S.loadFont(e1, i, r, a);
            M.loadedName = n.loadedName;
            M.font = n.font;
            M.fontMatrix = n.font.fontMatrix || t;
        }
        function applyInverseRotation(e1, t, a) {
            const r = Math.hypot(a[0], a[1]);
            return [
                (a[0] * e1 + a[1] * t) / r,
                (a[2] * e1 + a[3] * t) / r
            ];
        }
        function compareWithLastPosition(e1) {
            const t = getCurrentTextTransform();
            let a = t[4], r = t[5];
            if (M.font?.vertical) {
                if (a < c[0] || a > c[2] || r + e1 < c[1] || r > c[3]) return !1;
            } else if (a + e1 < c[0] || a > c[2] || r < c[1] || r > c[3]) return !1;
            if (!M.font || !y.prevTransform) return !0;
            let i = y.prevTransform[4], n = y.prevTransform[5];
            if (i === a && n === r) return !0;
            let s = -1;
            t[0] && 0 === t[1] && 0 === t[2] ? s = t[0] > 0 ? 0 : 180 : t[1] && 0 === t[0] && 0 === t[3] && (s = t[1] > 0 ? 90 : 270);
            switch(s){
                case 0:
                    break;
                case 90:
                    [a, r] = [
                        r,
                        a
                    ];
                    [i, n] = [
                        n,
                        i
                    ];
                    break;
                case 180:
                    [a, r, i, n] = [
                        -a,
                        -r,
                        -i,
                        -n
                    ];
                    break;
                case 270:
                    [a, r] = [
                        -r,
                        -a
                    ];
                    [i, n] = [
                        -n,
                        -i
                    ];
                    break;
                default:
                    [a, r] = applyInverseRotation(a, r, t);
                    [i, n] = applyInverseRotation(i, n, y.prevTransform);
            }
            if (M.font.vertical) {
                const e1 = (n - r) / y.textAdvanceScale, t = a - i, s = Math.sign(y.height);
                if (e1 < s * y.negativeSpaceMax) {
                    if (Math.abs(t) > .5 * y.width) {
                        appendEOL();
                        return !0;
                    }
                    resetLastChars();
                    flushTextContentItem();
                    return !0;
                }
                if (Math.abs(t) > y.width) {
                    appendEOL();
                    return !0;
                }
                e1 <= s * y.notASpace && resetLastChars();
                if (e1 <= s * y.trackingSpaceMin) if (shouldAddWhitepsace()) {
                    resetLastChars();
                    flushTextContentItem();
                    pushWhitespace({
                        height: Math.abs(e1)
                    });
                } else y.height += e1;
                else if (!addFakeSpaces(e1, y.prevTransform, s)) if (0 === y.str.length) {
                    resetLastChars();
                    pushWhitespace({
                        height: Math.abs(e1)
                    });
                } else y.height += e1;
                Math.abs(t) > .25 * y.width && flushTextContentItem();
                return !0;
            }
            const o = (a - i) / y.textAdvanceScale, l = r - n, h = Math.sign(y.width);
            if (o < h * y.negativeSpaceMax) {
                if (Math.abs(l) > .5 * y.height) {
                    appendEOL();
                    return !0;
                }
                resetLastChars();
                flushTextContentItem();
                return !0;
            }
            if (Math.abs(l) > y.height) {
                appendEOL();
                return !0;
            }
            o <= h * y.notASpace && resetLastChars();
            if (o <= h * y.trackingSpaceMin) if (shouldAddWhitepsace()) {
                resetLastChars();
                flushTextContentItem();
                pushWhitespace({
                    width: Math.abs(o)
                });
            } else y.width += o;
            else if (!addFakeSpaces(o, y.prevTransform, h)) if (0 === y.str.length) {
                resetLastChars();
                pushWhitespace({
                    width: Math.abs(o)
                });
            } else y.width += o;
            Math.abs(l) > .25 * y.height && flushTextContentItem();
            return !0;
        }
        function buildTextContentItem({ chars: e1, extraSpacing: t }) {
            const a = M.font;
            if (!e1) {
                const e1 = M.charSpacing + t;
                e1 && (a.vertical ? M.translateTextMatrix(0, -e1) : M.translateTextMatrix(e1 * M.textHScale, 0));
                d && compareWithLastPosition(0);
                return;
            }
            const r = a.charsToGlyphs(e1), i = M.fontMatrix[0] * M.fontSize;
            for(let e1 = 0, n = r.length; e1 < n; e1++){
                const s = r[e1], { category: o } = s;
                if (o.isInvisibleFormatMark) continue;
                let c = M.charSpacing + (e1 + 1 === n ? t : 0), l = s.width;
                a.vertical && (l = s.vmetric ? s.vmetric[0] : -l);
                let h = l * i;
                if (!d && o.isWhitespace) {
                    if (a.vertical) {
                        c += -h + M.wordSpacing;
                        M.translateTextMatrix(0, -c);
                    } else {
                        c += h + M.wordSpacing;
                        M.translateTextMatrix(c * M.textHScale, 0);
                    }
                    saveLastChar(" ");
                    continue;
                }
                if (!o.isZeroWidthDiacritic && !compareWithLastPosition(h)) {
                    a.vertical ? M.translateTextMatrix(0, h) : M.translateTextMatrix(h * M.textHScale, 0);
                    continue;
                }
                const u = ensureTextContentItem();
                o.isZeroWidthDiacritic && (h = 0);
                if (a.vertical) {
                    g?.addGlyph(getCurrentTextTransform(), 0, h, s.unicode);
                    M.translateTextMatrix(0, h);
                    h = Math.abs(h);
                    u.height += h;
                } else {
                    h *= M.textHScale;
                    g?.addGlyph(getCurrentTextTransform(), h, 0, s.unicode);
                    M.translateTextMatrix(h, 0);
                    u.width += h;
                }
                h && (u.prevTransform = getCurrentTextTransform());
                const f = s.unicode;
                if (saveLastChar(f)) {
                    u.str.push(" ");
                    g?.addExtraChar(" ");
                }
                g || u.str.push(f);
                c && (a.vertical ? M.translateTextMatrix(0, -c) : M.translateTextMatrix(c * M.textHScale, 0));
            }
        }
        function appendEOL() {
            g?.addExtraChar("\n");
            resetLastChars();
            if (y.initialized) {
                y.hasEOL = !0;
                flushTextContentItem();
            } else b.items.push({
                str: "",
                dir: "ltr",
                width: 0,
                height: 0,
                transform: getCurrentTextTransform(),
                fontName: M.loadedName,
                hasEOL: !0
            });
        }
        function addFakeSpaces(e1, t, a) {
            if (a * y.spaceInFlowMin <= e1 && e1 <= a * y.spaceInFlowMax) {
                if (y.initialized) {
                    resetLastChars();
                    y.str.push(" ");
                    g?.addExtraChar(" ");
                }
                return !1;
            }
            const r = y.fontName;
            let i = 0;
            if (y.vertical) {
                i = e1;
                e1 = 0;
            }
            flushTextContentItem();
            resetLastChars();
            pushWhitespace({
                width: Math.abs(e1),
                height: Math.abs(i),
                transform: t || getCurrentTextTransform(),
                fontName: r
            });
            return !0;
        }
        function flushTextContentItem() {
            if (y.initialized && y.str) {
                y.vertical ? y.totalHeight += y.height * y.textAdvanceScale : y.totalWidth += y.width * y.textAdvanceScale;
                b.items.push(runBidiTransform(y));
                y.initialized = !1;
                y.str.length = 0;
            }
        }
        function enqueueChunk(e1 = !1) {
            const t = b.items.length;
            if (0 !== t && !(e1 && t < 10)) {
                s?.enqueue(b, t);
                b.items = [];
                b.styles = Object.create(null);
            }
        }
        const D = new TimeSlotManager;
        return new Promise(function promiseBody(e1, t) {
            const next = function(a) {
                enqueueChunk(!0);
                Promise.all([
                    a,
                    s?.ready
                ]).then(function() {
                    try {
                        promiseBody(e1, t);
                    } catch (e1) {
                        t(e1);
                    }
                }, t);
            };
            a.ensureNotTerminated();
            D.reset();
            const f = {};
            let g, p, y, w = [];
            for(; !(g = D.check());){
                w.length = 0;
                f.args = w;
                if (!O.read(f)) break;
                const e1 = M;
                M = i.state;
                const t = f.fn;
                w = f.args;
                switch(0 | t){
                    case qe:
                        const t1 = w[0].name, f1 = w[1];
                        if (M.font && t1 === M.fontName && f1 === M.fontSize) break;
                        flushTextContentItem();
                        M.fontName = t1;
                        M.fontSize = f1;
                        next(handleSetFont(t1, null));
                        return;
                    case We:
                        M.textRise = w[0];
                        break;
                    case Ue:
                        M.textHScale = w[0] / 100;
                        break;
                    case Xe:
                        M.leading = w[0];
                        break;
                    case ze:
                        M.translateTextLineMatrix(w[0], w[1]);
                        M.textMatrix = M.textLineMatrix.slice();
                        break;
                    case $e:
                        M.leading = -w[1];
                        M.translateTextLineMatrix(w[0], w[1]);
                        M.textMatrix = M.textLineMatrix.slice();
                        break;
                    case Ve:
                        M.carriageReturn();
                        break;
                    case Ge:
                        M.setTextMatrix(w[0], w[1], w[2], w[3], w[4], w[5]);
                        M.setTextLineMatrix(w[0], w[1], w[2], w[3], w[4], w[5]);
                        updateAdvanceScale();
                        break;
                    case je:
                        M.charSpacing = w[0];
                        break;
                    case _e:
                        M.wordSpacing = w[0];
                        break;
                    case Pe:
                        M.textMatrix = la.slice();
                        M.textLineMatrix = la.slice();
                        break;
                    case Je:
                        if (!i.state.font) {
                            S.ensureStateFont(i.state);
                            continue;
                        }
                        const g1 = (M.font.vertical ? 1 : -1) * M.fontSize / 1e3, x = w[0];
                        for(let e1 = 0, t = x.length; e1 < t; e1++){
                            const t = x[e1];
                            if ("string" == typeof t) C.push(t);
                            else if ("number" == typeof t && 0 !== t) {
                                const e1 = C.join("");
                                C.length = 0;
                                buildTextContentItem({
                                    chars: e1,
                                    extraSpacing: t * g1
                                });
                            }
                        }
                        if (C.length > 0) {
                            const e1 = C.join("");
                            C.length = 0;
                            buildTextContentItem({
                                chars: e1,
                                extraSpacing: 0
                            });
                        }
                        break;
                    case Ke:
                        if (!i.state.font) {
                            S.ensureStateFont(i.state);
                            continue;
                        }
                        buildTextContentItem({
                            chars: w[0],
                            extraSpacing: 0
                        });
                        break;
                    case Ye:
                        if (!i.state.font) {
                            S.ensureStateFont(i.state);
                            continue;
                        }
                        M.carriageReturn();
                        buildTextContentItem({
                            chars: w[0],
                            extraSpacing: 0
                        });
                        break;
                    case Ze:
                        if (!i.state.font) {
                            S.ensureStateFont(i.state);
                            continue;
                        }
                        M.wordSpacing = w[0];
                        M.charSpacing = w[1];
                        M.carriageReturn();
                        buildTextContentItem({
                            chars: w[2],
                            extraSpacing: 0
                        });
                        break;
                    case bt:
                        flushTextContentItem();
                        v ??= r.get("XObject") || Dict.empty;
                        y = w[0] instanceof Name;
                        p = w[0].name;
                        if (y && F.getByName(p)) break;
                        next(new Promise(function(e1, t) {
                            if (!y) throw new FormatError("XObject must be referred to by name.");
                            let f = v.getRaw(p);
                            if (f instanceof Ref) {
                                if (F.getByRef(f)) {
                                    e1();
                                    return;
                                }
                                if (S.globalImageCache.getData(f, S.pageIndex)) {
                                    e1();
                                    return;
                                }
                                f = k.fetch(f);
                            }
                            if (!(f instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                            const { dict: g } = f, b = g.get("Subtype");
                            if (!(b instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                            if ("Form" !== b.name) {
                                F.set(p, g.objId, !0);
                                e1();
                                return;
                            }
                            const w = i.state.clone(), x = new StateManager(w), C = lookupMatrix(g.getArray("Matrix"), null);
                            C && x.transform(C);
                            const T = g.get("Resources");
                            enqueueChunk();
                            const O = {
                                enqueueInvoked: !1,
                                enqueue (e1, t) {
                                    this.enqueueInvoked = !0;
                                    s.enqueue(e1, t);
                                },
                                get desiredSize () {
                                    return s.desiredSize ?? 0;
                                },
                                get ready () {
                                    return s.ready;
                                }
                            };
                            S.getTextContent({
                                stream: f,
                                task: a,
                                resources: T instanceof Dict ? T : r,
                                stateManager: x,
                                includeMarkedContent: n,
                                sink: s && O,
                                seenStyles: o,
                                viewBox: c,
                                lang: l,
                                markedContentData: h,
                                disableNormalization: u,
                                keepWhiteSpace: d,
                                prevRefs: m
                            }).then(function() {
                                O.enqueueInvoked || F.set(p, g.objId, !0);
                                e1();
                            }, t);
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!S.options.ignoreErrors) throw e1;
                                warn(`getTextContent - ignoring XObject: "${e1}".`);
                            }
                        }));
                        return;
                    case ge:
                        y = w[0] instanceof Name;
                        p = w[0].name;
                        if (y && T.getByName(p)) break;
                        next(new Promise(function(e1, t) {
                            if (!y) throw new FormatError("GState must be referred to by name.");
                            const a = r.get("ExtGState");
                            if (!(a instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                            const i = a.get(p);
                            if (!(i instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                            const n = i.get("Font");
                            if (n) {
                                flushTextContentItem();
                                M.fontName = null;
                                M.fontSize = n[1];
                                handleSetFont(null, n[0]).then(e1, t);
                            } else {
                                T.set(p, i.objId, !0);
                                e1();
                            }
                        }).catch(function(e1) {
                            if (!(e1 instanceof AbortException)) {
                                if (!S.options.ignoreErrors) throw e1;
                                warn(`getTextContent - ignoring ExtGState: "${e1}".`);
                            }
                        }));
                        return;
                    case xt:
                        flushTextContentItem();
                        if (n) {
                            h.level++;
                            b.items.push({
                                type: "beginMarkedContent",
                                tag: w[0] instanceof Name ? w[0].name : null
                            });
                        }
                        break;
                    case St:
                        flushTextContentItem();
                        if (n) {
                            h.level++;
                            let e1 = null;
                            w[1] instanceof Dict && (e1 = w[1].get("MCID"));
                            b.items.push({
                                type: "beginMarkedContentProps",
                                id: Number.isInteger(e1) ? `${S.idFactory.getPageObjId()}_mc${e1}` : null,
                                tag: w[0] instanceof Name ? w[0].name : null
                            });
                        }
                        break;
                    case At:
                        flushTextContentItem();
                        if (n) {
                            if (0 === h.level) break;
                            h.level--;
                            b.items.push({
                                type: "endMarkedContent"
                            });
                        }
                        break;
                    case me:
                        !e1 || e1.font === M.font && e1.fontSize === M.fontSize && e1.fontName === M.fontName || flushTextContentItem();
                }
                if (b.items.length >= (s?.desiredSize ?? 1)) {
                    g = !0;
                    break;
                }
            }
            if (g) next(yn);
            else {
                flushTextContentItem();
                enqueueChunk();
                e1();
            }
        }).catch((e1)=>{
            if (!(e1 instanceof AbortException)) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`getTextContent - ignoring errors during "${a.name}" task: "${e1}".`);
                flushTextContentItem();
                enqueueChunk();
            }
        });
    }
    async extractDataStructures(e1, t) {
        const a = this.xref;
        let r;
        const i = this.readToUnicode(t.toUnicode);
        if (t.composite) {
            const a = e1.get("CIDSystemInfo");
            a instanceof Dict && (t.cidSystemInfo = {
                registry: stringToPDFString(a.get("Registry")),
                ordering: stringToPDFString(a.get("Ordering")),
                supplement: a.get("Supplement")
            });
            try {
                const t = e1.get("CIDToGIDMap");
                t instanceof BaseStream && (r = t.getBytes());
            } catch (e1) {
                if (!this.options.ignoreErrors) throw e1;
                warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e1}".`);
            }
        }
        const n = [];
        let s, o = null;
        if (e1.has("Encoding")) {
            s = e1.get("Encoding");
            if (s instanceof Dict) {
                o = s.get("BaseEncoding");
                o = o instanceof Name ? o.name : null;
                if (s.has("Differences")) {
                    const e1 = s.get("Differences");
                    let t = 0;
                    for (const r of e1){
                        const e1 = a.fetchIfRef(r);
                        if ("number" == typeof e1) t = e1;
                        else {
                            if (!(e1 instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e1}`);
                            n[t++] = e1.name;
                        }
                    }
                }
            } else if (s instanceof Name) o = s.name;
            else {
                const e1 = "Encoding is not a Name nor a Dict";
                if (!this.options.ignoreErrors) throw new FormatError(e1);
                warn(e1);
            }
            "MacRomanEncoding" !== o && "MacExpertEncoding" !== o && "WinAnsiEncoding" !== o && (o = null);
        }
        const c = !t.file || t.isInternalFont, l = Lr()[t.name];
        o && c && l && (o = null);
        if (o) t.defaultEncoding = getEncoding(o);
        else {
            const e1 = !!(t.flags & yr), a = !!(t.flags & wr);
            s = nr;
            "TrueType" !== t.type || a || (s = sr);
            if (e1 || l) {
                s = ir;
                c && (/Symbol/i.test(t.name) ? s = or : /Dingbats/i.test(t.name) ? s = cr : /Wingdings/i.test(t.name) && (s = sr));
            }
            t.defaultEncoding = s;
        }
        t.differences = n;
        t.baseEncodingName = o;
        t.hasEncoding = !!o || n.length > 0;
        t.dict = e1;
        t.toUnicode = await i;
        const h = await this.buildToUnicode(t);
        t.toUnicode = h;
        r && (t.cidToGidMap = this.readCidToGidMap(r, h));
        return t;
    }
    _simpleFontToUnicode(e1, t = !1) {
        assert(!e1.composite, "Must be a simple font.");
        const a = [], r = e1.defaultEncoding.slice(), i = e1.baseEncodingName, n = e1.differences;
        for(const e1 in n){
            const t = n[e1];
            ".notdef" !== t && (r[e1] = t);
        }
        const s = lr();
        for(const n in r){
            let o = r[n];
            if ("" === o) continue;
            let c = s[o];
            if (void 0 !== c) {
                a[n] = String.fromCharCode(c);
                continue;
            }
            let l = 0;
            switch(o[0]){
                case "G":
                    3 === o.length && (l = parseInt(o.substring(1), 16));
                    break;
                case "g":
                    5 === o.length && (l = parseInt(o.substring(1), 16));
                    break;
                case "C":
                case "c":
                    if (o.length >= 3 && o.length <= 4) {
                        const a = o.substring(1);
                        if (t) {
                            l = parseInt(a, 16);
                            break;
                        }
                        l = +a;
                        if (Number.isNaN(l) && Number.isInteger(parseInt(a, 16))) return this._simpleFontToUnicode(e1, !0);
                    }
                    break;
                case "u":
                    c = getUnicodeForGlyph(o, s);
                    -1 !== c && (l = c);
                    break;
                default:
                    switch(o){
                        case "f_h":
                        case "f_t":
                        case "T_h":
                            a[n] = o.replaceAll("_", "");
                            continue;
                    }
            }
            if (l > 0 && l <= 1114111 && Number.isInteger(l)) {
                if (i && l === +n) {
                    const e1 = getEncoding(i);
                    if (e1 && (o = e1[n])) {
                        a[n] = String.fromCharCode(s[o]);
                        continue;
                    }
                }
                a[n] = String.fromCodePoint(l);
            }
        }
        return a;
    }
    async buildToUnicode(e1) {
        e1.hasIncludedToUnicodeMap = e1.toUnicode?.length > 0;
        if (e1.hasIncludedToUnicodeMap) {
            !e1.composite && e1.hasEncoding && (e1.fallbackToUnicode = this._simpleFontToUnicode(e1));
            return e1.toUnicode;
        }
        if (!e1.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e1));
        if (e1.composite && (e1.cMap.builtInCMap && !(e1.cMap instanceof IdentityCMap) || "Adobe" === e1.cidSystemInfo?.registry && ("GB1" === e1.cidSystemInfo.ordering || "CNS1" === e1.cidSystemInfo.ordering || "Japan1" === e1.cidSystemInfo.ordering || "Korea1" === e1.cidSystemInfo.ordering))) {
            const { registry: t, ordering: a } = e1.cidSystemInfo, r = Name.get(`${t}-${a}-UCS2`), i = await CMapFactory.create({
                encoding: r,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            }), n = [], s = [];
            e1.cMap.forEach(function(e1, t) {
                if (t > 65535) throw new FormatError("Max size of CID is 65,535");
                const a = i.lookup(t);
                if (a) {
                    s.length = 0;
                    for(let e1 = 0, t = a.length; e1 < t; e1 += 2)s.push((a.charCodeAt(e1) << 8) + a.charCodeAt(e1 + 1));
                    n[e1] = String.fromCharCode(...s);
                }
            });
            return new ToUnicodeMap(n);
        }
        return new IdentityToUnicodeMap(e1.firstChar, e1.lastChar);
    }
    async readToUnicode(e1) {
        if (!e1) return null;
        if (e1 instanceof Name) {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            return t instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t.getMap());
        }
        if (e1 instanceof BaseStream) try {
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            if (t instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
            const a = new Array(t.length);
            t.forEach(function(e1, t) {
                if ("number" == typeof t) {
                    a[e1] = String.fromCodePoint(t);
                    return;
                }
                t.length % 2 != 0 && (t = "\0" + t);
                const r = [];
                for(let e1 = 0; e1 < t.length; e1 += 2){
                    const a = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    if (55296 != (63488 & a)) {
                        r.push(a);
                        continue;
                    }
                    e1 += 2;
                    const i = t.charCodeAt(e1) << 8 | t.charCodeAt(e1 + 1);
                    r.push(((1023 & a) << 10) + (1023 & i) + 65536);
                }
                a[e1] = String.fromCodePoint(...r);
            });
            return new ToUnicodeMap(a);
        } catch (e1) {
            if (e1 instanceof AbortException) return null;
            if (this.options.ignoreErrors) {
                warn(`readToUnicode - ignoring ToUnicode data: "${e1}".`);
                return null;
            }
            throw e1;
        }
        return null;
    }
    readCidToGidMap(e1, t) {
        const a = [];
        for(let r = 0, i = e1.length; r < i; r++){
            const i = e1[r++] << 8 | e1[r], n = r >> 1;
            (0 !== i || t.has(n)) && (a[n] = i);
        }
        return a;
    }
    extractWidths(e1, t, a) {
        const r = this.xref;
        let i = [], n = 0;
        const s = [];
        let o;
        if (a.composite) {
            const t = e1.get("DW");
            n = "number" == typeof t ? Math.ceil(t) : 1e3;
            const c = e1.get("W");
            if (Array.isArray(c)) for(let e1 = 0, t = c.length; e1 < t; e1++){
                let t = r.fetchIfRef(c[e1++]);
                if (!Number.isInteger(t)) break;
                const a = r.fetchIfRef(c[e1]);
                if (Array.isArray(a)) for (const e1 of a){
                    const a = r.fetchIfRef(e1);
                    "number" == typeof a && (i[t] = a);
                    t++;
                }
                else {
                    if (!Number.isInteger(a)) break;
                    {
                        const n = r.fetchIfRef(c[++e1]);
                        if ("number" != typeof n) continue;
                        for(let e1 = t; e1 <= a; e1++)i[e1] = n;
                    }
                }
            }
            if (a.vertical) {
                const t = e1.getArray("DW2");
                let a = isNumberArray(t, 2) ? t : [
                    880,
                    -1e3
                ];
                o = [
                    a[1],
                    .5 * n,
                    a[0]
                ];
                a = e1.get("W2");
                if (Array.isArray(a)) for(let e1 = 0, t = a.length; e1 < t; e1++){
                    let t = r.fetchIfRef(a[e1++]);
                    if (!Number.isInteger(t)) break;
                    const i = r.fetchIfRef(a[e1]);
                    if (Array.isArray(i)) for(let e1 = 0, a = i.length; e1 < a; e1++){
                        const a = [
                            r.fetchIfRef(i[e1++]),
                            r.fetchIfRef(i[e1++]),
                            r.fetchIfRef(i[e1])
                        ];
                        isNumberArray(a, null) && (s[t] = a);
                        t++;
                    }
                    else {
                        if (!Number.isInteger(i)) break;
                        {
                            const n = [
                                r.fetchIfRef(a[++e1]),
                                r.fetchIfRef(a[++e1]),
                                r.fetchIfRef(a[++e1])
                            ];
                            if (!isNumberArray(n, null)) continue;
                            for(let e1 = t; e1 <= i; e1++)s[e1] = n;
                        }
                    }
                }
            }
        } else {
            const s = e1.get("Widths");
            if (Array.isArray(s)) {
                let e1 = a.firstChar;
                for (const t of s){
                    const a = r.fetchIfRef(t);
                    "number" == typeof a && (i[e1] = a);
                    e1++;
                }
                const o = t.get("MissingWidth");
                n = "number" == typeof o ? o : 0;
            } else {
                const t = e1.get("BaseFont");
                if (t instanceof Name) {
                    const e1 = this.getBaseFontMetrics(t.name);
                    i = this.buildCharCodeToWidth(e1.widths, a);
                    n = e1.defaultWidth;
                }
            }
        }
        let c = !0, l = n;
        for(const e1 in i){
            const t = i[e1];
            if (t) if (l) {
                if (l !== t) {
                    c = !1;
                    break;
                }
            } else l = t;
        }
        c ? a.flags |= mr : a.flags &= ~mr;
        a.defaultWidth = n;
        a.widths = i;
        a.defaultVMetrics = o;
        a.vmetrics = s;
    }
    isSerifFont(e1) {
        const t = e1.split("-", 1)[0];
        return t in Pr() || /serif/gi.test(t);
    }
    getBaseFontMetrics(e1) {
        let t = 0, a = Object.create(null), r = !1;
        let i = Rr()[e1] || e1;
        const n = Xr();
        i in n || (i = this.isSerifFont(e1) ? "Times-Roman" : "Helvetica");
        const s = n[i];
        if ("number" == typeof s) {
            t = s;
            r = !0;
        } else a = s();
        return {
            defaultWidth: t,
            monospace: r,
            widths: a
        };
    }
    buildCharCodeToWidth(e1, t) {
        const a = Object.create(null), r = t.differences, i = t.defaultEncoding;
        for(let t = 0; t < 256; t++)t in r && e1[r[t]] ? a[t] = e1[r[t]] : t in i && e1[i[t]] && (a[t] = e1[i[t]]);
        return a;
    }
    preEvaluateFont(e1) {
        const t = e1;
        let a = e1.get("Subtype");
        if (!(a instanceof Name)) throw new FormatError("invalid font Subtype");
        let r, i = !1;
        if ("Type0" === a.name) {
            const t = e1.get("DescendantFonts");
            if (!t) throw new FormatError("Descendant fonts are not specified");
            if (!((e1 = Array.isArray(t) ? this.xref.fetchIfRef(t[0]) : t) instanceof Dict)) throw new FormatError("Descendant font is not a dictionary.");
            a = e1.get("Subtype");
            if (!(a instanceof Name)) throw new FormatError("invalid font Subtype");
            i = !0;
        }
        let n = e1.get("FirstChar");
        Number.isInteger(n) || (n = 0);
        let s = e1.get("LastChar");
        Number.isInteger(s) || (s = i ? 65535 : 255);
        const o = e1.get("FontDescriptor"), c = e1.get("ToUnicode") || t.get("ToUnicode");
        if (o) {
            r = new MurmurHash3_64;
            const a = t.getRaw("Encoding");
            if (a instanceof Name) r.update(a.name);
            else if (a instanceof Ref) r.update(a.toString());
            else if (a instanceof Dict) {
                for (const e1 of a.getRawValues())if (e1 instanceof Name) r.update(e1.name);
                else if (e1 instanceof Ref) r.update(e1.toString());
                else if (Array.isArray(e1)) {
                    const t = e1.length, a = new Array(t);
                    for(let r = 0; r < t; r++){
                        const t = e1[r];
                        t instanceof Name ? a[r] = t.name : ("number" == typeof t || t instanceof Ref) && (a[r] = t.toString());
                    }
                    r.update(a.join());
                }
            }
            r.update(`${n}-${s}`);
            if (c instanceof BaseStream) {
                const e1 = c.str || c, t = e1.buffer ? new Uint8Array(e1.buffer.buffer, 0, e1.bufferLength) : new Uint8Array(e1.bytes.buffer, e1.start, e1.end - e1.start);
                r.update(t);
            } else c instanceof Name && r.update(c.name);
            const o = e1.get("Widths") || t.get("Widths");
            if (Array.isArray(o)) {
                const e1 = [];
                for (const t of o)("number" == typeof t || t instanceof Ref) && e1.push(t.toString());
                r.update(e1.join());
            }
            if (i) {
                r.update("compositeFont");
                const a = e1.get("W") || t.get("W");
                if (Array.isArray(a)) {
                    const e1 = [];
                    for (const t of a)if ("number" == typeof t || t instanceof Ref) e1.push(t.toString());
                    else if (Array.isArray(t)) {
                        const a = [];
                        for (const e1 of t)("number" == typeof e1 || e1 instanceof Ref) && a.push(e1.toString());
                        e1.push(`[${a.join()}]`);
                    }
                    r.update(e1.join());
                }
                const i = e1.getRaw("CIDToGIDMap") || t.getRaw("CIDToGIDMap");
                i instanceof Name ? r.update(i.name) : i instanceof Ref ? r.update(i.toString()) : i instanceof BaseStream && r.update(i.peekBytes());
            }
        }
        return {
            descriptor: o,
            dict: e1,
            baseDict: t,
            composite: i,
            type: a.name,
            firstChar: n,
            lastChar: s,
            toUnicode: c,
            hash: r ? r.hexdigest() : ""
        };
    }
    async translateFont({ descriptor: e1, dict: a, baseDict: r, composite: i, type: n, firstChar: s, lastChar: o, toUnicode: c, cssFontInfo: l }) {
        const h = "Type3" === n;
        if (!e1) {
            if (!h) {
                let e1 = a.get("BaseFont");
                if (!(e1 instanceof Name)) throw new FormatError("Base font is not specified");
                e1 = e1.name.replaceAll(/[,_]/g, "-");
                const t = this.getBaseFontMetrics(e1), i = e1.split("-", 1)[0], l = (this.isSerifFont(i) ? br : 0) | (t.monospace ? mr : 0) | (Lr()[i] ? yr : wr), u = {
                    type: n,
                    name: e1,
                    loadedName: r.loadedName,
                    systemFontInfo: null,
                    widths: t.widths,
                    defaultWidth: t.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: l,
                    firstChar: s,
                    lastChar: o,
                    toUnicode: c,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: h
                }, d = a.get("Widths"), f = getStandardFontName(e1);
                let g = null;
                if (f) {
                    g = await this.fetchStandardFontData(f);
                    u.isInternalFont = !!g;
                }
                !u.isInternalFont && this.options.useSystemFonts && (u.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e1, f, n));
                const p = await this.extractDataStructures(a, u);
                if (Array.isArray(d)) {
                    const e1 = [];
                    let t = s;
                    for (const a of d){
                        const r = this.xref.fetchIfRef(a);
                        "number" == typeof r && (e1[t] = r);
                        t++;
                    }
                    p.widths = e1;
                } else p.widths = this.buildCharCodeToWidth(t.widths, p);
                return new Font(e1, g, p, this.options);
            }
            e1 = Dict.empty;
        }
        let u = e1.get("FontName"), d = a.get("BaseFont");
        "string" == typeof u && (u = Name.get(u));
        "string" == typeof d && (d = Name.get(d));
        const f = u?.name, g = d?.name;
        if (h) f || (u = Name.get(n));
        else if (f !== g) {
            info(`The FontDescriptor's FontName is "${f}" but should be the same as the Font's BaseFont "${g}".`);
            f && g && (g.startsWith(f) || !isKnownFontName(f) && isKnownFontName(g)) && (u = null);
            u ||= d;
        }
        if (!(u instanceof Name)) throw new FormatError("invalid font name");
        let p, m, b, y, w;
        try {
            p = e1.get("FontFile", "FontFile2", "FontFile3");
            if (p) {
                if (!(p instanceof BaseStream)) throw new FormatError("FontFile should be a stream");
                if (p.isEmpty) throw new FormatError("FontFile is empty");
            }
        } catch (e1) {
            if (!this.options.ignoreErrors) throw e1;
            warn(`translateFont - fetching "${u.name}" font file: "${e1}".`);
            p = null;
        }
        let x = !1, S = null, k = null;
        if (p) {
            if (p.dict) {
                const e1 = p.dict.get("Subtype");
                e1 instanceof Name && (m = e1.name);
                b = p.dict.get("Length1");
                y = p.dict.get("Length2");
                w = p.dict.get("Length3");
            }
        } else if (l) {
            const e1 = getXfaFontName(u.name);
            if (e1) {
                l.fontFamily = `${l.fontFamily}-PdfJS-XFA`;
                l.metrics = e1.metrics || null;
                S = e1.factors || null;
                p = await this.fetchStandardFontData(e1.name);
                x = !!p;
                r = a = getXfaFontDict(u.name);
                i = !0;
            }
        } else if (!h) {
            const e1 = getStandardFontName(u.name);
            if (e1) {
                p = await this.fetchStandardFontData(e1);
                x = !!p;
            }
            !x && this.options.useSystemFonts && (k = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, u.name, e1, n));
        }
        const C = lookupMatrix(a.getArray("FontMatrix"), t), v = lookupNormalRect(e1.getArray("FontBBox") || a.getArray("FontBBox"), h ? [
            0,
            0,
            0,
            0
        ] : void 0);
        let F = e1.get("Ascent");
        "number" != typeof F && (F = void 0);
        let T = e1.get("Descent");
        "number" != typeof T && (T = void 0);
        let O = e1.get("XHeight");
        "number" != typeof O && (O = 0);
        let M = e1.get("CapHeight");
        "number" != typeof M && (M = 0);
        let D = e1.get("Flags");
        Number.isInteger(D) || (D = 0);
        let R = e1.get("ItalicAngle");
        "number" != typeof R && (R = 0);
        const N = {
            type: n,
            name: u.name,
            subtype: m,
            file: p,
            length1: b,
            length2: y,
            length3: w,
            isInternalFont: x,
            loadedName: r.loadedName,
            composite: i,
            fixedPitch: !1,
            fontMatrix: C,
            firstChar: s,
            lastChar: o,
            toUnicode: c,
            bbox: v,
            ascent: F,
            descent: T,
            xHeight: O,
            capHeight: M,
            flags: D,
            italicAngle: R,
            isType3Font: h,
            cssFontInfo: l,
            scaleFactors: S,
            systemFontInfo: k
        };
        if (i) {
            const e1 = r.get("Encoding");
            e1 instanceof Name && (N.cidEncoding = e1.name);
            const t = await CMapFactory.create({
                encoding: e1,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
            });
            N.cMap = t;
            N.vertical = N.cMap.vertical;
        }
        const E = await this.extractDataStructures(a, N);
        this.extractWidths(a, e1, E);
        return new Font(u.name, p, E, this.options);
    }
    static buildFontPaths(e1, t, a, r) {
        function buildPath(t) {
            const i = `${e1.loadedName}_path_${t}`;
            try {
                if (e1.renderer.hasBuiltPath(t)) return;
                a.send("commonobj", [
                    i,
                    "FontPath",
                    e1.renderer.getPathJs(t)
                ]);
            } catch (e1) {
                if (r.ignoreErrors) {
                    warn(`buildFontPaths - ignoring ${i} glyph: "${e1}".`);
                    return;
                }
                throw e1;
            }
        }
        for (const e1 of t){
            buildPath(e1.fontChar);
            const t = e1.accent;
            t?.fontChar && buildPath(t.fontChar);
        }
    }
    static get fallbackFontDict() {
        const e1 = new Dict;
        e1.set("BaseFont", Name.get("Helvetica"));
        e1.set("Type", Name.get("FallbackType"));
        e1.set("Subtype", Name.get("FallbackType"));
        e1.set("Encoding", Name.get("WinAnsiEncoding"));
        return shadow(this, "fallbackFontDict", e1);
    }
}
class TranslatedFont {
    #G = !1;
    #V = null;
    constructor({ loadedName: e1, font: t, dict: a }){
        this.loadedName = e1;
        this.font = t;
        this.dict = a;
        this.type3Dependencies = t.isType3Font ? new Set : null;
    }
    send(e1) {
        if (!this.#G) {
            this.#G = !0;
            e1.send("commonobj", [
                this.loadedName,
                "Font",
                this.font.exportData()
            ]);
        }
    }
    fallback(e1, t) {
        if (this.font.data) {
            this.font.disableFontFace = !0;
            PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e1, t);
        }
    }
    loadType3Data(e1, t, a) {
        if (this.#V) return this.#V;
        const { font: r, type3Dependencies: i } = this;
        assert(r.isType3Font, "Must be a Type3 font.");
        const n = e1.clone({
            ignoreErrors: !1
        }), s = new RefSet(e1.type3FontRefs);
        this.dict.objId && !s.has(this.dict.objId) && s.put(this.dict.objId);
        n.type3FontRefs = s;
        let o = Promise.resolve();
        const c = this.dict.get("CharProcs"), l = this.dict.get("Resources") || t, h = Object.create(null), [u, d, f, g] = r.bbox, p = f - u, m = g - d, b = Math.hypot(p, m);
        for (const e1 of c.getKeys())o = o.then(()=>{
            const t = c.get(e1), r = new OperatorList;
            return n.getOperatorList({
                stream: t,
                task: a,
                resources: l,
                operatorList: r
            }).then(()=>{
                switch(r.fnArray[0]){
                    case et:
                        this.#K(r, b);
                        break;
                    case Qe:
                        b || this.#J(r);
                }
                h[e1] = r.getIR();
                for (const e1 of r.dependencies)i.add(e1);
            }).catch(function(t) {
                warn(`Type3 font resource "${e1}" is not available.`);
                const a = new OperatorList;
                h[e1] = a.getIR();
            });
        });
        this.#V = o.then(()=>{
            r.charProcOperatorList = h;
            if (this._bbox) {
                r.isCharBBox = !0;
                r.bbox = this._bbox;
            }
        });
        return this.#V;
    }
    #K(e1, t = NaN) {
        const a = Util.normalizeRect(e1.argsArray[0].slice(2)), r = a[2] - a[0], i = a[3] - a[1], n = Math.hypot(r, i);
        if (0 === r || 0 === i) {
            e1.fnArray.splice(0, 1);
            e1.argsArray.splice(0, 1);
        } else if (0 === t || Math.round(n / t) >= 10) {
            this._bbox ??= [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            Util.rectBoundingBox(...a, this._bbox);
        }
        let s = 0, o = e1.length;
        for(; s < o;){
            switch(e1.fnArray[s]){
                case et:
                    break;
                case tt:
                case at:
                case rt:
                case it:
                case nt:
                case st:
                case ot:
                case ct:
                case lt:
                case ht:
                case ut:
                case dt:
                case ft:
                case de:
                    e1.fnArray.splice(s, 1);
                    e1.argsArray.splice(s, 1);
                    o--;
                    continue;
                case ge:
                    const [t] = e1.argsArray[s];
                    let a = 0, r = t.length;
                    for(; a < r;){
                        const [e1] = t[a];
                        switch(e1){
                            case "TR":
                            case "TR2":
                            case "HT":
                            case "BG":
                            case "BG2":
                            case "UCR":
                            case "UCR2":
                                t.splice(a, 1);
                                r--;
                                continue;
                        }
                        a++;
                    }
            }
            s++;
        }
    }
    #J(e1) {
        let t = 1;
        const a = e1.length;
        for(; t < a;){
            if (e1.fnArray[t] === _t) {
                const a = e1.argsArray[t][2];
                this._bbox ??= [
                    1 / 0,
                    1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                Util.rectBoundingBox(...a, this._bbox);
            }
            t++;
        }
    }
}
class StateManager {
    constructor(e1 = new EvalState){
        this.state = e1;
        this.stateStack = [];
    }
    save() {
        const e1 = this.state;
        this.stateStack.push(this.state);
        this.state = e1.clone();
    }
    restore() {
        const e1 = this.stateStack.pop();
        e1 && (this.state = e1);
    }
    transform(e1) {
        this.state.ctm = Util.transform(this.state.ctm, e1);
    }
}
class TextState {
    constructor(){
        this.ctm = new Float32Array(la);
        this.fontName = null;
        this.fontSize = 0;
        this.loadedName = null;
        this.font = null;
        this.fontMatrix = t;
        this.textMatrix = la.slice();
        this.textLineMatrix = la.slice();
        this.charSpacing = 0;
        this.wordSpacing = 0;
        this.leading = 0;
        this.textHScale = 1;
        this.textRise = 0;
    }
    setTextMatrix(e1, t, a, r, i, n) {
        const s = this.textMatrix;
        s[0] = e1;
        s[1] = t;
        s[2] = a;
        s[3] = r;
        s[4] = i;
        s[5] = n;
    }
    setTextLineMatrix(e1, t, a, r, i, n) {
        const s = this.textLineMatrix;
        s[0] = e1;
        s[1] = t;
        s[2] = a;
        s[3] = r;
        s[4] = i;
        s[5] = n;
    }
    translateTextMatrix(e1, t) {
        const a = this.textMatrix;
        a[4] = a[0] * e1 + a[2] * t + a[4];
        a[5] = a[1] * e1 + a[3] * t + a[5];
    }
    translateTextLineMatrix(e1, t) {
        const a = this.textLineMatrix;
        a[4] = a[0] * e1 + a[2] * t + a[4];
        a[5] = a[1] * e1 + a[3] * t + a[5];
    }
    carriageReturn() {
        this.translateTextLineMatrix(0, -this.leading);
        this.textMatrix = this.textLineMatrix.slice();
    }
    clone() {
        const e1 = Object.create(this);
        e1.textMatrix = this.textMatrix.slice();
        e1.textLineMatrix = this.textLineMatrix.slice();
        e1.fontMatrix = this.fontMatrix.slice();
        return e1;
    }
}
class EvalState {
    constructor(){
        this.ctm = new Float32Array(la);
        this.font = null;
        this.textRenderingMode = x;
        this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
        this.patternFillColorSpace = null;
        this.patternStrokeColorSpace = null;
        this.currentPointX = this.currentPointY = 0;
        this.pathMinMax = new Float32Array([
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ]);
        this.pathBuffer = [];
    }
    get fillColorSpace() {
        return this._fillColorSpace;
    }
    set fillColorSpace(e1) {
        this._fillColorSpace = this.patternFillColorSpace = e1;
    }
    get strokeColorSpace() {
        return this._strokeColorSpace;
    }
    set strokeColorSpace(e1) {
        this._strokeColorSpace = this.patternStrokeColorSpace = e1;
    }
    clone({ newPath: e1 = !1 } = {}) {
        const t = Object.create(this);
        if (e1) {
            t.pathBuffer = [];
            t.pathMinMax = new Float32Array([
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ]);
        }
        return t;
    }
}
class EvaluatorPreprocessor {
    static get opMap() {
        return shadow(this, "opMap", Object.assign(Object.create(null), {
            w: {
                id: oe,
                numArgs: 1,
                variableArgs: !1
            },
            J: {
                id: ce,
                numArgs: 1,
                variableArgs: !1
            },
            j: {
                id: le,
                numArgs: 1,
                variableArgs: !1
            },
            M: {
                id: he,
                numArgs: 1,
                variableArgs: !1
            },
            d: {
                id: ue,
                numArgs: 2,
                variableArgs: !1
            },
            ri: {
                id: de,
                numArgs: 1,
                variableArgs: !1
            },
            i: {
                id: fe,
                numArgs: 1,
                variableArgs: !1
            },
            gs: {
                id: ge,
                numArgs: 1,
                variableArgs: !1
            },
            q: {
                id: pe,
                numArgs: 0,
                variableArgs: !1
            },
            Q: {
                id: me,
                numArgs: 0,
                variableArgs: !1
            },
            cm: {
                id: be,
                numArgs: 6,
                variableArgs: !1
            },
            m: {
                id: ye,
                numArgs: 2,
                variableArgs: !1
            },
            l: {
                id: we,
                numArgs: 2,
                variableArgs: !1
            },
            c: {
                id: xe,
                numArgs: 6,
                variableArgs: !1
            },
            v: {
                id: Se,
                numArgs: 4,
                variableArgs: !1
            },
            y: {
                id: Ae,
                numArgs: 4,
                variableArgs: !1
            },
            h: {
                id: ke,
                numArgs: 0,
                variableArgs: !1
            },
            re: {
                id: Ce,
                numArgs: 4,
                variableArgs: !1
            },
            S: {
                id: ve,
                numArgs: 0,
                variableArgs: !1
            },
            s: {
                id: Fe,
                numArgs: 0,
                variableArgs: !1
            },
            f: {
                id: Ie,
                numArgs: 0,
                variableArgs: !1
            },
            F: {
                id: Ie,
                numArgs: 0,
                variableArgs: !1
            },
            "f*": {
                id: Te,
                numArgs: 0,
                variableArgs: !1
            },
            B: {
                id: Oe,
                numArgs: 0,
                variableArgs: !1
            },
            "B*": {
                id: Me,
                numArgs: 0,
                variableArgs: !1
            },
            b: {
                id: De,
                numArgs: 0,
                variableArgs: !1
            },
            "b*": {
                id: Be,
                numArgs: 0,
                variableArgs: !1
            },
            n: {
                id: Re,
                numArgs: 0,
                variableArgs: !1
            },
            W: {
                id: Ne,
                numArgs: 0,
                variableArgs: !1
            },
            "W*": {
                id: Ee,
                numArgs: 0,
                variableArgs: !1
            },
            BT: {
                id: Pe,
                numArgs: 0,
                variableArgs: !1
            },
            ET: {
                id: Le,
                numArgs: 0,
                variableArgs: !1
            },
            Tc: {
                id: je,
                numArgs: 1,
                variableArgs: !1
            },
            Tw: {
                id: _e,
                numArgs: 1,
                variableArgs: !1
            },
            Tz: {
                id: Ue,
                numArgs: 1,
                variableArgs: !1
            },
            TL: {
                id: Xe,
                numArgs: 1,
                variableArgs: !1
            },
            Tf: {
                id: qe,
                numArgs: 2,
                variableArgs: !1
            },
            Tr: {
                id: He,
                numArgs: 1,
                variableArgs: !1
            },
            Ts: {
                id: We,
                numArgs: 1,
                variableArgs: !1
            },
            Td: {
                id: ze,
                numArgs: 2,
                variableArgs: !1
            },
            TD: {
                id: $e,
                numArgs: 2,
                variableArgs: !1
            },
            Tm: {
                id: Ge,
                numArgs: 6,
                variableArgs: !1
            },
            "T*": {
                id: Ve,
                numArgs: 0,
                variableArgs: !1
            },
            Tj: {
                id: Ke,
                numArgs: 1,
                variableArgs: !1
            },
            TJ: {
                id: Je,
                numArgs: 1,
                variableArgs: !1
            },
            "'": {
                id: Ye,
                numArgs: 1,
                variableArgs: !1
            },
            '"': {
                id: Ze,
                numArgs: 3,
                variableArgs: !1
            },
            d0: {
                id: Qe,
                numArgs: 2,
                variableArgs: !1
            },
            d1: {
                id: et,
                numArgs: 6,
                variableArgs: !1
            },
            CS: {
                id: tt,
                numArgs: 1,
                variableArgs: !1
            },
            cs: {
                id: at,
                numArgs: 1,
                variableArgs: !1
            },
            SC: {
                id: rt,
                numArgs: 4,
                variableArgs: !0
            },
            SCN: {
                id: it,
                numArgs: 33,
                variableArgs: !0
            },
            sc: {
                id: nt,
                numArgs: 4,
                variableArgs: !0
            },
            scn: {
                id: st,
                numArgs: 33,
                variableArgs: !0
            },
            G: {
                id: ot,
                numArgs: 1,
                variableArgs: !1
            },
            g: {
                id: ct,
                numArgs: 1,
                variableArgs: !1
            },
            RG: {
                id: lt,
                numArgs: 3,
                variableArgs: !1
            },
            rg: {
                id: ht,
                numArgs: 3,
                variableArgs: !1
            },
            K: {
                id: ut,
                numArgs: 4,
                variableArgs: !1
            },
            k: {
                id: dt,
                numArgs: 4,
                variableArgs: !1
            },
            sh: {
                id: ft,
                numArgs: 1,
                variableArgs: !1
            },
            BI: {
                id: gt,
                numArgs: 0,
                variableArgs: !1
            },
            ID: {
                id: pt,
                numArgs: 0,
                variableArgs: !1
            },
            EI: {
                id: mt,
                numArgs: 1,
                variableArgs: !1
            },
            Do: {
                id: bt,
                numArgs: 1,
                variableArgs: !1
            },
            MP: {
                id: yt,
                numArgs: 1,
                variableArgs: !1
            },
            DP: {
                id: wt,
                numArgs: 2,
                variableArgs: !1
            },
            BMC: {
                id: xt,
                numArgs: 1,
                variableArgs: !1
            },
            BDC: {
                id: St,
                numArgs: 2,
                variableArgs: !1
            },
            EMC: {
                id: At,
                numArgs: 0,
                variableArgs: !1
            },
            BX: {
                id: kt,
                numArgs: 0,
                variableArgs: !1
            },
            EX: {
                id: Ct,
                numArgs: 0,
                variableArgs: !1
            },
            BM: null,
            BD: null,
            true: null,
            fa: null,
            fal: null,
            fals: null,
            false: null,
            nu: null,
            nul: null,
            null: null
        }));
    }
    static MAX_INVALID_PATH_OPS = 10;
    constructor(e1, t, a = new StateManager){
        this.parser = new Parser({
            lexer: new Lexer(e1, EvaluatorPreprocessor.opMap),
            xref: t
        });
        this.stateManager = a;
        this.nonProcessedArgs = [];
        this._isPathOp = !1;
        this._numInvalidPathOPS = 0;
    }
    get savedStatesDepth() {
        return this.stateManager.stateStack.length;
    }
    read(e1) {
        let t = e1.args;
        for(;;){
            const a = this.parser.getObj();
            if (a instanceof Cmd) {
                const r = a.cmd, i = EvaluatorPreprocessor.opMap[r];
                if (!i) {
                    warn(`Unknown command "${r}".`);
                    continue;
                }
                const n = i.id, s = i.numArgs;
                let o = null !== t ? t.length : 0;
                this._isPathOp || (this._numInvalidPathOPS = 0);
                this._isPathOp = n >= ye && n <= Re;
                if (i.variableArgs) o > s && info(`Command ${r}: expected [0, ${s}] args, but received ${o} args.`);
                else {
                    if (o !== s) {
                        const e1 = this.nonProcessedArgs;
                        for(; o > s;){
                            e1.push(t.shift());
                            o--;
                        }
                        for(; o < s && 0 !== e1.length;){
                            null === t && (t = []);
                            t.unshift(e1.pop());
                            o++;
                        }
                    }
                    if (o < s) {
                        const e1 = `command ${r}: expected ${s} args, but received ${o} args.`;
                        if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e1}`);
                        warn(`Skipping ${e1}`);
                        null !== t && (t.length = 0);
                        continue;
                    }
                }
                this.preprocessCommand(n, t);
                e1.fn = n;
                e1.args = t;
                return !0;
            }
            if (a === aa) return !1;
            if (null !== a) {
                null === t && (t = []);
                t.push(a);
                if (t.length > 33) throw new FormatError("Too many arguments");
            }
        }
    }
    preprocessCommand(e1, t) {
        switch(0 | e1){
            case pe:
                this.stateManager.save();
                break;
            case me:
                this.stateManager.restore();
                break;
            case be:
                this.stateManager.transform(t);
        }
    }
}
class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
    constructor(e1){
        super(new StringStream(e1));
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        }, t = {
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3)
        };
        try {
            for(;;){
                e1.args.length = 0;
                if (!this.read(e1)) break;
                if (0 !== this.savedStatesDepth) continue;
                const { fn: a, args: r } = e1;
                switch(0 | a){
                    case qe:
                        const [e2, a1] = r;
                        e2 instanceof Name && (t.fontName = e2.name);
                        "number" == typeof a1 && a1 > 0 && (t.fontSize = a1);
                        break;
                    case ht:
                        ColorSpaceUtils.rgb.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case ct:
                        ColorSpaceUtils.gray.getRgbItem(r, 0, t.fontColor, 0);
                        break;
                    case dt:
                        ColorSpaceUtils.cmyk.getRgbItem(r, 0, t.fontColor, 0);
                }
            }
        } catch (e1) {
            warn(`parseDefaultAppearance - ignoring errors: "${e1}".`);
        }
        return t;
    }
}
function parseDefaultAppearance(e1) {
    return new DefaultAppearanceEvaluator(e1).parse();
}
class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
    constructor(e1, t, a, r){
        super(e1);
        this.stream = e1;
        this.evaluatorOptions = t;
        this.xref = a;
        this.globalColorSpaceCache = r;
        this.resources = e1.dict?.get("Resources");
    }
    parse() {
        const e1 = {
            fn: 0,
            args: []
        };
        let t = {
            scaleFactor: 1,
            fontSize: 0,
            fontName: "",
            fontColor: new Uint8ClampedArray(3),
            fillColorSpace: ColorSpaceUtils.gray
        }, a = !1;
        const r = [];
        try {
            for(;;){
                e1.args.length = 0;
                if (a || !this.read(e1)) break;
                const { fn: i, args: n } = e1;
                switch(0 | i){
                    case pe:
                        r.push({
                            scaleFactor: t.scaleFactor,
                            fontSize: t.fontSize,
                            fontName: t.fontName,
                            fontColor: t.fontColor.slice(),
                            fillColorSpace: t.fillColorSpace
                        });
                        break;
                    case me:
                        t = r.pop() || t;
                        break;
                    case Ge:
                        t.scaleFactor *= Math.hypot(n[0], n[1]);
                        break;
                    case qe:
                        const [e2, i1] = n;
                        e2 instanceof Name && (t.fontName = e2.name);
                        "number" == typeof i1 && i1 > 0 && (t.fontSize = i1 * t.scaleFactor);
                        break;
                    case at:
                        t.fillColorSpace = ColorSpaceUtils.parse({
                            cs: n[0],
                            xref: this.xref,
                            resources: this.resources,
                            pdfFunctionFactory: this._pdfFunctionFactory,
                            globalColorSpaceCache: this.globalColorSpaceCache,
                            localColorSpaceCache: this._localColorSpaceCache
                        });
                        break;
                    case nt:
                        t.fillColorSpace.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case ht:
                        ColorSpaceUtils.rgb.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case ct:
                        ColorSpaceUtils.gray.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case dt:
                        ColorSpaceUtils.cmyk.getRgbItem(n, 0, t.fontColor, 0);
                        break;
                    case Ke:
                    case Je:
                    case Ye:
                    case Ze:
                        a = !0;
                }
            }
        } catch (e1) {
            warn(`parseAppearanceStream - ignoring errors: "${e1}".`);
        }
        this.stream.reset();
        delete t.scaleFactor;
        delete t.fillColorSpace;
        return t;
    }
    get _localColorSpaceCache() {
        return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache);
    }
    get _pdfFunctionFactory() {
        return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
            xref: this.xref,
            isEvalSupported: this.evaluatorOptions.isEvalSupported
        }));
    }
}
function getPdfColor(e1, t) {
    if (e1[0] === e1[1] && e1[1] === e1[2]) {
        return `${numberToString(e1[0] / 255)} ${t ? "g" : "G"}`;
    }
    return Array.from(e1, (e1)=>numberToString(e1 / 255)).join(" ") + " " + (t ? "rg" : "RG");
}
class FakeUnicodeFont {
    constructor(e1, t){
        this.xref = e1;
        this.widths = null;
        this.firstChar = 1 / 0;
        this.lastChar = -1 / 0;
        this.fontFamily = t;
        const a = new OffscreenCanvas(1, 1);
        this.ctxMeasure = a.getContext("2d", {
            willReadFrequently: !0
        });
        FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1);
        this.fontName = Name.get(`InvalidPDFjsFont_${t}_${FakeUnicodeFont._fontNameId++}`);
    }
    get fontDescriptorRef() {
        if (!FakeUnicodeFont._fontDescriptorRef) {
            const e1 = new Dict(this.xref);
            e1.setIfName("Type", "FontDescriptor");
            e1.set("FontName", this.fontName);
            e1.set("FontFamily", "MyriadPro Regular");
            e1.set("FontBBox", [
                0,
                0,
                0,
                0
            ]);
            e1.setIfName("FontStretch", "Normal");
            e1.set("FontWeight", 400);
            e1.set("ItalicAngle", 0);
            FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e1);
        }
        return FakeUnicodeFont._fontDescriptorRef;
    }
    get descendantFontRef() {
        const e1 = new Dict(this.xref);
        e1.set("BaseFont", this.fontName);
        e1.setIfName("Type", "Font");
        e1.setIfName("Subtype", "CIDFontType0");
        e1.setIfName("CIDToGIDMap", "Identity");
        e1.set("FirstChar", this.firstChar);
        e1.set("LastChar", this.lastChar);
        e1.set("FontDescriptor", this.fontDescriptorRef);
        e1.set("DW", 1e3);
        const t = [], a = [
            ...this.widths.entries()
        ].sort();
        let r = null, i = null;
        for (const [e1, n] of a)if (r) if (e1 === r + i.length) i.push(n);
        else {
            t.push(r, i);
            r = e1;
            i = [
                n
            ];
        }
        else {
            r = e1;
            i = [
                n
            ];
        }
        r && t.push(r, i);
        e1.set("W", t);
        const n = new Dict(this.xref);
        n.set("Ordering", "Identity");
        n.set("Registry", "Adobe");
        n.set("Supplement", 0);
        e1.set("CIDSystemInfo", n);
        return this.xref.getNewPersistentRef(e1);
    }
    get baseFontRef() {
        const e1 = new Dict(this.xref);
        e1.set("BaseFont", this.fontName);
        e1.setIfName("Type", "Font");
        e1.setIfName("Subtype", "Type0");
        e1.setIfName("Encoding", "Identity-H");
        e1.set("DescendantFonts", [
            this.descendantFontRef
        ]);
        e1.setIfName("ToUnicode", "Identity-H");
        return this.xref.getNewPersistentRef(e1);
    }
    get resources() {
        const e1 = new Dict(this.xref), t = new Dict(this.xref);
        t.set(this.fontName.name, this.baseFontRef);
        e1.set("Font", t);
        return e1;
    }
    _createContext() {
        this.widths = new Map;
        this.ctxMeasure.font = `1000px ${this.fontFamily}`;
        return this.ctxMeasure;
    }
    createFontResources(e1) {
        const t = this._createContext();
        for (const a of e1.split(/\r\n?|\n/))for (const e1 of a.split("")){
            const a = e1.charCodeAt(0);
            if (this.widths.has(a)) continue;
            const r = t.measureText(e1), i = Math.ceil(r.width);
            this.widths.set(a, i);
            this.firstChar = Math.min(a, this.firstChar);
            this.lastChar = Math.max(a, this.lastChar);
        }
        return this.resources;
    }
    static getFirstPositionInfo(e1, t, i) {
        const [n, s, o, c] = e1;
        let l = o - n, h = c - s;
        t % 180 != 0 && ([l, h] = [
            h,
            l
        ]);
        const u = a * i;
        return {
            coords: [
                0,
                h + r * i - u
            ],
            bbox: [
                0,
                0,
                l,
                h
            ],
            matrix: 0 !== t ? getRotationMatrix(t, h, u) : void 0
        };
    }
    createAppearance(e1, t, i, n, s, o) {
        const c = this._createContext(), l = [];
        let h = -1 / 0;
        for (const t of e1.split(/\r\n?|\n/)){
            l.push(t);
            const e1 = c.measureText(t).width;
            h = Math.max(h, e1);
            for (const e1 of codePointIter(t)){
                const t = String.fromCodePoint(e1);
                let a = this.widths.get(e1);
                if (void 0 === a) {
                    const r = c.measureText(t);
                    a = Math.ceil(r.width);
                    this.widths.set(e1, a);
                    this.firstChar = Math.min(e1, this.firstChar);
                    this.lastChar = Math.max(e1, this.lastChar);
                }
            }
        }
        h *= n / 1e3;
        const [u, d, f, g] = t;
        let p = f - u, m = g - d;
        i % 180 != 0 && ([p, m] = [
            m,
            p
        ]);
        let b = 1;
        h > p && (b = p / h);
        let y = 1;
        const w = a * n, x = r * n, S = w * l.length;
        S > m && (y = m / S);
        const k = n * Math.min(b, y), C = [
            "q",
            `0 0 ${numberToString(p)} ${numberToString(m)} re W n`,
            "BT",
            `1 0 0 1 0 ${numberToString(m + x)} Tm 0 Tc ${getPdfColor(s, !0)}`,
            `/${this.fontName.name} ${numberToString(k)} Tf`
        ], { resources: v } = this;
        if (1 !== (o = "number" == typeof o && o >= 0 && o <= 1 ? o : 1)) {
            C.push("/R0 gs");
            const e1 = new Dict(this.xref), t = new Dict(this.xref);
            t.set("ca", o);
            t.set("CA", o);
            t.setIfName("Type", "ExtGState");
            e1.set("R0", t);
            v.set("ExtGState", e1);
        }
        const F = numberToString(w);
        for (const e1 of l)C.push(`0 -${F} Td <${stringToUTF16HexString(e1)}> Tj`);
        C.push("ET", "Q");
        const T = C.join("\n"), O = new Dict(this.xref);
        O.setIfName("Subtype", "Form");
        O.setIfName("Type", "XObject");
        O.set("BBox", [
            0,
            0,
            p,
            m
        ]);
        O.set("Length", T.length);
        O.set("Resources", v);
        if (i) {
            const e1 = getRotationMatrix(i, p, m);
            O.set("Matrix", e1);
        }
        const M = new StringStream(T);
        M.dict = O;
        return M;
    }
}
const wn = [
    "m/d",
    "m/d/yy",
    "mm/dd/yy",
    "mm/yy",
    "d-mmm",
    "d-mmm-yy",
    "dd-mmm-yy",
    "yy-mm-dd",
    "mmm-yy",
    "mmmm-yy",
    "mmm d, yyyy",
    "mmmm d, yyyy",
    "m/d/yy h:MM tt",
    "m/d/yy HH:MM"
], xn = [
    "HH:MM",
    "h:MM tt",
    "HH:MM:ss",
    "h:MM:ss tt"
];
class NameOrNumberTree {
    constructor(e1, t, a){
        this.root = e1;
        this.xref = t;
        this._type = a;
    }
    getAll() {
        const e1 = new Map;
        if (!this.root) return e1;
        const t = this.xref, a = new RefSet;
        a.put(this.root);
        const r = [
            this.root
        ];
        for(; r.length > 0;){
            const i = t.fetchIfRef(r.shift());
            if (!(i instanceof Dict)) continue;
            if (i.has("Kids")) {
                const e1 = i.get("Kids");
                if (!Array.isArray(e1)) continue;
                for (const t of e1){
                    if (a.has(t)) throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
                    r.push(t);
                    a.put(t);
                }
                continue;
            }
            const n = i.get(this._type);
            if (Array.isArray(n)) for(let a = 0, r = n.length; a < r; a += 2)e1.set(t.fetchIfRef(n[a]), t.fetchIfRef(n[a + 1]));
        }
        return e1;
    }
    getRaw(e1) {
        if (!this.root) return null;
        const t = this.xref;
        let a = t.fetchIfRef(this.root), r = 0;
        for(; a.has("Kids");){
            if (++r > 10) {
                warn(`Search depth limit reached for "${this._type}" tree.`);
                return null;
            }
            const i = a.get("Kids");
            if (!Array.isArray(i)) return null;
            let n = 0, s = i.length - 1;
            for(; n <= s;){
                const r = n + s >> 1, o = t.fetchIfRef(i[r]), c = o.get("Limits");
                if (e1 < t.fetchIfRef(c[0])) s = r - 1;
                else {
                    if (!(e1 > t.fetchIfRef(c[1]))) {
                        a = o;
                        break;
                    }
                    n = r + 1;
                }
            }
            if (n > s) return null;
        }
        const i = a.get(this._type);
        if (Array.isArray(i)) {
            let a = 0, r = i.length - 2;
            for(; a <= r;){
                const n = a + r >> 1, s = n + (1 & n), o = t.fetchIfRef(i[s]);
                if (e1 < o) r = s - 2;
                else {
                    if (!(e1 > o)) return i[s + 1];
                    a = s + 2;
                }
            }
        }
        return null;
    }
    get(e1) {
        return this.xref.fetchIfRef(this.getRaw(e1));
    }
}
class NameTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Names");
    }
}
class NumberTree extends NameOrNumberTree {
    constructor(e1, t){
        super(e1, t, "Nums");
    }
}
function clearGlobalCaches() {
    !function clearPatternCaches() {
        hi = Object.create(null);
    }();
    !function clearPrimitiveCaches() {
        ra = Object.create(null);
        ia = Object.create(null);
        na = Object.create(null);
    }();
    !function clearUnicodeCaches() {
        gr.clear();
    }();
    JpxImage.cleanup();
}
function pickPlatformItem(e1) {
    return e1 instanceof Dict ? e1.has("UF") ? e1.get("UF") : e1.has("F") ? e1.get("F") : e1.has("Unix") ? e1.get("Unix") : e1.has("Mac") ? e1.get("Mac") : e1.has("DOS") ? e1.get("DOS") : null : null;
}
class FileSpec {
    #Y = !1;
    constructor(e1, t, a = !1){
        if (e1 instanceof Dict) {
            this.xref = t;
            this.root = e1;
            e1.has("FS") && (this.fs = e1.get("FS"));
            e1.has("RF") && warn("Related file specifications are not supported");
            a || (e1.has("EF") ? this.#Y = !0 : warn("Non-embedded file specifications are not supported"));
        }
    }
    get filename() {
        let e1 = "";
        const t = pickPlatformItem(this.root);
        t && "string" == typeof t && (e1 = stringToPDFString(t, !0).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/"));
        return shadow(this, "filename", e1 || "unnamed");
    }
    get content() {
        if (!this.#Y) return null;
        this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
        let e1 = null;
        if (this._contentRef) {
            const t = this.xref.fetchIfRef(this._contentRef);
            t instanceof BaseStream ? e1 = t.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
        } else warn("Embedded file specification does not have any content");
        return e1;
    }
    get description() {
        let e1 = "";
        const t = this.root?.get("Desc");
        t && "string" == typeof t && (e1 = stringToPDFString(t));
        return shadow(this, "description", e1);
    }
    get serializable() {
        return {
            rawFilename: this.filename,
            filename: (e1 = this.filename, e1.substring(e1.lastIndexOf("/") + 1)),
            content: this.content,
            description: this.description
        };
        //TURBOPACK unreachable
        ;
        var e1;
    }
}
const Sn = 0, An = -2, kn = -3, Cn = -4, vn = -5, Fn = -6, In = -9;
function isWhitespace(e1, t) {
    const a = e1[t];
    return " " === a || "\n" === a || "\r" === a || "\t" === a;
}
class XMLParserBase {
    _resolveEntities(e1) {
        return e1.replaceAll(/&([^;]+);/g, (e1, t)=>{
            if ("#x" === t.substring(0, 2)) return String.fromCodePoint(parseInt(t.substring(2), 16));
            if ("#" === t.substring(0, 1)) return String.fromCodePoint(parseInt(t.substring(1), 10));
            switch(t){
                case "lt":
                    return "<";
                case "gt":
                    return ">";
                case "amp":
                    return "&";
                case "quot":
                    return '"';
                case "apos":
                    return "'";
            }
            return this.onResolveEntity(t);
        });
    }
    _parseContent(e1, t) {
        const a = [];
        let r = t;
        function skipWs() {
            for(; r < e1.length && isWhitespace(e1, r);)++r;
        }
        for(; r < e1.length && !isWhitespace(e1, r) && ">" !== e1[r] && "/" !== e1[r];)++r;
        const i = e1.substring(t, r);
        skipWs();
        for(; r < e1.length && ">" !== e1[r] && "/" !== e1[r] && "?" !== e1[r];){
            skipWs();
            let t = "", i = "";
            for(; r < e1.length && !isWhitespace(e1, r) && "=" !== e1[r];){
                t += e1[r];
                ++r;
            }
            skipWs();
            if ("=" !== e1[r]) return null;
            ++r;
            skipWs();
            const n = e1[r];
            if ('"' !== n && "'" !== n) return null;
            const s = e1.indexOf(n, ++r);
            if (s < 0) return null;
            i = e1.substring(r, s);
            a.push({
                name: t,
                value: this._resolveEntities(i)
            });
            r = s + 1;
            skipWs();
        }
        return {
            name: i,
            attributes: a,
            parsed: r - t
        };
    }
    _parseProcessingInstruction(e1, t) {
        let a = t;
        for(; a < e1.length && !isWhitespace(e1, a) && ">" !== e1[a] && "?" !== e1[a] && "/" !== e1[a];)++a;
        const r = e1.substring(t, a);
        !function skipWs() {
            for(; a < e1.length && isWhitespace(e1, a);)++a;
        }();
        const i = a;
        for(; a < e1.length && ("?" !== e1[a] || ">" !== e1[a + 1]);)++a;
        return {
            name: r,
            value: e1.substring(i, a),
            parsed: a - t
        };
    }
    parseXml(e1) {
        let t = 0;
        for(; t < e1.length;){
            let a = t;
            if ("<" === e1[t]) {
                ++a;
                let t;
                switch(e1[a]){
                    case "/":
                        ++a;
                        t = e1.indexOf(">", a);
                        if (t < 0) {
                            this.onError(In);
                            return;
                        }
                        this.onEndElement(e1.substring(a, t));
                        a = t + 1;
                        break;
                    case "?":
                        ++a;
                        const r = this._parseProcessingInstruction(e1, a);
                        if ("?>" !== e1.substring(a + r.parsed, a + r.parsed + 2)) {
                            this.onError(kn);
                            return;
                        }
                        this.onPi(r.name, r.value);
                        a += r.parsed + 2;
                        break;
                    case "!":
                        if ("--" === e1.substring(a + 1, a + 3)) {
                            t = e1.indexOf("--\x3e", a + 3);
                            if (t < 0) {
                                this.onError(vn);
                                return;
                            }
                            this.onComment(e1.substring(a + 3, t));
                            a = t + 3;
                        } else if ("[CDATA[" === e1.substring(a + 1, a + 8)) {
                            t = e1.indexOf("]]>", a + 8);
                            if (t < 0) {
                                this.onError(An);
                                return;
                            }
                            this.onCdata(e1.substring(a + 8, t));
                            a = t + 3;
                        } else {
                            if ("DOCTYPE" !== e1.substring(a + 1, a + 8)) {
                                this.onError(Fn);
                                return;
                            }
                            {
                                const r = e1.indexOf("[", a + 8);
                                let i = !1;
                                t = e1.indexOf(">", a + 8);
                                if (t < 0) {
                                    this.onError(Cn);
                                    return;
                                }
                                if (r > 0 && t > r) {
                                    t = e1.indexOf("]>", a + 8);
                                    if (t < 0) {
                                        this.onError(Cn);
                                        return;
                                    }
                                    i = !0;
                                }
                                const n = e1.substring(a + 8, t + (i ? 1 : 0));
                                this.onDoctype(n);
                                a = t + (i ? 2 : 1);
                            }
                        }
                        break;
                    default:
                        const i = this._parseContent(e1, a);
                        if (null === i) {
                            this.onError(Fn);
                            return;
                        }
                        let n = !1;
                        if ("/>" === e1.substring(a + i.parsed, a + i.parsed + 2)) n = !0;
                        else if (">" !== e1.substring(a + i.parsed, a + i.parsed + 1)) {
                            this.onError(In);
                            return;
                        }
                        this.onBeginElement(i.name, i.attributes, n);
                        a += i.parsed + (n ? 2 : 1);
                }
            } else {
                for(; a < e1.length && "<" !== e1[a];)a++;
                const r = e1.substring(t, a);
                this.onText(this._resolveEntities(r));
            }
            t = a;
        }
    }
    onResolveEntity(e1) {
        return `&${e1};`;
    }
    onPi(e1, t) {}
    onComment(e1) {}
    onCdata(e1) {}
    onDoctype(e1) {}
    onText(e1) {}
    onBeginElement(e1, t, a) {}
    onEndElement(e1) {}
    onError(e1) {}
}
class SimpleDOMNode {
    constructor(e1, t){
        this.nodeName = e1;
        this.nodeValue = t;
        Object.defineProperty(this, "parentNode", {
            value: null,
            writable: !0
        });
    }
    get firstChild() {
        return this.childNodes?.[0];
    }
    get nextSibling() {
        const e1 = this.parentNode.childNodes;
        if (!e1) return;
        const t = e1.indexOf(this);
        return -1 !== t ? e1[t + 1] : void 0;
    }
    get textContent() {
        return this.childNodes ? this.childNodes.map((e1)=>e1.textContent).join("") : this.nodeValue || "";
    }
    get children() {
        return this.childNodes || [];
    }
    hasChildNodes() {
        return this.childNodes?.length > 0;
    }
    searchNode(e1, t) {
        if (t >= e1.length) return this;
        const a = e1[t];
        if (a.name.startsWith("#") && t < e1.length - 1) return this.searchNode(e1, t + 1);
        const r = [];
        let i = this;
        for(;;){
            if (a.name === i.nodeName) {
                if (0 !== a.pos) {
                    if (0 === r.length) return null;
                    {
                        const [n] = r.pop();
                        let s = 0;
                        for (const r of n.childNodes)if (a.name === r.nodeName) {
                            if (s === a.pos) return r.searchNode(e1, t + 1);
                            s++;
                        }
                        return i.searchNode(e1, t + 1);
                    }
                }
                {
                    const a = i.searchNode(e1, t + 1);
                    if (null !== a) return a;
                }
            }
            if (i.childNodes?.length > 0) {
                r.push([
                    i,
                    0
                ]);
                i = i.childNodes[0];
            } else {
                if (0 === r.length) return null;
                for(; 0 !== r.length;){
                    const [e1, t] = r.pop(), a = t + 1;
                    if (a < e1.childNodes.length) {
                        r.push([
                            e1,
                            a
                        ]);
                        i = e1.childNodes[a];
                        break;
                    }
                }
                if (0 === r.length) return null;
            }
        }
    }
    dump(e1) {
        if ("#text" !== this.nodeName) {
            e1.push(`<${this.nodeName}`);
            if (this.attributes) for (const t of this.attributes)e1.push(` ${t.name}="${encodeToXmlString(t.value)}"`);
            if (this.hasChildNodes()) {
                e1.push(">");
                for (const t of this.childNodes)t.dump(e1);
                e1.push(`</${this.nodeName}>`);
            } else this.nodeValue ? e1.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e1.push("/>");
        } else e1.push(encodeToXmlString(this.nodeValue));
    }
}
class SimpleXMLParser extends XMLParserBase {
    constructor({ hasAttributes: e1 = !1, lowerCaseName: t = !1 }){
        super();
        this._currentFragment = null;
        this._stack = null;
        this._errorCode = Sn;
        this._hasAttributes = e1;
        this._lowerCaseName = t;
    }
    parseFromString(e1) {
        this._currentFragment = [];
        this._stack = [];
        this._errorCode = Sn;
        this.parseXml(e1);
        if (this._errorCode !== Sn) return;
        const [t] = this._currentFragment;
        return t ? {
            documentElement: t
        } : void 0;
    }
    onText(e1) {
        if (function isWhitespaceString(e1) {
            for(let t = 0, a = e1.length; t < a; t++)if (!isWhitespace(e1, t)) return !1;
            return !0;
        }(e1)) return;
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onCdata(e1) {
        const t = new SimpleDOMNode("#text", e1);
        this._currentFragment.push(t);
    }
    onBeginElement(e1, t, a) {
        this._lowerCaseName && (e1 = e1.toLowerCase());
        const r = new SimpleDOMNode(e1);
        r.childNodes = [];
        this._hasAttributes && (r.attributes = t);
        this._currentFragment.push(r);
        if (!a) {
            this._stack.push(this._currentFragment);
            this._currentFragment = r.childNodes;
        }
    }
    onEndElement(e1) {
        this._currentFragment = this._stack.pop() || [];
        const t = this._currentFragment.at(-1);
        if (!t) return null;
        for (const e1 of t.childNodes)e1.parentNode = t;
        return t;
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class MetadataParser {
    constructor(e1){
        e1 = this._repair(e1);
        const t = new SimpleXMLParser({
            lowerCaseName: !0
        }).parseFromString(e1);
        this._metadataMap = new Map;
        this._data = e1;
        t && this._parse(t);
    }
    _repair(e1) {
        return e1.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e1, t) {
            const a = t.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e1, t, a, r) {
                return String.fromCharCode(64 * t + 8 * a + 1 * r);
            }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e1, t) {
                switch(t){
                    case "amp":
                        return "&";
                    case "apos":
                        return "'";
                    case "gt":
                        return ">";
                    case "lt":
                        return "<";
                    case "quot":
                        return '"';
                }
                throw new Error(`_repair: ${t} isn't defined.`);
            }), r = [
                ">"
            ];
            for(let e1 = 0, t = a.length; e1 < t; e1 += 2){
                const t = 256 * a.charCodeAt(e1) + a.charCodeAt(e1 + 1);
                t >= 32 && t < 127 && 60 !== t && 62 !== t && 38 !== t ? r.push(String.fromCharCode(t)) : r.push("&#x" + (65536 + t).toString(16).substring(1) + ";");
            }
            return r.join("");
        });
    }
    _getSequence(e1) {
        const t = e1.nodeName;
        return "rdf:bag" !== t && "rdf:seq" !== t && "rdf:alt" !== t ? null : e1.childNodes.filter((e1)=>"rdf:li" === e1.nodeName);
    }
    _parseArray(e1) {
        if (!e1.hasChildNodes()) return;
        const [t] = e1.childNodes, a = this._getSequence(t) || [];
        this._metadataMap.set(e1.nodeName, a.map((e1)=>e1.textContent.trim()));
    }
    _parse(e1) {
        let t = e1.documentElement;
        if ("rdf:rdf" !== t.nodeName) {
            t = t.firstChild;
            for(; t && "rdf:rdf" !== t.nodeName;)t = t.nextSibling;
        }
        if (t && "rdf:rdf" === t.nodeName && t.hasChildNodes()) {
            for (const e1 of t.childNodes)if ("rdf:description" === e1.nodeName) for (const t of e1.childNodes){
                const e1 = t.nodeName;
                switch(e1){
                    case "#text":
                        continue;
                    case "dc:creator":
                    case "dc:subject":
                        this._parseArray(t);
                        continue;
                }
                this._metadataMap.set(e1, t.textContent.trim());
            }
        }
    }
    get serializable() {
        return {
            parsedData: this._metadataMap,
            rawData: this._data
        };
    }
}
const Tn = 1, On = 2, Mn = 3, Dn = 4, Bn = 5;
class StructTreeRoot {
    constructor(e1, t, a){
        this.xref = e1;
        this.dict = t;
        this.ref = a instanceof Ref ? a : null;
        this.roleMap = new Map;
        this.structParentIds = null;
    }
    init() {
        this.readRoleMap();
    }
    #Z(e1, t, a) {
        if (!(e1 instanceof Ref) || t < 0) return;
        this.structParentIds ||= new RefSetCache;
        let r = this.structParentIds.get(e1);
        if (!r) {
            r = [];
            this.structParentIds.put(e1, r);
        }
        r.push([
            t,
            a
        ]);
    }
    addAnnotationIdToPage(e1, t) {
        this.#Z(e1, t, Dn);
    }
    readRoleMap() {
        const e1 = this.dict.get("RoleMap");
        if (e1 instanceof Dict) for (const [t, a] of e1)a instanceof Name && this.roleMap.set(t, a.name);
    }
    static async canCreateStructureTree({ catalogRef: e1, pdfManager: t, newAnnotationsByPage: a }) {
        if (!(e1 instanceof Ref)) {
            warn("Cannot save the struct tree: no catalog reference.");
            return !1;
        }
        let r = 0, i = !0;
        for (const [e1, n] of a){
            const { ref: a } = await t.getPage(e1);
            if (!(a instanceof Ref)) {
                warn(`Cannot save the struct tree: page ${e1} has no ref.`);
                i = !0;
                break;
            }
            for (const e1 of n)if (e1.accessibilityData?.type) {
                e1.parentTreeId = r++;
                i = !1;
            }
        }
        if (i) {
            for (const e1 of a.values())for (const t of e1)delete t.parentTreeId;
            return !1;
        }
        return !0;
    }
    static async createStructureTree({ newAnnotationsByPage: e1, xref: t, catalogRef: a, pdfManager: r, changes: i }) {
        const n = await r.ensureCatalog("cloneDict"), s = new RefSetCache;
        s.put(a, n);
        const o = t.getNewTemporaryRef();
        n.set("StructTreeRoot", o);
        const c = new Dict(t);
        c.set("Type", Name.get("StructTreeRoot"));
        const l = t.getNewTemporaryRef();
        c.set("ParentTree", l);
        const h = [];
        c.set("K", h);
        s.put(o, c);
        const u = new Dict(t), d = [];
        u.set("Nums", d);
        const f = await this.#Q({
            newAnnotationsByPage: e1,
            structTreeRootRef: o,
            structTreeRoot: null,
            kids: h,
            nums: d,
            xref: t,
            pdfManager: r,
            changes: i,
            cache: s
        });
        c.set("ParentTreeNextKey", f);
        s.put(l, u);
        for (const [e1, t] of s.items())i.put(e1, {
            data: t
        });
    }
    async canUpdateStructTree({ pdfManager: e1, newAnnotationsByPage: t }) {
        if (!this.ref) {
            warn("Cannot update the struct tree: no root reference.");
            return !1;
        }
        let a = this.dict.get("ParentTreeNextKey");
        if (!Number.isInteger(a) || a < 0) {
            warn("Cannot update the struct tree: invalid next key.");
            return !1;
        }
        const r = this.dict.get("ParentTree");
        if (!(r instanceof Dict)) {
            warn("Cannot update the struct tree: ParentTree isn't a dict.");
            return !1;
        }
        const i = r.get("Nums");
        if (!Array.isArray(i)) {
            warn("Cannot update the struct tree: nums isn't an array.");
            return !1;
        }
        const n = new NumberTree(r, this.xref);
        for (const a of t.keys()){
            const { pageDict: t } = await e1.getPage(a);
            if (!t.has("StructParents")) continue;
            const r = t.get("StructParents");
            if (!Number.isInteger(r) || !Array.isArray(n.get(r))) {
                warn(`Cannot save the struct tree: page ${a} has a wrong id.`);
                return !1;
            }
        }
        let s = !0;
        for (const [r, i] of t){
            const { pageDict: t } = await e1.getPage(r);
            StructTreeRoot.#ee({
                elements: i,
                xref: this.xref,
                pageDict: t,
                numberTree: n
            });
            for (const e1 of i)if (e1.accessibilityData?.type) {
                e1.accessibilityData.structParent >= 0 || (e1.parentTreeId = a++);
                s = !1;
            }
        }
        if (s) {
            for (const e1 of t.values())for (const t of e1){
                delete t.parentTreeId;
                delete t.structTreeParent;
            }
            return !1;
        }
        return !0;
    }
    async updateStructureTree({ newAnnotationsByPage: e1, pdfManager: t, changes: a }) {
        const { ref: r, xref: i } = this, n = this.dict.clone(), s = new RefSetCache;
        s.put(r, n);
        let o, c = n.getRaw("ParentTree");
        if (c instanceof Ref) o = i.fetch(c);
        else {
            o = c;
            c = i.getNewTemporaryRef();
            n.set("ParentTree", c);
        }
        o = o.clone();
        s.put(c, o);
        let l = o.getRaw("Nums"), h = null;
        if (l instanceof Ref) {
            h = l;
            l = i.fetch(h);
        }
        l = l.slice();
        h || o.set("Nums", l);
        const u = await StructTreeRoot.#Q({
            newAnnotationsByPage: e1,
            structTreeRootRef: r,
            structTreeRoot: this,
            kids: null,
            nums: l,
            xref: i,
            pdfManager: t,
            changes: a,
            cache: s
        });
        if (-1 !== u) {
            n.set("ParentTreeNextKey", u);
            h && s.put(h, l);
            for (const [e1, t] of s.items())a.put(e1, {
                data: t
            });
        }
    }
    static async #Q({ newAnnotationsByPage: e1, structTreeRootRef: t, structTreeRoot: a, kids: r, nums: i, xref: n, pdfManager: s, changes: o, cache: c }) {
        const l = Name.get("OBJR");
        let h, u = -1;
        for (const [d, f] of e1){
            const e1 = await s.getPage(d), { ref: g } = e1, p = g instanceof Ref;
            for (const { accessibilityData: s, ref: m, parentTreeId: b, structTreeParent: y } of f){
                if (!s?.type) continue;
                const { structParent: f } = s;
                if (a && Number.isInteger(f) && f >= 0) {
                    let t = (h ||= new Map).get(d);
                    if (void 0 === t) {
                        t = new StructTreePage(a, e1.pageDict).collectObjects(g);
                        h.set(d, t);
                    }
                    const r = t?.get(f);
                    if (r) {
                        const e1 = n.fetch(r).clone();
                        StructTreeRoot.#te(e1, s);
                        o.put(r, {
                            data: e1
                        });
                        continue;
                    }
                }
                u = Math.max(u, b);
                const w = n.getNewTemporaryRef(), x = new Dict(n);
                StructTreeRoot.#te(x, s);
                await this.#ae({
                    structTreeParent: y,
                    tagDict: x,
                    newTagRef: w,
                    structTreeRootRef: t,
                    fallbackKids: r,
                    xref: n,
                    cache: c
                });
                const S = new Dict(n);
                x.set("K", S);
                S.set("Type", l);
                p && S.set("Pg", g);
                S.set("Obj", m);
                c.put(w, x);
                i.push(b, w);
            }
        }
        return u + 1;
    }
    static #te(e1, { type: t, title: a, lang: r, alt: i, expanded: n, actualText: s }) {
        e1.set("S", Name.get(t));
        a && e1.set("T", stringToAsciiOrUTF16BE(a));
        r && e1.set("Lang", stringToAsciiOrUTF16BE(r));
        i && e1.set("Alt", stringToAsciiOrUTF16BE(i));
        n && e1.set("E", stringToAsciiOrUTF16BE(n));
        s && e1.set("ActualText", stringToAsciiOrUTF16BE(s));
    }
    static #ee({ elements: e1, xref: t, pageDict: a, numberTree: r }) {
        const i = new Map;
        for (const t of e1)if (t.structTreeParentId) {
            const e1 = parseInt(t.structTreeParentId.split("_mc")[1], 10);
            let a = i.get(e1);
            if (!a) {
                a = [];
                i.set(e1, a);
            }
            a.push(t);
        }
        const n = a.get("StructParents");
        if (!Number.isInteger(n)) return;
        const s = r.get(n), updateElement = (e1, a, r)=>{
            const n = i.get(e1);
            if (n) {
                const e1 = a.getRaw("P"), i = t.fetchIfRef(e1);
                if (e1 instanceof Ref && i instanceof Dict) {
                    const e1 = {
                        ref: r,
                        dict: a
                    };
                    for (const t of n)t.structTreeParent = e1;
                }
                return !0;
            }
            return !1;
        };
        for (const e1 of s){
            if (!(e1 instanceof Ref)) continue;
            const a = t.fetch(e1), r = a.get("K");
            if (Number.isInteger(r)) updateElement(r, a, e1);
            else if (Array.isArray(r)) for (let i of r){
                i = t.fetchIfRef(i);
                if (Number.isInteger(i) && updateElement(i, a, e1)) break;
                if (!(i instanceof Dict)) continue;
                if (!isName(i.get("Type"), "MCR")) break;
                const r = i.get("MCID");
                if (Number.isInteger(r) && updateElement(r, a, e1)) break;
            }
        }
    }
    static async #ae({ structTreeParent: e1, tagDict: t, newTagRef: a, structTreeRootRef: r, fallbackKids: i, xref: n, cache: s }) {
        let o, c = null;
        if (e1) {
            ({ ref: c } = e1);
            o = e1.dict.getRaw("P") || r;
        } else o = r;
        t.set("P", o);
        const l = n.fetchIfRef(o);
        if (!l) {
            i.push(a);
            return;
        }
        let h = s.get(o);
        if (!h) {
            h = l.clone();
            s.put(o, h);
        }
        const u = h.getRaw("K");
        let d = u instanceof Ref ? s.get(u) : null;
        if (!d) {
            d = n.fetchIfRef(u);
            d = Array.isArray(d) ? d.slice() : [
                u
            ];
            const e1 = n.getNewTemporaryRef();
            h.set("K", e1);
            s.put(e1, d);
        }
        const f = d.indexOf(c);
        d.splice(f >= 0 ? f + 1 : d.length, 0, a);
    }
}
class StructElementNode {
    constructor(e1, t){
        this.tree = e1;
        this.xref = e1.xref;
        this.dict = t;
        this.kids = [];
        this.parseKids();
    }
    get role() {
        const e1 = this.dict.get("S"), t = e1 instanceof Name ? e1.name : "", { root: a } = this.tree;
        return a.roleMap.get(t) ?? t;
    }
    parseKids() {
        let e1 = null;
        const t = this.dict.getRaw("Pg");
        t instanceof Ref && (e1 = t.toString());
        const a = this.dict.get("K");
        if (Array.isArray(a)) for (const t of a){
            const a = this.parseKid(e1, this.xref.fetchIfRef(t));
            a && this.kids.push(a);
        }
        else {
            const t = this.parseKid(e1, a);
            t && this.kids.push(t);
        }
    }
    parseKid(e1, t) {
        if (Number.isInteger(t)) return this.tree.pageDict.objId !== e1 ? null : new StructElement({
            type: Tn,
            mcid: t,
            pageObjId: e1
        });
        if (!(t instanceof Dict)) return null;
        const a = t.getRaw("Pg");
        a instanceof Ref && (e1 = a.toString());
        const r = t.get("Type") instanceof Name ? t.get("Type").name : null;
        if ("MCR" === r) {
            if (this.tree.pageDict.objId !== e1) return null;
            const a = t.getRaw("Stm");
            return new StructElement({
                type: On,
                refObjId: a instanceof Ref ? a.toString() : null,
                pageObjId: e1,
                mcid: t.get("MCID")
            });
        }
        if ("OBJR" === r) {
            if (this.tree.pageDict.objId !== e1) return null;
            const a = t.getRaw("Obj");
            return new StructElement({
                type: Mn,
                refObjId: a instanceof Ref ? a.toString() : null,
                pageObjId: e1
            });
        }
        return new StructElement({
            type: Bn,
            dict: t
        });
    }
}
class StructElement {
    constructor({ type: e1, dict: t = null, mcid: a = null, pageObjId: r = null, refObjId: i = null }){
        this.type = e1;
        this.dict = t;
        this.mcid = a;
        this.pageObjId = r;
        this.refObjId = i;
        this.parentNode = null;
    }
}
class StructTreePage {
    constructor(e1, t){
        this.root = e1;
        this.xref = e1?.xref ?? null;
        this.rootDict = e1?.dict ?? null;
        this.pageDict = t;
        this.nodes = [];
    }
    collectObjects(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return null;
        const t = this.rootDict.get("ParentTree");
        if (!t) return null;
        const a = this.root.structParentIds?.get(e1);
        if (!a) return null;
        const r = new Map, i = new NumberTree(t, this.xref);
        for (const [e1] of a){
            const t = i.getRaw(e1);
            t instanceof Ref && r.set(e1, t);
        }
        return r;
    }
    parse(e1) {
        if (!(this.root && this.rootDict && e1 instanceof Ref)) return;
        const t = this.rootDict.get("ParentTree");
        if (!t) return;
        const a = this.pageDict.get("StructParents"), r = this.root.structParentIds?.get(e1);
        if (!Number.isInteger(a) && !r) return;
        const i = new Map, n = new NumberTree(t, this.xref);
        if (Number.isInteger(a)) {
            const e1 = n.get(a);
            if (Array.isArray(e1)) for (const t of e1)t instanceof Ref && this.addNode(this.xref.fetch(t), i);
        }
        if (r) for (const [e1, t] of r){
            const a = n.get(e1);
            if (a) {
                const e1 = this.addNode(this.xref.fetchIfRef(a), i);
                1 === e1?.kids?.length && e1.kids[0].type === Mn && (e1.kids[0].type = t);
            }
        }
    }
    addNode(e1, t, a = 0) {
        if (a > 40) {
            warn("StructTree MAX_DEPTH reached.");
            return null;
        }
        if (!(e1 instanceof Dict)) return null;
        if (t.has(e1)) return t.get(e1);
        const r = new StructElementNode(this, e1);
        t.set(e1, r);
        const i = e1.get("P");
        if (!(i instanceof Dict) || isName(i.get("Type"), "StructTreeRoot")) {
            this.addTopLevelNode(e1, r) || t.delete(e1);
            return r;
        }
        const n = this.addNode(i, t, a + 1);
        if (!n) return r;
        let s = !1;
        for (const t of n.kids)if (t.type === Bn && t.dict === e1) {
            t.parentNode = r;
            s = !0;
        }
        s || t.delete(e1);
        return r;
    }
    addTopLevelNode(e1, t) {
        const a = this.rootDict.get("K");
        if (!a) return !1;
        if (a instanceof Dict) {
            if (a.objId !== e1.objId) return !1;
            this.nodes[0] = t;
            return !0;
        }
        if (!Array.isArray(a)) return !0;
        let r = !1;
        for(let i = 0; i < a.length; i++){
            const n = a[i];
            if (n?.toString() === e1.objId) {
                this.nodes[i] = t;
                r = !0;
            }
        }
        return r;
    }
    get serializable() {
        function nodeToSerializable(e1, t, a = 0) {
            if (a > 40) {
                warn("StructTree too deep to be fully serialized.");
                return;
            }
            const r = Object.create(null);
            r.role = e1.role;
            r.children = [];
            t.children.push(r);
            let i = e1.dict.get("Alt");
            "string" != typeof i && (i = e1.dict.get("ActualText"));
            "string" == typeof i && (r.alt = stringToPDFString(i));
            const n = e1.dict.get("A");
            if (n instanceof Dict) {
                const e1 = lookupNormalRect(n.getArray("BBox"), null);
                if (e1) r.bbox = e1;
                else {
                    const e1 = n.get("Width"), t = n.get("Height");
                    "number" == typeof e1 && e1 > 0 && "number" == typeof t && t > 0 && (r.bbox = [
                        0,
                        0,
                        e1,
                        t
                    ]);
                }
            }
            const s = e1.dict.get("Lang");
            "string" == typeof s && (r.lang = stringToPDFString(s));
            for (const t of e1.kids){
                const e1 = t.type === Bn ? t.parentNode : null;
                e1 ? nodeToSerializable(e1, r, a + 1) : t.type === Tn || t.type === On ? r.children.push({
                    type: "content",
                    id: `p${t.pageObjId}_mc${t.mcid}`
                }) : t.type === Mn ? r.children.push({
                    type: "object",
                    id: t.refObjId
                }) : t.type === Dn && r.children.push({
                    type: "annotation",
                    id: `pdfjs_internal_id_${t.refObjId}`
                });
            }
        }
        const e1 = Object.create(null);
        e1.children = [];
        e1.role = "Root";
        for (const t of this.nodes)t && nodeToSerializable(t, e1);
        return e1;
    }
}
const Rn = (function _isValidExplicitDest(e1, t, a) {
    if (!Array.isArray(a) || a.length < 2) return !1;
    const [r, i, ...n] = a;
    if (!e1(r) && !Number.isInteger(r)) return !1;
    if (!t(i)) return !1;
    const s = n.length;
    let o = !0;
    switch(i.name){
        case "XYZ":
            if (s < 2 || s > 3) return !1;
            break;
        case "Fit":
        case "FitB":
            return 0 === s;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
            if (s > 1) return !1;
            break;
        case "FitR":
            if (4 !== s) return !1;
            o = !1;
            break;
        default:
            return !1;
    }
    for (const e1 of n)if (!("number" == typeof e1 || o && null === e1)) return !1;
    return !0;
}).bind(null, (e1)=>e1 instanceof Ref, isName);
function fetchDest(e1) {
    e1 instanceof Dict && (e1 = e1.get("D"));
    return Rn(e1) ? e1 : null;
}
function fetchRemoteDest(e1) {
    let t = e1.get("D");
    if (t) {
        t instanceof Name && (t = t.name);
        if ("string" == typeof t) return stringToPDFString(t, !0);
        if (Rn(t)) return JSON.stringify(t);
    }
    return null;
}
class Catalog {
    #re = null;
    #ie = null;
    builtInCMapCache = new Map;
    fontCache = new RefSetCache;
    globalColorSpaceCache = new GlobalColorSpaceCache;
    globalImageCache = new GlobalImageCache;
    nonBlendModesSet = new RefSet;
    pageDictCache = new RefSetCache;
    pageIndexCache = new RefSetCache;
    pageKidsCountCache = new RefSetCache;
    standardFontDataCache = new Map;
    systemFontCache = new Map;
    constructor(e1, t){
        this.pdfManager = e1;
        this.xref = t;
        this.#ie = t.getCatalogObj();
        if (!(this.#ie instanceof Dict)) throw new FormatError("Catalog object is not a dictionary.");
        this.toplevelPagesDict;
    }
    cloneDict() {
        return this.#ie.clone();
    }
    get version() {
        const e1 = this.#ie.get("Version");
        if (e1 instanceof Name) {
            if (oa.test(e1.name)) return shadow(this, "version", e1.name);
            warn(`Invalid PDF catalog version: ${e1.name}`);
        }
        return shadow(this, "version", null);
    }
    get lang() {
        const e1 = this.#ie.get("Lang");
        return shadow(this, "lang", e1 && "string" == typeof e1 ? stringToPDFString(e1) : null);
    }
    get needsRendering() {
        const e1 = this.#ie.get("NeedsRendering");
        return shadow(this, "needsRendering", "boolean" == typeof e1 && e1);
    }
    get collection() {
        let e1 = null;
        try {
            const t = this.#ie.get("Collection");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("Cannot fetch Collection entry; assuming no collection is present.");
        }
        return shadow(this, "collection", e1);
    }
    get acroForm() {
        let e1 = null;
        try {
            const t = this.#ie.get("AcroForm");
            t instanceof Dict && t.size > 0 && (e1 = t);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("Cannot fetch AcroForm entry; assuming no forms are present.");
        }
        return shadow(this, "acroForm", e1);
    }
    get acroFormRef() {
        const e1 = this.#ie.getRaw("AcroForm");
        return shadow(this, "acroFormRef", e1 instanceof Ref ? e1 : null);
    }
    get metadata() {
        const e1 = this.#ie.getRaw("Metadata");
        if (!(e1 instanceof Ref)) return shadow(this, "metadata", null);
        let t = null;
        try {
            const a = this.xref.fetch(e1, !this.xref.encrypt?.encryptMetadata);
            if (a instanceof BaseStream && a.dict instanceof Dict) {
                const e1 = a.dict.get("Type"), r = a.dict.get("Subtype");
                if (isName(e1, "Metadata") && isName(r, "XML")) {
                    const e1 = stringToUTF8String(a.getString());
                    e1 && (t = new MetadataParser(e1).serializable);
                }
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info(`Skipping invalid Metadata: "${e1}".`);
        }
        return shadow(this, "metadata", t);
    }
    get markInfo() {
        let e1 = null;
        try {
            e1 = this.#ne();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read mark info.");
        }
        return shadow(this, "markInfo", e1);
    }
    #ne() {
        const e1 = this.#ie.get("MarkInfo");
        if (!(e1 instanceof Dict)) return null;
        const t = {
            Marked: !1,
            UserProperties: !1,
            Suspects: !1
        };
        for(const a in t){
            const r = e1.get(a);
            "boolean" == typeof r && (t[a] = r);
        }
        return t;
    }
    get structTreeRoot() {
        let e1 = null;
        try {
            e1 = this.#se();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable read to structTreeRoot info.");
        }
        return shadow(this, "structTreeRoot", e1);
    }
    #se() {
        const e1 = this.#ie.getRaw("StructTreeRoot"), t = this.xref.fetchIfRef(e1);
        if (!(t instanceof Dict)) return null;
        const a = new StructTreeRoot(this.xref, t, e1);
        a.init();
        return a;
    }
    get toplevelPagesDict() {
        const e1 = this.#ie.get("Pages");
        if (!(e1 instanceof Dict)) throw new FormatError("Invalid top-level pages dictionary.");
        return shadow(this, "toplevelPagesDict", e1);
    }
    get documentOutline() {
        let e1 = null;
        try {
            e1 = this.#oe();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read document outline.");
        }
        return shadow(this, "documentOutline", e1);
    }
    #oe() {
        let e1 = this.#ie.get("Outlines");
        if (!(e1 instanceof Dict)) return null;
        e1 = e1.getRaw("First");
        if (!(e1 instanceof Ref)) return null;
        const t = {
            items: []
        }, a = [
            {
                obj: e1,
                parent: t
            }
        ], r = new RefSet;
        r.put(e1);
        const i = this.xref, n = new Uint8ClampedArray(3);
        for(; a.length > 0;){
            const t = a.shift(), s = i.fetchIfRef(t.obj);
            if (null === s) continue;
            s.has("Title") || warn("Invalid outline item encountered.");
            const o = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: s,
                resultObj: o,
                docBaseUrl: this.baseUrl,
                docAttachments: this.attachments
            });
            const c = s.get("Title"), l = s.get("F") || 0, h = s.getArray("C"), u = s.get("Count");
            let d = n;
            !isNumberArray(h, 3) || 0 === h[0] && 0 === h[1] && 0 === h[2] || (d = ColorSpaceUtils.rgb.getRgb(h, 0));
            const f = {
                action: o.action,
                attachment: o.attachment,
                dest: o.dest,
                url: o.url,
                unsafeUrl: o.unsafeUrl,
                newWindow: o.newWindow,
                setOCGState: o.setOCGState,
                title: "string" == typeof c ? stringToPDFString(c) : "",
                color: d,
                count: Number.isInteger(u) ? u : void 0,
                bold: !!(2 & l),
                italic: !!(1 & l),
                items: []
            };
            t.parent.items.push(f);
            e1 = s.getRaw("First");
            if (e1 instanceof Ref && !r.has(e1)) {
                a.push({
                    obj: e1,
                    parent: f
                });
                r.put(e1);
            }
            e1 = s.getRaw("Next");
            if (e1 instanceof Ref && !r.has(e1)) {
                a.push({
                    obj: e1,
                    parent: t.parent
                });
                r.put(e1);
            }
        }
        return t.items.length > 0 ? t.items : null;
    }
    get permissions() {
        let e1 = null;
        try {
            e1 = this.#ce();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read permissions.");
        }
        return shadow(this, "permissions", e1);
    }
    #ce() {
        const e1 = this.xref.trailer.get("Encrypt");
        if (!(e1 instanceof Dict)) return null;
        let t = e1.get("P");
        if ("number" != typeof t) return null;
        t += 2 ** 32;
        const a = [];
        for(const e1 in w){
            const r = w[e1];
            t & r && a.push(r);
        }
        return a;
    }
    get optionalContentConfig() {
        let e1 = null;
        try {
            const t = this.#ie.get("OCProperties");
            if (!t) return shadow(this, "optionalContentConfig", null);
            const a = t.get("D");
            if (!a) return shadow(this, "optionalContentConfig", null);
            const r = t.get("OCGs");
            if (!Array.isArray(r)) return shadow(this, "optionalContentConfig", null);
            const i = new RefSetCache;
            for (const e1 of r)e1 instanceof Ref && !i.has(e1) && i.put(e1, this.#le(e1));
            e1 = this.#he(a, i);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Unable to read optional content config: ${e1}`);
        }
        return shadow(this, "optionalContentConfig", e1);
    }
    #le(e1) {
        const t = this.xref.fetch(e1), a = {
            id: e1.toString(),
            name: null,
            intent: null,
            usage: {
                print: null,
                view: null
            },
            rbGroups: []
        }, r = t.get("Name");
        "string" == typeof r && (a.name = stringToPDFString(r));
        let i = t.getArray("Intent");
        Array.isArray(i) || (i = [
            i
        ]);
        i.every((e1)=>e1 instanceof Name) && (a.intent = i.map((e1)=>e1.name));
        const n = t.get("Usage");
        if (!(n instanceof Dict)) return a;
        const s = a.usage, o = n.get("Print");
        if (o instanceof Dict) {
            const e1 = o.get("PrintState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    s.print = {
                        printState: e1.name
                    };
            }
        }
        const c = n.get("View");
        if (c instanceof Dict) {
            const e1 = c.get("ViewState");
            if (e1 instanceof Name) switch(e1.name){
                case "ON":
                case "OFF":
                    s.view = {
                        viewState: e1.name
                    };
            }
        }
        return a;
    }
    #he(e1, t) {
        function parseOnOff(e1) {
            const a = [];
            if (Array.isArray(e1)) for (const r of e1)r instanceof Ref && t.has(r) && a.push(r.toString());
            return a;
        }
        function parseOrder(e1, a = 0) {
            if (!Array.isArray(e1)) return null;
            const i = [];
            for (const n of e1){
                if (n instanceof Ref && t.has(n)) {
                    r.put(n);
                    i.push(n.toString());
                    continue;
                }
                const e1 = parseNestedOrder(n, a);
                e1 && i.push(e1);
            }
            if (a > 0) return i;
            const n = [];
            for (const [e1] of t.items())r.has(e1) || n.push(e1.toString());
            n.length && i.push({
                name: null,
                order: n
            });
            return i;
        }
        function parseNestedOrder(e1, t) {
            if (++t > i) {
                warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                return null;
            }
            const r = a.fetchIfRef(e1);
            if (!Array.isArray(r)) return null;
            const n = a.fetchIfRef(r[0]);
            if ("string" != typeof n) return null;
            const s = parseOrder(r.slice(1), t);
            return s?.length ? {
                name: stringToPDFString(n),
                order: s
            } : null;
        }
        const a = this.xref, r = new RefSet, i = 10;
        !function parseRBGroups(e1) {
            if (Array.isArray(e1)) for (const r of e1){
                const e1 = a.fetchIfRef(r);
                if (!Array.isArray(e1) || !e1.length) continue;
                const i = new Set;
                for (const a of e1)if (a instanceof Ref && t.has(a) && !i.has(a.toString())) {
                    i.add(a.toString());
                    t.get(a).rbGroups.push(i);
                }
            }
        }(e1.get("RBGroups"));
        return {
            name: "string" == typeof e1.get("Name") ? stringToPDFString(e1.get("Name")) : null,
            creator: "string" == typeof e1.get("Creator") ? stringToPDFString(e1.get("Creator")) : null,
            baseState: e1.get("BaseState") instanceof Name ? e1.get("BaseState").name : null,
            on: parseOnOff(e1.get("ON")),
            off: parseOnOff(e1.get("OFF")),
            order: parseOrder(e1.get("Order")),
            groups: [
                ...t
            ]
        };
    }
    setActualNumPages(e1 = null) {
        this.#re = e1;
    }
    get hasActualNumPages() {
        return null !== this.#re;
    }
    get _pagesCount() {
        const e1 = this.toplevelPagesDict.get("Count");
        if (!Number.isInteger(e1)) throw new FormatError("Page count in top-level pages dictionary is not an integer.");
        return shadow(this, "_pagesCount", e1);
    }
    get numPages() {
        return this.#re ?? this._pagesCount;
    }
    get destinations() {
        const e1 = this.#ue(), t = Object.create(null);
        for (const a of e1)if (a instanceof NameTree) for (const [e1, r] of a.getAll()){
            const a = fetchDest(r);
            a && (t[stringToPDFString(e1, !0)] = a);
        }
        else if (a instanceof Dict) for (const [e1, r] of a){
            const a = fetchDest(r);
            a && (t[stringToPDFString(e1, !0)] ||= a);
        }
        return shadow(this, "destinations", t);
    }
    getDestination(e1) {
        if (this.hasOwnProperty("destinations")) return this.destinations[e1] ?? null;
        const t = this.#ue();
        for (const a of t)if (a instanceof NameTree || a instanceof Dict) {
            const t = fetchDest(a.get(e1));
            if (t) return t;
        }
        if (t.length) {
            const t = this.destinations[e1];
            if (t) return t;
        }
        return null;
    }
    #ue() {
        const e1 = this.#ie.get("Names"), t = [];
        e1?.has("Dests") && t.push(new NameTree(e1.getRaw("Dests"), this.xref));
        this.#ie.has("Dests") && t.push(this.#ie.get("Dests"));
        return t;
    }
    get pageLabels() {
        let e1 = null;
        try {
            e1 = this.#de();
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn("Unable to read page labels.");
        }
        return shadow(this, "pageLabels", e1);
    }
    #de() {
        const e1 = this.#ie.getRaw("PageLabels");
        if (!e1) return null;
        const t = new Array(this.numPages);
        let a = null, r = "";
        const i = new NumberTree(e1, this.xref).getAll();
        let n = "", s = 1;
        for(let e1 = 0, o = this.numPages; e1 < o; e1++){
            const o = i.get(e1);
            if (void 0 !== o) {
                if (!(o instanceof Dict)) throw new FormatError("PageLabel is not a dictionary.");
                if (o.has("Type") && !isName(o.get("Type"), "PageLabel")) throw new FormatError("Invalid type in PageLabel dictionary.");
                if (o.has("S")) {
                    const e1 = o.get("S");
                    if (!(e1 instanceof Name)) throw new FormatError("Invalid style in PageLabel dictionary.");
                    a = e1.name;
                } else a = null;
                if (o.has("P")) {
                    const e1 = o.get("P");
                    if ("string" != typeof e1) throw new FormatError("Invalid prefix in PageLabel dictionary.");
                    r = stringToPDFString(e1);
                } else r = "";
                if (o.has("St")) {
                    const e1 = o.get("St");
                    if (!(Number.isInteger(e1) && e1 >= 1)) throw new FormatError("Invalid start in PageLabel dictionary.");
                    s = e1;
                } else s = 1;
            }
            switch(a){
                case "D":
                    n = s;
                    break;
                case "R":
                case "r":
                    n = toRomanNumerals(s, "r" === a);
                    break;
                case "A":
                case "a":
                    const e2 = 26, t1 = "a" === a ? 97 : 65, r1 = s - 1;
                    n = String.fromCharCode(t1 + r1 % e2).repeat(Math.floor(r1 / e2) + 1);
                    break;
                default:
                    if (a) throw new FormatError(`Invalid style "${a}" in PageLabel dictionary.`);
                    n = "";
            }
            t[e1] = r + n;
            s++;
        }
        return t;
    }
    get pageLayout() {
        const e1 = this.#ie.get("PageLayout");
        let t = "";
        if (e1 instanceof Name) switch(e1.name){
            case "SinglePage":
            case "OneColumn":
            case "TwoColumnLeft":
            case "TwoColumnRight":
            case "TwoPageLeft":
            case "TwoPageRight":
                t = e1.name;
        }
        return shadow(this, "pageLayout", t);
    }
    get pageMode() {
        const e1 = this.#ie.get("PageMode");
        let t = "UseNone";
        if (e1 instanceof Name) switch(e1.name){
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "FullScreen":
            case "UseOC":
            case "UseAttachments":
                t = e1.name;
        }
        return shadow(this, "pageMode", t);
    }
    get viewerPreferences() {
        const e1 = this.#ie.get("ViewerPreferences");
        if (!(e1 instanceof Dict)) return shadow(this, "viewerPreferences", null);
        let t = null;
        for (const [a, r] of e1){
            let e1;
            switch(a){
                case "HideToolbar":
                case "HideMenubar":
                case "HideWindowUI":
                case "FitWindow":
                case "CenterWindow":
                case "DisplayDocTitle":
                case "PickTrayByPDFSize":
                    "boolean" == typeof r && (e1 = r);
                    break;
                case "NonFullScreenPageMode":
                    if (r instanceof Name) switch(r.name){
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                            e1 = r.name;
                            break;
                        default:
                            e1 = "UseNone";
                    }
                    break;
                case "Direction":
                    if (r instanceof Name) switch(r.name){
                        case "L2R":
                        case "R2L":
                            e1 = r.name;
                            break;
                        default:
                            e1 = "L2R";
                    }
                    break;
                case "ViewArea":
                case "ViewClip":
                case "PrintArea":
                case "PrintClip":
                    if (r instanceof Name) switch(r.name){
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                            e1 = r.name;
                            break;
                        default:
                            e1 = "CropBox";
                    }
                    break;
                case "PrintScaling":
                    if (r instanceof Name) switch(r.name){
                        case "None":
                        case "AppDefault":
                            e1 = r.name;
                            break;
                        default:
                            e1 = "AppDefault";
                    }
                    break;
                case "Duplex":
                    if (r instanceof Name) switch(r.name){
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                            e1 = r.name;
                            break;
                        default:
                            e1 = "None";
                    }
                    break;
                case "PrintPageRange":
                    if (Array.isArray(r) && r.length % 2 == 0) {
                        r.every((e1, t, a)=>Number.isInteger(e1) && e1 > 0 && (0 === t || e1 >= a[t - 1]) && e1 <= this.numPages) && (e1 = r);
                    }
                    break;
                case "NumCopies":
                    Number.isInteger(r) && r > 0 && (e1 = r);
                    break;
                default:
                    warn(`Ignoring non-standard key in ViewerPreferences: ${a}.`);
                    continue;
            }
            if (void 0 !== e1) {
                t ??= Object.create(null);
                t[a] = e1;
            } else warn(`Bad value, for key "${a}", in ViewerPreferences: ${r}.`);
        }
        return shadow(this, "viewerPreferences", t);
    }
    get openAction() {
        const e1 = this.#ie.get("OpenAction"), t = Object.create(null);
        if (e1 instanceof Dict) {
            const a = new Dict(this.xref);
            a.set("A", e1);
            const r = {
                url: null,
                dest: null,
                action: null
            };
            Catalog.parseDestDictionary({
                destDict: a,
                resultObj: r
            });
            Array.isArray(r.dest) ? t.dest = r.dest : r.action && (t.action = r.action);
        } else Rn(e1) && (t.dest = e1);
        return shadow(this, "openAction", objectSize(t) > 0 ? t : null);
    }
    get attachments() {
        const e1 = this.#ie.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("EmbeddedFiles")) {
            const a = new NameTree(e1.getRaw("EmbeddedFiles"), this.xref);
            for (const [e1, r] of a.getAll()){
                const a = new FileSpec(r, this.xref);
                t ??= Object.create(null);
                t[stringToPDFString(e1, !0)] = a.serializable;
            }
        }
        return shadow(this, "attachments", t);
    }
    get xfaImages() {
        const e1 = this.#ie.get("Names");
        let t = null;
        if (e1 instanceof Dict && e1.has("XFAImages")) {
            const a = new NameTree(e1.getRaw("XFAImages"), this.xref);
            for (const [e1, r] of a.getAll())if (r instanceof BaseStream) {
                t ??= new Map;
                t.set(stringToPDFString(e1, !0), r.getBytes());
            }
        }
        return shadow(this, "xfaImages", t);
    }
    #fe() {
        const e1 = this.#ie.get("Names");
        let t = null;
        function appendIfJavaScriptDict(e1, a) {
            if (!(a instanceof Dict)) return;
            if (!isName(a.get("S"), "JavaScript")) return;
            let r = a.get("JS");
            if (r instanceof BaseStream) r = r.getString();
            else if ("string" != typeof r) return;
            r = stringToPDFString(r, !0).replaceAll("\0", "");
            r && (t ||= new Map).set(e1, r);
        }
        if (e1 instanceof Dict && e1.has("JavaScript")) {
            const t = new NameTree(e1.getRaw("JavaScript"), this.xref);
            for (const [e1, a] of t.getAll())appendIfJavaScriptDict(stringToPDFString(e1, !0), a);
        }
        const a = this.#ie.get("OpenAction");
        a && appendIfJavaScriptDict("OpenAction", a);
        return t;
    }
    get jsActions() {
        const e1 = this.#fe();
        let t = collectActions(this.xref, this.#ie, ae);
        if (e1) {
            t ||= Object.create(null);
            for (const [a, r] of e1)a in t ? t[a].push(r) : t[a] = [
                r
            ];
        }
        return shadow(this, "jsActions", t);
    }
    async cleanup(e1 = !1) {
        clearGlobalCaches();
        this.globalColorSpaceCache.clear();
        this.globalImageCache.clear(e1);
        this.pageKidsCountCache.clear();
        this.pageIndexCache.clear();
        this.pageDictCache.clear();
        this.nonBlendModesSet.clear();
        for (const { dict: e1 } of (await Promise.all(this.fontCache)))delete e1.cacheKey;
        this.fontCache.clear();
        this.builtInCMapCache.clear();
        this.standardFontDataCache.clear();
        this.systemFontCache.clear();
    }
    async getPageDict(e1) {
        const t = [
            this.toplevelPagesDict
        ], a = new RefSet, r = this.#ie.getRaw("Pages");
        r instanceof Ref && a.put(r);
        const i = this.xref, n = this.pageKidsCountCache, s = this.pageIndexCache, o = this.pageDictCache;
        let c = 0;
        for(; t.length;){
            const r = t.pop();
            if (r instanceof Ref) {
                const l = n.get(r);
                if (l >= 0 && c + l <= e1) {
                    c += l;
                    continue;
                }
                if (a.has(r)) throw new FormatError("Pages tree contains circular reference.");
                a.put(r);
                const h = await (o.get(r) || i.fetchAsync(r));
                if (h instanceof Dict) {
                    let t = h.getRaw("Type");
                    t instanceof Ref && (t = await i.fetchAsync(t));
                    if (isName(t, "Page") || !h.has("Kids")) {
                        n.has(r) || n.put(r, 1);
                        s.has(r) || s.put(r, c);
                        if (c === e1) return [
                            h,
                            r
                        ];
                        c++;
                        continue;
                    }
                }
                t.push(h);
                continue;
            }
            if (!(r instanceof Dict)) throw new FormatError("Page dictionary kid reference points to wrong type of object.");
            const { objId: l } = r;
            let h = r.getRaw("Count");
            h instanceof Ref && (h = await i.fetchAsync(h));
            if (Number.isInteger(h) && h >= 0) {
                l && !n.has(l) && n.put(l, h);
                if (c + h <= e1) {
                    c += h;
                    continue;
                }
            }
            let u = r.getRaw("Kids");
            u instanceof Ref && (u = await i.fetchAsync(u));
            if (!Array.isArray(u)) {
                let t = r.getRaw("Type");
                t instanceof Ref && (t = await i.fetchAsync(t));
                if (isName(t, "Page") || !r.has("Kids")) {
                    if (c === e1) return [
                        r,
                        null
                    ];
                    c++;
                    continue;
                }
                throw new FormatError("Page dictionary kids object is not an array.");
            }
            for(let e1 = u.length - 1; e1 >= 0; e1--){
                const a = u[e1];
                t.push(a);
                r === this.toplevelPagesDict && a instanceof Ref && !o.has(a) && o.put(a, i.fetchAsync(a));
            }
        }
        throw new Error(`Page index ${e1} not found.`);
    }
    async getAllPageDicts(e1 = !1) {
        const { ignoreErrors: t } = this.pdfManager.evaluatorOptions, a = [
            {
                currentNode: this.toplevelPagesDict,
                posInKids: 0
            }
        ], r = new RefSet, i = this.#ie.getRaw("Pages");
        i instanceof Ref && r.put(i);
        const n = new Map, s = this.xref, o = this.pageIndexCache;
        let c = 0;
        function addPageDict(e1, t) {
            t && !o.has(t) && o.put(t, c);
            n.set(c++, [
                e1,
                t
            ]);
        }
        function addPageError(a) {
            if (a instanceof XRefEntryException && !e1) throw a;
            if (e1 && t && 0 === c) {
                warn(`getAllPageDicts - Skipping invalid first page: "${a}".`);
                a = Dict.empty;
            }
            n.set(c++, [
                a,
                null
            ]);
        }
        for(; a.length > 0;){
            const e1 = a.at(-1), { currentNode: t, posInKids: i } = e1;
            let n = t.getRaw("Kids");
            if (n instanceof Ref) try {
                n = await s.fetchAsync(n);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            if (!Array.isArray(n)) {
                addPageError(new FormatError("Page dictionary kids object is not an array."));
                break;
            }
            if (i >= n.length) {
                a.pop();
                continue;
            }
            const o = n[i];
            let c;
            if (o instanceof Ref) {
                if (r.has(o)) {
                    addPageError(new FormatError("Pages tree contains circular reference."));
                    break;
                }
                r.put(o);
                try {
                    c = await s.fetchAsync(o);
                } catch (e1) {
                    addPageError(e1);
                    break;
                }
            } else c = o;
            if (!(c instanceof Dict)) {
                addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
                break;
            }
            let l = c.getRaw("Type");
            if (l instanceof Ref) try {
                l = await s.fetchAsync(l);
            } catch (e1) {
                addPageError(e1);
                break;
            }
            isName(l, "Page") || !c.has("Kids") ? addPageDict(c, o instanceof Ref ? o : null) : a.push({
                currentNode: c,
                posInKids: 0
            });
            e1.posInKids++;
        }
        return n;
    }
    getPageIndex(e1) {
        const t = this.pageIndexCache.get(e1);
        if (void 0 !== t) return Promise.resolve(t);
        const a = this.xref;
        let r = 0;
        const next = (t)=>(function pagesBeforeRef(t) {
                let r, i = 0;
                return a.fetchAsync(t).then(function(a) {
                    if (isRefsEqual(t, e1) && !isDict(a, "Page") && !(a instanceof Dict && !a.has("Type") && a.has("Contents"))) throw new FormatError("The reference does not point to a /Page dictionary.");
                    if (!a) return null;
                    if (!(a instanceof Dict)) throw new FormatError("Node must be a dictionary.");
                    r = a.getRaw("Parent");
                    return a.getAsync("Parent");
                }).then(function(e1) {
                    if (!e1) return null;
                    if (!(e1 instanceof Dict)) throw new FormatError("Parent must be a dictionary.");
                    return e1.getAsync("Kids");
                }).then(function(e1) {
                    if (!e1) return null;
                    const n = [];
                    let s = !1;
                    for (const r of e1){
                        if (!(r instanceof Ref)) throw new FormatError("Kid must be a reference.");
                        if (isRefsEqual(r, t)) {
                            s = !0;
                            break;
                        }
                        n.push(a.fetchAsync(r).then(function(e1) {
                            if (!(e1 instanceof Dict)) throw new FormatError("Kid node must be a dictionary.");
                            e1.has("Count") ? i += e1.get("Count") : i++;
                        }));
                    }
                    if (!s) throw new FormatError("Kid reference not found in parent's kids.");
                    return Promise.all(n).then(()=>[
                            i,
                            r
                        ]);
                });
            })(t).then((t)=>{
                if (!t) {
                    this.pageIndexCache.put(e1, r);
                    return r;
                }
                const [a, i] = t;
                r += a;
                return next(i);
            });
        return next(e1);
    }
    get baseUrl() {
        const e1 = this.#ie.get("URI");
        if (e1 instanceof Dict) {
            const t = e1.get("Base");
            if ("string" == typeof t) {
                const e1 = createValidAbsoluteUrl(t, null, {
                    tryConvertEncoding: !0
                });
                if (e1) return shadow(this, "baseUrl", e1.href);
            }
        }
        return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
    }
    static parseDestDictionary({ destDict: e1, resultObj: t, docBaseUrl: a = null, docAttachments: r = null }) {
        if (!(e1 instanceof Dict)) {
            warn("parseDestDictionary: `destDict` must be a dictionary.");
            return;
        }
        let i, n, s = e1.get("A");
        if (!(s instanceof Dict)) if (e1.has("Dest")) s = e1.get("Dest");
        else {
            s = e1.get("AA");
            s instanceof Dict && (s.has("D") ? s = s.get("D") : s.has("U") && (s = s.get("U")));
        }
        if (s instanceof Dict) {
            const e1 = s.get("S");
            if (!(e1 instanceof Name)) {
                warn("parseDestDictionary: Invalid type in Action dictionary.");
                return;
            }
            const a = e1.name;
            switch(a){
                case "ResetForm":
                    const e2 = s.get("Flags"), o = !(1 & ("number" == typeof e2 ? e2 : 0)), c = [], l = [];
                    for (const e1 of s.get("Fields") || [])e1 instanceof Ref ? l.push(e1.toString()) : "string" == typeof e1 && c.push(stringToPDFString(e1));
                    t.resetForm = {
                        fields: c,
                        refs: l,
                        include: o
                    };
                    break;
                case "URI":
                    i = s.get("URI");
                    i instanceof Name && (i = "/" + i.name);
                    break;
                case "GoTo":
                    n = s.get("D");
                    break;
                case "Launch":
                case "GoToR":
                    const h = s.get("F");
                    if (h instanceof Dict) {
                        const e1 = new FileSpec(h, null, !0), { rawFilename: t } = e1.serializable;
                        i = t;
                    } else "string" == typeof h && (i = h);
                    const u = fetchRemoteDest(s);
                    u && "string" == typeof i && (i = i.split("#", 1)[0] + "#" + u);
                    const d = s.get("NewWindow");
                    "boolean" == typeof d && (t.newWindow = d);
                    break;
                case "GoToE":
                    const f = s.get("T");
                    let g;
                    if (r && f instanceof Dict) {
                        const e1 = f.get("R"), t = f.get("N");
                        isName(e1, "C") && "string" == typeof t && (g = r[stringToPDFString(t, !0)]);
                    }
                    if (g) {
                        t.attachment = g;
                        const e1 = fetchRemoteDest(s);
                        e1 && (t.attachmentDest = e1);
                    } else warn('parseDestDictionary - unimplemented "GoToE" action.');
                    break;
                case "Named":
                    const p = s.get("N");
                    p instanceof Name && (t.action = p.name);
                    break;
                case "SetOCGState":
                    const m = s.get("State"), b = s.get("PreserveRB");
                    if (!Array.isArray(m) || 0 === m.length) break;
                    const y = [];
                    for (const e1 of m)if (e1 instanceof Name) switch(e1.name){
                        case "ON":
                        case "OFF":
                        case "Toggle":
                            y.push(e1.name);
                    }
                    else e1 instanceof Ref && y.push(e1.toString());
                    if (y.length !== m.length) break;
                    t.setOCGState = {
                        state: y,
                        preserveRB: "boolean" != typeof b || b
                    };
                    break;
                case "JavaScript":
                    const w = s.get("JS");
                    let x;
                    w instanceof BaseStream ? x = w.getString() : "string" == typeof w && (x = w);
                    const S = x && recoverJsURL(stringToPDFString(x, !0));
                    if (S) {
                        i = S.url;
                        t.newWindow = S.newWindow;
                        break;
                    }
                default:
                    if ("JavaScript" === a || "SubmitForm" === a) break;
                    warn(`parseDestDictionary - unsupported action: "${a}".`);
            }
        } else e1.has("Dest") && (n = e1.get("Dest"));
        if ("string" == typeof i) {
            const e1 = createValidAbsoluteUrl(i, a, {
                addDefaultProtocol: !0,
                tryConvertEncoding: !0
            });
            e1 && (t.url = e1.href);
            t.unsafeUrl = i;
        }
        if (n) {
            n instanceof Name && (n = n.name);
            "string" == typeof n ? t.dest = stringToPDFString(n, !0) : Rn(n) && (t.dest = n);
        }
    }
}
function addChildren(e1, t) {
    if (e1 instanceof Dict) e1 = e1.getRawValues();
    else if (e1 instanceof BaseStream) e1 = e1.dict.getRawValues();
    else if (!Array.isArray(e1)) return;
    for (const r of e1)((a = r) instanceof Ref || a instanceof Dict || a instanceof BaseStream || Array.isArray(a)) && t.push(r);
    var a;
}
class ObjectLoader {
    refSet = new RefSet;
    constructor(e1, t, a){
        this.dict = e1;
        this.keys = t;
        this.xref = a;
    }
    async load() {
        const { keys: e1, dict: t } = this, a = [];
        for (const r of e1){
            const e1 = t.getRaw(r);
            void 0 !== e1 && a.push(e1);
        }
        await this.#ge(a);
        this.refSet = null;
    }
    async #ge(e1) {
        const t = [], a = [];
        for(; e1.length;){
            let r = e1.pop();
            if (r instanceof Ref) {
                if (this.refSet.has(r)) continue;
                try {
                    this.refSet.put(r);
                    r = this.xref.fetch(r);
                } catch (e1) {
                    if (!(e1 instanceof MissingDataException)) {
                        warn(`ObjectLoader.#walk - requesting all data: "${e1}".`);
                        await this.xref.stream.manager.requestAllChunks();
                        return;
                    }
                    t.push(r);
                    a.push({
                        begin: e1.begin,
                        end: e1.end
                    });
                }
            }
            if (r instanceof BaseStream) {
                const e1 = r.getBaseStreams();
                if (e1) {
                    let i = !1;
                    for (const t of e1)if (!t.isDataLoaded) {
                        i = !0;
                        a.push({
                            begin: t.start,
                            end: t.end
                        });
                    }
                    i && t.push(r);
                }
            }
            addChildren(r, e1);
        }
        if (a.length) {
            await this.xref.stream.manager.requestRanges(a);
            for (const e1 of t)e1 instanceof Ref && this.refSet.remove(e1);
            await this.#ge(t);
        }
    }
    static async load(e1, t, a) {
        if (a.stream.isDataLoaded) return;
        const r = new ObjectLoader(e1, t, a);
        await r.load();
    }
}
const Nn = Symbol(), En = Symbol(), Pn = Symbol(), Ln = Symbol(), jn = Symbol(), _n = Symbol(), Un = Symbol(), Xn = Symbol(), qn = Symbol(), Hn = Symbol("content"), Wn = Symbol("data"), zn = Symbol(), $n = Symbol("extra"), Gn = Symbol(), Vn = Symbol(), Kn = Symbol(), Jn = Symbol(), Yn = Symbol(), Zn = Symbol(), Qn = Symbol(), es = Symbol(), ts = Symbol(), as = Symbol(), rs = Symbol(), is = Symbol(), ns = Symbol(), ss = Symbol(), os = Symbol(), cs = Symbol(), ls = Symbol(), hs = Symbol(), us = Symbol(), ds = Symbol(), fs = Symbol(), gs = Symbol(), ps = Symbol(), ms = Symbol(), bs = Symbol(), ys = Symbol(), ws = Symbol(), xs = Symbol(), Ss = Symbol(), As = Symbol(), ks = Symbol(), Cs = Symbol(), vs = Symbol("namespaceId"), Fs = Symbol("nodeName"), Is = Symbol(), Ts = Symbol(), Os = Symbol(), Ms = Symbol(), Ds = Symbol(), Bs = Symbol(), Rs = Symbol(), Ns = Symbol(), Es = Symbol("root"), Ls = Symbol(), js = Symbol(), _s = Symbol(), Us = Symbol(), Xs = Symbol(), qs = Symbol(), Hs = Symbol(), Ws = Symbol(), zs = Symbol(), $s = Symbol(), Gs = Symbol(), Vs = Symbol("uid"), Ks = Symbol(), Js = {
    config: {
        id: 0,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xci/")
    },
    connectionSet: {
        id: 1,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
    },
    datasets: {
        id: 2,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-data/")
    },
    form: {
        id: 3,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-form/")
    },
    localeSet: {
        id: 4,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
    },
    pdf: {
        id: 5,
        check: (e1)=>"http://ns.adobe.com/xdp/pdf/" === e1
    },
    signature: {
        id: 6,
        check: (e1)=>"http://www.w3.org/2000/09/xmldsig#" === e1
    },
    sourceSet: {
        id: 7,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-source-set/")
    },
    stylesheet: {
        id: 8,
        check: (e1)=>"http://www.w3.org/1999/XSL/Transform" === e1
    },
    template: {
        id: 9,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xfa-template/")
    },
    xdc: {
        id: 10,
        check: (e1)=>e1.startsWith("http://www.xfa.org/schema/xdc/")
    },
    xdp: {
        id: 11,
        check: (e1)=>"http://ns.adobe.com/xdp/" === e1
    },
    xfdf: {
        id: 12,
        check: (e1)=>"http://ns.adobe.com/xfdf/" === e1
    },
    xhtml: {
        id: 13,
        check: (e1)=>"http://www.w3.org/1999/xhtml" === e1
    },
    xmpmeta: {
        id: 14,
        check: (e1)=>"http://ns.adobe.com/xmpmeta/" === e1
    }
}, Ys = {
    pt: (e1)=>e1,
    cm: (e1)=>e1 / 2.54 * 72,
    mm: (e1)=>e1 / 25.4 * 72,
    in: (e1)=>72 * e1,
    px: (e1)=>e1
}, Zs = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e1) {
    return e1.startsWith("'") || e1.startsWith('"') ? e1.slice(1, -1) : e1;
}
function getInteger({ data: e1, defaultValue: t, validate: a }) {
    if (!e1) return t;
    e1 = e1.trim();
    const r = parseInt(e1, 10);
    return !isNaN(r) && a(r) ? r : t;
}
function getFloat({ data: e1, defaultValue: t, validate: a }) {
    if (!e1) return t;
    e1 = e1.trim();
    const r = parseFloat(e1);
    return !isNaN(r) && a(r) ? r : t;
}
function getKeyword({ data: e1, defaultValue: t, validate: a }) {
    return e1 && a(e1 = e1.trim()) ? e1 : t;
}
function getStringOption(e1, t) {
    return getKeyword({
        data: e1,
        defaultValue: t[0],
        validate: (e1)=>t.includes(e1)
    });
}
function getMeasurement(e1, t = "0") {
    t ||= "0";
    if (!e1) return getMeasurement(t);
    const a = e1.trim().match(Zs);
    if (!a) return getMeasurement(t);
    const [, r, i] = a, n = parseFloat(r);
    if (isNaN(n)) return getMeasurement(t);
    if (0 === n) return 0;
    const s = Ys[i];
    return s ? s(n) : n;
}
function getRatio(e1) {
    if (!e1) return {
        num: 1,
        den: 1
    };
    const t = e1.split(":", 2).map((e1)=>parseFloat(e1.trim())).filter((e1)=>!isNaN(e1));
    1 === t.length && t.push(1);
    if (0 === t.length) return {
        num: 1,
        den: 1
    };
    const [a, r] = t;
    return {
        num: a,
        den: r
    };
}
function getRelevant(e1) {
    return e1 ? e1.trim().split(/\s+/).map((e1)=>({
            excluded: "-" === e1[0],
            viewname: e1.substring(1)
        })) : [];
}
class HTMLResult {
    static get FAILURE() {
        return shadow(this, "FAILURE", new HTMLResult(!1, null, null, null));
    }
    static get EMPTY() {
        return shadow(this, "EMPTY", new HTMLResult(!0, null, null, null));
    }
    constructor(e1, t, a, r){
        this.success = e1;
        this.html = t;
        this.bbox = a;
        this.breakNode = r;
    }
    isBreak() {
        return !!this.breakNode;
    }
    static breakNode(e1) {
        return new HTMLResult(!1, null, null, e1);
    }
    static success(e1, t = null) {
        return new HTMLResult(!0, e1, t, null);
    }
}
class FontFinder {
    constructor(e1){
        this.fonts = new Map;
        this.cache = new Map;
        this.warned = new Set;
        this.defaultFont = null;
        this.add(e1);
    }
    add(e1, t = null) {
        for (const t of e1)this.addPdfFont(t);
        for (const e1 of this.fonts.values())e1.regular || (e1.regular = e1.italic || e1.bold || e1.bolditalic);
        if (!t || 0 === t.size) return;
        const a = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
        for (const e1 of t)this.fonts.set(e1, a);
    }
    addPdfFont(e1) {
        const t = e1.cssFontInfo, a = t.fontFamily;
        let r = this.fonts.get(a);
        if (!r) {
            r = Object.create(null);
            this.fonts.set(a, r);
            this.defaultFont || (this.defaultFont = r);
        }
        let i = "";
        const n = parseFloat(t.fontWeight);
        0 !== parseFloat(t.italicAngle) ? i = n >= 700 ? "bolditalic" : "italic" : n >= 700 && (i = "bold");
        if (!i) {
            (e1.name.includes("Bold") || e1.psName?.includes("Bold")) && (i = "bold");
            (e1.name.includes("Italic") || e1.name.endsWith("It") || e1.psName?.includes("Italic") || e1.psName?.endsWith("It")) && (i += "italic");
        }
        i || (i = "regular");
        r[i] = e1;
    }
    getDefault() {
        return this.defaultFont;
    }
    find(e1, t = !0) {
        let a = this.fonts.get(e1) || this.cache.get(e1);
        if (a) return a;
        const r = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
        let i = e1.replaceAll(r, "");
        a = this.fonts.get(i);
        if (a) {
            this.cache.set(e1, a);
            return a;
        }
        i = i.toLowerCase();
        const n = [];
        for (const [e1, t] of this.fonts.entries())e1.replaceAll(r, "").toLowerCase().startsWith(i) && n.push(t);
        if (0 === n.length) for (const [, e1] of this.fonts.entries())e1.regular.name?.replaceAll(r, "").toLowerCase().startsWith(i) && n.push(e1);
        if (0 === n.length) {
            i = i.replaceAll(/psmt|mt/gi, "");
            for (const [e1, t] of this.fonts.entries())e1.replaceAll(r, "").toLowerCase().startsWith(i) && n.push(t);
        }
        if (0 === n.length) for (const e1 of this.fonts.values())e1.regular.name?.replaceAll(r, "").toLowerCase().startsWith(i) && n.push(e1);
        if (n.length >= 1) {
            1 !== n.length && t && warn(`XFA - Too many choices to guess the correct font: ${e1}`);
            this.cache.set(e1, n[0]);
            return n[0];
        }
        if (t && !this.warned.has(e1)) {
            this.warned.add(e1);
            warn(`XFA - Cannot find the font: ${e1}`);
        }
        return null;
    }
}
function selectFont(e1, t) {
    return "italic" === e1.posture ? "bold" === e1.weight ? t.bolditalic : t.italic : "bold" === e1.weight ? t.bold : t.regular;
}
class FontInfo {
    constructor(e1, t, a, r){
        this.lineHeight = a;
        this.paraMargin = t || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        if (!e1) {
            [this.pdfFont, this.xfaFont] = this.defaultFont(r);
            return;
        }
        this.xfaFont = {
            typeface: e1.typeface,
            posture: e1.posture,
            weight: e1.weight,
            size: e1.size,
            letterSpacing: e1.letterSpacing
        };
        const i = r.find(e1.typeface);
        if (i) {
            this.pdfFont = selectFont(e1, i);
            this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(r));
        } else [this.pdfFont, this.xfaFont] = this.defaultFont(r);
    }
    defaultFont(e1) {
        const t = e1.find("Helvetica", !1) || e1.find("Myriad Pro", !1) || e1.find("Arial", !1) || e1.getDefault();
        if (t?.regular) {
            const e1 = t.regular;
            return [
                e1,
                {
                    typeface: e1.cssFontInfo.fontFamily,
                    posture: "normal",
                    weight: "normal",
                    size: 10,
                    letterSpacing: 0
                }
            ];
        }
        return [
            null,
            {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
            }
        ];
    }
}
class FontSelector {
    constructor(e1, t, a, r){
        this.fontFinder = r;
        this.stack = [
            new FontInfo(e1, t, a, r)
        ];
    }
    pushData(e1, t, a) {
        const r = this.stack.at(-1);
        for (const t of [
            "typeface",
            "posture",
            "weight",
            "size",
            "letterSpacing"
        ])e1[t] || (e1[t] = r.xfaFont[t]);
        for (const e1 of [
            "top",
            "bottom",
            "left",
            "right"
        ])isNaN(t[e1]) && (t[e1] = r.paraMargin[e1]);
        const i = new FontInfo(e1, t, a || r.lineHeight, this.fontFinder);
        i.pdfFont || (i.pdfFont = r.pdfFont);
        this.stack.push(i);
    }
    popFont() {
        this.stack.pop();
    }
    topFont() {
        return this.stack.at(-1);
    }
}
class TextMeasure {
    constructor(e1, t, a, r){
        this.glyphs = [];
        this.fontSelector = new FontSelector(e1, t, a, r);
        this.extraHeight = 0;
    }
    pushData(e1, t, a) {
        this.fontSelector.pushData(e1, t, a);
    }
    popFont(e1) {
        return this.fontSelector.popFont();
    }
    addPara() {
        const e1 = this.fontSelector.topFont();
        this.extraHeight += e1.paraMargin.top + e1.paraMargin.bottom;
    }
    addString(e1) {
        if (!e1) return;
        const t = this.fontSelector.topFont(), a = t.xfaFont.size;
        if (t.pdfFont) {
            const r = t.xfaFont.letterSpacing, i = t.pdfFont, n = i.lineHeight || 1.2, s = t.lineHeight || Math.max(1.2, n) * a, o = n - (void 0 === i.lineGap ? .2 : i.lineGap), c = Math.max(1, o) * a, l = a / 1e3, h = i.defaultWidth || i.charsToGlyphs(" ")[0].width;
            for (const t of e1.split(/[\u2029\n]/)){
                const e1 = i.encodeString(t).join(""), a = i.charsToGlyphs(e1);
                for (const e1 of a){
                    const t = e1.width || h;
                    this.glyphs.push([
                        t * l + r,
                        s,
                        c,
                        e1.unicode,
                        !1
                    ]);
                }
                this.glyphs.push([
                    0,
                    0,
                    0,
                    "\n",
                    !0
                ]);
            }
            this.glyphs.pop();
        } else {
            for (const t of e1.split(/[\u2029\n]/)){
                for (const e1 of t.split(""))this.glyphs.push([
                    a,
                    1.2 * a,
                    a,
                    e1,
                    !1
                ]);
                this.glyphs.push([
                    0,
                    0,
                    0,
                    "\n",
                    !0
                ]);
            }
            this.glyphs.pop();
        }
    }
    compute(e1) {
        let t = -1, a = 0, r = 0, i = 0, n = 0, s = 0, o = !1, c = !0;
        for(let l = 0, h = this.glyphs.length; l < h; l++){
            const [h, u, d, f, g] = this.glyphs[l], p = " " === f, m = c ? d : u;
            if (g) {
                r = Math.max(r, n);
                n = 0;
                i += s;
                s = m;
                t = -1;
                a = 0;
                c = !1;
            } else if (p) if (n + h > e1) {
                r = Math.max(r, n);
                n = 0;
                i += s;
                s = m;
                t = -1;
                a = 0;
                o = !0;
                c = !1;
            } else {
                s = Math.max(m, s);
                a = n;
                n += h;
                t = l;
            }
            else if (n + h > e1) {
                i += s;
                s = m;
                if (-1 !== t) {
                    l = t;
                    r = Math.max(r, a);
                    n = 0;
                    t = -1;
                    a = 0;
                } else {
                    r = Math.max(r, n);
                    n = h;
                }
                o = !0;
                c = !1;
            } else {
                n += h;
                s = Math.max(m, s);
            }
        }
        r = Math.max(r, n);
        i += s + this.extraHeight;
        return {
            width: 1.02 * r,
            height: i,
            isBroken: o
        };
    }
}
const Qs = /^[^.[]+/, eo = /^[^\]]+/, to = 0, ao = 1, ro = 2, io = 3, no = 4, so = new Map([
    [
        "$data",
        (e1, t)=>e1.datasets ? e1.datasets.data : e1
    ],
    [
        "$record",
        (e1, t)=>(e1.datasets ? e1.datasets.data : e1)[is]()[0]
    ],
    [
        "$template",
        (e1, t)=>e1.template
    ],
    [
        "$connectionSet",
        (e1, t)=>e1.connectionSet
    ],
    [
        "$form",
        (e1, t)=>e1.form
    ],
    [
        "$layout",
        (e1, t)=>e1.layout
    ],
    [
        "$host",
        (e1, t)=>e1.host
    ],
    [
        "$dataWindow",
        (e1, t)=>e1.dataWindow
    ],
    [
        "$event",
        (e1, t)=>e1.event
    ],
    [
        "!",
        (e1, t)=>e1.datasets
    ],
    [
        "$xfa",
        (e1, t)=>e1
    ],
    [
        "xfa",
        (e1, t)=>e1
    ],
    [
        "$",
        (e1, t)=>t
    ]
]), oo = new WeakMap;
function parseExpression(e1, t, a = !0) {
    let r = e1.match(Qs);
    if (!r) return null;
    let [i] = r;
    const n = [
        {
            name: i,
            cacheName: "." + i,
            index: 0,
            js: null,
            formCalc: null,
            operator: to
        }
    ];
    let s = i.length;
    for(; s < e1.length;){
        const c = s;
        if ("[" === e1.charAt(s++)) {
            r = e1.slice(s).match(eo);
            if (!r) {
                warn("XFA - Invalid index in SOM expression");
                return null;
            }
            n.at(-1).index = "*" === (o = (o = r[0]).trim()) ? 1 / 0 : parseInt(o, 10) || 0;
            s += r[0].length + 1;
            continue;
        }
        let l;
        switch(e1.charAt(s)){
            case ".":
                if (!t) return null;
                s++;
                l = ao;
                break;
            case "#":
                s++;
                l = ro;
                break;
            case "[":
                if (a) {
                    warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                    return null;
                }
                l = io;
                break;
            case "(":
                if (a) {
                    warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                    return null;
                }
                l = no;
                break;
            default:
                l = to;
        }
        r = e1.slice(s).match(Qs);
        if (!r) break;
        [i] = r;
        s += i.length;
        n.push({
            name: i,
            cacheName: e1.slice(c, s),
            operator: l,
            index: 0,
            js: null,
            formCalc: null
        });
    }
    var o;
    return n;
}
function searchNode(e1, t, a, r = !0, i = !0) {
    const n = parseExpression(a, r);
    if (!n) return null;
    const s = so.get(n[0].name);
    let o, c = 0;
    if (s) {
        o = !0;
        e1 = [
            s(e1, t)
        ];
        c = 1;
    } else {
        o = null === t;
        e1 = [
            t || e1
        ];
    }
    for(let a = n.length; c < a; c++){
        const { name: a, cacheName: r, operator: s, index: l } = n[c], h = [];
        for (const t of e1){
            if (!t.isXFAObject) continue;
            let e1, n;
            if (i) {
                n = oo.get(t);
                if (!n) {
                    n = new Map;
                    oo.set(t, n);
                }
                e1 = n.get(r);
            }
            if (!e1) {
                switch(s){
                    case to:
                        e1 = t[Qn](a, !1);
                        break;
                    case ao:
                        e1 = t[Qn](a, !0);
                        break;
                    case ro:
                        e1 = t[Zn](a);
                        e1 = e1.isXFAObjectArray ? e1.children : [
                            e1
                        ];
                }
                i && n.set(r, e1);
            }
            e1.length > 0 && h.push(e1);
        }
        if (0 !== h.length || o || 0 !== c) e1 = isFinite(l) ? h.filter((e1)=>l < e1.length).map((e1)=>e1[l]) : h.flat();
        else {
            const a = t[cs]();
            if (!(t = a)) return null;
            c = -1;
            e1 = [
                t
            ];
        }
    }
    return 0 === e1.length ? null : e1;
}
function createDataNode(e1, t, a) {
    const r = parseExpression(a);
    if (!r) return null;
    if (r.some((e1)=>e1.operator === ao)) return null;
    const i = so.get(r[0].name);
    let n = 0;
    if (i) {
        e1 = i(e1, t);
        n = 1;
    } else e1 = t || e1;
    for(let t = r.length; n < t; n++){
        const { name: t, operator: a, index: i } = r[n];
        if (!isFinite(i)) {
            r[n].index = 0;
            return e1.createNodes(r.slice(n));
        }
        let s;
        switch(a){
            case to:
                s = e1[Qn](t, !1);
                break;
            case ao:
                s = e1[Qn](t, !0);
                break;
            case ro:
                s = e1[Zn](t);
                s = s.isXFAObjectArray ? s.children : [
                    s
                ];
        }
        if (0 === s.length) return e1.createNodes(r.slice(n));
        if (!(i < s.length)) {
            r[n].index = i - s.length;
            return e1.createNodes(r.slice(n));
        }
        {
            const t = s[i];
            if (!t.isXFAObject) {
                warn("XFA - Cannot create a node.");
                return null;
            }
            e1 = t;
        }
    }
    return null;
}
const co = Symbol(), lo = Symbol(), ho = Symbol(), uo = Symbol("_children"), fo = Symbol(), go = Symbol(), po = Symbol(), mo = Symbol(), bo = Symbol(), yo = Symbol(), wo = Symbol(), xo = Symbol(), So = Symbol(), Ao = Symbol("parent"), ko = Symbol(), Co = Symbol(), vo = Symbol();
let Fo = 0;
const Io = Js.datasets.id;
class XFAObject {
    constructor(e1, t, a = !1){
        this[vs] = e1;
        this[Fs] = t;
        this[wo] = a;
        this[Ao] = null;
        this[uo] = [];
        this[Vs] = `${t}${Fo++}`;
        this[hs] = null;
    }
    get isXFAObject() {
        return !0;
    }
    get isXFAObjectArray() {
        return !1;
    }
    createNodes(e1) {
        let t = this, a = null;
        for (const { name: r, index: i } of e1){
            for(let e1 = 0, n = isFinite(i) ? i : 0; e1 <= n; e1++){
                const e1 = t[vs] === Io ? -1 : t[vs];
                a = new XmlObject(e1, r);
                t[Pn](a);
            }
            t = a;
        }
        return a;
    }
    [Ts](e1) {
        if (!this[wo] || !this[Os](e1)) return !1;
        const t = e1[Fs], a = this[t];
        if (!(a instanceof XFAObjectArray)) {
            null !== a && this[Ns](a);
            this[t] = e1;
            this[Pn](e1);
            return !0;
        }
        if (a.push(e1)) {
            this[Pn](e1);
            return !0;
        }
        let r = "";
        this.id ? r = ` (id: ${this.id})` : this.name && (r = ` (name: ${this.name} ${this.h.value})`);
        warn(`XFA - node "${this[Fs]}"${r} has already enough "${t}"!`);
        return !1;
    }
    [Os](e1) {
        return this.hasOwnProperty(e1[Fs]) && e1[vs] === this[vs];
    }
    [ws]() {
        return !1;
    }
    [Nn]() {
        return !1;
    }
    [ps]() {
        return !1;
    }
    [ms]() {
        return !1;
    }
    [Bs]() {
        this.para && this[ls]()[$n].paraStack.pop();
    }
    [Rs]() {
        this[ls]()[$n].paraStack.push(this.para);
    }
    [_s](e1) {
        this.id && this[vs] === Js.template.id && e1.set(this.id, this);
    }
    [ls]() {
        return this[hs].template;
    }
    [xs]() {
        return !1;
    }
    [Ss]() {
        return !1;
    }
    [Pn](e1) {
        e1[Ao] = this;
        this[uo].push(e1);
        !e1[hs] && this[hs] && (e1[hs] = this[hs]);
    }
    [Ns](e1) {
        const t = this[uo].indexOf(e1);
        this[uo].splice(t, 1);
    }
    [us]() {
        return this.hasOwnProperty("value");
    }
    [Xs](e1) {}
    [Ms](e1) {}
    [Gn]() {}
    [jn](e1) {
        delete this[wo];
        if (this[Un]) {
            e1.clean(this[Un]);
            delete this[Un];
        }
    }
    [fs](e1) {
        return this[uo].indexOf(e1);
    }
    [gs](e1, t) {
        t[Ao] = this;
        this[uo].splice(e1, 0, t);
        !t[hs] && this[hs] && (t[hs] = this[hs]);
    }
    [As]() {
        return !this.name;
    }
    [Cs]() {
        return "";
    }
    [Hs]() {
        return 0 === this[uo].length ? this[Hn] : this[uo].map((e1)=>e1[Hs]()).join("");
    }
    get [ho]() {
        const e1 = Object.getPrototypeOf(this);
        if (!e1._attributes) {
            const t = e1._attributes = new Set;
            for (const e1 of Object.getOwnPropertyNames(this)){
                if (null === this[e1] || this[e1] instanceof XFAObject || this[e1] instanceof XFAObjectArray) break;
                t.add(e1);
            }
        }
        return shadow(this, ho, e1._attributes);
    }
    [ys](e1) {
        let t = this;
        for(; t;){
            if (t === e1) return !0;
            t = t[cs]();
        }
        return !1;
    }
    [cs]() {
        return this[Ao];
    }
    [os]() {
        return this[cs]();
    }
    [is](e1 = null) {
        return e1 ? this[e1] : this[uo];
    }
    [zn]() {
        const e1 = Object.create(null);
        this[Hn] && (e1.$content = this[Hn]);
        for (const t of Object.getOwnPropertyNames(this)){
            const a = this[t];
            null !== a && (a instanceof XFAObject ? e1[t] = a[zn]() : a instanceof XFAObjectArray ? a.isEmpty() || (e1[t] = a.dump()) : e1[t] = a);
        }
        return e1;
    }
    [Gs]() {
        return null;
    }
    [zs]() {
        return HTMLResult.EMPTY;
    }
    *[ns]() {
        for (const e1 of this[is]())yield e1;
    }
    *[mo](e1, t) {
        for (const a of this[ns]())if (!e1 || t === e1.has(a[Fs])) {
            const e1 = this[Yn](), t = a[zs](e1);
            t.success || (this[$n].failingNode = a);
            yield t;
        }
    }
    [Vn]() {
        return null;
    }
    [En](e1, t) {
        this[$n].children.push(e1);
    }
    [Yn]() {}
    [Ln]({ filter: e1 = null, include: t = !0 }) {
        if (this[$n].generator) {
            const e1 = this[Yn](), t = this[$n].failingNode[zs](e1);
            if (!t.success) return t;
            t.html && this[En](t.html, t.bbox);
            delete this[$n].failingNode;
        } else this[$n].generator = this[mo](e1, t);
        for(;;){
            const e1 = this[$n].generator.next();
            if (e1.done) break;
            const t = e1.value;
            if (!t.success) return t;
            t.html && this[En](t.html, t.bbox);
        }
        this[$n].generator = null;
        return HTMLResult.EMPTY;
    }
    [Us](e1) {
        this[Co] = new Set(Object.keys(e1));
    }
    [yo](e1) {
        const t = this[ho], a = this[Co];
        return [
            ...e1
        ].filter((e1)=>t.has(e1) && !a.has(e1));
    }
    [Ls](e1, t = new Set) {
        for (const a of this[uo])a[ko](e1, t);
    }
    [ko](e1, t) {
        const a = this[bo](e1, t);
        a ? this[co](a, e1, t) : this[Ls](e1, t);
    }
    [bo](e1, t) {
        const { use: a, usehref: r } = this;
        if (!a && !r) return null;
        let i = null, n = null, s = null, o = a;
        if (r) {
            o = r;
            r.startsWith("#som(") && r.endsWith(")") ? n = r.slice(5, -1) : r.startsWith(".#som(") && r.endsWith(")") ? n = r.slice(6, -1) : r.startsWith("#") ? s = r.slice(1) : r.startsWith(".#") && (s = r.slice(2));
        } else a.startsWith("#") ? s = a.slice(1) : n = a;
        this.use = this.usehref = "";
        if (s) i = e1.get(s);
        else {
            i = searchNode(e1.get(Es), this, n, !0, !1);
            i && (i = i[0]);
        }
        if (!i) {
            warn(`XFA - Invalid prototype reference: ${o}.`);
            return null;
        }
        if (i[Fs] !== this[Fs]) {
            warn(`XFA - Incompatible prototype: ${i[Fs]} !== ${this[Fs]}.`);
            return null;
        }
        if (t.has(i)) {
            warn("XFA - Cycle detected in prototypes use.");
            return null;
        }
        t.add(i);
        const c = i[bo](e1, t);
        c && i[co](c, e1, t);
        i[Ls](e1, t);
        t.delete(i);
        return i;
    }
    [co](e1, t, a) {
        if (a.has(e1)) {
            warn("XFA - Cycle detected in prototypes use.");
            return;
        }
        !this[Hn] && e1[Hn] && (this[Hn] = e1[Hn]);
        new Set(a).add(e1);
        for (const t of this[yo](e1[Co])){
            this[t] = e1[t];
            this[Co] && this[Co].add(t);
        }
        for (const r of Object.getOwnPropertyNames(this)){
            if (this[ho].has(r)) continue;
            const i = this[r], n = e1[r];
            if (i instanceof XFAObjectArray) {
                for (const e1 of i[uo])e1[ko](t, a);
                for(let r = i[uo].length, s = n[uo].length; r < s; r++){
                    const n = e1[uo][r][Xn]();
                    if (!i.push(n)) break;
                    n[Ao] = this;
                    this[uo].push(n);
                    n[ko](t, a);
                }
            } else if (null === i) {
                if (null !== n) {
                    const e1 = n[Xn]();
                    e1[Ao] = this;
                    this[r] = e1;
                    this[uo].push(e1);
                    e1[ko](t, a);
                }
            } else {
                i[Ls](t, a);
                n && i[co](n, t, a);
            }
        }
    }
    static [fo](e1) {
        return Array.isArray(e1) ? e1.map((e1)=>XFAObject[fo](e1)) : "object" == typeof e1 && null !== e1 ? Object.assign({}, e1) : e1;
    }
    [Xn]() {
        const e1 = Object.create(Object.getPrototypeOf(this));
        for (const t of Object.getOwnPropertySymbols(this))try {
            e1[t] = this[t];
        } catch  {
            shadow(e1, t, this[t]);
        }
        e1[Vs] = `${e1[Fs]}${Fo++}`;
        e1[uo] = [];
        for (const t of Object.getOwnPropertyNames(this)){
            if (this[ho].has(t)) {
                e1[t] = XFAObject[fo](this[t]);
                continue;
            }
            const a = this[t];
            e1[t] = a instanceof XFAObjectArray ? new XFAObjectArray(a[xo]) : null;
        }
        for (const t of this[uo]){
            const a = t[Fs], r = t[Xn]();
            e1[uo].push(r);
            r[Ao] = e1;
            null === e1[a] ? e1[a] = r : e1[a][uo].push(r);
        }
        return e1;
    }
    [is](e1 = null) {
        return e1 ? this[uo].filter((t)=>t[Fs] === e1) : this[uo];
    }
    [Zn](e1) {
        return this[e1];
    }
    [Qn](e1, t, a = !0) {
        return Array.from(this[es](e1, t, a));
    }
    *[es](e1, t, a = !0) {
        if ("parent" !== e1) {
            for (const a of this[uo]){
                a[Fs] === e1 && (yield a);
                a.name === e1 && (yield a);
                (t || a[As]()) && (yield* a[es](e1, t, !1));
            }
            a && this[ho].has(e1) && (yield new XFAAttribute(this, e1, this[e1]));
        } else yield this[Ao];
    }
}
class XFAObjectArray {
    constructor(e1 = 1 / 0){
        this[xo] = e1;
        this[uo] = [];
    }
    get isXFAObject() {
        return !1;
    }
    get isXFAObjectArray() {
        return !0;
    }
    push(e1) {
        if (this[uo].length <= this[xo]) {
            this[uo].push(e1);
            return !0;
        }
        warn(`XFA - node "${e1[Fs]}" accepts no more than ${this[xo]} children`);
        return !1;
    }
    isEmpty() {
        return 0 === this[uo].length;
    }
    dump() {
        return 1 === this[uo].length ? this[uo][0][zn]() : this[uo].map((e1)=>e1[zn]());
    }
    [Xn]() {
        const e1 = new XFAObjectArray(this[xo]);
        e1[uo] = this[uo].map((e1)=>e1[Xn]());
        return e1;
    }
    get children() {
        return this[uo];
    }
    clear() {
        this[uo].length = 0;
    }
}
class XFAAttribute {
    constructor(e1, t, a){
        this[Ao] = e1;
        this[Fs] = t;
        this[Hn] = a;
        this[qn] = !1;
        this[Vs] = "attribute" + Fo++;
    }
    [cs]() {
        return this[Ao];
    }
    [bs]() {
        return !0;
    }
    [ts]() {
        return this[Hn].trim();
    }
    [Xs](e1) {
        e1 = e1.value || "";
        this[Hn] = e1.toString();
    }
    [Hs]() {
        return this[Hn];
    }
    [ys](e1) {
        return this[Ao] === e1 || this[Ao][ys](e1);
    }
}
class XmlObject extends XFAObject {
    constructor(e1, t, a = {}){
        super(e1, t);
        this[Hn] = "";
        this[go] = null;
        if ("#text" !== t) {
            const e1 = new Map;
            this[lo] = e1;
            for (const [t, r] of Object.entries(a))e1.set(t, new XFAAttribute(this, t, r));
            if (a.hasOwnProperty(Is)) {
                const e1 = a[Is].xfa.dataNode;
                void 0 !== e1 && ("dataGroup" === e1 ? this[go] = !1 : "dataValue" === e1 && (this[go] = !0));
            }
        }
        this[qn] = !1;
    }
    [$s](e1) {
        const t = this[Fs];
        if ("#text" === t) {
            e1.push(encodeToXmlString(this[Hn]));
            return;
        }
        const a = utf8StringToString(t), r = this[vs] === Io ? "xfa:" : "";
        e1.push(`<${r}${a}`);
        for (const [t, a] of this[lo].entries()){
            const r = utf8StringToString(t);
            e1.push(` ${r}="${encodeToXmlString(a[Hn])}"`);
        }
        null !== this[go] && (this[go] ? e1.push(' xfa:dataNode="dataValue"') : e1.push(' xfa:dataNode="dataGroup"'));
        if (this[Hn] || 0 !== this[uo].length) {
            e1.push(">");
            if (this[Hn]) "string" == typeof this[Hn] ? e1.push(encodeToXmlString(this[Hn])) : this[Hn][$s](e1);
            else for (const t of this[uo])t[$s](e1);
            e1.push(`</${r}${a}>`);
        } else e1.push("/>");
    }
    [Ts](e1) {
        if (this[Hn]) {
            const e1 = new XmlObject(this[vs], "#text");
            this[Pn](e1);
            e1[Hn] = this[Hn];
            this[Hn] = "";
        }
        this[Pn](e1);
        return !0;
    }
    [Ms](e1) {
        this[Hn] += e1;
    }
    [Gn]() {
        if (this[Hn] && this[uo].length > 0) {
            const e1 = new XmlObject(this[vs], "#text");
            this[Pn](e1);
            e1[Hn] = this[Hn];
            delete this[Hn];
        }
    }
    [zs]() {
        return "#text" === this[Fs] ? HTMLResult.success({
            name: "#text",
            value: this[Hn]
        }) : HTMLResult.EMPTY;
    }
    [is](e1 = null) {
        return e1 ? this[uo].filter((t)=>t[Fs] === e1) : this[uo];
    }
    [Jn]() {
        return this[lo];
    }
    [Zn](e1) {
        const t = this[lo].get(e1);
        return void 0 !== t ? t : this[is](e1);
    }
    *[es](e1, t) {
        const a = this[lo].get(e1);
        a && (yield a);
        for (const a of this[uo]){
            a[Fs] === e1 && (yield a);
            t && (yield* a[es](e1, t));
        }
    }
    *[Kn](e1, t) {
        const a = this[lo].get(e1);
        !a || t && a[qn] || (yield a);
        for (const a of this[uo])yield* a[Kn](e1, t);
    }
    *[rs](e1, t, a) {
        for (const r of this[uo]){
            r[Fs] !== e1 || a && r[qn] || (yield r);
            t && (yield* r[rs](e1, t, a));
        }
    }
    [bs]() {
        return null === this[go] ? 0 === this[uo].length || this[uo][0][vs] === Js.xhtml.id : this[go];
    }
    [ts]() {
        return null === this[go] ? 0 === this[uo].length ? this[Hn].trim() : this[uo][0][vs] === Js.xhtml.id ? this[uo][0][Hs]().trim() : null : this[Hn].trim();
    }
    [Xs](e1) {
        e1 = e1.value || "";
        this[Hn] = e1.toString();
    }
    [zn](e1 = !1) {
        const t = Object.create(null);
        e1 && (t.$ns = this[vs]);
        this[Hn] && (t.$content = this[Hn]);
        t.$name = this[Fs];
        t.children = [];
        for (const a of this[uo])t.children.push(a[zn](e1));
        t.attributes = Object.create(null);
        for (const [e1, a] of this[lo])t.attributes[e1] = a[Hn];
        return t;
    }
}
class ContentObject extends XFAObject {
    constructor(e1, t){
        super(e1, t);
        this[Hn] = "";
    }
    [Ms](e1) {
        this[Hn] += e1;
    }
    [Gn]() {}
}
class OptionObject extends ContentObject {
    constructor(e1, t, a){
        super(e1, t);
        this[So] = a;
    }
    [Gn]() {
        this[Hn] = getKeyword({
            data: this[Hn],
            defaultValue: this[So][0],
            validate: (e1)=>this[So].includes(e1)
        });
    }
    [jn](e1) {
        super[jn](e1);
        delete this[So];
    }
}
class StringObject extends ContentObject {
    [Gn]() {
        this[Hn] = this[Hn].trim();
    }
}
class IntegerObject extends ContentObject {
    constructor(e1, t, a, r){
        super(e1, t);
        this[po] = a;
        this[vo] = r;
    }
    [Gn]() {
        this[Hn] = getInteger({
            data: this[Hn],
            defaultValue: this[po],
            validate: this[vo]
        });
    }
    [jn](e1) {
        super[jn](e1);
        delete this[po];
        delete this[vo];
    }
}
class Option01 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 0, (e1)=>1 === e1);
    }
}
class Option10 extends IntegerObject {
    constructor(e1, t){
        super(e1, t, 1, (e1)=>0 === e1);
    }
}
function measureToString(e1) {
    return "string" == typeof e1 ? "0px" : Number.isInteger(e1) ? `${e1}px` : `${e1.toFixed(2)}px`;
}
const Oo = {
    anchorType (e1, t) {
        const a = e1[os]();
        if (a && (!a.layout || "position" === a.layout)) {
            "transform" in t || (t.transform = "");
            switch(e1.anchorType){
                case "bottomCenter":
                    t.transform += "translate(-50%, -100%)";
                    break;
                case "bottomLeft":
                    t.transform += "translate(0,-100%)";
                    break;
                case "bottomRight":
                    t.transform += "translate(-100%,-100%)";
                    break;
                case "middleCenter":
                    t.transform += "translate(-50%,-50%)";
                    break;
                case "middleLeft":
                    t.transform += "translate(0,-50%)";
                    break;
                case "middleRight":
                    t.transform += "translate(-100%,-50%)";
                    break;
                case "topCenter":
                    t.transform += "translate(-50%,0)";
                    break;
                case "topRight":
                    t.transform += "translate(-100%,0)";
            }
        }
    },
    dimensions (e1, t) {
        const a = e1[os]();
        let r = e1.w;
        const i = e1.h;
        if (a.layout?.includes("row")) {
            const t = a[$n], i = e1.colSpan;
            let n;
            if (-1 === i) {
                n = Math.sumPrecise(t.columnWidths.slice(t.currentColumn));
                t.currentColumn = 0;
            } else {
                n = Math.sumPrecise(t.columnWidths.slice(t.currentColumn, t.currentColumn + i));
                t.currentColumn = (t.currentColumn + e1.colSpan) % t.columnWidths.length;
            }
            isNaN(n) || (r = e1.w = n);
        }
        t.width = "" !== r ? measureToString(r) : "auto";
        t.height = "" !== i ? measureToString(i) : "auto";
    },
    position (e1, t) {
        const a = e1[os]();
        if (!a?.layout || "position" === a.layout) {
            t.position = "absolute";
            t.left = measureToString(e1.x);
            t.top = measureToString(e1.y);
        }
    },
    rotate (e1, t) {
        if (e1.rotate) {
            "transform" in t || (t.transform = "");
            t.transform += `rotate(-${e1.rotate}deg)`;
            t.transformOrigin = "top left";
        }
    },
    presence (e1, t) {
        switch(e1.presence){
            case "invisible":
                t.visibility = "hidden";
                break;
            case "hidden":
            case "inactive":
                t.display = "none";
        }
    },
    hAlign (e1, t) {
        if ("para" === e1[Fs]) switch(e1.hAlign){
            case "justifyAll":
                t.textAlign = "justify-all";
                break;
            case "radix":
                t.textAlign = "left";
                break;
            default:
                t.textAlign = e1.hAlign;
        }
        else switch(e1.hAlign){
            case "left":
                t.alignSelf = "start";
                break;
            case "center":
                t.alignSelf = "center";
                break;
            case "right":
                t.alignSelf = "end";
        }
    },
    margin (e1, t) {
        e1.margin && (t.margin = e1.margin[Gs]().margin);
    }
};
function setMinMaxDimensions(e1, t) {
    if ("position" === e1[os]().layout) {
        e1.minW > 0 && (t.minWidth = measureToString(e1.minW));
        e1.maxW > 0 && (t.maxWidth = measureToString(e1.maxW));
        e1.minH > 0 && (t.minHeight = measureToString(e1.minH));
        e1.maxH > 0 && (t.maxHeight = measureToString(e1.maxH));
    }
}
function layoutText(e1, t, a, r, i, n) {
    const s = new TextMeasure(t, a, r, i);
    "string" == typeof e1 ? s.addString(e1) : e1[Ds](s);
    return s.compute(n);
}
function layoutNode(e1, t) {
    let a = null, r = null, i = !1;
    if ((!e1.w || !e1.h) && e1.value) {
        let n = 0, s = 0;
        if (e1.margin) {
            n = e1.margin.leftInset + e1.margin.rightInset;
            s = e1.margin.topInset + e1.margin.bottomInset;
        }
        let o = null, c = null;
        if (e1.para) {
            c = Object.create(null);
            o = "" === e1.para.lineHeight ? null : e1.para.lineHeight;
            c.top = "" === e1.para.spaceAbove ? 0 : e1.para.spaceAbove;
            c.bottom = "" === e1.para.spaceBelow ? 0 : e1.para.spaceBelow;
            c.left = "" === e1.para.marginLeft ? 0 : e1.para.marginLeft;
            c.right = "" === e1.para.marginRight ? 0 : e1.para.marginRight;
        }
        let l = e1.font;
        if (!l) {
            const t = e1[ls]();
            let a = e1[cs]();
            for(; a && a !== t;){
                if (a.font) {
                    l = a.font;
                    break;
                }
                a = a[cs]();
            }
        }
        const h = (e1.w || t.width) - n, u = e1[hs].fontFinder;
        if (e1.value.exData && e1.value.exData[Hn] && "text/html" === e1.value.exData.contentType) {
            const t = layoutText(e1.value.exData[Hn], l, c, o, u, h);
            r = t.width;
            a = t.height;
            i = t.isBroken;
        } else {
            const t = e1.value[Hs]();
            if (t) {
                const e1 = layoutText(t, l, c, o, u, h);
                r = e1.width;
                a = e1.height;
                i = e1.isBroken;
            }
        }
        null === r || e1.w || (r += n);
        null === a || e1.h || (a += s);
    }
    return {
        w: r,
        h: a,
        isBroken: i
    };
}
function computeBbox(e1, t, a) {
    let r;
    if ("" !== e1.w && "" !== e1.h) r = [
        e1.x,
        e1.y,
        e1.w,
        e1.h
    ];
    else {
        if (!a) return null;
        let i = e1.w;
        if ("" === i) {
            if (0 === e1.maxW) {
                const t = e1[os]();
                i = "position" === t.layout && "" !== t.w ? 0 : e1.minW;
            } else i = Math.min(e1.maxW, a.width);
            t.attributes.style.width = measureToString(i);
        }
        let n = e1.h;
        if ("" === n) {
            if (0 === e1.maxH) {
                const t = e1[os]();
                n = "position" === t.layout && "" !== t.h ? 0 : e1.minH;
            } else n = Math.min(e1.maxH, a.height);
            t.attributes.style.height = measureToString(n);
        }
        r = [
            e1.x,
            e1.y,
            i,
            n
        ];
    }
    return r;
}
function fixDimensions(e1) {
    const t = e1[os]();
    if (t.layout?.includes("row")) {
        const a = t[$n], r = e1.colSpan;
        let i;
        i = -1 === r ? Math.sumPrecise(a.columnWidths.slice(a.currentColumn)) : Math.sumPrecise(a.columnWidths.slice(a.currentColumn, a.currentColumn + r));
        isNaN(i) || (e1.w = i);
    }
    t.layout && "position" !== t.layout && (e1.x = e1.y = 0);
    "table" === e1.layout && "" === e1.w && Array.isArray(e1.columnWidths) && (e1.w = Math.sumPrecise(e1.columnWidths));
}
function layoutClass(e1) {
    switch(e1.layout){
        case "position":
        default:
            return "xfaPosition";
        case "lr-tb":
            return "xfaLrTb";
        case "rl-row":
            return "xfaRlRow";
        case "rl-tb":
            return "xfaRlTb";
        case "row":
            return "xfaRow";
        case "table":
            return "xfaTable";
        case "tb":
            return "xfaTb";
    }
}
function toStyle(e1, ...t) {
    const a = Object.create(null);
    for (const r of t){
        const t = e1[r];
        if (null !== t) {
            if (Oo.hasOwnProperty(r)) Oo[r](e1, a);
            else if (t instanceof XFAObject) {
                const e1 = t[Gs]();
                e1 ? Object.assign(a, e1) : warn(`(DEBUG) - XFA - style for ${r} not implemented yet`);
            }
        }
    }
    return a;
}
function createWrapper(e1, t) {
    const { attributes: a } = t, { style: r } = a, i = {
        name: "div",
        attributes: {
            class: [
                "xfaWrapper"
            ],
            style: Object.create(null)
        },
        children: []
    };
    a.class.push("xfaWrapped");
    if (e1.border) {
        const { widths: a, insets: n } = e1.border[$n];
        let s, o, c = n[0], l = n[3];
        const h = n[0] + n[2], u = n[1] + n[3];
        switch(e1.border.hand){
            case "even":
                c -= a[0] / 2;
                l -= a[3] / 2;
                s = `calc(100% + ${(a[1] + a[3]) / 2 - u}px)`;
                o = `calc(100% + ${(a[0] + a[2]) / 2 - h}px)`;
                break;
            case "left":
                c -= a[0];
                l -= a[3];
                s = `calc(100% + ${a[1] + a[3] - u}px)`;
                o = `calc(100% + ${a[0] + a[2] - h}px)`;
                break;
            case "right":
                s = u ? `calc(100% - ${u}px)` : "100%";
                o = h ? `calc(100% - ${h}px)` : "100%";
        }
        const d = [
            "xfaBorder"
        ];
        isPrintOnly(e1.border) && d.push("xfaPrintOnly");
        const f = {
            name: "div",
            attributes: {
                class: d,
                style: {
                    top: `${c}px`,
                    left: `${l}px`,
                    width: s,
                    height: o
                }
            },
            children: []
        };
        for (const e1 of [
            "border",
            "borderWidth",
            "borderColor",
            "borderRadius",
            "borderStyle"
        ])if (void 0 !== r[e1]) {
            f.attributes.style[e1] = r[e1];
            delete r[e1];
        }
        i.children.push(f, t);
    } else i.children.push(t);
    for (const e1 of [
        "background",
        "backgroundClip",
        "top",
        "left",
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "transform",
        "transformOrigin",
        "visibility"
    ])if (void 0 !== r[e1]) {
        i.attributes.style[e1] = r[e1];
        delete r[e1];
    }
    i.attributes.style.position = "absolute" === r.position ? "absolute" : "relative";
    delete r.position;
    if (r.alignSelf) {
        i.attributes.style.alignSelf = r.alignSelf;
        delete r.alignSelf;
    }
    return i;
}
function fixTextIndent(e1) {
    const t = getMeasurement(e1.textIndent, "0px");
    if (t >= 0) return;
    const a = "padding" + ("left" === ("right" === e1.textAlign ? "right" : "left") ? "Left" : "Right"), r = getMeasurement(e1[a], "0px");
    e1[a] = r - t + "px";
}
function setAccess(e1, t) {
    switch(e1.access){
        case "nonInteractive":
            t.push("xfaNonInteractive");
            break;
        case "readOnly":
            t.push("xfaReadOnly");
            break;
        case "protected":
            t.push("xfaDisabled");
    }
}
function isPrintOnly(e1) {
    return e1.relevant.length > 0 && !e1.relevant[0].excluded && "print" === e1.relevant[0].viewname;
}
function getCurrentPara(e1) {
    const t = e1[ls]()[$n].paraStack;
    return t.length ? t.at(-1) : null;
}
function setPara(e1, t, a) {
    if (a.attributes.class?.includes("xfaRich")) {
        if (t) {
            "" === e1.h && (t.height = "auto");
            "" === e1.w && (t.width = "auto");
        }
        const r = getCurrentPara(e1);
        if (r) {
            const e1 = a.attributes.style;
            e1.display = "flex";
            e1.flexDirection = "column";
            switch(r.vAlign){
                case "top":
                    e1.justifyContent = "start";
                    break;
                case "bottom":
                    e1.justifyContent = "end";
                    break;
                case "middle":
                    e1.justifyContent = "center";
            }
            const t = r[Gs]();
            for (const [a, r] of Object.entries(t))a in e1 || (e1[a] = r);
        }
    }
}
function setFontFamily(e1, t, a, r) {
    if (!a) {
        delete r.fontFamily;
        return;
    }
    const i = stripQuotes(e1.typeface);
    r.fontFamily = `"${i}"`;
    const n = a.find(i);
    if (n) {
        const { fontFamily: a } = n.regular.cssFontInfo;
        a !== i && (r.fontFamily = `"${a}"`);
        const s = getCurrentPara(t);
        if (s && "" !== s.lineHeight) return;
        if (r.lineHeight) return;
        const o = selectFont(e1, n);
        o && (r.lineHeight = Math.max(1.2, o.lineHeight));
    }
}
function fixURL(e1) {
    const t = createValidAbsoluteUrl(e1, null, {
        addDefaultProtocol: !0,
        tryConvertEncoding: !0
    });
    return t ? t.href : null;
}
function createLine(e1, t) {
    return {
        name: "div",
        attributes: {
            class: [
                "lr-tb" === e1.layout ? "xfaLr" : "xfaRl"
            ]
        },
        children: t
    };
}
function flushHTML(e1) {
    if (!e1[$n]) return null;
    const t = {
        name: "div",
        attributes: e1[$n].attributes,
        children: e1[$n].children
    };
    if (e1[$n].failingNode) {
        const a = e1[$n].failingNode[Vn]();
        a && (e1.layout.endsWith("-tb") ? t.children.push(createLine(e1, [
            a
        ])) : t.children.push(a));
    }
    return 0 === t.children.length ? null : t;
}
function addHTML(e1, t, a) {
    const r = e1[$n], i = r.availableSpace, [n, s, o, c] = a;
    switch(e1.layout){
        case "position":
            r.width = Math.max(r.width, n + o);
            r.height = Math.max(r.height, s + c);
            r.children.push(t);
            break;
        case "lr-tb":
        case "rl-tb":
            if (!r.line || 1 === r.attempt) {
                r.line = createLine(e1, []);
                r.children.push(r.line);
                r.numberInLine = 0;
            }
            r.numberInLine += 1;
            r.line.children.push(t);
            if (0 === r.attempt) {
                r.currentWidth += o;
                r.height = Math.max(r.height, r.prevHeight + c);
            } else {
                r.currentWidth = o;
                r.prevHeight = r.height;
                r.height += c;
                r.attempt = 0;
            }
            r.width = Math.max(r.width, r.currentWidth);
            break;
        case "rl-row":
        case "row":
            {
                r.children.push(t);
                r.width += o;
                r.height = Math.max(r.height, c);
                const e1 = measureToString(r.height);
                for (const t of r.children)t.attributes.style.height = e1;
                break;
            }
        case "table":
        case "tb":
            r.width = MathClamp(o, r.width, i.width);
            r.height += c;
            r.children.push(t);
    }
}
function getAvailableSpace(e1) {
    const t = e1[$n].availableSpace, a = e1.margin ? e1.margin.topInset + e1.margin.bottomInset : 0, r = e1.margin ? e1.margin.leftInset + e1.margin.rightInset : 0;
    switch(e1.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === e1[$n].attempt ? {
                width: t.width - r - e1[$n].currentWidth,
                height: t.height - a - e1[$n].prevHeight
            } : {
                width: t.width - r,
                height: t.height - a - e1[$n].height
            };
        case "rl-row":
        case "row":
            return {
                width: Math.sumPrecise(e1[$n].columnWidths.slice(e1[$n].currentColumn)),
                height: t.height - r
            };
        case "table":
        case "tb":
            return {
                width: t.width - r,
                height: t.height - a - e1[$n].height
            };
        default:
            return t;
    }
}
function checkDimensions(e1, t) {
    if (null === e1[ls]()[$n].firstUnsplittable) return !0;
    if (0 === e1.w || 0 === e1.h) return !0;
    const a = e1[os](), r = a[$n]?.attempt || 0, [, i, n, s] = function getTransformedBBox(e1) {
        let t, a, r = "" === e1.w ? NaN : e1.w, i = "" === e1.h ? NaN : e1.h, [n, s] = [
            0,
            0
        ];
        switch(e1.anchorType || ""){
            case "bottomCenter":
                [n, s] = [
                    r / 2,
                    i
                ];
                break;
            case "bottomLeft":
                [n, s] = [
                    0,
                    i
                ];
                break;
            case "bottomRight":
                [n, s] = [
                    r,
                    i
                ];
                break;
            case "middleCenter":
                [n, s] = [
                    r / 2,
                    i / 2
                ];
                break;
            case "middleLeft":
                [n, s] = [
                    0,
                    i / 2
                ];
                break;
            case "middleRight":
                [n, s] = [
                    r,
                    i / 2
                ];
                break;
            case "topCenter":
                [n, s] = [
                    r / 2,
                    0
                ];
                break;
            case "topRight":
                [n, s] = [
                    r,
                    0
                ];
        }
        switch(e1.rotate || 0){
            case 0:
                [t, a] = [
                    -n,
                    -s
                ];
                break;
            case 90:
                [t, a] = [
                    -s,
                    n
                ];
                [r, i] = [
                    i,
                    -r
                ];
                break;
            case 180:
                [t, a] = [
                    n,
                    s
                ];
                [r, i] = [
                    -r,
                    -i
                ];
                break;
            case 270:
                [t, a] = [
                    s,
                    -n
                ];
                [r, i] = [
                    -i,
                    r
                ];
        }
        return [
            e1.x + t + Math.min(0, r),
            e1.y + a + Math.min(0, i),
            Math.abs(r),
            Math.abs(i)
        ];
    }(e1);
    switch(a.layout){
        case "lr-tb":
        case "rl-tb":
            return 0 === r ? e1[ls]()[$n].noLayoutFailure ? "" !== e1.w ? Math.round(n - t.width) <= 2 : t.width > 2 : !("" !== e1.h && Math.round(s - t.height) > 2) && ("" !== e1.w ? Math.round(n - t.width) <= 2 || 0 === a[$n].numberInLine && t.height > 2 : t.width > 2) : !!e1[ls]()[$n].noLayoutFailure || !("" !== e1.h && Math.round(s - t.height) > 2) && ("" === e1.w || Math.round(n - t.width) <= 2 || !a[Ss]()) && t.height > 2;
        case "table":
        case "tb":
            return !!e1[ls]()[$n].noLayoutFailure || ("" === e1.h || e1[xs]() ? ("" === e1.w || Math.round(n - t.width) <= 2 || !a[Ss]()) && t.height > 2 : Math.round(s - t.height) <= 2);
        case "position":
            if (e1[ls]()[$n].noLayoutFailure) return !0;
            if ("" === e1.h || Math.round(s + i - t.height) <= 2) return !0;
            return s + i > e1[ls]()[$n].currentContentArea.h;
        case "rl-row":
        case "row":
            return !!e1[ls]()[$n].noLayoutFailure || "" === e1.h || Math.round(s - t.height) <= 2;
        default:
            return !0;
    }
}
const Mo = Js.template.id, Do = "http://www.w3.org/2000/svg", Bo = /^H(\d+)$/, Ro = new Set([
    "image/gif",
    "image/jpeg",
    "image/jpg",
    "image/pjpeg",
    "image/png",
    "image/apng",
    "image/x-png",
    "image/bmp",
    "image/x-ms-bmp",
    "image/tiff",
    "image/tif",
    "application/octet-stream"
]), No = [
    [
        [
            66,
            77
        ],
        "image/bmp"
    ],
    [
        [
            255,
            216,
            255
        ],
        "image/jpeg"
    ],
    [
        [
            73,
            73,
            42,
            0
        ],
        "image/tiff"
    ],
    [
        [
            77,
            77,
            0,
            42
        ],
        "image/tiff"
    ],
    [
        [
            71,
            73,
            70,
            56,
            57,
            97
        ],
        "image/gif"
    ],
    [
        [
            137,
            80,
            78,
            71,
            13,
            10,
            26,
            10
        ],
        "image/png"
    ]
];
function getBorderDims(e1) {
    if (!e1 || !e1.border) return {
        w: 0,
        h: 0
    };
    const t = e1.border[as]();
    return t ? {
        w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2],
        h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3]
    } : {
        w: 0,
        h: 0
    };
}
function hasMargin(e1) {
    return e1.margin && (e1.margin.topInset || e1.margin.rightInset || e1.margin.bottomInset || e1.margin.leftInset);
}
function _setValue(e1, t) {
    if (!e1.value) {
        const t = new Value({});
        e1[Pn](t);
        e1.value = t;
    }
    e1.value[Xs](t);
}
function* getContainedChildren(e1) {
    for (const t of e1[is]())t instanceof SubformSet ? yield* t[ns]() : yield t;
}
function isRequired(e1) {
    return "error" === e1.validate?.nullTest;
}
function setTabIndex(e1) {
    for(; e1;){
        if (!e1.traversal) {
            e1[qs] = e1[cs]()[qs];
            return;
        }
        if (e1[qs]) return;
        let t = null;
        for (const a of e1.traversal[is]())if ("next" === a.operation) {
            t = a;
            break;
        }
        if (!t || !t.ref) {
            e1[qs] = e1[cs]()[qs];
            return;
        }
        const a = e1[ls]();
        e1[qs] = ++a[qs];
        const r = a[js](t.ref, e1);
        if (!r) return;
        e1 = r[0];
    }
}
function applyAssist(e1, t) {
    const a = e1.assist;
    if (a) {
        const e1 = a[zs]();
        e1 && (t.title = e1);
        const r = a.role.match(Bo);
        if (r) {
            const e1 = "heading", a = r[1];
            t.role = e1;
            t["aria-level"] = a;
        }
    }
    if ("table" === e1.layout) t.role = "table";
    else if ("row" === e1.layout) t.role = "row";
    else {
        const a = e1[cs]();
        "row" === a.layout && (t.role = "TH" === a.assist?.role ? "columnheader" : "cell");
    }
}
function ariaLabel(e1) {
    if (!e1.assist) return null;
    const t = e1.assist;
    return t.speak && "" !== t.speak[Hn] ? t.speak[Hn] : t.toolTip ? t.toolTip[Hn] : null;
}
function valueToHtml(e1) {
    return HTMLResult.success({
        name: "div",
        attributes: {
            class: [
                "xfaRich"
            ],
            style: Object.create(null)
        },
        children: [
            {
                name: "span",
                attributes: {
                    style: Object.create(null)
                },
                value: e1
            }
        ]
    });
}
function setFirstUnsplittable(e1) {
    const t = e1[ls]();
    if (null === t[$n].firstUnsplittable) {
        t[$n].firstUnsplittable = e1;
        t[$n].noLayoutFailure = !0;
    }
}
function unsetFirstUnsplittable(e1) {
    const t = e1[ls]();
    t[$n].firstUnsplittable === e1 && (t[$n].noLayoutFailure = !1);
}
function handleBreak(e1) {
    if (e1[$n]) return !1;
    e1[$n] = Object.create(null);
    if ("auto" === e1.targetType) return !1;
    const t = e1[ls]();
    let a = null;
    if (e1.target) {
        a = t[js](e1.target, e1[cs]());
        if (!a) return !1;
        a = a[0];
    }
    const { currentPageArea: r, currentContentArea: i } = t[$n];
    if ("pageArea" === e1.targetType) {
        a instanceof PageArea || (a = null);
        if (e1.startNew) {
            e1[$n].target = a || r;
            return !0;
        }
        if (a && a !== r) {
            e1[$n].target = a;
            return !0;
        }
        return !1;
    }
    a instanceof ContentArea || (a = null);
    const n = a && a[cs]();
    let s, o = n;
    if (e1.startNew) if (a) {
        const e1 = n.contentArea.children, t = e1.indexOf(i), r = e1.indexOf(a);
        -1 !== t && t < r && (o = null);
        s = r - 1;
    } else s = r.contentArea.children.indexOf(i);
    else {
        if (!a || a === i) return !1;
        s = n.contentArea.children.indexOf(a) - 1;
        o = n === r ? null : n;
    }
    e1[$n].target = o;
    e1[$n].index = s;
    return !0;
}
function handleOverflow(e1, t, a) {
    const r = e1[ls](), i = r[$n].noLayoutFailure, n = t[os];
    t[os] = ()=>e1;
    r[$n].noLayoutFailure = !0;
    const s = t[zs](a);
    e1[En](s.html, s.bbox);
    r[$n].noLayoutFailure = i;
    t[os] = n;
}
class AppearanceFilter extends StringObject {
    constructor(e1){
        super(Mo, "appearanceFilter");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Arc extends XFAObject {
    constructor(e1){
        super(Mo, "arc", !0);
        this.circular = getInteger({
            data: e1.circular,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.startAngle = getFloat({
            data: e1.startAngle,
            defaultValue: 0,
            validate: (e1)=>!0
        });
        this.sweepAngle = getFloat({
            data: e1.sweepAngle,
            defaultValue: 360,
            validate: (e1)=>!0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.edge = null;
        this.fill = null;
    }
    [zs]() {
        const e1 = this.edge || new Edge({}), t = e1[Gs](), a = Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(a, this.fill[Gs]()) : a.fill = "transparent";
        a.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0);
        a.stroke = t.color;
        let r;
        const i = {
            xmlns: Do,
            style: {
                width: "100%",
                height: "100%",
                overflow: "visible"
            }
        };
        if (360 === this.sweepAngle) r = {
            name: "ellipse",
            attributes: {
                xmlns: Do,
                cx: "50%",
                cy: "50%",
                rx: "50%",
                ry: "50%",
                style: a
            }
        };
        else {
            const e1 = this.startAngle * Math.PI / 180, t = this.sweepAngle * Math.PI / 180, n = this.sweepAngle > 180 ? 1 : 0, [s, o, c, l] = [
                50 * (1 + Math.cos(e1)),
                50 * (1 - Math.sin(e1)),
                50 * (1 + Math.cos(e1 + t)),
                50 * (1 - Math.sin(e1 + t))
            ];
            r = {
                name: "path",
                attributes: {
                    xmlns: Do,
                    d: `M ${s} ${o} A 50 50 0 ${n} 0 ${c} ${l}`,
                    vectorEffect: "non-scaling-stroke",
                    style: a
                }
            };
            Object.assign(i, {
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none"
            });
        }
        const n = {
            name: "svg",
            children: [
                r
            ],
            attributes: i
        };
        if (hasMargin(this[cs]()[cs]())) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                n
            ]
        });
        n.attributes.style.position = "absolute";
        return HTMLResult.success(n);
    }
}
class Area extends XFAObject {
    constructor(e1){
        super(Mo, "area", !0);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.desc = null;
        this.extras = null;
        this.area = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    *[ns]() {
        yield* getContainedChildren(this);
    }
    [As]() {
        return !0;
    }
    [ms]() {
        return !0;
    }
    [En](e1, t) {
        const [a, r, i, n] = t;
        this[$n].width = Math.max(this[$n].width, a + i);
        this[$n].height = Math.max(this[$n].height, r + n);
        this[$n].children.push(e1);
    }
    [Yn]() {
        return this[$n].availableSpace;
    }
    [zs](e1) {
        const t = toStyle(this, "position"), a = {
            style: t,
            id: this[Vs],
            class: [
                "xfaArea"
            ]
        };
        isPrintOnly(this) && a.class.push("xfaPrintOnly");
        this.name && (a.xfaName = this.name);
        const r = [];
        this[$n] = {
            children: r,
            width: 0,
            height: 0,
            availableSpace: e1
        };
        const i = this[Ln]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "exclGroup",
                "subform",
                "subformSet"
            ]),
            include: !0
        });
        if (!i.success) {
            if (i.isBreak()) return i;
            delete this[$n];
            return HTMLResult.FAILURE;
        }
        t.width = measureToString(this[$n].width);
        t.height = measureToString(this[$n].height);
        const n = {
            name: "div",
            attributes: a,
            children: r
        }, s = [
            this.x,
            this.y,
            this[$n].width,
            this[$n].height
        ];
        delete this[$n];
        return HTMLResult.success(n, s);
    }
}
class Assist extends XFAObject {
    constructor(e1){
        super(Mo, "assist", !0);
        this.id = e1.id || "";
        this.role = e1.role || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.speak = null;
        this.toolTip = null;
    }
    [zs]() {
        return this.toolTip?.[Hn] || null;
    }
}
class Barcode extends XFAObject {
    constructor(e1){
        super(Mo, "barcode", !0);
        this.charEncoding = getKeyword({
            data: e1.charEncoding ? e1.charEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        });
        this.checksum = getStringOption(e1.checksum, [
            "none",
            "1mod10",
            "1mod10_1mod11",
            "2mod10",
            "auto"
        ]);
        this.dataColumnCount = getInteger({
            data: e1.dataColumnCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.dataLength = getInteger({
            data: e1.dataLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.dataPrep = getStringOption(e1.dataPrep, [
            "none",
            "flateCompress"
        ]);
        this.dataRowCount = getInteger({
            data: e1.dataRowCount,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0
        });
        this.endChar = e1.endChar || "";
        this.errorCorrectionLevel = getInteger({
            data: e1.errorCorrectionLevel,
            defaultValue: -1,
            validate: (e1)=>e1 >= 0 && e1 <= 8
        });
        this.id = e1.id || "";
        this.moduleHeight = getMeasurement(e1.moduleHeight, "5mm");
        this.moduleWidth = getMeasurement(e1.moduleWidth, "0.25mm");
        this.printCheckDigit = getInteger({
            data: e1.printCheckDigit,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.rowColumnRatio = getRatio(e1.rowColumnRatio);
        this.startChar = e1.startChar || "";
        this.textLocation = getStringOption(e1.textLocation, [
            "below",
            "above",
            "aboveEmbedded",
            "belowEmbedded",
            "none"
        ]);
        this.truncate = getInteger({
            data: e1.truncate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.type = getStringOption(e1.type ? e1.type.toLowerCase() : "", [
            "aztec",
            "codabar",
            "code2of5industrial",
            "code2of5interleaved",
            "code2of5matrix",
            "code2of5standard",
            "code3of9",
            "code3of9extended",
            "code11",
            "code49",
            "code93",
            "code128",
            "code128a",
            "code128b",
            "code128c",
            "code128sscc",
            "datamatrix",
            "ean8",
            "ean8add2",
            "ean8add5",
            "ean13",
            "ean13add2",
            "ean13add5",
            "ean13pwcd",
            "fim",
            "logmars",
            "maxicode",
            "msi",
            "pdf417",
            "pdf417macro",
            "plessey",
            "postauscust2",
            "postauscust3",
            "postausreplypaid",
            "postausstandard",
            "postukrm4scc",
            "postusdpbc",
            "postusimb",
            "postusstandard",
            "postus5zip",
            "qrcode",
            "rfid",
            "rss14",
            "rss14expanded",
            "rss14limited",
            "rss14stacked",
            "rss14stackedomni",
            "rss14truncated",
            "telepen",
            "ucc128",
            "ucc128random",
            "ucc128sscc",
            "upca",
            "upcaadd2",
            "upcaadd5",
            "upcapwcd",
            "upce",
            "upceadd2",
            "upceadd5",
            "upcean2",
            "upcean5",
            "upsmaxicode"
        ]);
        this.upsMode = getStringOption(e1.upsMode, [
            "usCarrier",
            "internationalCarrier",
            "secureSymbol",
            "standardSymbol"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.wideNarrowRatio = getRatio(e1.wideNarrowRatio);
        this.encrypt = null;
        this.extras = null;
    }
}
class Bind extends XFAObject {
    constructor(e1){
        super(Mo, "bind", !0);
        this.match = getStringOption(e1.match, [
            "once",
            "dataRef",
            "global",
            "none"
        ]);
        this.ref = e1.ref || "";
        this.picture = null;
    }
}
class BindItems extends XFAObject {
    constructor(e1){
        super(Mo, "bindItems");
        this.connection = e1.connection || "";
        this.labelRef = e1.labelRef || "";
        this.ref = e1.ref || "";
        this.valueRef = e1.valueRef || "";
    }
}
class Bookend extends XFAObject {
    constructor(e1){
        super(Mo, "bookend");
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class BooleanElement extends Option01 {
    constructor(e1){
        super(Mo, "boolean");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [zs](e1) {
        return valueToHtml(1 === this[Hn] ? "1" : "0");
    }
}
class Border extends XFAObject {
    constructor(e1){
        super(Mo, "border", !0);
        this.break = getStringOption(e1.break, [
            "close",
            "open"
        ]);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.extras = null;
        this.fill = null;
        this.margin = null;
    }
    [as]() {
        if (!this[$n]) {
            const e1 = this.edge.children.slice();
            if (e1.length < 4) {
                const t = e1.at(-1) || new Edge({});
                for(let a = e1.length; a < 4; a++)e1.push(t);
            }
            const t = e1.map((e1)=>e1.thickness), a = [
                0,
                0,
                0,
                0
            ];
            if (this.margin) {
                a[0] = this.margin.topInset;
                a[1] = this.margin.rightInset;
                a[2] = this.margin.bottomInset;
                a[3] = this.margin.leftInset;
            }
            this[$n] = {
                widths: t,
                insets: a,
                edges: e1
            };
        }
        return this[$n];
    }
    [Gs]() {
        const { edges: e1 } = this[as](), t = e1.map((e1)=>{
            const t = e1[Gs]();
            t.color ||= "#000000";
            return t;
        }), a = Object.create(null);
        this.margin && Object.assign(a, this.margin[Gs]());
        "visible" === this.fill?.presence && Object.assign(a, this.fill[Gs]());
        if (this.corner.children.some((e1)=>0 !== e1.radius)) {
            const e1 = this.corner.children.map((e1)=>e1[Gs]());
            if (2 === e1.length || 3 === e1.length) {
                const t = e1.at(-1);
                for(let a = e1.length; a < 4; a++)e1.push(t);
            }
            a.borderRadius = e1.map((e1)=>e1.radius).join(" ");
        }
        switch(this.presence){
            case "invisible":
            case "hidden":
                a.borderStyle = "";
                break;
            case "inactive":
                a.borderStyle = "none";
                break;
            default:
                a.borderStyle = t.map((e1)=>e1.style).join(" ");
        }
        a.borderWidth = t.map((e1)=>e1.width).join(" ");
        a.borderColor = t.map((e1)=>e1.color).join(" ");
        return a;
    }
}
class Break extends XFAObject {
    constructor(e1){
        super(Mo, "break", !0);
        this.after = getStringOption(e1.after, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]);
        this.afterTarget = e1.afterTarget || "";
        this.before = getStringOption(e1.before, [
            "auto",
            "contentArea",
            "pageArea",
            "pageEven",
            "pageOdd"
        ]);
        this.beforeTarget = e1.beforeTarget || "";
        this.bookendLeader = e1.bookendLeader || "";
        this.bookendTrailer = e1.bookendTrailer || "";
        this.id = e1.id || "";
        this.overflowLeader = e1.overflowLeader || "";
        this.overflowTarget = e1.overflowTarget || "";
        this.overflowTrailer = e1.overflowTrailer || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class BreakAfter extends XFAObject {
    constructor(e1){
        super(Mo, "breakAfter", !0);
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.target = e1.target || "";
        this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]);
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.script = null;
    }
}
class BreakBefore extends XFAObject {
    constructor(e1){
        super(Mo, "breakBefore", !0);
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.startNew = getInteger({
            data: e1.startNew,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.target = e1.target || "";
        this.targetType = getStringOption(e1.targetType, [
            "auto",
            "contentArea",
            "pageArea"
        ]);
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.script = null;
    }
    [zs](e1) {
        this[$n] = {};
        return HTMLResult.FAILURE;
    }
}
class Button extends XFAObject {
    constructor(e1){
        super(Mo, "button", !0);
        this.highlight = getStringOption(e1.highlight, [
            "inverted",
            "none",
            "outline",
            "push"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [zs](e1) {
        const t = this[cs]()[cs](), a = {
            name: "button",
            attributes: {
                id: this[Vs],
                class: [
                    "xfaButton"
                ],
                style: {}
            },
            children: []
        };
        for (const e1 of t.event.children){
            if ("click" !== e1.activity || !e1.script) continue;
            const t = recoverJsURL(e1.script[Hn]);
            if (!t) continue;
            const r = fixURL(t.url);
            r && a.children.push({
                name: "a",
                attributes: {
                    id: "link" + this[Vs],
                    href: r,
                    newWindow: t.newWindow,
                    class: [
                        "xfaLink"
                    ],
                    style: {}
                },
                children: []
            });
        }
        return HTMLResult.success(a);
    }
}
class Calculate extends XFAObject {
    constructor(e1){
        super(Mo, "calculate", !0);
        this.id = e1.id || "";
        this.override = getStringOption(e1.override, [
            "disabled",
            "error",
            "ignore",
            "warning"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.message = null;
        this.script = null;
    }
}
class Caption extends XFAObject {
    constructor(e1){
        super(Mo, "caption", !0);
        this.id = e1.id || "";
        this.placement = getStringOption(e1.placement, [
            "left",
            "bottom",
            "inline",
            "right",
            "top"
        ]);
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.reserve = Math.ceil(getMeasurement(e1.reserve));
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.font = null;
        this.margin = null;
        this.para = null;
        this.value = null;
    }
    [Xs](e1) {
        _setValue(this, e1);
    }
    [as](e1) {
        if (!this[$n]) {
            let { width: t, height: a } = e1;
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    t = this.reserve <= 0 ? t : this.reserve;
                    break;
                case "top":
                case "bottom":
                    a = this.reserve <= 0 ? a : this.reserve;
            }
            this[$n] = layoutNode(this, {
                width: t,
                height: a
            });
        }
        return this[$n];
    }
    [zs](e1) {
        if (!this.value) return HTMLResult.EMPTY;
        this[Rs]();
        const t = this.value[zs](e1).html;
        if (!t) {
            this[Bs]();
            return HTMLResult.EMPTY;
        }
        const a = this.reserve;
        if (this.reserve <= 0) {
            const { w: t, h: a } = this[as](e1);
            switch(this.placement){
                case "left":
                case "right":
                case "inline":
                    this.reserve = t;
                    break;
                case "top":
                case "bottom":
                    this.reserve = a;
            }
        }
        const r = [];
        "string" == typeof t ? r.push({
            name: "#text",
            value: t
        }) : r.push(t);
        const i = toStyle(this, "font", "margin", "visibility");
        switch(this.placement){
            case "left":
            case "right":
                this.reserve > 0 && (i.width = measureToString(this.reserve));
                break;
            case "top":
            case "bottom":
                this.reserve > 0 && (i.height = measureToString(this.reserve));
        }
        setPara(this, null, t);
        this[Bs]();
        this.reserve = a;
        return HTMLResult.success({
            name: "div",
            attributes: {
                style: i,
                class: [
                    "xfaCaption"
                ]
            },
            children: r
        });
    }
}
class Certificate extends StringObject {
    constructor(e1){
        super(Mo, "certificate");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Certificates extends XFAObject {
    constructor(e1){
        super(Mo, "certificates", !0);
        this.credentialServerPolicy = getStringOption(e1.credentialServerPolicy, [
            "optional",
            "required"
        ]);
        this.id = e1.id || "";
        this.url = e1.url || "";
        this.urlPolicy = e1.urlPolicy || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encryption = null;
        this.issuers = null;
        this.keyUsage = null;
        this.oids = null;
        this.signing = null;
        this.subjectDNs = null;
    }
}
class CheckButton extends XFAObject {
    constructor(e1){
        super(Mo, "checkButton", !0);
        this.id = e1.id || "";
        this.mark = getStringOption(e1.mark, [
            "default",
            "check",
            "circle",
            "cross",
            "diamond",
            "square",
            "star"
        ]);
        this.shape = getStringOption(e1.shape, [
            "square",
            "round"
        ]);
        this.size = getMeasurement(e1.size, "10pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        const t = toStyle(this, "margin"), a = measureToString(this.size);
        t.width = t.height = a;
        let r, i, n;
        const s = this[cs]()[cs](), o = s.items.children.length && s.items.children[0][zs]().html || [], c = {
            on: (void 0 !== o[0] ? o[0] : "on").toString(),
            off: (void 0 !== o[1] ? o[1] : "off").toString()
        }, l = (s.value?.[Hs]() || "off") === c.on || void 0, h = s[os](), u = s[Vs];
        let d;
        if (h instanceof ExclGroup) {
            n = h[Vs];
            r = "radio";
            i = "xfaRadio";
            d = h[Wn]?.[Vs] || h[Vs];
        } else {
            r = "checkbox";
            i = "xfaCheckbox";
            d = s[Wn]?.[Vs] || s[Vs];
        }
        const f = {
            name: "input",
            attributes: {
                class: [
                    i
                ],
                style: t,
                fieldId: u,
                dataId: d,
                type: r,
                checked: l,
                xfaOn: c.on,
                xfaOff: c.off,
                "aria-label": ariaLabel(s),
                "aria-required": !1
            }
        };
        n && (f.attributes.name = n);
        if (isRequired(s)) {
            f.attributes["aria-required"] = !0;
            f.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                f
            ]
        });
    }
}
class ChoiceList extends XFAObject {
    constructor(e1){
        super(Mo, "choiceList", !0);
        this.commitOn = getStringOption(e1.commitOn, [
            "select",
            "exit"
        ]);
        this.id = e1.id || "";
        this.open = getStringOption(e1.open, [
            "userControl",
            "always",
            "multiSelect",
            "onEntry"
        ]);
        this.textEntry = getInteger({
            data: e1.textEntry,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        const t = toStyle(this, "border", "margin"), a = this[cs]()[cs](), r = {
            fontSize: `calc(${a.font?.size || 10}px * var(--total-scale-factor))`
        }, i = [];
        if (a.items.children.length > 0) {
            const e1 = a.items;
            let t = 0, n = 0;
            if (2 === e1.children.length) {
                t = e1.children[0].save;
                n = 1 - t;
            }
            const s = e1.children[t][zs]().html, o = e1.children[n][zs]().html;
            let c = !1;
            const l = a.value?.[Hs]() || "";
            for(let e1 = 0, t = s.length; e1 < t; e1++){
                const t = {
                    name: "option",
                    attributes: {
                        value: o[e1] || s[e1],
                        style: r
                    },
                    value: s[e1]
                };
                o[e1] === l && (t.attributes.selected = c = !0);
                i.push(t);
            }
            c || i.splice(0, 0, {
                name: "option",
                attributes: {
                    hidden: !0,
                    selected: !0
                },
                value: " "
            });
        }
        const n = {
            class: [
                "xfaSelect"
            ],
            fieldId: a[Vs],
            dataId: a[Wn]?.[Vs] || a[Vs],
            style: t,
            "aria-label": ariaLabel(a),
            "aria-required": !1
        };
        if (isRequired(a)) {
            n["aria-required"] = !0;
            n.required = !0;
        }
        "multiSelect" === this.open && (n.multiple = !0);
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                {
                    name: "select",
                    children: i,
                    attributes: n
                }
            ]
        });
    }
}
class Color extends XFAObject {
    constructor(e1){
        super(Mo, "color", !0);
        this.cSpace = getStringOption(e1.cSpace, [
            "SRGB"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.value = e1.value ? function getColor(e1, t = [
            0,
            0,
            0
        ]) {
            let [a, r, i] = t;
            if (!e1) return {
                r: a,
                g: r,
                b: i
            };
            const n = e1.split(",", 3).map((e1)=>MathClamp(parseInt(e1.trim(), 10), 0, 255)).map((e1)=>isNaN(e1) ? 0 : e1);
            if (n.length < 3) return {
                r: a,
                g: r,
                b: i
            };
            [a, r, i] = n;
            return {
                r: a,
                g: r,
                b: i
            };
        }(e1.value) : "";
        this.extras = null;
    }
    [us]() {
        return !1;
    }
    [Gs]() {
        return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
    }
}
class Comb extends XFAObject {
    constructor(e1){
        super(Mo, "comb");
        this.id = e1.id || "";
        this.numberOfCells = getInteger({
            data: e1.numberOfCells,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Connect extends XFAObject {
    constructor(e1){
        super(Mo, "connect", !0);
        this.connection = e1.connection || "";
        this.id = e1.id || "";
        this.ref = e1.ref || "";
        this.usage = getStringOption(e1.usage, [
            "exportAndImport",
            "exportOnly",
            "importOnly"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.picture = null;
    }
}
class ContentArea extends XFAObject {
    constructor(e1){
        super(Mo, "contentArea", !0);
        this.h = getMeasurement(e1.h);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = getMeasurement(e1.w);
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.desc = null;
        this.extras = null;
    }
    [zs](e1) {
        const t = {
            left: measureToString(this.x),
            top: measureToString(this.y),
            width: measureToString(this.w),
            height: measureToString(this.h)
        }, a = [
            "xfaContentarea"
        ];
        isPrintOnly(this) && a.push("xfaPrintOnly");
        return HTMLResult.success({
            name: "div",
            children: [],
            attributes: {
                style: t,
                class: a,
                id: this[Vs]
            }
        });
    }
}
class Corner extends XFAObject {
    constructor(e1){
        super(Mo, "corner", !0);
        this.id = e1.id || "";
        this.inverted = getInteger({
            data: e1.inverted,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.join = getStringOption(e1.join, [
            "square",
            "round"
        ]);
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.radius = getMeasurement(e1.radius);
        this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]);
        this.thickness = getMeasurement(e1.thickness, "0.5pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs]() {
        const e1 = toStyle(this, "visibility");
        e1.radius = measureToString("square" === this.join ? 0 : this.radius);
        return e1;
    }
}
class DateElement extends ContentObject {
    constructor(e1){
        super(Mo, "date");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = this[Hn].trim();
        this[Hn] = e1 ? new Date(e1) : null;
    }
    [zs](e1) {
        return valueToHtml(this[Hn] ? this[Hn].toString() : "");
    }
}
class DateTime extends ContentObject {
    constructor(e1){
        super(Mo, "dateTime");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = this[Hn].trim();
        this[Hn] = e1 ? new Date(e1) : null;
    }
    [zs](e1) {
        return valueToHtml(this[Hn] ? this[Hn].toString() : "");
    }
}
class DateTimeEdit extends XFAObject {
    constructor(e1){
        super(Mo, "dateTimeEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.picker = getStringOption(e1.picker, [
            "host",
            "none"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        const t = toStyle(this, "border", "font", "margin"), a = this[cs]()[cs](), r = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: a[Vs],
                dataId: a[Wn]?.[Vs] || a[Vs],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(a),
                "aria-required": !1
            }
        };
        if (isRequired(a)) {
            r.attributes["aria-required"] = !0;
            r.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                r
            ]
        });
    }
}
class Decimal extends ContentObject {
    constructor(e1){
        super(Mo, "decimal");
        this.fracDigits = getInteger({
            data: e1.fracDigits,
            defaultValue: 2,
            validate: (e1)=>!0
        });
        this.id = e1.id || "";
        this.leadDigits = getInteger({
            data: e1.leadDigits,
            defaultValue: -1,
            validate: (e1)=>!0
        });
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = parseFloat(this[Hn].trim());
        this[Hn] = isNaN(e1) ? null : e1;
    }
    [zs](e1) {
        return valueToHtml(null !== this[Hn] ? this[Hn].toString() : "");
    }
}
class DefaultUi extends XFAObject {
    constructor(e1){
        super(Mo, "defaultUi", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class Desc extends XFAObject {
    constructor(e1){
        super(Mo, "desc", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class DigestMethod extends OptionObject {
    constructor(e1){
        super(Mo, "digestMethod", [
            "",
            "SHA1",
            "SHA256",
            "SHA512",
            "RIPEMD160"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class DigestMethods extends XFAObject {
    constructor(e1){
        super(Mo, "digestMethods", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.digestMethod = new XFAObjectArray;
    }
}
class Draw extends XFAObject {
    constructor(e1){
        super(Mo, "draw", !0);
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.border = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.value = null;
        this.setProperty = new XFAObjectArray;
    }
    [Xs](e1) {
        _setValue(this, e1);
    }
    [zs](e1) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        fixDimensions(this);
        this[Rs]();
        const t = this.w, a = this.h, { w: r, h: i, isBroken: n } = layoutNode(this, e1);
        if (r && "" === this.w) {
            if (n && this[os]()[Ss]()) {
                this[Bs]();
                return HTMLResult.FAILURE;
            }
            this.w = r;
        }
        i && "" === this.h && (this.h = i);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) {
            this.w = t;
            this.h = a;
            this[Bs]();
            return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const s = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
        setMinMaxDimensions(this, s);
        if (s.margin) {
            s.padding = s.margin;
            delete s.margin;
        }
        const o = [
            "xfaDraw"
        ];
        this.font && o.push("xfaFont");
        isPrintOnly(this) && o.push("xfaPrintOnly");
        const c = {
            style: s,
            id: this[Vs],
            class: o
        };
        this.name && (c.xfaName = this.name);
        const l = {
            name: "div",
            attributes: c,
            children: []
        };
        applyAssist(this, c);
        const h = computeBbox(this, l, e1), u = this.value ? this.value[zs](e1).html : null;
        if (null === u) {
            this.w = t;
            this.h = a;
            this[Bs]();
            return HTMLResult.success(createWrapper(this, l), h);
        }
        l.children.push(u);
        setPara(this, s, u);
        this.w = t;
        this.h = a;
        this[Bs]();
        return HTMLResult.success(createWrapper(this, l), h);
    }
}
class Edge extends XFAObject {
    constructor(e1){
        super(Mo, "edge", !0);
        this.cap = getStringOption(e1.cap, [
            "square",
            "butt",
            "round"
        ]);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.stroke = getStringOption(e1.stroke, [
            "solid",
            "dashDot",
            "dashDotDot",
            "dashed",
            "dotted",
            "embossed",
            "etched",
            "lowered",
            "raised"
        ]);
        this.thickness = getMeasurement(e1.thickness, "0.5pt");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs]() {
        const e1 = toStyle(this, "visibility");
        Object.assign(e1, {
            linecap: this.cap,
            width: measureToString(this.thickness),
            color: this.color ? this.color[Gs]() : "#000000",
            style: ""
        });
        if ("visible" !== this.presence) e1.style = "none";
        else switch(this.stroke){
            case "solid":
                e1.style = "solid";
                break;
            case "dashDot":
            case "dashDotDot":
            case "dashed":
                e1.style = "dashed";
                break;
            case "dotted":
                e1.style = "dotted";
                break;
            case "embossed":
                e1.style = "ridge";
                break;
            case "etched":
                e1.style = "groove";
                break;
            case "lowered":
                e1.style = "inset";
                break;
            case "raised":
                e1.style = "outset";
        }
        return e1;
    }
}
class Encoding extends OptionObject {
    constructor(e1){
        super(Mo, "encoding", [
            "adbe.x509.rsa_sha1",
            "adbe.pkcs7.detached",
            "adbe.pkcs7.sha1"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Encodings extends XFAObject {
    constructor(e1){
        super(Mo, "encodings", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encoding = new XFAObjectArray;
    }
}
class Encrypt extends XFAObject {
    constructor(e1){
        super(Mo, "encrypt", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = null;
    }
}
class EncryptData extends XFAObject {
    constructor(e1){
        super(Mo, "encryptData", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "encrypt",
            "decrypt"
        ]);
        this.target = e1.target || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.filter = null;
        this.manifest = null;
    }
}
class Encryption extends XFAObject {
    constructor(e1){
        super(Mo, "encryption", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class EncryptionMethod extends OptionObject {
    constructor(e1){
        super(Mo, "encryptionMethod", [
            "",
            "AES256-CBC",
            "TRIPLEDES-CBC",
            "AES128-CBC",
            "AES192-CBC"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class EncryptionMethods extends XFAObject {
    constructor(e1){
        super(Mo, "encryptionMethods", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.encryptionMethod = new XFAObjectArray;
    }
}
class Event extends XFAObject {
    constructor(e1){
        super(Mo, "event", !0);
        this.activity = getStringOption(e1.activity, [
            "click",
            "change",
            "docClose",
            "docReady",
            "enter",
            "exit",
            "full",
            "indexChange",
            "initialize",
            "mouseDown",
            "mouseEnter",
            "mouseExit",
            "mouseUp",
            "postExecute",
            "postOpen",
            "postPrint",
            "postSave",
            "postSign",
            "postSubmit",
            "preExecute",
            "preOpen",
            "prePrint",
            "preSave",
            "preSign",
            "preSubmit",
            "ready",
            "validationState"
        ]);
        this.id = e1.id || "";
        this.listen = getStringOption(e1.listen, [
            "refOnly",
            "refAndDescendents"
        ]);
        this.name = e1.name || "";
        this.ref = e1.ref || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.encryptData = null;
        this.execute = null;
        this.script = null;
        this.signData = null;
        this.submit = null;
    }
}
class ExData extends ContentObject {
    constructor(e1){
        super(Mo, "exData");
        this.contentType = e1.contentType || "";
        this.href = e1.href || "";
        this.id = e1.id || "";
        this.maxLength = getInteger({
            data: e1.maxLength,
            defaultValue: -1,
            validate: (e1)=>e1 >= -1
        });
        this.name = e1.name || "";
        this.rid = e1.rid || "";
        this.transferEncoding = getStringOption(e1.transferEncoding, [
            "none",
            "base64",
            "package"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [ps]() {
        return "text/html" === this.contentType;
    }
    [Ts](e1) {
        if ("text/html" === this.contentType && e1[vs] === Js.xhtml.id) {
            this[Hn] = e1;
            return !0;
        }
        if ("text/xml" === this.contentType) {
            this[Hn] = e1;
            return !0;
        }
        return !1;
    }
    [zs](e1) {
        return "text/html" === this.contentType && this[Hn] ? this[Hn][zs](e1) : HTMLResult.EMPTY;
    }
}
class ExObject extends XFAObject {
    constructor(e1){
        super(Mo, "exObject", !0);
        this.archive = e1.archive || "";
        this.classId = e1.classId || "";
        this.codeBase = e1.codeBase || "";
        this.codeType = e1.codeType || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class ExclGroup extends XFAObject {
    constructor(e1){
        super(Mo, "exclGroup", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.accessKey = e1.accessKey || "";
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]);
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.connect = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
    }
    [ms]() {
        return !0;
    }
    [us]() {
        return !0;
    }
    [Xs](e1) {
        for (const t of this.field.children){
            if (!t.value) {
                const e1 = new Value({});
                t[Pn](e1);
                t.value = e1;
            }
            t.value[Xs](e1);
        }
    }
    [Ss]() {
        return this.layout.endsWith("-tb") && 0 === this[$n].attempt && this[$n].numberInLine > 0 || this[cs]()[Ss]();
    }
    [xs]() {
        const e1 = this[os]();
        if (!e1[xs]()) return !1;
        if (void 0 !== this[$n]._isSplittable) return this[$n]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
            this[$n]._isSplittable = !1;
            return !1;
        }
        if (e1.layout?.endsWith("-tb") && 0 !== e1[$n].numberInLine) return !1;
        this[$n]._isSplittable = !0;
        return !0;
    }
    [Vn]() {
        return flushHTML(this);
    }
    [En](e1, t) {
        addHTML(this, e1, t);
    }
    [Yn]() {
        return getAvailableSpace(this);
    }
    [zs](e1) {
        setTabIndex(this);
        if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], a = {
            id: this[Vs],
            class: []
        };
        setAccess(this, a.class);
        this[$n] ||= Object.create(null);
        Object.assign(this[$n], {
            children: t,
            attributes: a,
            attempt: 0,
            line: null,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const r = this[xs]();
        r || setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const i = new Set([
            "field"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[os]().columnWidths;
            if (Array.isArray(e1) && e1.length > 0) {
                this[$n].columnWidths = e1;
                this[$n].currentColumn = 0;
            }
        }
        const n = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), s = [
            "xfaExclgroup"
        ], o = layoutClass(this);
        o && s.push(o);
        isPrintOnly(this) && s.push("xfaPrintOnly");
        a.style = n;
        a.class = s;
        this.name && (a.xfaName = this.name);
        this[Rs]();
        const c = "lr-tb" === this.layout || "rl-tb" === this.layout, l = c ? 2 : 1;
        for(; this[$n].attempt < l; this[$n].attempt++){
            c && 1 === this[$n].attempt && (this[$n].numberInLine = 0);
            const e1 = this[Ln]({
                filter: i,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) {
                this[Bs]();
                return e1;
            }
            if (c && 0 === this[$n].attempt && 0 === this[$n].numberInLine && !this[ls]()[$n].noLayoutFailure) {
                this[$n].attempt = l;
                break;
            }
        }
        this[Bs]();
        r || unsetFirstUnsplittable(this);
        if (this[$n].attempt === l) {
            r || delete this[$n];
            return HTMLResult.FAILURE;
        }
        let h = 0, u = 0;
        if (this.margin) {
            h = this.margin.leftInset + this.margin.rightInset;
            u = this.margin.topInset + this.margin.bottomInset;
        }
        const d = Math.max(this[$n].width + h, this.w || 0), f = Math.max(this[$n].height + u, this.h || 0), g = [
            this.x,
            this.y,
            d,
            f
        ];
        "" === this.w && (n.width = measureToString(d));
        "" === this.h && (n.height = measureToString(f));
        const p = {
            name: "div",
            attributes: a,
            children: t
        };
        applyAssist(this, a);
        delete this[$n];
        return HTMLResult.success(createWrapper(this, p), g);
    }
}
class Execute extends XFAObject {
    constructor(e1){
        super(Mo, "execute");
        this.connection = e1.connection || "";
        this.executeType = getStringOption(e1.executeType, [
            "import",
            "remerge"
        ]);
        this.id = e1.id || "";
        this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Extras extends XFAObject {
    constructor(e1){
        super(Mo, "extras", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.extras = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
}
class Field extends XFAObject {
    constructor(e1){
        super(Mo, "field", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.accessKey = e1.accessKey || "";
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.rotate = getInteger({
            data: e1.rotate,
            defaultValue: 0,
            validate: (e1)=>e1 % 90 == 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.border = null;
        this.calculate = null;
        this.caption = null;
        this.desc = null;
        this.extras = null;
        this.font = null;
        this.format = null;
        this.items = new XFAObjectArray(2);
        this.keep = null;
        this.margin = null;
        this.para = null;
        this.traversal = null;
        this.ui = null;
        this.validate = null;
        this.value = null;
        this.bindItems = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
    }
    [ms]() {
        return !0;
    }
    [Xs](e1) {
        _setValue(this, e1);
    }
    [zs](e1) {
        setTabIndex(this);
        if (!this.ui) {
            this.ui = new Ui({});
            this.ui[hs] = this[hs];
            this[Pn](this.ui);
            let e1;
            switch(this.items.children.length){
                case 0:
                    e1 = new TextEdit({});
                    this.ui.textEdit = e1;
                    break;
                case 1:
                    e1 = new CheckButton({});
                    this.ui.checkButton = e1;
                    break;
                case 2:
                    e1 = new ChoiceList({});
                    this.ui.choiceList = e1;
            }
            this.ui[Pn](e1);
        }
        if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
        this.caption && delete this.caption[$n];
        this[Rs]();
        const t = this.caption ? this.caption[zs](e1).html : null, a = this.w, r = this.h;
        let i = 0, n = 0;
        if (this.margin) {
            i = this.margin.leftInset + this.margin.rightInset;
            n = this.margin.topInset + this.margin.bottomInset;
        }
        let s = null;
        if ("" === this.w || "" === this.h) {
            let t = null, a = null, r = 0, o = 0;
            if (this.ui.checkButton) r = o = this.ui.checkButton.size;
            else {
                const { w: t, h: a } = layoutNode(this, e1);
                if (null !== t) {
                    r = t;
                    o = a;
                } else o = function fonts_getMetrics(e1, t = !1) {
                    let a = null;
                    if (e1) {
                        const t = stripQuotes(e1.typeface), r = e1[hs].fontFinder.find(t);
                        a = selectFont(e1, r);
                    }
                    if (!a) return {
                        lineHeight: 12,
                        lineGap: 2,
                        lineNoGap: 10
                    };
                    const r = e1.size || 10, i = a.lineHeight ? Math.max(t ? 0 : 1.2, a.lineHeight) : 1.2, n = void 0 === a.lineGap ? .2 : a.lineGap;
                    return {
                        lineHeight: i * r,
                        lineGap: n * r,
                        lineNoGap: Math.max(1, i - n) * r
                    };
                }(this.font, !0).lineNoGap;
            }
            s = getBorderDims(this.ui[as]());
            r += s.w;
            o += s.h;
            if (this.caption) {
                const { w: i, h: n, isBroken: s } = this.caption[as](e1);
                if (s && this[os]()[Ss]()) {
                    this[Bs]();
                    return HTMLResult.FAILURE;
                }
                t = i;
                a = n;
                switch(this.caption.placement){
                    case "left":
                    case "right":
                    case "inline":
                        t += r;
                        break;
                    case "top":
                    case "bottom":
                        a += o;
                }
            } else {
                t = r;
                a = o;
            }
            if (t && "" === this.w) {
                t += i;
                this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t ? t : this.minW);
            }
            if (a && "" === this.h) {
                a += n;
                this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < a ? a : this.minH);
            }
        }
        this[Bs]();
        fixDimensions(this);
        setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) {
            this.w = a;
            this.h = r;
            this[Bs]();
            return HTMLResult.FAILURE;
        }
        unsetFirstUnsplittable(this);
        const o = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
        setMinMaxDimensions(this, o);
        const c = [
            "xfaField"
        ];
        this.font && c.push("xfaFont");
        isPrintOnly(this) && c.push("xfaPrintOnly");
        const l = {
            style: o,
            id: this[Vs],
            class: c
        };
        if (o.margin) {
            o.padding = o.margin;
            delete o.margin;
        }
        setAccess(this, c);
        this.name && (l.xfaName = this.name);
        const h = [], u = {
            name: "div",
            attributes: l,
            children: h
        };
        applyAssist(this, l);
        const d = this.border ? this.border[Gs]() : null, f = computeBbox(this, u, e1), g = this.ui[zs]().html;
        if (!g) {
            Object.assign(o, d);
            return HTMLResult.success(createWrapper(this, u), f);
        }
        this[qs] && (g.children?.[0] ? g.children[0].attributes.tabindex = this[qs] : g.attributes.tabindex = this[qs]);
        g.attributes.style ||= Object.create(null);
        let p = null;
        if (this.ui.button) {
            1 === g.children.length && ([p] = g.children.splice(0, 1));
            Object.assign(g.attributes.style, d);
        } else Object.assign(o, d);
        h.push(g);
        if (this.value) {
            if (this.ui.imageEdit) g.children.push(this.value[zs]().html);
            else if (!this.ui.button) {
                let e1 = "";
                if (this.value.exData) e1 = this.value.exData[Hs]();
                else if (this.value.text) e1 = this.value.text[as]();
                else {
                    const t = this.value[zs]().html;
                    null !== t && (e1 = t.children[0].value);
                }
                this.ui.textEdit && this.value.text?.maxChars && (g.children[0].attributes.maxLength = this.value.text.maxChars);
                if (e1) {
                    if (this.ui.numericEdit) {
                        e1 = parseFloat(e1);
                        e1 = isNaN(e1) ? "" : e1.toString();
                    }
                    "textarea" === g.children[0].name ? g.children[0].attributes.textContent = e1 : g.children[0].attributes.value = e1;
                }
            }
        }
        if (!this.ui.imageEdit && g.children?.[0] && this.h) {
            s = s || getBorderDims(this.ui[as]());
            let t = 0;
            if (this.caption && [
                "top",
                "bottom"
            ].includes(this.caption.placement)) {
                t = this.caption.reserve;
                t <= 0 && (t = this.caption[as](e1).h);
                const a = this.h - t - n - s.h;
                g.children[0].attributes.style.height = measureToString(a);
            } else g.children[0].attributes.style.height = "100%";
        }
        p && g.children.push(p);
        if (!t) {
            g.attributes.class && g.attributes.class.push("xfaLeft");
            this.w = a;
            this.h = r;
            return HTMLResult.success(createWrapper(this, u), f);
        }
        if (this.ui.button) {
            o.padding && delete o.padding;
            "div" === t.name && (t.name = "span");
            g.children.push(t);
            return HTMLResult.success(u, f);
        }
        this.ui.checkButton && (t.attributes.class[0] = "xfaCaptionForCheckButton");
        g.attributes.class ||= [];
        g.children.splice(0, 0, t);
        switch(this.caption.placement){
            case "left":
            case "inline":
                g.attributes.class.push("xfaLeft");
                break;
            case "right":
                g.attributes.class.push("xfaRight");
                break;
            case "top":
                g.attributes.class.push("xfaTop");
                break;
            case "bottom":
                g.attributes.class.push("xfaBottom");
        }
        this.w = a;
        this.h = r;
        return HTMLResult.success(createWrapper(this, u), f);
    }
}
class Fill extends XFAObject {
    constructor(e1){
        super(Mo, "fill", !0);
        this.id = e1.id || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
        this.linear = null;
        this.pattern = null;
        this.radial = null;
        this.solid = null;
        this.stipple = null;
    }
    [Gs]() {
        const e1 = this[cs](), t = e1[cs]()[cs](), a = Object.create(null);
        let r = "color", i = r;
        if (e1 instanceof Border) {
            r = "background-color";
            i = "background";
            t instanceof Ui && (a.backgroundColor = "white");
        }
        if (e1 instanceof Rectangle || e1 instanceof Arc) {
            r = i = "fill";
            a.fill = "white";
        }
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("extras" === e1 || "color" === e1) continue;
            const t = this[e1];
            if (!(t instanceof XFAObject)) continue;
            const n = t[Gs](this.color);
            n && (a[n.startsWith("#") ? r : i] = n);
            return a;
        }
        if (this.color?.value) {
            const e1 = this.color[Gs]();
            a[e1.startsWith("#") ? r : i] = e1;
        }
        return a;
    }
}
class Filter extends XFAObject {
    constructor(e1){
        super(Mo, "filter", !0);
        this.addRevocationInfo = getStringOption(e1.addRevocationInfo, [
            "",
            "required",
            "optional",
            "none"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.version = getInteger({
            data: this.version,
            defaultValue: 5,
            validate: (e1)=>e1 >= 1 && e1 <= 5
        });
        this.appearanceFilter = null;
        this.certificates = null;
        this.digestMethods = null;
        this.encodings = null;
        this.encryptionMethods = null;
        this.handler = null;
        this.lockDocument = null;
        this.mdp = null;
        this.reasons = null;
        this.timeStamp = null;
    }
}
class Float extends ContentObject {
    constructor(e1){
        super(Mo, "float");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = parseFloat(this[Hn].trim());
        this[Hn] = isNaN(e1) ? null : e1;
    }
    [zs](e1) {
        return valueToHtml(null !== this[Hn] ? this[Hn].toString() : "");
    }
}
class template_Font extends XFAObject {
    constructor(e1){
        super(Mo, "font", !0);
        this.baselineShift = getMeasurement(e1.baselineShift);
        this.fontHorizontalScale = getFloat({
            data: e1.fontHorizontalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        });
        this.fontVerticalScale = getFloat({
            data: e1.fontVerticalScale,
            defaultValue: 100,
            validate: (e1)=>e1 >= 0
        });
        this.id = e1.id || "";
        this.kerningMode = getStringOption(e1.kerningMode, [
            "none",
            "pair"
        ]);
        this.letterSpacing = getMeasurement(e1.letterSpacing, "0");
        this.lineThrough = getInteger({
            data: e1.lineThrough,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.lineThroughPeriod = getStringOption(e1.lineThroughPeriod, [
            "all",
            "word"
        ]);
        this.overline = getInteger({
            data: e1.overline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.overlinePeriod = getStringOption(e1.overlinePeriod, [
            "all",
            "word"
        ]);
        this.posture = getStringOption(e1.posture, [
            "normal",
            "italic"
        ]);
        this.size = getMeasurement(e1.size, "10pt");
        this.typeface = e1.typeface || "Courier";
        this.underline = getInteger({
            data: e1.underline,
            defaultValue: 0,
            validate: (e1)=>1 === e1 || 2 === e1
        });
        this.underlinePeriod = getStringOption(e1.underlinePeriod, [
            "all",
            "word"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.weight = getStringOption(e1.weight, [
            "normal",
            "bold"
        ]);
        this.extras = null;
        this.fill = null;
    }
    [jn](e1) {
        super[jn](e1);
        this[hs].usedTypefaces.add(this.typeface);
    }
    [Gs]() {
        const e1 = toStyle(this, "fill"), t = e1.color;
        if (t) {
            if ("#000000" === t) delete e1.color;
            else if (!t.startsWith("#")) {
                e1.background = t;
                e1.backgroundClip = "text";
                e1.color = "transparent";
            }
        }
        this.baselineShift && (e1.verticalAlign = measureToString(this.baselineShift));
        e1.fontKerning = "none" === this.kerningMode ? "none" : "normal";
        e1.letterSpacing = measureToString(this.letterSpacing);
        if (0 !== this.lineThrough) {
            e1.textDecoration = "line-through";
            2 === this.lineThrough && (e1.textDecorationStyle = "double");
        }
        if (0 !== this.overline) {
            e1.textDecoration = "overline";
            2 === this.overline && (e1.textDecorationStyle = "double");
        }
        e1.fontStyle = this.posture;
        e1.fontSize = measureToString(.99 * this.size);
        setFontFamily(this, this, this[hs].fontFinder, e1);
        if (0 !== this.underline) {
            e1.textDecoration = "underline";
            2 === this.underline && (e1.textDecorationStyle = "double");
        }
        e1.fontWeight = this.weight;
        return e1;
    }
}
class Format extends XFAObject {
    constructor(e1){
        super(Mo, "format", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.picture = null;
    }
}
class Handler extends StringObject {
    constructor(e1){
        super(Mo, "handler");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Hyphenation extends XFAObject {
    constructor(e1){
        super(Mo, "hyphenation");
        this.excludeAllCaps = getInteger({
            data: e1.excludeAllCaps,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.excludeInitialCap = getInteger({
            data: e1.excludeInitialCap,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hyphenate = getInteger({
            data: e1.hyphenate,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.id = e1.id || "";
        this.pushCharacterCount = getInteger({
            data: e1.pushCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        });
        this.remainCharacterCount = getInteger({
            data: e1.remainCharacterCount,
            defaultValue: 3,
            validate: (e1)=>e1 >= 0
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.wordCharacterCount = getInteger({
            data: e1.wordCharacterCount,
            defaultValue: 7,
            validate: (e1)=>e1 >= 0
        });
    }
}
class Image extends StringObject {
    constructor(e1){
        super(Mo, "image");
        this.aspect = getStringOption(e1.aspect, [
            "fit",
            "actual",
            "height",
            "none",
            "width"
        ]);
        this.contentType = e1.contentType || "";
        this.href = e1.href || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.transferEncoding = getStringOption(e1.transferEncoding, [
            "base64",
            "none",
            "package"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [zs]() {
        if (this.contentType && !Ro.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
        let e1 = this[hs].images?.get(this.href);
        if (!e1 && (this.href || !this[Hn])) return HTMLResult.EMPTY;
        e1 || "base64" !== this.transferEncoding || (e1 = function fromBase64Util(e1) {
            return Uint8Array.fromBase64 ? Uint8Array.fromBase64(e1) : stringToBytes(atob(e1));
        }(this[Hn]));
        if (!e1) return HTMLResult.EMPTY;
        if (!this.contentType) {
            for (const [t, a] of No)if (e1.length > t.length && t.every((t, a)=>t === e1[a])) {
                this.contentType = a;
                break;
            }
            if (!this.contentType) return HTMLResult.EMPTY;
        }
        const t = new Blob([
            e1
        ], {
            type: this.contentType
        });
        let a;
        switch(this.aspect){
            case "fit":
            case "actual":
                break;
            case "height":
                a = {
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "none":
                a = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                };
                break;
            case "width":
                a = {
                    width: "100%",
                    objectFit: "fill"
                };
        }
        const r = this[cs]();
        return HTMLResult.success({
            name: "img",
            attributes: {
                class: [
                    "xfaImage"
                ],
                style: a,
                src: URL.createObjectURL(t),
                alt: r ? ariaLabel(r[cs]()) : null
            }
        });
    }
}
class ImageEdit extends XFAObject {
    constructor(e1){
        super(Mo, "imageEdit", !0);
        this.data = getStringOption(e1.data, [
            "link",
            "embed"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        return "embed" === this.data ? HTMLResult.success({
            name: "div",
            children: [],
            attributes: {}
        }) : HTMLResult.EMPTY;
    }
}
class Integer extends ContentObject {
    constructor(e1){
        super(Mo, "integer");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = parseInt(this[Hn].trim(), 10);
        this[Hn] = isNaN(e1) ? null : e1;
    }
    [zs](e1) {
        return valueToHtml(null !== this[Hn] ? this[Hn].toString() : "");
    }
}
class Issuers extends XFAObject {
    constructor(e1){
        super(Mo, "issuers", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class Items extends XFAObject {
    constructor(e1){
        super(Mo, "items", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.ref = e1.ref || "";
        this.save = getInteger({
            data: e1.save,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
    [zs]() {
        const e1 = [];
        for (const t of this[is]())e1.push(t[Hs]());
        return HTMLResult.success(e1);
    }
}
class Keep extends XFAObject {
    constructor(e1){
        super(Mo, "keep", !0);
        this.id = e1.id || "";
        const t = [
            "none",
            "contentArea",
            "pageArea"
        ];
        this.intact = getStringOption(e1.intact, t);
        this.next = getStringOption(e1.next, t);
        this.previous = getStringOption(e1.previous, t);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
}
class KeyUsage extends XFAObject {
    constructor(e1){
        super(Mo, "keyUsage");
        const t = [
            "",
            "yes",
            "no"
        ];
        this.crlSign = getStringOption(e1.crlSign, t);
        this.dataEncipherment = getStringOption(e1.dataEncipherment, t);
        this.decipherOnly = getStringOption(e1.decipherOnly, t);
        this.digitalSignature = getStringOption(e1.digitalSignature, t);
        this.encipherOnly = getStringOption(e1.encipherOnly, t);
        this.id = e1.id || "";
        this.keyAgreement = getStringOption(e1.keyAgreement, t);
        this.keyCertSign = getStringOption(e1.keyCertSign, t);
        this.keyEncipherment = getStringOption(e1.keyEncipherment, t);
        this.nonRepudiation = getStringOption(e1.nonRepudiation, t);
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Line extends XFAObject {
    constructor(e1){
        super(Mo, "line", !0);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.slope = getStringOption(e1.slope, [
            "\\",
            "/"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.edge = null;
    }
    [zs]() {
        const e1 = this[cs]()[cs](), t = this.edge || new Edge({}), a = t[Gs](), r = Object.create(null), i = "visible" === t.presence ? t.thickness : 0;
        r.strokeWidth = measureToString(i);
        r.stroke = a.color;
        let n, s, o, c, l = "100%", h = "100%";
        if (e1.w <= i) {
            [n, s, o, c] = [
                "50%",
                0,
                "50%",
                "100%"
            ];
            l = r.strokeWidth;
        } else if (e1.h <= i) {
            [n, s, o, c] = [
                0,
                "50%",
                "100%",
                "50%"
            ];
            h = r.strokeWidth;
        } else "\\" === this.slope ? [n, s, o, c] = [
            0,
            0,
            "100%",
            "100%"
        ] : [n, s, o, c] = [
            0,
            "100%",
            "100%",
            0
        ];
        const u = {
            name: "svg",
            children: [
                {
                    name: "line",
                    attributes: {
                        xmlns: Do,
                        x1: n,
                        y1: s,
                        x2: o,
                        y2: c,
                        style: r
                    }
                }
            ],
            attributes: {
                xmlns: Do,
                width: l,
                height: h,
                style: {
                    overflow: "visible"
                }
            }
        };
        if (hasMargin(e1)) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                u
            ]
        });
        u.attributes.style.position = "absolute";
        return HTMLResult.success(u);
    }
}
class Linear extends XFAObject {
    constructor(e1){
        super(Mo, "linear", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "toRight",
            "toBottom",
            "toLeft",
            "toTop"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs](e1) {
        e1 = e1 ? e1[Gs]() : "#FFFFFF";
        return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e1}, ${this.color ? this.color[Gs]() : "#000000"})`;
    }
}
class LockDocument extends ContentObject {
    constructor(e1){
        super(Mo, "lockDocument");
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        this[Hn] = getStringOption(this[Hn], [
            "auto",
            "0",
            "1"
        ]);
    }
}
class Manifest extends XFAObject {
    constructor(e1){
        super(Mo, "manifest", !0);
        this.action = getStringOption(e1.action, [
            "include",
            "all",
            "exclude"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.ref = new XFAObjectArray;
    }
}
class Margin extends XFAObject {
    constructor(e1){
        super(Mo, "margin", !0);
        this.bottomInset = getMeasurement(e1.bottomInset, "0");
        this.id = e1.id || "";
        this.leftInset = getMeasurement(e1.leftInset, "0");
        this.rightInset = getMeasurement(e1.rightInset, "0");
        this.topInset = getMeasurement(e1.topInset, "0");
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [Gs]() {
        return {
            margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset)
        };
    }
}
class Mdp extends XFAObject {
    constructor(e1){
        super(Mo, "mdp");
        this.id = e1.id || "";
        this.permissions = getInteger({
            data: e1.permissions,
            defaultValue: 2,
            validate: (e1)=>1 === e1 || 3 === e1
        });
        this.signatureType = getStringOption(e1.signatureType, [
            "filler",
            "author"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Medium extends XFAObject {
    constructor(e1){
        super(Mo, "medium");
        this.id = e1.id || "";
        this.imagingBBox = function getBBox(e1) {
            const t = -1;
            if (!e1) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const a = e1.split(",", 4).map((e1)=>getMeasurement(e1.trim(), "-1"));
            if (a.length < 4 || a[2] < 0 || a[3] < 0) return {
                x: t,
                y: t,
                width: t,
                height: t
            };
            const [r, i, n, s] = a;
            return {
                x: r,
                y: i,
                width: n,
                height: s
            };
        }(e1.imagingBBox);
        this.long = getMeasurement(e1.long);
        this.orientation = getStringOption(e1.orientation, [
            "portrait",
            "landscape"
        ]);
        this.short = getMeasurement(e1.short);
        this.stock = e1.stock || "";
        this.trayIn = getStringOption(e1.trayIn, [
            "auto",
            "delegate",
            "pageFront"
        ]);
        this.trayOut = getStringOption(e1.trayOut, [
            "auto",
            "delegate"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Message extends XFAObject {
    constructor(e1){
        super(Mo, "message", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.text = new XFAObjectArray;
    }
}
class NumericEdit extends XFAObject {
    constructor(e1){
        super(Mo, "numericEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        const t = toStyle(this, "border", "font", "margin"), a = this[cs]()[cs](), r = {
            name: "input",
            attributes: {
                type: "text",
                fieldId: a[Vs],
                dataId: a[Wn]?.[Vs] || a[Vs],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(a),
                "aria-required": !1
            }
        };
        if (isRequired(a)) {
            r.attributes["aria-required"] = !0;
            r.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                r
            ]
        });
    }
}
class Occur extends XFAObject {
    constructor(e1){
        super(Mo, "occur", !0);
        this.id = e1.id || "";
        this.initial = "" !== e1.initial ? getInteger({
            data: e1.initial,
            defaultValue: "",
            validate: (e1)=>!0
        }) : "";
        this.max = "" !== e1.max ? getInteger({
            data: e1.max,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "";
        this.min = "" !== e1.min ? getInteger({
            data: e1.min,
            defaultValue: 1,
            validate: (e1)=>!0
        }) : "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [jn]() {
        const e1 = this[cs](), t = this.min;
        "" === this.min && (this.min = e1 instanceof PageArea || e1 instanceof PageSet ? 0 : 1);
        "" === this.max && (this.max = "" === t ? e1 instanceof PageArea || e1 instanceof PageSet ? -1 : 1 : this.min);
        -1 !== this.max && this.max < this.min && (this.max = this.min);
        "" === this.initial && (this.initial = e1 instanceof Template ? 1 : this.min);
    }
}
class Oid extends StringObject {
    constructor(e1){
        super(Mo, "oid");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Oids extends XFAObject {
    constructor(e1){
        super(Mo, "oids", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.oid = new XFAObjectArray;
    }
}
class Overflow extends XFAObject {
    constructor(e1){
        super(Mo, "overflow");
        this.id = e1.id || "";
        this.leader = e1.leader || "";
        this.target = e1.target || "";
        this.trailer = e1.trailer || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [as]() {
        if (!this[$n]) {
            const e1 = this[cs](), t = this[ls](), a = t[js](this.target, e1), r = t[js](this.leader, e1), i = t[js](this.trailer, e1);
            this[$n] = {
                target: a?.[0] || null,
                leader: r?.[0] || null,
                trailer: i?.[0] || null,
                addLeader: !1,
                addTrailer: !1
            };
        }
        return this[$n];
    }
}
class PageArea extends XFAObject {
    constructor(e1){
        super(Mo, "pageArea", !0);
        this.blankOrNotBlank = getStringOption(e1.blankOrNotBlank, [
            "any",
            "blank",
            "notBlank"
        ]);
        this.id = e1.id || "";
        this.initialNumber = getInteger({
            data: e1.initialNumber,
            defaultValue: 1,
            validate: (e1)=>!0
        });
        this.name = e1.name || "";
        this.numbered = getInteger({
            data: e1.numbered,
            defaultValue: 1,
            validate: (e1)=>!0
        });
        this.oddOrEven = getStringOption(e1.oddOrEven, [
            "any",
            "even",
            "odd"
        ]);
        this.pagePosition = getStringOption(e1.pagePosition, [
            "any",
            "first",
            "last",
            "only",
            "rest"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.desc = null;
        this.extras = null;
        this.medium = null;
        this.occur = null;
        this.area = new XFAObjectArray;
        this.contentArea = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.subform = new XFAObjectArray;
    }
    [ks]() {
        if (!this[$n]) {
            this[$n] = {
                numberOfUse: 0
            };
            return !0;
        }
        return !this.occur || -1 === this.occur.max || this[$n].numberOfUse < this.occur.max;
    }
    [_n]() {
        delete this[$n];
    }
    [ss]() {
        this[$n] ||= {
            numberOfUse: 0
        };
        const e1 = this[cs]();
        if ("orderedOccurrence" === e1.relation && this[ks]()) {
            this[$n].numberOfUse += 1;
            return this;
        }
        return e1[ss]();
    }
    [Yn]() {
        return this[$n].space || {
            width: 0,
            height: 0
        };
    }
    [zs]() {
        this[$n] ||= {
            numberOfUse: 1
        };
        const e1 = [];
        this[$n].children = e1;
        const t = Object.create(null);
        if (this.medium && this.medium.short && this.medium.long) {
            t.width = measureToString(this.medium.short);
            t.height = measureToString(this.medium.long);
            this[$n].space = {
                width: this.medium.short,
                height: this.medium.long
            };
            if ("landscape" === this.medium.orientation) {
                const e1 = t.width;
                t.width = t.height;
                t.height = e1;
                this[$n].space = {
                    width: this.medium.long,
                    height: this.medium.short
                };
            }
        } else warn("XFA - No medium specified in pageArea: please file a bug.");
        this[Ln]({
            filter: new Set([
                "area",
                "draw",
                "field",
                "subform"
            ]),
            include: !0
        });
        this[Ln]({
            filter: new Set([
                "contentArea"
            ]),
            include: !0
        });
        return HTMLResult.success({
            name: "div",
            children: e1,
            attributes: {
                class: [
                    "xfaPage"
                ],
                id: this[Vs],
                style: t,
                xfaName: this.name
            }
        });
    }
}
class PageSet extends XFAObject {
    constructor(e1){
        super(Mo, "pageSet", !0);
        this.duplexImposition = getStringOption(e1.duplexImposition, [
            "longEdge",
            "shortEdge"
        ]);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relation = getStringOption(e1.relation, [
            "orderedOccurrence",
            "duplexPaginated",
            "simplexPaginated"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.occur = null;
        this.pageArea = new XFAObjectArray;
        this.pageSet = new XFAObjectArray;
    }
    [_n]() {
        for (const e1 of this.pageArea.children)e1[_n]();
        for (const e1 of this.pageSet.children)e1[_n]();
    }
    [ks]() {
        return !this.occur || -1 === this.occur.max || this[$n].numberOfUse < this.occur.max;
    }
    [ss]() {
        this[$n] ||= {
            numberOfUse: 1,
            pageIndex: -1,
            pageSetIndex: -1
        };
        if ("orderedOccurrence" === this.relation) {
            if (this[$n].pageIndex + 1 < this.pageArea.children.length) {
                this[$n].pageIndex += 1;
                return this.pageArea.children[this[$n].pageIndex][ss]();
            }
            if (this[$n].pageSetIndex + 1 < this.pageSet.children.length) {
                this[$n].pageSetIndex += 1;
                return this.pageSet.children[this[$n].pageSetIndex][ss]();
            }
            if (this[ks]()) {
                this[$n].numberOfUse += 1;
                this[$n].pageIndex = -1;
                this[$n].pageSetIndex = -1;
                return this[ss]();
            }
            const e1 = this[cs]();
            if (e1 instanceof PageSet) return e1[ss]();
            this[_n]();
            return this[ss]();
        }
        const e1 = this[ls]()[$n].pageNumber, t = e1 % 2 == 0 ? "even" : "odd", a = 0 === e1 ? "first" : "rest";
        let r = this.pageArea.children.find((e1)=>e1.oddOrEven === t && e1.pagePosition === a);
        if (r) return r;
        r = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && e1.pagePosition === a);
        if (r) return r;
        r = this.pageArea.children.find((e1)=>"any" === e1.oddOrEven && "any" === e1.pagePosition);
        return r || this.pageArea.children[0];
    }
}
class Para extends XFAObject {
    constructor(e1){
        super(Mo, "para", !0);
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.lineHeight = e1.lineHeight ? getMeasurement(e1.lineHeight, "0pt") : "";
        this.marginLeft = e1.marginLeft ? getMeasurement(e1.marginLeft, "0pt") : "";
        this.marginRight = e1.marginRight ? getMeasurement(e1.marginRight, "0pt") : "";
        this.orphans = getInteger({
            data: e1.orphans,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.preserve = e1.preserve || "";
        this.radixOffset = e1.radixOffset ? getMeasurement(e1.radixOffset, "0pt") : "";
        this.spaceAbove = e1.spaceAbove ? getMeasurement(e1.spaceAbove, "0pt") : "";
        this.spaceBelow = e1.spaceBelow ? getMeasurement(e1.spaceBelow, "0pt") : "";
        this.tabDefault = e1.tabDefault ? getMeasurement(this.tabDefault) : "";
        this.tabStops = (e1.tabStops || "").trim().split(/\s+/).map((e1, t)=>t % 2 == 1 ? getMeasurement(e1) : e1);
        this.textIndent = e1.textIndent ? getMeasurement(e1.textIndent, "0pt") : "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.vAlign = getStringOption(e1.vAlign, [
            "top",
            "bottom",
            "middle"
        ]);
        this.widows = getInteger({
            data: e1.widows,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.hyphenation = null;
    }
    [Gs]() {
        const e1 = toStyle(this, "hAlign");
        "" !== this.marginLeft && (e1.paddingLeft = measureToString(this.marginLeft));
        "" !== this.marginRight && (e1.paddingRight = measureToString(this.marginRight));
        "" !== this.spaceAbove && (e1.paddingTop = measureToString(this.spaceAbove));
        "" !== this.spaceBelow && (e1.paddingBottom = measureToString(this.spaceBelow));
        if ("" !== this.textIndent) {
            e1.textIndent = measureToString(this.textIndent);
            fixTextIndent(e1);
        }
        this.lineHeight > 0 && (e1.lineHeight = measureToString(this.lineHeight));
        "" !== this.tabDefault && (e1.tabSize = measureToString(this.tabDefault));
        this.tabStops.length;
        this.hyphenatation && Object.assign(e1, this.hyphenatation[Gs]());
        return e1;
    }
}
class PasswordEdit extends XFAObject {
    constructor(e1){
        super(Mo, "passwordEdit", !0);
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.passwordChar = e1.passwordChar || "*";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.margin = null;
    }
}
class template_Pattern extends XFAObject {
    constructor(e1){
        super(Mo, "pattern", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "crossHatch",
            "crossDiagonal",
            "diagonalLeft",
            "diagonalRight",
            "horizontal",
            "vertical"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs](e1) {
        e1 = e1 ? e1[Gs]() : "#FFFFFF";
        const t = this.color ? this.color[Gs]() : "#000000", a = "repeating-linear-gradient", r = `${e1},${e1} 5px,${t} 5px,${t} 10px`;
        switch(this.type){
            case "crossHatch":
                return `${a}(to top,${r}) ${a}(to right,${r})`;
            case "crossDiagonal":
                return `${a}(45deg,${r}) ${a}(-45deg,${r})`;
            case "diagonalLeft":
                return `${a}(45deg,${r})`;
            case "diagonalRight":
                return `${a}(-45deg,${r})`;
            case "horizontal":
                return `${a}(to top,${r})`;
            case "vertical":
                return `${a}(to right,${r})`;
        }
        return "";
    }
}
class Picture extends StringObject {
    constructor(e1){
        super(Mo, "picture");
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Proto extends XFAObject {
    constructor(e1){
        super(Mo, "proto", !0);
        this.appearanceFilter = new XFAObjectArray;
        this.arc = new XFAObjectArray;
        this.area = new XFAObjectArray;
        this.assist = new XFAObjectArray;
        this.barcode = new XFAObjectArray;
        this.bindItems = new XFAObjectArray;
        this.bookend = new XFAObjectArray;
        this.boolean = new XFAObjectArray;
        this.border = new XFAObjectArray;
        this.break = new XFAObjectArray;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.button = new XFAObjectArray;
        this.calculate = new XFAObjectArray;
        this.caption = new XFAObjectArray;
        this.certificate = new XFAObjectArray;
        this.certificates = new XFAObjectArray;
        this.checkButton = new XFAObjectArray;
        this.choiceList = new XFAObjectArray;
        this.color = new XFAObjectArray;
        this.comb = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.contentArea = new XFAObjectArray;
        this.corner = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.dateTimeEdit = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.defaultUi = new XFAObjectArray;
        this.desc = new XFAObjectArray;
        this.digestMethod = new XFAObjectArray;
        this.digestMethods = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.edge = new XFAObjectArray;
        this.encoding = new XFAObjectArray;
        this.encodings = new XFAObjectArray;
        this.encrypt = new XFAObjectArray;
        this.encryptData = new XFAObjectArray;
        this.encryption = new XFAObjectArray;
        this.encryptionMethod = new XFAObjectArray;
        this.encryptionMethods = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.execute = new XFAObjectArray;
        this.extras = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.fill = new XFAObjectArray;
        this.filter = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.font = new XFAObjectArray;
        this.format = new XFAObjectArray;
        this.handler = new XFAObjectArray;
        this.hyphenation = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.imageEdit = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.issuers = new XFAObjectArray;
        this.items = new XFAObjectArray;
        this.keep = new XFAObjectArray;
        this.keyUsage = new XFAObjectArray;
        this.line = new XFAObjectArray;
        this.linear = new XFAObjectArray;
        this.lockDocument = new XFAObjectArray;
        this.manifest = new XFAObjectArray;
        this.margin = new XFAObjectArray;
        this.mdp = new XFAObjectArray;
        this.medium = new XFAObjectArray;
        this.message = new XFAObjectArray;
        this.numericEdit = new XFAObjectArray;
        this.occur = new XFAObjectArray;
        this.oid = new XFAObjectArray;
        this.oids = new XFAObjectArray;
        this.overflow = new XFAObjectArray;
        this.pageArea = new XFAObjectArray;
        this.pageSet = new XFAObjectArray;
        this.para = new XFAObjectArray;
        this.passwordEdit = new XFAObjectArray;
        this.pattern = new XFAObjectArray;
        this.picture = new XFAObjectArray;
        this.radial = new XFAObjectArray;
        this.reason = new XFAObjectArray;
        this.reasons = new XFAObjectArray;
        this.rectangle = new XFAObjectArray;
        this.ref = new XFAObjectArray;
        this.script = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
        this.signData = new XFAObjectArray;
        this.signature = new XFAObjectArray;
        this.signing = new XFAObjectArray;
        this.solid = new XFAObjectArray;
        this.speak = new XFAObjectArray;
        this.stipple = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
        this.subjectDN = new XFAObjectArray;
        this.subjectDNs = new XFAObjectArray;
        this.submit = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.textEdit = new XFAObjectArray;
        this.time = new XFAObjectArray;
        this.timeStamp = new XFAObjectArray;
        this.toolTip = new XFAObjectArray;
        this.traversal = new XFAObjectArray;
        this.traverse = new XFAObjectArray;
        this.ui = new XFAObjectArray;
        this.validate = new XFAObjectArray;
        this.value = new XFAObjectArray;
        this.variables = new XFAObjectArray;
    }
}
class Radial extends XFAObject {
    constructor(e1){
        super(Mo, "radial", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "toEdge",
            "toCenter"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs](e1) {
        e1 = e1 ? e1[Gs]() : "#FFFFFF";
        const t = this.color ? this.color[Gs]() : "#000000";
        return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e1},${t}` : `${t},${e1}`})`;
    }
}
class Reason extends StringObject {
    constructor(e1){
        super(Mo, "reason");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Reasons extends XFAObject {
    constructor(e1){
        super(Mo, "reasons", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.reason = new XFAObjectArray;
    }
}
class Rectangle extends XFAObject {
    constructor(e1){
        super(Mo, "rectangle", !0);
        this.hand = getStringOption(e1.hand, [
            "even",
            "left",
            "right"
        ]);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.corner = new XFAObjectArray(4);
        this.edge = new XFAObjectArray(4);
        this.fill = null;
    }
    [zs]() {
        const e1 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t = e1[Gs](), a = Object.create(null);
        "visible" === this.fill?.presence ? Object.assign(a, this.fill[Gs]()) : a.fill = "transparent";
        a.strokeWidth = measureToString("visible" === e1.presence ? e1.thickness : 0);
        a.stroke = t.color;
        const r = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[Gs](), i = {
            name: "svg",
            children: [
                {
                    name: "rect",
                    attributes: {
                        xmlns: Do,
                        width: "100%",
                        height: "100%",
                        x: 0,
                        y: 0,
                        rx: r.radius,
                        ry: r.radius,
                        style: a
                    }
                }
            ],
            attributes: {
                xmlns: Do,
                style: {
                    overflow: "visible"
                },
                width: "100%",
                height: "100%"
            }
        };
        if (hasMargin(this[cs]()[cs]())) return HTMLResult.success({
            name: "div",
            attributes: {
                style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                }
            },
            children: [
                i
            ]
        });
        i.attributes.style.position = "absolute";
        return HTMLResult.success(i);
    }
}
class RefElement extends StringObject {
    constructor(e1){
        super(Mo, "ref");
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Script extends StringObject {
    constructor(e1){
        super(Mo, "script");
        this.binding = e1.binding || "";
        this.contentType = e1.contentType || "";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.runAt = getStringOption(e1.runAt, [
            "client",
            "both",
            "server"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SetProperty extends XFAObject {
    constructor(e1){
        super(Mo, "setProperty");
        this.connection = e1.connection || "";
        this.ref = e1.ref || "";
        this.target = e1.target || "";
    }
}
class SignData extends XFAObject {
    constructor(e1){
        super(Mo, "signData", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "sign",
            "clear",
            "verify"
        ]);
        this.ref = e1.ref || "";
        this.target = e1.target || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.filter = null;
        this.manifest = null;
    }
}
class Signature extends XFAObject {
    constructor(e1){
        super(Mo, "signature", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "PDF1.3",
            "PDF1.6"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.border = null;
        this.extras = null;
        this.filter = null;
        this.manifest = null;
        this.margin = null;
    }
}
class Signing extends XFAObject {
    constructor(e1){
        super(Mo, "signing", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.certificate = new XFAObjectArray;
    }
}
class Solid extends XFAObject {
    constructor(e1){
        super(Mo, "solid", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
    }
    [Gs](e1) {
        return e1 ? e1[Gs]() : "#FFFFFF";
    }
}
class Speak extends StringObject {
    constructor(e1){
        super(Mo, "speak");
        this.disable = getInteger({
            data: e1.disable,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.id = e1.id || "";
        this.priority = getStringOption(e1.priority, [
            "custom",
            "caption",
            "name",
            "toolTip"
        ]);
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Stipple extends XFAObject {
    constructor(e1){
        super(Mo, "stipple", !0);
        this.id = e1.id || "";
        this.rate = getInteger({
            data: e1.rate,
            defaultValue: 50,
            validate: (e1)=>e1 >= 0 && e1 <= 100
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.color = null;
        this.extras = null;
    }
    [Gs](e1) {
        const t = this.rate / 100;
        return Util.makeHexColor(Math.round(e1.value.r * (1 - t) + this.value.r * t), Math.round(e1.value.g * (1 - t) + this.value.g * t), Math.round(e1.value.b * (1 - t) + this.value.b * t));
    }
}
class Subform extends XFAObject {
    constructor(e1){
        super(Mo, "subform", !0);
        this.access = getStringOption(e1.access, [
            "open",
            "nonInteractive",
            "protected",
            "readOnly"
        ]);
        this.allowMacro = getInteger({
            data: e1.allowMacro,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.anchorType = getStringOption(e1.anchorType, [
            "topLeft",
            "bottomCenter",
            "bottomLeft",
            "bottomRight",
            "middleCenter",
            "middleLeft",
            "middleRight",
            "topCenter",
            "topRight"
        ]);
        this.colSpan = getInteger({
            data: e1.colSpan,
            defaultValue: 1,
            validate: (e1)=>e1 >= 1 || -1 === e1
        });
        this.columnWidths = (e1.columnWidths || "").trim().split(/\s+/).map((e1)=>"-1" === e1 ? -1 : getMeasurement(e1));
        this.h = e1.h ? getMeasurement(e1.h) : "";
        this.hAlign = getStringOption(e1.hAlign, [
            "left",
            "center",
            "justify",
            "justifyAll",
            "radix",
            "right"
        ]);
        this.id = e1.id || "";
        this.layout = getStringOption(e1.layout, [
            "position",
            "lr-tb",
            "rl-row",
            "rl-tb",
            "row",
            "table",
            "tb"
        ]);
        this.locale = e1.locale || "";
        this.maxH = getMeasurement(e1.maxH, "0pt");
        this.maxW = getMeasurement(e1.maxW, "0pt");
        this.mergeMode = getStringOption(e1.mergeMode, [
            "consumeData",
            "matchTemplate"
        ]);
        this.minH = getMeasurement(e1.minH, "0pt");
        this.minW = getMeasurement(e1.minW, "0pt");
        this.name = e1.name || "";
        this.presence = getStringOption(e1.presence, [
            "visible",
            "hidden",
            "inactive",
            "invisible"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.restoreState = getStringOption(e1.restoreState, [
            "manual",
            "auto"
        ]);
        this.scope = getStringOption(e1.scope, [
            "name",
            "none"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.w = e1.w ? getMeasurement(e1.w) : "";
        this.x = getMeasurement(e1.x, "0pt");
        this.y = getMeasurement(e1.y, "0pt");
        this.assist = null;
        this.bind = null;
        this.bookend = null;
        this.border = null;
        this.break = null;
        this.calculate = null;
        this.desc = null;
        this.extras = null;
        this.keep = null;
        this.margin = null;
        this.occur = null;
        this.overflow = null;
        this.pageSet = null;
        this.para = null;
        this.traversal = null;
        this.validate = null;
        this.variables = null;
        this.area = new XFAObjectArray;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.connect = new XFAObjectArray;
        this.draw = new XFAObjectArray;
        this.event = new XFAObjectArray;
        this.exObject = new XFAObjectArray;
        this.exclGroup = new XFAObjectArray;
        this.field = new XFAObjectArray;
        this.proto = new XFAObjectArray;
        this.setProperty = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    [os]() {
        const e1 = this[cs]();
        return e1 instanceof SubformSet ? e1[os]() : e1;
    }
    [ms]() {
        return !0;
    }
    [Ss]() {
        return this.layout.endsWith("-tb") && 0 === this[$n].attempt && this[$n].numberInLine > 0 || this[cs]()[Ss]();
    }
    *[ns]() {
        yield* getContainedChildren(this);
    }
    [Vn]() {
        return flushHTML(this);
    }
    [En](e1, t) {
        addHTML(this, e1, t);
    }
    [Yn]() {
        return getAvailableSpace(this);
    }
    [xs]() {
        const e1 = this[os]();
        if (!e1[xs]()) return !1;
        if (void 0 !== this[$n]._isSplittable) return this[$n]._isSplittable;
        if ("position" === this.layout || this.layout.includes("row")) {
            this[$n]._isSplittable = !1;
            return !1;
        }
        if (this.keep && "none" !== this.keep.intact) {
            this[$n]._isSplittable = !1;
            return !1;
        }
        if (e1.layout?.endsWith("-tb") && 0 !== e1[$n].numberInLine) return !1;
        this[$n]._isSplittable = !0;
        return !0;
    }
    [zs](e1) {
        setTabIndex(this);
        if (this.break) {
            if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
                const e1 = new BreakAfter({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[hs] = this[hs];
                this[Pn](e1);
                this.breakAfter.push(e1);
            }
            if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
                const e1 = new BreakBefore({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                });
                e1[hs] = this[hs];
                this[Pn](e1);
                this.breakBefore.push(e1);
            }
            if ("" !== this.break.overflowTarget) {
                const e1 = new Overflow({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                });
                e1[hs] = this[hs];
                this[Pn](e1);
                this.overflow.push(e1);
            }
            this[Ns](this.break);
            this.break = null;
        }
        if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
        (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
        if (this.breakBefore.children.length >= 1) {
            const e1 = this.breakBefore.children[0];
            if (handleBreak(e1)) return HTMLResult.breakNode(e1);
        }
        if (this[$n]?.afterBreakAfter) return HTMLResult.EMPTY;
        fixDimensions(this);
        const t = [], a = {
            id: this[Vs],
            class: []
        };
        setAccess(this, a.class);
        this[$n] ||= Object.create(null);
        Object.assign(this[$n], {
            children: t,
            line: null,
            attributes: a,
            attempt: 0,
            numberInLine: 0,
            availableSpace: {
                width: Math.min(this.w || 1 / 0, e1.width),
                height: Math.min(this.h || 1 / 0, e1.height)
            },
            width: 0,
            height: 0,
            prevHeight: 0,
            currentWidth: 0
        });
        const r = this[ls](), i = r[$n].noLayoutFailure, n = this[xs]();
        n || setFirstUnsplittable(this);
        if (!checkDimensions(this, e1)) return HTMLResult.FAILURE;
        const s = new Set([
            "area",
            "draw",
            "exclGroup",
            "field",
            "subform",
            "subformSet"
        ]);
        if (this.layout.includes("row")) {
            const e1 = this[os]().columnWidths;
            if (Array.isArray(e1) && e1.length > 0) {
                this[$n].columnWidths = e1;
                this[$n].currentColumn = 0;
            }
        }
        const o = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), c = [
            "xfaSubform"
        ], l = layoutClass(this);
        l && c.push(l);
        a.style = o;
        a.class = c;
        this.name && (a.xfaName = this.name);
        if (this.overflow) {
            const t = this.overflow[as]();
            if (t.addLeader) {
                t.addLeader = !1;
                handleOverflow(this, t.leader, e1);
            }
        }
        this[Rs]();
        const h = "lr-tb" === this.layout || "rl-tb" === this.layout, u = h ? 2 : 1;
        for(; this[$n].attempt < u; this[$n].attempt++){
            h && 1 === this[$n].attempt && (this[$n].numberInLine = 0);
            const e1 = this[Ln]({
                filter: s,
                include: !0
            });
            if (e1.success) break;
            if (e1.isBreak()) {
                this[Bs]();
                return e1;
            }
            if (h && 0 === this[$n].attempt && 0 === this[$n].numberInLine && !r[$n].noLayoutFailure) {
                this[$n].attempt = u;
                break;
            }
        }
        this[Bs]();
        n || unsetFirstUnsplittable(this);
        r[$n].noLayoutFailure = i;
        if (this[$n].attempt === u) {
            this.overflow && (this[ls]()[$n].overflowNode = this.overflow);
            n || delete this[$n];
            return HTMLResult.FAILURE;
        }
        if (this.overflow) {
            const t = this.overflow[as]();
            if (t.addTrailer) {
                t.addTrailer = !1;
                handleOverflow(this, t.trailer, e1);
            }
        }
        let d = 0, f = 0;
        if (this.margin) {
            d = this.margin.leftInset + this.margin.rightInset;
            f = this.margin.topInset + this.margin.bottomInset;
        }
        const g = Math.max(this[$n].width + d, this.w || 0), p = Math.max(this[$n].height + f, this.h || 0), m = [
            this.x,
            this.y,
            g,
            p
        ];
        "" === this.w && (o.width = measureToString(g));
        "" === this.h && (o.height = measureToString(p));
        if (("0px" === o.width || "0px" === o.height) && 0 === t.length) return HTMLResult.EMPTY;
        const b = {
            name: "div",
            attributes: a,
            children: t
        };
        applyAssist(this, a);
        const y = HTMLResult.success(createWrapper(this, b), m);
        if (this.breakAfter.children.length >= 1) {
            const e1 = this.breakAfter.children[0];
            if (handleBreak(e1)) {
                this[$n].afterBreakAfter = y;
                return HTMLResult.breakNode(e1);
            }
        }
        delete this[$n];
        return y;
    }
}
class SubformSet extends XFAObject {
    constructor(e1){
        super(Mo, "subformSet", !0);
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.relation = getStringOption(e1.relation, [
            "ordered",
            "choice",
            "unordered"
        ]);
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.bookend = null;
        this.break = null;
        this.desc = null;
        this.extras = null;
        this.occur = null;
        this.overflow = null;
        this.breakAfter = new XFAObjectArray;
        this.breakBefore = new XFAObjectArray;
        this.subform = new XFAObjectArray;
        this.subformSet = new XFAObjectArray;
    }
    *[ns]() {
        yield* getContainedChildren(this);
    }
    [os]() {
        let e1 = this[cs]();
        for(; !(e1 instanceof Subform);)e1 = e1[cs]();
        return e1;
    }
    [ms]() {
        return !0;
    }
}
class SubjectDN extends ContentObject {
    constructor(e1){
        super(Mo, "subjectDN");
        this.delimiter = e1.delimiter || ",";
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        this[Hn] = new Map(this[Hn].split(this.delimiter).map((e1)=>{
            (e1 = e1.split("=", 2))[0] = e1[0].trim();
            return e1;
        }));
    }
}
class SubjectDNs extends XFAObject {
    constructor(e1){
        super(Mo, "subjectDNs", !0);
        this.id = e1.id || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.subjectDN = new XFAObjectArray;
    }
}
class Submit extends XFAObject {
    constructor(e1){
        super(Mo, "submit", !0);
        this.embedPDF = getInteger({
            data: e1.embedPDF,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.format = getStringOption(e1.format, [
            "xdp",
            "formdata",
            "pdf",
            "urlencoded",
            "xfd",
            "xml"
        ]);
        this.id = e1.id || "";
        this.target = e1.target || "";
        this.textEncoding = getKeyword({
            data: e1.textEncoding ? e1.textEncoding.toLowerCase() : "",
            defaultValue: "",
            validate: (e1)=>[
                    "utf-8",
                    "big-five",
                    "fontspecific",
                    "gbk",
                    "gb-18030",
                    "gb-2312",
                    "ksc-5601",
                    "none",
                    "shift-jis",
                    "ucs-2",
                    "utf-16"
                ].includes(e1) || e1.match(/iso-8859-\d{2}/)
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.xdpContent = e1.xdpContent || "";
        this.encrypt = null;
        this.encryptData = new XFAObjectArray;
        this.signData = new XFAObjectArray;
    }
}
class Template extends XFAObject {
    constructor(e1){
        super(Mo, "template", !0);
        this.baseProfile = getStringOption(e1.baseProfile, [
            "full",
            "interactiveForms"
        ]);
        this.extras = null;
        this.subform = new XFAObjectArray;
    }
    [Gn]() {
        0 === this.subform.children.length && warn("XFA - No subforms in template node.");
        this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
        this[qs] = 5e3;
    }
    [xs]() {
        return !0;
    }
    [js](e1, t) {
        return e1.startsWith("#") ? [
            this[ds].get(e1.slice(1))
        ] : searchNode(this, t, e1, !0, !0);
    }
    *[Ws]() {
        if (!this.subform.children.length) return HTMLResult.success({
            name: "div",
            children: []
        });
        this[$n] = {
            overflowNode: null,
            firstUnsplittable: null,
            currentContentArea: null,
            currentPageArea: null,
            noLayoutFailure: !1,
            pageNumber: 1,
            pagePosition: "first",
            oddOrEven: "odd",
            blankOrNotBlank: "nonBlank",
            paraStack: []
        };
        const e1 = this.subform.children[0];
        e1.pageSet[_n]();
        const t = e1.pageSet.pageArea.children, a = {
            name: "div",
            children: []
        };
        let r = null, i = null, n = null;
        if (e1.breakBefore.children.length >= 1) {
            i = e1.breakBefore.children[0];
            n = i.target;
        } else if (e1.subform.children.length >= 1 && e1.subform.children[0].breakBefore.children.length >= 1) {
            i = e1.subform.children[0].breakBefore.children[0];
            n = i.target;
        } else if (e1.break?.beforeTarget) {
            i = e1.break;
            n = i.beforeTarget;
        } else if (e1.subform.children.length >= 1 && e1.subform.children[0].break?.beforeTarget) {
            i = e1.subform.children[0].break;
            n = i.beforeTarget;
        }
        if (i) {
            const e1 = this[js](n, i[cs]());
            if (e1 instanceof PageArea) {
                r = e1;
                i[$n] = {};
            }
        }
        r ||= t[0];
        r[$n] = {
            numberOfUse: 1
        };
        const s = r[cs]();
        s[$n] = {
            numberOfUse: 1,
            pageIndex: s.pageArea.children.indexOf(r),
            pageSetIndex: 0
        };
        let o, c = null, l = null, h = !0, u = 0, d = 0;
        for(;;){
            if (h) u = 0;
            else {
                a.children.pop();
                if (3 == ++u) {
                    warn("XFA - Something goes wrong: please file a bug.");
                    return a;
                }
            }
            o = null;
            this[$n].currentPageArea = r;
            const t = r[zs]().html;
            a.children.push(t);
            if (c) {
                this[$n].noLayoutFailure = !0;
                t.children.push(c[zs](r[$n].space).html);
                c = null;
            }
            if (l) {
                this[$n].noLayoutFailure = !0;
                t.children.push(l[zs](r[$n].space).html);
                l = null;
            }
            const i = r.contentArea.children, n = t.children.filter((e1)=>e1.attributes.class.includes("xfaContentarea"));
            h = !1;
            this[$n].firstUnsplittable = null;
            this[$n].noLayoutFailure = !1;
            const flush = (t)=>{
                const a = e1[Vn]();
                if (a) {
                    h ||= a.children?.length > 0;
                    n[t].children.push(a);
                }
            };
            for(let t = d, r = i.length; t < r; t++){
                const r = this[$n].currentContentArea = i[t], s = {
                    width: r.w,
                    height: r.h
                };
                d = 0;
                if (c) {
                    n[t].children.push(c[zs](s).html);
                    c = null;
                }
                if (l) {
                    n[t].children.push(l[zs](s).html);
                    l = null;
                }
                const u = e1[zs](s);
                if (u.success) {
                    if (u.html) {
                        h ||= u.html.children?.length > 0;
                        n[t].children.push(u.html);
                    } else !h && a.children.length > 1 && a.children.pop();
                    return a;
                }
                if (u.isBreak()) {
                    const e1 = u.breakNode;
                    flush(t);
                    if ("auto" === e1.targetType) continue;
                    if (e1.leader) {
                        c = this[js](e1.leader, e1[cs]());
                        c = c ? c[0] : null;
                    }
                    if (e1.trailer) {
                        l = this[js](e1.trailer, e1[cs]());
                        l = l ? l[0] : null;
                    }
                    if ("pageArea" === e1.targetType) {
                        o = e1[$n].target;
                        t = 1 / 0;
                    } else if (e1[$n].target) {
                        o = e1[$n].target;
                        d = e1[$n].index + 1;
                        t = 1 / 0;
                    } else t = e1[$n].index;
                } else if (this[$n].overflowNode) {
                    const e1 = this[$n].overflowNode;
                    this[$n].overflowNode = null;
                    const a = e1[as](), r = a.target;
                    a.addLeader = null !== a.leader;
                    a.addTrailer = null !== a.trailer;
                    flush(t);
                    const n = t;
                    t = 1 / 0;
                    if (r instanceof PageArea) o = r;
                    else if (r instanceof ContentArea) {
                        const e1 = i.indexOf(r);
                        if (-1 !== e1) e1 > n ? t = e1 - 1 : d = e1;
                        else {
                            o = r[cs]();
                            d = o.contentArea.children.indexOf(r);
                        }
                    }
                } else flush(t);
            }
            this[$n].pageNumber += 1;
            o && (o[ks]() ? o[$n].numberOfUse += 1 : o = null);
            r = o || r[ss]();
            yield null;
        }
    }
}
class Text extends ContentObject {
    constructor(e1){
        super(Mo, "text");
        this.id = e1.id || "";
        this.maxChars = getInteger({
            data: e1.maxChars,
            defaultValue: 0,
            validate: (e1)=>e1 >= 0
        });
        this.name = e1.name || "";
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Nn]() {
        return !0;
    }
    [Ts](e1) {
        if (e1[vs] === Js.xhtml.id) {
            this[Hn] = e1;
            return !0;
        }
        warn(`XFA - Invalid content in Text: ${e1[Fs]}.`);
        return !1;
    }
    [Ms](e1) {
        this[Hn] instanceof XFAObject || super[Ms](e1);
    }
    [Gn]() {
        "string" == typeof this[Hn] && (this[Hn] = this[Hn].replaceAll("\r\n", "\n"));
    }
    [as]() {
        return "string" == typeof this[Hn] ? this[Hn].split(/[\u2029\u2028\n]/).filter((e1)=>!!e1).join("\n") : this[Hn][Hs]();
    }
    [zs](e1) {
        if ("string" == typeof this[Hn]) {
            const e1 = valueToHtml(this[Hn]).html;
            if (this[Hn].includes("\u2029")) {
                e1.name = "div";
                e1.children = [];
                this[Hn].split("\u2029").map((e1)=>e1.split(/[\u2028\n]/).flatMap((e1)=>[
                            {
                                name: "span",
                                value: e1
                            },
                            {
                                name: "br"
                            }
                        ])).forEach((t)=>{
                    e1.children.push({
                        name: "p",
                        children: t
                    });
                });
            } else if (/[\u2028\n]/.test(this[Hn])) {
                e1.name = "div";
                e1.children = [];
                this[Hn].split(/[\u2028\n]/).forEach((t)=>{
                    e1.children.push({
                        name: "span",
                        value: t
                    }, {
                        name: "br"
                    });
                });
            }
            return HTMLResult.success(e1);
        }
        return this[Hn][zs](e1);
    }
}
class TextEdit extends XFAObject {
    constructor(e1){
        super(Mo, "textEdit", !0);
        this.allowRichText = getInteger({
            data: e1.allowRichText,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.hScrollPolicy = getStringOption(e1.hScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.id = e1.id || "";
        this.multiLine = getInteger({
            data: e1.multiLine,
            defaultValue: "",
            validate: (e1)=>0 === e1 || 1 === e1
        });
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.vScrollPolicy = getStringOption(e1.vScrollPolicy, [
            "auto",
            "off",
            "on"
        ]);
        this.border = null;
        this.comb = null;
        this.extras = null;
        this.margin = null;
    }
    [zs](e1) {
        const t = toStyle(this, "border", "font", "margin");
        let a;
        const r = this[cs]()[cs]();
        "" === this.multiLine && (this.multiLine = r instanceof Draw ? 1 : 0);
        a = 1 === this.multiLine ? {
            name: "textarea",
            attributes: {
                dataId: r[Wn]?.[Vs] || r[Vs],
                fieldId: r[Vs],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(r),
                "aria-required": !1
            }
        } : {
            name: "input",
            attributes: {
                type: "text",
                dataId: r[Wn]?.[Vs] || r[Vs],
                fieldId: r[Vs],
                class: [
                    "xfaTextfield"
                ],
                style: t,
                "aria-label": ariaLabel(r),
                "aria-required": !1
            }
        };
        if (isRequired(r)) {
            a.attributes["aria-required"] = !0;
            a.attributes.required = !0;
        }
        return HTMLResult.success({
            name: "label",
            attributes: {
                class: [
                    "xfaLabel"
                ]
            },
            children: [
                a
            ]
        });
    }
}
class Time extends StringObject {
    constructor(e1){
        super(Mo, "time");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
    [Gn]() {
        const e1 = this[Hn].trim();
        this[Hn] = e1 ? new Date(e1) : null;
    }
    [zs](e1) {
        return valueToHtml(this[Hn] ? this[Hn].toString() : "");
    }
}
class TimeStamp extends XFAObject {
    constructor(e1){
        super(Mo, "timeStamp");
        this.id = e1.id || "";
        this.server = e1.server || "";
        this.type = getStringOption(e1.type, [
            "optional",
            "required"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class ToolTip extends StringObject {
    constructor(e1){
        super(Mo, "toolTip");
        this.id = e1.id || "";
        this.rid = e1.rid || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Traversal extends XFAObject {
    constructor(e1){
        super(Mo, "traversal", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.traverse = new XFAObjectArray;
    }
}
class Traverse extends XFAObject {
    constructor(e1){
        super(Mo, "traverse", !0);
        this.id = e1.id || "";
        this.operation = getStringOption(e1.operation, [
            "next",
            "back",
            "down",
            "first",
            "left",
            "right",
            "up"
        ]);
        this.ref = e1.ref || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.script = null;
    }
    get name() {
        return this.operation;
    }
    [As]() {
        return !1;
    }
}
class Ui extends XFAObject {
    constructor(e1){
        super(Mo, "ui", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.picture = null;
        this.barcode = null;
        this.button = null;
        this.checkButton = null;
        this.choiceList = null;
        this.dateTimeEdit = null;
        this.defaultUi = null;
        this.imageEdit = null;
        this.numericEdit = null;
        this.passwordEdit = null;
        this.signature = null;
        this.textEdit = null;
    }
    [as]() {
        if (void 0 === this[$n]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                if ("extras" === e1 || "picture" === e1) continue;
                const t = this[e1];
                if (t instanceof XFAObject) {
                    this[$n] = t;
                    return t;
                }
            }
            this[$n] = null;
        }
        return this[$n];
    }
    [zs](e1) {
        const t = this[as]();
        return t ? t[zs](e1) : HTMLResult.EMPTY;
    }
}
class Validate extends XFAObject {
    constructor(e1){
        super(Mo, "validate", !0);
        this.formatTest = getStringOption(e1.formatTest, [
            "warning",
            "disabled",
            "error"
        ]);
        this.id = e1.id || "";
        this.nullTest = getStringOption(e1.nullTest, [
            "disabled",
            "error",
            "warning"
        ]);
        this.scriptTest = getStringOption(e1.scriptTest, [
            "error",
            "disabled",
            "warning"
        ]);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.extras = null;
        this.message = null;
        this.picture = null;
        this.script = null;
    }
}
class Value extends XFAObject {
    constructor(e1){
        super(Mo, "value", !0);
        this.id = e1.id || "";
        this.override = getInteger({
            data: e1.override,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.relevant = getRelevant(e1.relevant);
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.arc = null;
        this.boolean = null;
        this.date = null;
        this.dateTime = null;
        this.decimal = null;
        this.exData = null;
        this.float = null;
        this.image = null;
        this.integer = null;
        this.line = null;
        this.rectangle = null;
        this.text = null;
        this.time = null;
    }
    [Xs](e1) {
        const t = this[cs]();
        if (t instanceof Field && t.ui?.imageEdit) {
            if (!this.image) {
                this.image = new Image({});
                this[Pn](this.image);
            }
            this.image[Hn] = e1[Hn];
            return;
        }
        const a = e1[Fs];
        if (null === this[a]) {
            for (const e1 of Object.getOwnPropertyNames(this)){
                const t = this[e1];
                if (t instanceof XFAObject) {
                    this[e1] = null;
                    this[Ns](t);
                }
            }
            this[e1[Fs]] = e1;
            this[Pn](e1);
        } else this[a][Hn] = e1[Hn];
    }
    [Hs]() {
        if (this.exData) return "string" == typeof this.exData[Hn] ? this.exData[Hn].trim() : this.exData[Hn][Hs]().trim();
        for (const e1 of Object.getOwnPropertyNames(this)){
            if ("image" === e1) continue;
            const t = this[e1];
            if (t instanceof XFAObject) return (t[Hn] || "").toString().trim();
        }
        return null;
    }
    [zs](e1) {
        for (const t of Object.getOwnPropertyNames(this)){
            const a = this[t];
            if (a instanceof XFAObject) return a[zs](e1);
        }
        return HTMLResult.EMPTY;
    }
}
class Variables extends XFAObject {
    constructor(e1){
        super(Mo, "variables", !0);
        this.id = e1.id || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
        this.boolean = new XFAObjectArray;
        this.date = new XFAObjectArray;
        this.dateTime = new XFAObjectArray;
        this.decimal = new XFAObjectArray;
        this.exData = new XFAObjectArray;
        this.float = new XFAObjectArray;
        this.image = new XFAObjectArray;
        this.integer = new XFAObjectArray;
        this.manifest = new XFAObjectArray;
        this.script = new XFAObjectArray;
        this.text = new XFAObjectArray;
        this.time = new XFAObjectArray;
    }
    [As]() {
        return !0;
    }
}
class TemplateNamespace {
    static [Ks](e1, t) {
        if (TemplateNamespace.hasOwnProperty(e1)) {
            const a = TemplateNamespace[e1](t);
            a[Us](t);
            return a;
        }
    }
    static appearanceFilter(e1) {
        return new AppearanceFilter(e1);
    }
    static arc(e1) {
        return new Arc(e1);
    }
    static area(e1) {
        return new Area(e1);
    }
    static assist(e1) {
        return new Assist(e1);
    }
    static barcode(e1) {
        return new Barcode(e1);
    }
    static bind(e1) {
        return new Bind(e1);
    }
    static bindItems(e1) {
        return new BindItems(e1);
    }
    static bookend(e1) {
        return new Bookend(e1);
    }
    static boolean(e1) {
        return new BooleanElement(e1);
    }
    static border(e1) {
        return new Border(e1);
    }
    static break(e1) {
        return new Break(e1);
    }
    static breakAfter(e1) {
        return new BreakAfter(e1);
    }
    static breakBefore(e1) {
        return new BreakBefore(e1);
    }
    static button(e1) {
        return new Button(e1);
    }
    static calculate(e1) {
        return new Calculate(e1);
    }
    static caption(e1) {
        return new Caption(e1);
    }
    static certificate(e1) {
        return new Certificate(e1);
    }
    static certificates(e1) {
        return new Certificates(e1);
    }
    static checkButton(e1) {
        return new CheckButton(e1);
    }
    static choiceList(e1) {
        return new ChoiceList(e1);
    }
    static color(e1) {
        return new Color(e1);
    }
    static comb(e1) {
        return new Comb(e1);
    }
    static connect(e1) {
        return new Connect(e1);
    }
    static contentArea(e1) {
        return new ContentArea(e1);
    }
    static corner(e1) {
        return new Corner(e1);
    }
    static date(e1) {
        return new DateElement(e1);
    }
    static dateTime(e1) {
        return new DateTime(e1);
    }
    static dateTimeEdit(e1) {
        return new DateTimeEdit(e1);
    }
    static decimal(e1) {
        return new Decimal(e1);
    }
    static defaultUi(e1) {
        return new DefaultUi(e1);
    }
    static desc(e1) {
        return new Desc(e1);
    }
    static digestMethod(e1) {
        return new DigestMethod(e1);
    }
    static digestMethods(e1) {
        return new DigestMethods(e1);
    }
    static draw(e1) {
        return new Draw(e1);
    }
    static edge(e1) {
        return new Edge(e1);
    }
    static encoding(e1) {
        return new Encoding(e1);
    }
    static encodings(e1) {
        return new Encodings(e1);
    }
    static encrypt(e1) {
        return new Encrypt(e1);
    }
    static encryptData(e1) {
        return new EncryptData(e1);
    }
    static encryption(e1) {
        return new Encryption(e1);
    }
    static encryptionMethod(e1) {
        return new EncryptionMethod(e1);
    }
    static encryptionMethods(e1) {
        return new EncryptionMethods(e1);
    }
    static event(e1) {
        return new Event(e1);
    }
    static exData(e1) {
        return new ExData(e1);
    }
    static exObject(e1) {
        return new ExObject(e1);
    }
    static exclGroup(e1) {
        return new ExclGroup(e1);
    }
    static execute(e1) {
        return new Execute(e1);
    }
    static extras(e1) {
        return new Extras(e1);
    }
    static field(e1) {
        return new Field(e1);
    }
    static fill(e1) {
        return new Fill(e1);
    }
    static filter(e1) {
        return new Filter(e1);
    }
    static float(e1) {
        return new Float(e1);
    }
    static font(e1) {
        return new template_Font(e1);
    }
    static format(e1) {
        return new Format(e1);
    }
    static handler(e1) {
        return new Handler(e1);
    }
    static hyphenation(e1) {
        return new Hyphenation(e1);
    }
    static image(e1) {
        return new Image(e1);
    }
    static imageEdit(e1) {
        return new ImageEdit(e1);
    }
    static integer(e1) {
        return new Integer(e1);
    }
    static issuers(e1) {
        return new Issuers(e1);
    }
    static items(e1) {
        return new Items(e1);
    }
    static keep(e1) {
        return new Keep(e1);
    }
    static keyUsage(e1) {
        return new KeyUsage(e1);
    }
    static line(e1) {
        return new Line(e1);
    }
    static linear(e1) {
        return new Linear(e1);
    }
    static lockDocument(e1) {
        return new LockDocument(e1);
    }
    static manifest(e1) {
        return new Manifest(e1);
    }
    static margin(e1) {
        return new Margin(e1);
    }
    static mdp(e1) {
        return new Mdp(e1);
    }
    static medium(e1) {
        return new Medium(e1);
    }
    static message(e1) {
        return new Message(e1);
    }
    static numericEdit(e1) {
        return new NumericEdit(e1);
    }
    static occur(e1) {
        return new Occur(e1);
    }
    static oid(e1) {
        return new Oid(e1);
    }
    static oids(e1) {
        return new Oids(e1);
    }
    static overflow(e1) {
        return new Overflow(e1);
    }
    static pageArea(e1) {
        return new PageArea(e1);
    }
    static pageSet(e1) {
        return new PageSet(e1);
    }
    static para(e1) {
        return new Para(e1);
    }
    static passwordEdit(e1) {
        return new PasswordEdit(e1);
    }
    static pattern(e1) {
        return new template_Pattern(e1);
    }
    static picture(e1) {
        return new Picture(e1);
    }
    static proto(e1) {
        return new Proto(e1);
    }
    static radial(e1) {
        return new Radial(e1);
    }
    static reason(e1) {
        return new Reason(e1);
    }
    static reasons(e1) {
        return new Reasons(e1);
    }
    static rectangle(e1) {
        return new Rectangle(e1);
    }
    static ref(e1) {
        return new RefElement(e1);
    }
    static script(e1) {
        return new Script(e1);
    }
    static setProperty(e1) {
        return new SetProperty(e1);
    }
    static signData(e1) {
        return new SignData(e1);
    }
    static signature(e1) {
        return new Signature(e1);
    }
    static signing(e1) {
        return new Signing(e1);
    }
    static solid(e1) {
        return new Solid(e1);
    }
    static speak(e1) {
        return new Speak(e1);
    }
    static stipple(e1) {
        return new Stipple(e1);
    }
    static subform(e1) {
        return new Subform(e1);
    }
    static subformSet(e1) {
        return new SubformSet(e1);
    }
    static subjectDN(e1) {
        return new SubjectDN(e1);
    }
    static subjectDNs(e1) {
        return new SubjectDNs(e1);
    }
    static submit(e1) {
        return new Submit(e1);
    }
    static template(e1) {
        return new Template(e1);
    }
    static text(e1) {
        return new Text(e1);
    }
    static textEdit(e1) {
        return new TextEdit(e1);
    }
    static time(e1) {
        return new Time(e1);
    }
    static timeStamp(e1) {
        return new TimeStamp(e1);
    }
    static toolTip(e1) {
        return new ToolTip(e1);
    }
    static traversal(e1) {
        return new Traversal(e1);
    }
    static traverse(e1) {
        return new Traverse(e1);
    }
    static ui(e1) {
        return new Ui(e1);
    }
    static validate(e1) {
        return new Validate(e1);
    }
    static value(e1) {
        return new Value(e1);
    }
    static variables(e1) {
        return new Variables(e1);
    }
}
const Eo = Js.datasets.id;
function createText(e1) {
    const t = new Text({});
    t[Hn] = e1;
    return t;
}
class Binder {
    constructor(e1){
        this.root = e1;
        this.datasets = e1.datasets;
        this.data = e1.datasets?.data || new XmlObject(Js.datasets.id, "data");
        this.emptyMerge = 0 === this.data[is]().length;
        this.root.form = this.form = e1.template[Xn]();
    }
    _isConsumeData() {
        return !this.emptyMerge && this._mergeMode;
    }
    _isMatchTemplate() {
        return !this._isConsumeData();
    }
    bind() {
        this._bindElement(this.form, this.data);
        return this.form;
    }
    getData() {
        return this.data;
    }
    _bindValue(e1, t, a) {
        e1[Wn] = t;
        if (e1[us]()) if (t[bs]()) {
            const a = t[ts]();
            e1[Xs](createText(a));
        } else if (e1 instanceof Field && "multiSelect" === e1.ui?.choiceList?.open) {
            const a = t[is]().map((e1)=>e1[Hn].trim()).join("\n");
            e1[Xs](createText(a));
        } else this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
        else !t[bs]() || this._isMatchTemplate() ? this._bindElement(e1, t) : warn("XFA - Nodes haven't the same type.");
    }
    _findDataByNameToConsume(e1, t, a, r) {
        if (!e1) return null;
        let i, n;
        for(let r = 0; r < 3; r++){
            i = a[rs](e1, !1, !0);
            for(;;){
                n = i.next().value;
                if (!n) break;
                if (t === n[bs]()) return n;
            }
            if (a[vs] === Js.datasets.id && "data" === a[Fs]) break;
            a = a[cs]();
        }
        if (!r) return null;
        i = this.data[rs](e1, !0, !1);
        n = i.next().value;
        if (n) return n;
        i = this.data[Kn](e1, !0);
        n = i.next().value;
        return n?.[bs]() ? n : null;
    }
    _setProperties(e1, t) {
        if (e1.hasOwnProperty("setProperty")) for (const { ref: a, target: r, connection: i } of e1.setProperty.children){
            if (i) continue;
            if (!a) continue;
            const n = searchNode(this.root, t, a, !1, !1);
            if (!n) {
                warn(`XFA - Invalid reference: ${a}.`);
                continue;
            }
            const [s] = n;
            if (!s[ys](this.data)) {
                warn("XFA - Invalid node: must be a data node.");
                continue;
            }
            const o = searchNode(this.root, e1, r, !1, !1);
            if (!o) {
                warn(`XFA - Invalid target: ${r}.`);
                continue;
            }
            const [c] = o;
            if (!c[ys](e1)) {
                warn("XFA - Invalid target: must be a property or subproperty.");
                continue;
            }
            const l = c[cs]();
            if (c instanceof SetProperty || l instanceof SetProperty) {
                warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                continue;
            }
            if (c instanceof BindItems || l instanceof BindItems) {
                warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                continue;
            }
            const h = s[Hs](), u = c[Fs];
            if (c instanceof XFAAttribute) {
                const e1 = Object.create(null);
                e1[u] = h;
                const t = Reflect.construct(Object.getPrototypeOf(l).constructor, [
                    e1
                ]);
                l[u] = t[u];
            } else if (c.hasOwnProperty(Hn)) {
                c[Wn] = s;
                c[Hn] = h;
                c[Gn]();
            } else warn("XFA - Invalid node to use in setProperty");
        }
    }
    _bindItems(e1, t) {
        if (!e1.hasOwnProperty("items") || !e1.hasOwnProperty("bindItems") || e1.bindItems.isEmpty()) return;
        for (const t of e1.items.children)e1[Ns](t);
        e1.items.clear();
        const a = new Items({}), r = new Items({});
        e1[Pn](a);
        e1.items.push(a);
        e1[Pn](r);
        e1.items.push(r);
        for (const { ref: i, labelRef: n, valueRef: s, connection: o } of e1.bindItems.children){
            if (o) continue;
            if (!i) continue;
            const e1 = searchNode(this.root, t, i, !1, !1);
            if (e1) for (const t of e1){
                if (!t[ys](this.datasets)) {
                    warn(`XFA - Invalid ref (${i}): must be a datasets child.`);
                    continue;
                }
                const e1 = searchNode(this.root, t, n, !0, !1);
                if (!e1) {
                    warn(`XFA - Invalid label: ${n}.`);
                    continue;
                }
                const [o] = e1;
                if (!o[ys](this.datasets)) {
                    warn("XFA - Invalid label: must be a datasets child.");
                    continue;
                }
                const c = searchNode(this.root, t, s, !0, !1);
                if (!c) {
                    warn(`XFA - Invalid value: ${s}.`);
                    continue;
                }
                const [l] = c;
                if (!l[ys](this.datasets)) {
                    warn("XFA - Invalid value: must be a datasets child.");
                    continue;
                }
                const h = createText(o[Hs]()), u = createText(l[Hs]());
                a[Pn](h);
                a.text.push(h);
                r[Pn](u);
                r.text.push(u);
            }
            else warn(`XFA - Invalid reference: ${i}.`);
        }
    }
    _bindOccurrences(e1, t, a) {
        let r;
        if (t.length > 1) {
            r = e1[Xn]();
            r[Ns](r.occur);
            r.occur = null;
        }
        this._bindValue(e1, t[0], a);
        this._setProperties(e1, t[0]);
        this._bindItems(e1, t[0]);
        if (1 === t.length) return;
        const i = e1[cs](), n = e1[Fs], s = i[fs](e1);
        for(let e1 = 1, o = t.length; e1 < o; e1++){
            const o = t[e1], c = r[Xn]();
            i[n].push(c);
            i[gs](s + e1, c);
            this._bindValue(c, o, a);
            this._setProperties(c, o);
            this._bindItems(c, o);
        }
    }
    _createOccurrences(e1) {
        if (!this.emptyMerge) return;
        const { occur: t } = e1;
        if (!t || t.initial <= 1) return;
        const a = e1[cs](), r = e1[Fs];
        if (!(a[r] instanceof XFAObjectArray)) return;
        let i;
        i = e1.name ? a[r].children.filter((t)=>t.name === e1.name).length : a[r].children.length;
        const n = a[fs](e1) + 1, s = t.initial - i;
        if (s) {
            const t = e1[Xn]();
            t[Ns](t.occur);
            t.occur = null;
            a[r].push(t);
            a[gs](n, t);
            for(let e1 = 1; e1 < s; e1++){
                const i = t[Xn]();
                a[r].push(i);
                a[gs](n + e1, i);
            }
        }
    }
    _getOccurInfo(e1) {
        const { name: t, occur: a } = e1;
        if (!a || !t) return [
            1,
            1
        ];
        const r = -1 === a.max ? 1 / 0 : a.max;
        return [
            a.min,
            r
        ];
    }
    _setAndBind(e1, t) {
        this._setProperties(e1, t);
        this._bindItems(e1, t);
        this._bindElement(e1, t);
    }
    _bindElement(e1, t) {
        const a = [];
        this._createOccurrences(e1);
        for (const r of e1[is]()){
            if (r[Wn]) continue;
            if (void 0 === this._mergeMode && "subform" === r[Fs]) {
                this._mergeMode = "consumeData" === r.mergeMode;
                const e1 = t[is]();
                if (e1.length > 0) this._bindOccurrences(r, [
                    e1[0]
                ], null);
                else if (this.emptyMerge) {
                    const e1 = t[vs] === Eo ? -1 : t[vs], a = r[Wn] = new XmlObject(e1, r.name || "root");
                    t[Pn](a);
                    this._bindElement(r, a);
                }
                continue;
            }
            if (!r[ms]()) continue;
            let e1 = !1, i = null, n = null, s = null;
            if (r.bind) {
                switch(r.bind.match){
                    case "none":
                        this._setAndBind(r, t);
                        continue;
                    case "global":
                        e1 = !0;
                        break;
                    case "dataRef":
                        if (!r.bind.ref) {
                            warn(`XFA - ref is empty in node ${r[Fs]}.`);
                            this._setAndBind(r, t);
                            continue;
                        }
                        n = r.bind.ref;
                }
                r.bind.picture && (i = r.bind.picture[Hn]);
            }
            const [o, c] = this._getOccurInfo(r);
            if (n) {
                s = searchNode(this.root, t, n, !0, !1);
                if (null === s) {
                    s = createDataNode(this.data, t, n);
                    if (!s) continue;
                    this._isConsumeData() && (s[qn] = !0);
                    this._setAndBind(r, s);
                    continue;
                }
                this._isConsumeData() && (s = s.filter((e1)=>!e1[qn]));
                s.length > c ? s = s.slice(0, c) : 0 === s.length && (s = null);
                s && this._isConsumeData() && s.forEach((e1)=>{
                    e1[qn] = !0;
                });
            } else {
                if (!r.name) {
                    this._setAndBind(r, t);
                    continue;
                }
                if (this._isConsumeData()) {
                    const a = [];
                    for(; a.length < c;){
                        const i = this._findDataByNameToConsume(r.name, r[us](), t, e1);
                        if (!i) break;
                        i[qn] = !0;
                        a.push(i);
                    }
                    s = a.length > 0 ? a : null;
                } else {
                    s = t[rs](r.name, !1, this.emptyMerge).next().value;
                    if (!s) {
                        if (0 === o) {
                            a.push(r);
                            continue;
                        }
                        const e1 = t[vs] === Eo ? -1 : t[vs];
                        s = r[Wn] = new XmlObject(e1, r.name);
                        this.emptyMerge && (s[qn] = !0);
                        t[Pn](s);
                        this._setAndBind(r, s);
                        continue;
                    }
                    this.emptyMerge && (s[qn] = !0);
                    s = [
                        s
                    ];
                }
            }
            s ? this._bindOccurrences(r, s, i) : o > 0 ? this._setAndBind(r, t) : a.push(r);
        }
        a.forEach((e1)=>e1[cs]()[Ns](e1));
    }
}
class DataHandler {
    constructor(e1, t){
        this.data = t;
        this.dataset = e1.datasets || null;
    }
    serialize(e1) {
        const t = [
            [
                -1,
                this.data[is]()
            ]
        ];
        for(; t.length > 0;){
            const a = t.at(-1), [r, i] = a;
            if (r + 1 === i.length) {
                t.pop();
                continue;
            }
            const n = i[++a[0]], s = e1.get(n[Vs]);
            if (s) n[Xs](s);
            else {
                const t = n[Jn]();
                for (const a of t.values()){
                    const t = e1.get(a[Vs]);
                    if (t) {
                        a[Xs](t);
                        break;
                    }
                }
            }
            const o = n[is]();
            o.length > 0 && t.push([
                -1,
                o
            ]);
        }
        const a = [
            '<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'
        ];
        if (this.dataset) for (const e1 of this.dataset[is]())"data" !== e1[Fs] && e1[$s](a);
        this.data[$s](a);
        a.push("</xfa:datasets>");
        return a.join("");
    }
}
const Po = Js.config.id;
class Acrobat extends XFAObject {
    constructor(e1){
        super(Po, "acrobat", !0);
        this.acrobat7 = null;
        this.autoSave = null;
        this.common = null;
        this.validate = null;
        this.validateApprovalSignatures = null;
        this.submitUrl = new XFAObjectArray;
    }
}
class Acrobat7 extends XFAObject {
    constructor(e1){
        super(Po, "acrobat7", !0);
        this.dynamicRender = null;
    }
}
class ADBE_JSConsole extends OptionObject {
    constructor(e1){
        super(Po, "ADBE_JSConsole", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class ADBE_JSDebugger extends OptionObject {
    constructor(e1){
        super(Po, "ADBE_JSDebugger", [
            "delegate",
            "Enable",
            "Disable"
        ]);
    }
}
class AddSilentPrint extends Option01 {
    constructor(e1){
        super(Po, "addSilentPrint");
    }
}
class AddViewerPreferences extends Option01 {
    constructor(e1){
        super(Po, "addViewerPreferences");
    }
}
class AdjustData extends Option10 {
    constructor(e1){
        super(Po, "adjustData");
    }
}
class AdobeExtensionLevel extends IntegerObject {
    constructor(e1){
        super(Po, "adobeExtensionLevel", 0, (e1)=>e1 >= 1 && e1 <= 8);
    }
}
class Agent extends XFAObject {
    constructor(e1){
        super(Po, "agent", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.common = new XFAObjectArray;
    }
}
class AlwaysEmbed extends ContentObject {
    constructor(e1){
        super(Po, "alwaysEmbed");
    }
}
class Amd extends StringObject {
    constructor(e1){
        super(Po, "amd");
    }
}
class config_Area extends XFAObject {
    constructor(e1){
        super(Po, "area");
        this.level = getInteger({
            data: e1.level,
            defaultValue: 0,
            validate: (e1)=>e1 >= 1 && e1 <= 3
        });
        this.name = getStringOption(e1.name, [
            "",
            "barcode",
            "coreinit",
            "deviceDriver",
            "font",
            "general",
            "layout",
            "merge",
            "script",
            "signature",
            "sourceSet",
            "templateCache"
        ]);
    }
}
class Attributes extends OptionObject {
    constructor(e1){
        super(Po, "attributes", [
            "preserve",
            "delegate",
            "ignore"
        ]);
    }
}
class AutoSave extends OptionObject {
    constructor(e1){
        super(Po, "autoSave", [
            "disabled",
            "enabled"
        ]);
    }
}
class Base extends StringObject {
    constructor(e1){
        super(Po, "base");
    }
}
class BatchOutput extends XFAObject {
    constructor(e1){
        super(Po, "batchOutput");
        this.format = getStringOption(e1.format, [
            "none",
            "concat",
            "zip",
            "zipCompress"
        ]);
    }
}
class BehaviorOverride extends ContentObject {
    constructor(e1){
        super(Po, "behaviorOverride");
    }
    [Gn]() {
        this[Hn] = new Map(this[Hn].trim().split(/\s+/).filter((e1)=>e1.includes(":")).map((e1)=>e1.split(":", 2)));
    }
}
class Cache extends XFAObject {
    constructor(e1){
        super(Po, "cache", !0);
        this.templateCache = null;
    }
}
class Change extends Option01 {
    constructor(e1){
        super(Po, "change");
    }
}
class Common extends XFAObject {
    constructor(e1){
        super(Po, "common", !0);
        this.data = null;
        this.locale = null;
        this.localeSet = null;
        this.messaging = null;
        this.suppressBanner = null;
        this.template = null;
        this.validationMessaging = null;
        this.versionControl = null;
        this.log = new XFAObjectArray;
    }
}
class Compress extends XFAObject {
    constructor(e1){
        super(Po, "compress");
        this.scope = getStringOption(e1.scope, [
            "imageOnly",
            "document"
        ]);
    }
}
class CompressLogicalStructure extends Option01 {
    constructor(e1){
        super(Po, "compressLogicalStructure");
    }
}
class CompressObjectStream extends Option10 {
    constructor(e1){
        super(Po, "compressObjectStream");
    }
}
class Compression extends XFAObject {
    constructor(e1){
        super(Po, "compression", !0);
        this.compressLogicalStructure = null;
        this.compressObjectStream = null;
        this.level = null;
        this.type = null;
    }
}
class Config extends XFAObject {
    constructor(e1){
        super(Po, "config", !0);
        this.acrobat = null;
        this.present = null;
        this.trace = null;
        this.agent = new XFAObjectArray;
    }
}
class Conformance extends OptionObject {
    constructor(e1){
        super(Po, "conformance", [
            "A",
            "B"
        ]);
    }
}
class ContentCopy extends Option01 {
    constructor(e1){
        super(Po, "contentCopy");
    }
}
class Copies extends IntegerObject {
    constructor(e1){
        super(Po, "copies", 1, (e1)=>e1 >= 1);
    }
}
class Creator extends StringObject {
    constructor(e1){
        super(Po, "creator");
    }
}
class CurrentPage extends IntegerObject {
    constructor(e1){
        super(Po, "currentPage", 0, (e1)=>e1 >= 0);
    }
}
class Data extends XFAObject {
    constructor(e1){
        super(Po, "data", !0);
        this.adjustData = null;
        this.attributes = null;
        this.incrementalLoad = null;
        this.outputXSL = null;
        this.range = null;
        this.record = null;
        this.startNode = null;
        this.uri = null;
        this.window = null;
        this.xsl = null;
        this.excludeNS = new XFAObjectArray;
        this.transform = new XFAObjectArray;
    }
}
class Debug extends XFAObject {
    constructor(e1){
        super(Po, "debug", !0);
        this.uri = null;
    }
}
class DefaultTypeface extends ContentObject {
    constructor(e1){
        super(Po, "defaultTypeface");
        this.writingScript = getStringOption(e1.writingScript, [
            "*",
            "Arabic",
            "Cyrillic",
            "EastEuropeanRoman",
            "Greek",
            "Hebrew",
            "Japanese",
            "Korean",
            "Roman",
            "SimplifiedChinese",
            "Thai",
            "TraditionalChinese",
            "Vietnamese"
        ]);
    }
}
class Destination extends OptionObject {
    constructor(e1){
        super(Po, "destination", [
            "pdf",
            "pcl",
            "ps",
            "webClient",
            "zpl"
        ]);
    }
}
class DocumentAssembly extends Option01 {
    constructor(e1){
        super(Po, "documentAssembly");
    }
}
class Driver extends XFAObject {
    constructor(e1){
        super(Po, "driver", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
    }
}
class DuplexOption extends OptionObject {
    constructor(e1){
        super(Po, "duplexOption", [
            "simplex",
            "duplexFlipLongEdge",
            "duplexFlipShortEdge"
        ]);
    }
}
class DynamicRender extends OptionObject {
    constructor(e1){
        super(Po, "dynamicRender", [
            "forbidden",
            "required"
        ]);
    }
}
class Embed extends Option01 {
    constructor(e1){
        super(Po, "embed");
    }
}
class config_Encrypt extends Option01 {
    constructor(e1){
        super(Po, "encrypt");
    }
}
class config_Encryption extends XFAObject {
    constructor(e1){
        super(Po, "encryption", !0);
        this.encrypt = null;
        this.encryptionLevel = null;
        this.permissions = null;
    }
}
class EncryptionLevel extends OptionObject {
    constructor(e1){
        super(Po, "encryptionLevel", [
            "40bit",
            "128bit"
        ]);
    }
}
class Enforce extends StringObject {
    constructor(e1){
        super(Po, "enforce");
    }
}
class Equate extends XFAObject {
    constructor(e1){
        super(Po, "equate");
        this.force = getInteger({
            data: e1.force,
            defaultValue: 1,
            validate: (e1)=>0 === e1
        });
        this.from = e1.from || "";
        this.to = e1.to || "";
    }
}
class EquateRange extends XFAObject {
    constructor(e1){
        super(Po, "equateRange");
        this.from = e1.from || "";
        this.to = e1.to || "";
        this._unicodeRange = e1.unicodeRange || "";
    }
    get unicodeRange() {
        const e1 = [], t = /U\+([0-9a-fA-F]+)/, a = this._unicodeRange;
        for (let r of a.split(",").map((e1)=>e1.trim()).filter((e1)=>!!e1)){
            r = r.split("-", 2).map((e1)=>{
                const a = e1.match(t);
                return a ? parseInt(a[1], 16) : 0;
            });
            1 === r.length && r.push(r[0]);
            e1.push(r);
        }
        return shadow(this, "unicodeRange", e1);
    }
}
class Exclude extends ContentObject {
    constructor(e1){
        super(Po, "exclude");
    }
    [Gn]() {
        this[Hn] = this[Hn].trim().split(/\s+/).filter((e1)=>e1 && [
                "calculate",
                "close",
                "enter",
                "exit",
                "initialize",
                "ready",
                "validate"
            ].includes(e1));
    }
}
class ExcludeNS extends StringObject {
    constructor(e1){
        super(Po, "excludeNS");
    }
}
class FlipLabel extends OptionObject {
    constructor(e1){
        super(Po, "flipLabel", [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class config_FontInfo extends XFAObject {
    constructor(e1){
        super(Po, "fontInfo", !0);
        this.embed = null;
        this.map = null;
        this.subsetBelow = null;
        this.alwaysEmbed = new XFAObjectArray;
        this.defaultTypeface = new XFAObjectArray;
        this.neverEmbed = new XFAObjectArray;
    }
}
class FormFieldFilling extends Option01 {
    constructor(e1){
        super(Po, "formFieldFilling");
    }
}
class GroupParent extends StringObject {
    constructor(e1){
        super(Po, "groupParent");
    }
}
class IfEmpty extends OptionObject {
    constructor(e1){
        super(Po, "ifEmpty", [
            "dataValue",
            "dataGroup",
            "ignore",
            "remove"
        ]);
    }
}
class IncludeXDPContent extends StringObject {
    constructor(e1){
        super(Po, "includeXDPContent");
    }
}
class IncrementalLoad extends OptionObject {
    constructor(e1){
        super(Po, "incrementalLoad", [
            "none",
            "forwardOnly"
        ]);
    }
}
class IncrementalMerge extends Option01 {
    constructor(e1){
        super(Po, "incrementalMerge");
    }
}
class Interactive extends Option01 {
    constructor(e1){
        super(Po, "interactive");
    }
}
class Jog extends OptionObject {
    constructor(e1){
        super(Po, "jog", [
            "usePrinterSetting",
            "none",
            "pageSet"
        ]);
    }
}
class LabelPrinter extends XFAObject {
    constructor(e1){
        super(Po, "labelPrinter", !0);
        this.name = getStringOption(e1.name, [
            "zpl",
            "dpl",
            "ipl",
            "tcpl"
        ]);
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
    }
}
class Layout extends OptionObject {
    constructor(e1){
        super(Po, "layout", [
            "paginate",
            "panel"
        ]);
    }
}
class Level extends IntegerObject {
    constructor(e1){
        super(Po, "level", 0, (e1)=>e1 > 0);
    }
}
class Linearized extends Option01 {
    constructor(e1){
        super(Po, "linearized");
    }
}
class Locale extends StringObject {
    constructor(e1){
        super(Po, "locale");
    }
}
class LocaleSet extends StringObject {
    constructor(e1){
        super(Po, "localeSet");
    }
}
class Log extends XFAObject {
    constructor(e1){
        super(Po, "log", !0);
        this.mode = null;
        this.threshold = null;
        this.to = null;
        this.uri = null;
    }
}
class MapElement extends XFAObject {
    constructor(e1){
        super(Po, "map", !0);
        this.equate = new XFAObjectArray;
        this.equateRange = new XFAObjectArray;
    }
}
class MediumInfo extends XFAObject {
    constructor(e1){
        super(Po, "mediumInfo", !0);
        this.map = null;
    }
}
class config_Message extends XFAObject {
    constructor(e1){
        super(Po, "message", !0);
        this.msgId = null;
        this.severity = null;
    }
}
class Messaging extends XFAObject {
    constructor(e1){
        super(Po, "messaging", !0);
        this.message = new XFAObjectArray;
    }
}
class Mode extends OptionObject {
    constructor(e1){
        super(Po, "mode", [
            "append",
            "overwrite"
        ]);
    }
}
class ModifyAnnots extends Option01 {
    constructor(e1){
        super(Po, "modifyAnnots");
    }
}
class MsgId extends IntegerObject {
    constructor(e1){
        super(Po, "msgId", 1, (e1)=>e1 >= 1);
    }
}
class NameAttr extends StringObject {
    constructor(e1){
        super(Po, "nameAttr");
    }
}
class NeverEmbed extends ContentObject {
    constructor(e1){
        super(Po, "neverEmbed");
    }
}
class NumberOfCopies extends IntegerObject {
    constructor(e1){
        super(Po, "numberOfCopies", null, (e1)=>e1 >= 2 && e1 <= 5);
    }
}
class OpenAction extends XFAObject {
    constructor(e1){
        super(Po, "openAction", !0);
        this.destination = null;
    }
}
class Output extends XFAObject {
    constructor(e1){
        super(Po, "output", !0);
        this.to = null;
        this.type = null;
        this.uri = null;
    }
}
class OutputBin extends StringObject {
    constructor(e1){
        super(Po, "outputBin");
    }
}
class OutputXSL extends XFAObject {
    constructor(e1){
        super(Po, "outputXSL", !0);
        this.uri = null;
    }
}
class Overprint extends OptionObject {
    constructor(e1){
        super(Po, "overprint", [
            "none",
            "both",
            "draw",
            "field"
        ]);
    }
}
class Packets extends StringObject {
    constructor(e1){
        super(Po, "packets");
    }
    [Gn]() {
        "*" !== this[Hn] && (this[Hn] = this[Hn].trim().split(/\s+/).filter((e1)=>[
                "config",
                "datasets",
                "template",
                "xfdf",
                "xslt"
            ].includes(e1)));
    }
}
class PageOffset extends XFAObject {
    constructor(e1){
        super(Po, "pageOffset");
        this.x = getInteger({
            data: e1.x,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        });
        this.y = getInteger({
            data: e1.y,
            defaultValue: "useXDCSetting",
            validate: (e1)=>!0
        });
    }
}
class PageRange extends StringObject {
    constructor(e1){
        super(Po, "pageRange");
    }
    [Gn]() {
        const e1 = this[Hn].trim().split(/\s+/).map((e1)=>parseInt(e1, 10)), t = [];
        for(let a = 0, r = e1.length; a < r; a += 2)t.push(e1.slice(a, a + 2));
        this[Hn] = t;
    }
}
class Pagination extends OptionObject {
    constructor(e1){
        super(Po, "pagination", [
            "simplex",
            "duplexShortEdge",
            "duplexLongEdge"
        ]);
    }
}
class PaginationOverride extends OptionObject {
    constructor(e1){
        super(Po, "paginationOverride", [
            "none",
            "forceDuplex",
            "forceDuplexLongEdge",
            "forceDuplexShortEdge",
            "forceSimplex"
        ]);
    }
}
class Part extends IntegerObject {
    constructor(e1){
        super(Po, "part", 1, (e1)=>!1);
    }
}
class Pcl extends XFAObject {
    constructor(e1){
        super(Po, "pcl", !0);
        this.name = e1.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.pageOffset = null;
        this.staple = null;
        this.xdc = null;
    }
}
class Pdf extends XFAObject {
    constructor(e1){
        super(Po, "pdf", !0);
        this.name = e1.name || "";
        this.adobeExtensionLevel = null;
        this.batchOutput = null;
        this.compression = null;
        this.creator = null;
        this.encryption = null;
        this.fontInfo = null;
        this.interactive = null;
        this.linearized = null;
        this.openAction = null;
        this.pdfa = null;
        this.producer = null;
        this.renderPolicy = null;
        this.scriptModel = null;
        this.silentPrint = null;
        this.submitFormat = null;
        this.tagged = null;
        this.version = null;
        this.viewerPreferences = null;
        this.xdc = null;
    }
}
class Pdfa extends XFAObject {
    constructor(e1){
        super(Po, "pdfa", !0);
        this.amd = null;
        this.conformance = null;
        this.includeXDPContent = null;
        this.part = null;
    }
}
class Permissions extends XFAObject {
    constructor(e1){
        super(Po, "permissions", !0);
        this.accessibleContent = null;
        this.change = null;
        this.contentCopy = null;
        this.documentAssembly = null;
        this.formFieldFilling = null;
        this.modifyAnnots = null;
        this.plaintextMetadata = null;
        this.print = null;
        this.printHighQuality = null;
    }
}
class PickTrayByPDFSize extends Option01 {
    constructor(e1){
        super(Po, "pickTrayByPDFSize");
    }
}
class config_Picture extends StringObject {
    constructor(e1){
        super(Po, "picture");
    }
}
class PlaintextMetadata extends Option01 {
    constructor(e1){
        super(Po, "plaintextMetadata");
    }
}
class Presence extends OptionObject {
    constructor(e1){
        super(Po, "presence", [
            "preserve",
            "dissolve",
            "dissolveStructure",
            "ignore",
            "remove"
        ]);
    }
}
class Present extends XFAObject {
    constructor(e1){
        super(Po, "present", !0);
        this.behaviorOverride = null;
        this.cache = null;
        this.common = null;
        this.copies = null;
        this.destination = null;
        this.incrementalMerge = null;
        this.layout = null;
        this.output = null;
        this.overprint = null;
        this.pagination = null;
        this.paginationOverride = null;
        this.script = null;
        this.validate = null;
        this.xdp = null;
        this.driver = new XFAObjectArray;
        this.labelPrinter = new XFAObjectArray;
        this.pcl = new XFAObjectArray;
        this.pdf = new XFAObjectArray;
        this.ps = new XFAObjectArray;
        this.submitUrl = new XFAObjectArray;
        this.webClient = new XFAObjectArray;
        this.zpl = new XFAObjectArray;
    }
}
class Print extends Option01 {
    constructor(e1){
        super(Po, "print");
    }
}
class PrintHighQuality extends Option01 {
    constructor(e1){
        super(Po, "printHighQuality");
    }
}
class PrintScaling extends OptionObject {
    constructor(e1){
        super(Po, "printScaling", [
            "appdefault",
            "noScaling"
        ]);
    }
}
class PrinterName extends StringObject {
    constructor(e1){
        super(Po, "printerName");
    }
}
class Producer extends StringObject {
    constructor(e1){
        super(Po, "producer");
    }
}
class Ps extends XFAObject {
    constructor(e1){
        super(Po, "ps", !0);
        this.name = e1.name || "";
        this.batchOutput = null;
        this.fontInfo = null;
        this.jog = null;
        this.mediumInfo = null;
        this.outputBin = null;
        this.staple = null;
        this.xdc = null;
    }
}
class Range extends ContentObject {
    constructor(e1){
        super(Po, "range");
    }
    [Gn]() {
        this[Hn] = this[Hn].split(",", 2).map((e1)=>e1.split("-").map((e1)=>parseInt(e1.trim(), 10))).filter((e1)=>e1.every((e1)=>!isNaN(e1))).map((e1)=>{
            1 === e1.length && e1.push(e1[0]);
            return e1;
        });
    }
}
class Record extends ContentObject {
    constructor(e1){
        super(Po, "record");
    }
    [Gn]() {
        this[Hn] = this[Hn].trim();
        const e1 = parseInt(this[Hn], 10);
        !isNaN(e1) && e1 >= 0 && (this[Hn] = e1);
    }
}
class Relevant extends ContentObject {
    constructor(e1){
        super(Po, "relevant");
    }
    [Gn]() {
        this[Hn] = this[Hn].trim().split(/\s+/);
    }
}
class Rename extends ContentObject {
    constructor(e1){
        super(Po, "rename");
    }
    [Gn]() {
        this[Hn] = this[Hn].trim();
        (this[Hn].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Hn])) && warn("XFA - Rename: invalid XFA name");
    }
}
class RenderPolicy extends OptionObject {
    constructor(e1){
        super(Po, "renderPolicy", [
            "server",
            "client"
        ]);
    }
}
class RunScripts extends OptionObject {
    constructor(e1){
        super(Po, "runScripts", [
            "both",
            "client",
            "none",
            "server"
        ]);
    }
}
class config_Script extends XFAObject {
    constructor(e1){
        super(Po, "script", !0);
        this.currentPage = null;
        this.exclude = null;
        this.runScripts = null;
    }
}
class ScriptModel extends OptionObject {
    constructor(e1){
        super(Po, "scriptModel", [
            "XFA",
            "none"
        ]);
    }
}
class Severity extends OptionObject {
    constructor(e1){
        super(Po, "severity", [
            "ignore",
            "error",
            "information",
            "trace",
            "warning"
        ]);
    }
}
class SilentPrint extends XFAObject {
    constructor(e1){
        super(Po, "silentPrint", !0);
        this.addSilentPrint = null;
        this.printerName = null;
    }
}
class Staple extends XFAObject {
    constructor(e1){
        super(Po, "staple");
        this.mode = getStringOption(e1.mode, [
            "usePrinterSetting",
            "on",
            "off"
        ]);
    }
}
class StartNode extends StringObject {
    constructor(e1){
        super(Po, "startNode");
    }
}
class StartPage extends IntegerObject {
    constructor(e1){
        super(Po, "startPage", 0, (e1)=>!0);
    }
}
class SubmitFormat extends OptionObject {
    constructor(e1){
        super(Po, "submitFormat", [
            "html",
            "delegate",
            "fdf",
            "xml",
            "pdf"
        ]);
    }
}
class SubmitUrl extends StringObject {
    constructor(e1){
        super(Po, "submitUrl");
    }
}
class SubsetBelow extends IntegerObject {
    constructor(e1){
        super(Po, "subsetBelow", 100, (e1)=>e1 >= 0 && e1 <= 100);
    }
}
class SuppressBanner extends Option01 {
    constructor(e1){
        super(Po, "suppressBanner");
    }
}
class Tagged extends Option01 {
    constructor(e1){
        super(Po, "tagged");
    }
}
class config_Template extends XFAObject {
    constructor(e1){
        super(Po, "template", !0);
        this.base = null;
        this.relevant = null;
        this.startPage = null;
        this.uri = null;
        this.xsl = null;
    }
}
class Threshold extends OptionObject {
    constructor(e1){
        super(Po, "threshold", [
            "trace",
            "error",
            "information",
            "warning"
        ]);
    }
}
class To extends OptionObject {
    constructor(e1){
        super(Po, "to", [
            "null",
            "memory",
            "stderr",
            "stdout",
            "system",
            "uri"
        ]);
    }
}
class TemplateCache extends XFAObject {
    constructor(e1){
        super(Po, "templateCache");
        this.maxEntries = getInteger({
            data: e1.maxEntries,
            defaultValue: 5,
            validate: (e1)=>e1 >= 0
        });
    }
}
class Trace extends XFAObject {
    constructor(e1){
        super(Po, "trace", !0);
        this.area = new XFAObjectArray;
    }
}
class Transform extends XFAObject {
    constructor(e1){
        super(Po, "transform", !0);
        this.groupParent = null;
        this.ifEmpty = null;
        this.nameAttr = null;
        this.picture = null;
        this.presence = null;
        this.rename = null;
        this.whitespace = null;
    }
}
class Type extends OptionObject {
    constructor(e1){
        super(Po, "type", [
            "none",
            "ascii85",
            "asciiHex",
            "ccittfax",
            "flate",
            "lzw",
            "runLength",
            "native",
            "xdp",
            "mergedXDP"
        ]);
    }
}
class Uri extends StringObject {
    constructor(e1){
        super(Po, "uri");
    }
}
class config_Validate extends OptionObject {
    constructor(e1){
        super(Po, "validate", [
            "preSubmit",
            "prePrint",
            "preExecute",
            "preSave"
        ]);
    }
}
class ValidateApprovalSignatures extends ContentObject {
    constructor(e1){
        super(Po, "validateApprovalSignatures");
    }
    [Gn]() {
        this[Hn] = this[Hn].trim().split(/\s+/).filter((e1)=>[
                "docReady",
                "postSign"
            ].includes(e1));
    }
}
class ValidationMessaging extends OptionObject {
    constructor(e1){
        super(Po, "validationMessaging", [
            "allMessagesIndividually",
            "allMessagesTogether",
            "firstMessageOnly",
            "noMessages"
        ]);
    }
}
class Version extends OptionObject {
    constructor(e1){
        super(Po, "version", [
            "1.7",
            "1.6",
            "1.5",
            "1.4",
            "1.3",
            "1.2"
        ]);
    }
}
class VersionControl extends XFAObject {
    constructor(e1){
        super(Po, "VersionControl");
        this.outputBelow = getStringOption(e1.outputBelow, [
            "warn",
            "error",
            "update"
        ]);
        this.sourceAbove = getStringOption(e1.sourceAbove, [
            "warn",
            "error"
        ]);
        this.sourceBelow = getStringOption(e1.sourceBelow, [
            "update",
            "maintain"
        ]);
    }
}
class ViewerPreferences extends XFAObject {
    constructor(e1){
        super(Po, "viewerPreferences", !0);
        this.ADBE_JSConsole = null;
        this.ADBE_JSDebugger = null;
        this.addViewerPreferences = null;
        this.duplexOption = null;
        this.enforce = null;
        this.numberOfCopies = null;
        this.pageRange = null;
        this.pickTrayByPDFSize = null;
        this.printScaling = null;
    }
}
class WebClient extends XFAObject {
    constructor(e1){
        super(Po, "webClient", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.fontInfo = null;
        this.xdc = null;
    }
}
class Whitespace extends OptionObject {
    constructor(e1){
        super(Po, "whitespace", [
            "preserve",
            "ltrim",
            "normalize",
            "rtrim",
            "trim"
        ]);
    }
}
class Window extends ContentObject {
    constructor(e1){
        super(Po, "window");
    }
    [Gn]() {
        const e1 = this[Hn].split(",", 2).map((e1)=>parseInt(e1.trim(), 10));
        if (e1.some((e1)=>isNaN(e1))) this[Hn] = [
            0,
            0
        ];
        else {
            1 === e1.length && e1.push(e1[0]);
            this[Hn] = e1;
        }
    }
}
class Xdc extends XFAObject {
    constructor(e1){
        super(Po, "xdc", !0);
        this.uri = new XFAObjectArray;
        this.xsl = new XFAObjectArray;
    }
}
class Xdp extends XFAObject {
    constructor(e1){
        super(Po, "xdp", !0);
        this.packets = null;
    }
}
class Xsl extends XFAObject {
    constructor(e1){
        super(Po, "xsl", !0);
        this.debug = null;
        this.uri = null;
    }
}
class Zpl extends XFAObject {
    constructor(e1){
        super(Po, "zpl", !0);
        this.name = e1.name ? e1.name.trim() : "";
        this.batchOutput = null;
        this.flipLabel = null;
        this.fontInfo = null;
        this.xdc = null;
    }
}
class ConfigNamespace {
    static [Ks](e1, t) {
        if (ConfigNamespace.hasOwnProperty(e1)) return ConfigNamespace[e1](t);
    }
    static acrobat(e1) {
        return new Acrobat(e1);
    }
    static acrobat7(e1) {
        return new Acrobat7(e1);
    }
    static ADBE_JSConsole(e1) {
        return new ADBE_JSConsole(e1);
    }
    static ADBE_JSDebugger(e1) {
        return new ADBE_JSDebugger(e1);
    }
    static addSilentPrint(e1) {
        return new AddSilentPrint(e1);
    }
    static addViewerPreferences(e1) {
        return new AddViewerPreferences(e1);
    }
    static adjustData(e1) {
        return new AdjustData(e1);
    }
    static adobeExtensionLevel(e1) {
        return new AdobeExtensionLevel(e1);
    }
    static agent(e1) {
        return new Agent(e1);
    }
    static alwaysEmbed(e1) {
        return new AlwaysEmbed(e1);
    }
    static amd(e1) {
        return new Amd(e1);
    }
    static area(e1) {
        return new config_Area(e1);
    }
    static attributes(e1) {
        return new Attributes(e1);
    }
    static autoSave(e1) {
        return new AutoSave(e1);
    }
    static base(e1) {
        return new Base(e1);
    }
    static batchOutput(e1) {
        return new BatchOutput(e1);
    }
    static behaviorOverride(e1) {
        return new BehaviorOverride(e1);
    }
    static cache(e1) {
        return new Cache(e1);
    }
    static change(e1) {
        return new Change(e1);
    }
    static common(e1) {
        return new Common(e1);
    }
    static compress(e1) {
        return new Compress(e1);
    }
    static compressLogicalStructure(e1) {
        return new CompressLogicalStructure(e1);
    }
    static compressObjectStream(e1) {
        return new CompressObjectStream(e1);
    }
    static compression(e1) {
        return new Compression(e1);
    }
    static config(e1) {
        return new Config(e1);
    }
    static conformance(e1) {
        return new Conformance(e1);
    }
    static contentCopy(e1) {
        return new ContentCopy(e1);
    }
    static copies(e1) {
        return new Copies(e1);
    }
    static creator(e1) {
        return new Creator(e1);
    }
    static currentPage(e1) {
        return new CurrentPage(e1);
    }
    static data(e1) {
        return new Data(e1);
    }
    static debug(e1) {
        return new Debug(e1);
    }
    static defaultTypeface(e1) {
        return new DefaultTypeface(e1);
    }
    static destination(e1) {
        return new Destination(e1);
    }
    static documentAssembly(e1) {
        return new DocumentAssembly(e1);
    }
    static driver(e1) {
        return new Driver(e1);
    }
    static duplexOption(e1) {
        return new DuplexOption(e1);
    }
    static dynamicRender(e1) {
        return new DynamicRender(e1);
    }
    static embed(e1) {
        return new Embed(e1);
    }
    static encrypt(e1) {
        return new config_Encrypt(e1);
    }
    static encryption(e1) {
        return new config_Encryption(e1);
    }
    static encryptionLevel(e1) {
        return new EncryptionLevel(e1);
    }
    static enforce(e1) {
        return new Enforce(e1);
    }
    static equate(e1) {
        return new Equate(e1);
    }
    static equateRange(e1) {
        return new EquateRange(e1);
    }
    static exclude(e1) {
        return new Exclude(e1);
    }
    static excludeNS(e1) {
        return new ExcludeNS(e1);
    }
    static flipLabel(e1) {
        return new FlipLabel(e1);
    }
    static fontInfo(e1) {
        return new config_FontInfo(e1);
    }
    static formFieldFilling(e1) {
        return new FormFieldFilling(e1);
    }
    static groupParent(e1) {
        return new GroupParent(e1);
    }
    static ifEmpty(e1) {
        return new IfEmpty(e1);
    }
    static includeXDPContent(e1) {
        return new IncludeXDPContent(e1);
    }
    static incrementalLoad(e1) {
        return new IncrementalLoad(e1);
    }
    static incrementalMerge(e1) {
        return new IncrementalMerge(e1);
    }
    static interactive(e1) {
        return new Interactive(e1);
    }
    static jog(e1) {
        return new Jog(e1);
    }
    static labelPrinter(e1) {
        return new LabelPrinter(e1);
    }
    static layout(e1) {
        return new Layout(e1);
    }
    static level(e1) {
        return new Level(e1);
    }
    static linearized(e1) {
        return new Linearized(e1);
    }
    static locale(e1) {
        return new Locale(e1);
    }
    static localeSet(e1) {
        return new LocaleSet(e1);
    }
    static log(e1) {
        return new Log(e1);
    }
    static map(e1) {
        return new MapElement(e1);
    }
    static mediumInfo(e1) {
        return new MediumInfo(e1);
    }
    static message(e1) {
        return new config_Message(e1);
    }
    static messaging(e1) {
        return new Messaging(e1);
    }
    static mode(e1) {
        return new Mode(e1);
    }
    static modifyAnnots(e1) {
        return new ModifyAnnots(e1);
    }
    static msgId(e1) {
        return new MsgId(e1);
    }
    static nameAttr(e1) {
        return new NameAttr(e1);
    }
    static neverEmbed(e1) {
        return new NeverEmbed(e1);
    }
    static numberOfCopies(e1) {
        return new NumberOfCopies(e1);
    }
    static openAction(e1) {
        return new OpenAction(e1);
    }
    static output(e1) {
        return new Output(e1);
    }
    static outputBin(e1) {
        return new OutputBin(e1);
    }
    static outputXSL(e1) {
        return new OutputXSL(e1);
    }
    static overprint(e1) {
        return new Overprint(e1);
    }
    static packets(e1) {
        return new Packets(e1);
    }
    static pageOffset(e1) {
        return new PageOffset(e1);
    }
    static pageRange(e1) {
        return new PageRange(e1);
    }
    static pagination(e1) {
        return new Pagination(e1);
    }
    static paginationOverride(e1) {
        return new PaginationOverride(e1);
    }
    static part(e1) {
        return new Part(e1);
    }
    static pcl(e1) {
        return new Pcl(e1);
    }
    static pdf(e1) {
        return new Pdf(e1);
    }
    static pdfa(e1) {
        return new Pdfa(e1);
    }
    static permissions(e1) {
        return new Permissions(e1);
    }
    static pickTrayByPDFSize(e1) {
        return new PickTrayByPDFSize(e1);
    }
    static picture(e1) {
        return new config_Picture(e1);
    }
    static plaintextMetadata(e1) {
        return new PlaintextMetadata(e1);
    }
    static presence(e1) {
        return new Presence(e1);
    }
    static present(e1) {
        return new Present(e1);
    }
    static print(e1) {
        return new Print(e1);
    }
    static printHighQuality(e1) {
        return new PrintHighQuality(e1);
    }
    static printScaling(e1) {
        return new PrintScaling(e1);
    }
    static printerName(e1) {
        return new PrinterName(e1);
    }
    static producer(e1) {
        return new Producer(e1);
    }
    static ps(e1) {
        return new Ps(e1);
    }
    static range(e1) {
        return new Range(e1);
    }
    static record(e1) {
        return new Record(e1);
    }
    static relevant(e1) {
        return new Relevant(e1);
    }
    static rename(e1) {
        return new Rename(e1);
    }
    static renderPolicy(e1) {
        return new RenderPolicy(e1);
    }
    static runScripts(e1) {
        return new RunScripts(e1);
    }
    static script(e1) {
        return new config_Script(e1);
    }
    static scriptModel(e1) {
        return new ScriptModel(e1);
    }
    static severity(e1) {
        return new Severity(e1);
    }
    static silentPrint(e1) {
        return new SilentPrint(e1);
    }
    static staple(e1) {
        return new Staple(e1);
    }
    static startNode(e1) {
        return new StartNode(e1);
    }
    static startPage(e1) {
        return new StartPage(e1);
    }
    static submitFormat(e1) {
        return new SubmitFormat(e1);
    }
    static submitUrl(e1) {
        return new SubmitUrl(e1);
    }
    static subsetBelow(e1) {
        return new SubsetBelow(e1);
    }
    static suppressBanner(e1) {
        return new SuppressBanner(e1);
    }
    static tagged(e1) {
        return new Tagged(e1);
    }
    static template(e1) {
        return new config_Template(e1);
    }
    static templateCache(e1) {
        return new TemplateCache(e1);
    }
    static threshold(e1) {
        return new Threshold(e1);
    }
    static to(e1) {
        return new To(e1);
    }
    static trace(e1) {
        return new Trace(e1);
    }
    static transform(e1) {
        return new Transform(e1);
    }
    static type(e1) {
        return new Type(e1);
    }
    static uri(e1) {
        return new Uri(e1);
    }
    static validate(e1) {
        return new config_Validate(e1);
    }
    static validateApprovalSignatures(e1) {
        return new ValidateApprovalSignatures(e1);
    }
    static validationMessaging(e1) {
        return new ValidationMessaging(e1);
    }
    static version(e1) {
        return new Version(e1);
    }
    static versionControl(e1) {
        return new VersionControl(e1);
    }
    static viewerPreferences(e1) {
        return new ViewerPreferences(e1);
    }
    static webClient(e1) {
        return new WebClient(e1);
    }
    static whitespace(e1) {
        return new Whitespace(e1);
    }
    static window(e1) {
        return new Window(e1);
    }
    static xdc(e1) {
        return new Xdc(e1);
    }
    static xdp(e1) {
        return new Xdp(e1);
    }
    static xsl(e1) {
        return new Xsl(e1);
    }
    static zpl(e1) {
        return new Zpl(e1);
    }
}
const Lo = Js.connectionSet.id;
class ConnectionSet extends XFAObject {
    constructor(e1){
        super(Lo, "connectionSet", !0);
        this.wsdlConnection = new XFAObjectArray;
        this.xmlConnection = new XFAObjectArray;
        this.xsdConnection = new XFAObjectArray;
    }
}
class EffectiveInputPolicy extends XFAObject {
    constructor(e1){
        super(Lo, "effectiveInputPolicy");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class EffectiveOutputPolicy extends XFAObject {
    constructor(e1){
        super(Lo, "effectiveOutputPolicy");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class Operation extends StringObject {
    constructor(e1){
        super(Lo, "operation");
        this.id = e1.id || "";
        this.input = e1.input || "";
        this.name = e1.name || "";
        this.output = e1.output || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class RootElement extends StringObject {
    constructor(e1){
        super(Lo, "rootElement");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SoapAction extends StringObject {
    constructor(e1){
        super(Lo, "soapAction");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class SoapAddress extends StringObject {
    constructor(e1){
        super(Lo, "soapAddress");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class connection_set_Uri extends StringObject {
    constructor(e1){
        super(Lo, "uri");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class WsdlAddress extends StringObject {
    constructor(e1){
        super(Lo, "wsdlAddress");
        this.id = e1.id || "";
        this.name = e1.name || "";
        this.use = e1.use || "";
        this.usehref = e1.usehref || "";
    }
}
class WsdlConnection extends XFAObject {
    constructor(e1){
        super(Lo, "wsdlConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.effectiveInputPolicy = null;
        this.effectiveOutputPolicy = null;
        this.operation = null;
        this.soapAction = null;
        this.soapAddress = null;
        this.wsdlAddress = null;
    }
}
class XmlConnection extends XFAObject {
    constructor(e1){
        super(Lo, "xmlConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.uri = null;
    }
}
class XsdConnection extends XFAObject {
    constructor(e1){
        super(Lo, "xsdConnection", !0);
        this.dataDescription = e1.dataDescription || "";
        this.name = e1.name || "";
        this.rootElement = null;
        this.uri = null;
    }
}
class ConnectionSetNamespace {
    static [Ks](e1, t) {
        if (ConnectionSetNamespace.hasOwnProperty(e1)) return ConnectionSetNamespace[e1](t);
    }
    static connectionSet(e1) {
        return new ConnectionSet(e1);
    }
    static effectiveInputPolicy(e1) {
        return new EffectiveInputPolicy(e1);
    }
    static effectiveOutputPolicy(e1) {
        return new EffectiveOutputPolicy(e1);
    }
    static operation(e1) {
        return new Operation(e1);
    }
    static rootElement(e1) {
        return new RootElement(e1);
    }
    static soapAction(e1) {
        return new SoapAction(e1);
    }
    static soapAddress(e1) {
        return new SoapAddress(e1);
    }
    static uri(e1) {
        return new connection_set_Uri(e1);
    }
    static wsdlAddress(e1) {
        return new WsdlAddress(e1);
    }
    static wsdlConnection(e1) {
        return new WsdlConnection(e1);
    }
    static xmlConnection(e1) {
        return new XmlConnection(e1);
    }
    static xsdConnection(e1) {
        return new XsdConnection(e1);
    }
}
const jo = Js.datasets.id;
class datasets_Data extends XmlObject {
    constructor(e1){
        super(jo, "data", e1);
    }
    [ws]() {
        return !0;
    }
}
class Datasets extends XFAObject {
    constructor(e1){
        super(jo, "datasets", !0);
        this.data = null;
        this.Signature = null;
    }
    [Ts](e1) {
        const t = e1[Fs];
        ("data" === t && e1[vs] === jo || "Signature" === t && e1[vs] === Js.signature.id) && (this[t] = e1);
        this[Pn](e1);
    }
}
class DatasetsNamespace {
    static [Ks](e1, t) {
        if (DatasetsNamespace.hasOwnProperty(e1)) return DatasetsNamespace[e1](t);
    }
    static datasets(e1) {
        return new Datasets(e1);
    }
    static data(e1) {
        return new datasets_Data(e1);
    }
}
const _o = Js.localeSet.id;
class CalendarSymbols extends XFAObject {
    constructor(e1){
        super(_o, "calendarSymbols", !0);
        this.name = "gregorian";
        this.dayNames = new XFAObjectArray(2);
        this.eraNames = null;
        this.meridiemNames = null;
        this.monthNames = new XFAObjectArray(2);
    }
}
class CurrencySymbol extends StringObject {
    constructor(e1){
        super(_o, "currencySymbol");
        this.name = getStringOption(e1.name, [
            "symbol",
            "isoname",
            "decimal"
        ]);
    }
}
class CurrencySymbols extends XFAObject {
    constructor(e1){
        super(_o, "currencySymbols", !0);
        this.currencySymbol = new XFAObjectArray(3);
    }
}
class DatePattern extends StringObject {
    constructor(e1){
        super(_o, "datePattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class DatePatterns extends XFAObject {
    constructor(e1){
        super(_o, "datePatterns", !0);
        this.datePattern = new XFAObjectArray(4);
    }
}
class DateTimeSymbols extends ContentObject {
    constructor(e1){
        super(_o, "dateTimeSymbols");
    }
}
class Day extends StringObject {
    constructor(e1){
        super(_o, "day");
    }
}
class DayNames extends XFAObject {
    constructor(e1){
        super(_o, "dayNames", !0);
        this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.day = new XFAObjectArray(7);
    }
}
class Era extends StringObject {
    constructor(e1){
        super(_o, "era");
    }
}
class EraNames extends XFAObject {
    constructor(e1){
        super(_o, "eraNames", !0);
        this.era = new XFAObjectArray(2);
    }
}
class locale_set_Locale extends XFAObject {
    constructor(e1){
        super(_o, "locale", !0);
        this.desc = e1.desc || "";
        this.name = "isoname";
        this.calendarSymbols = null;
        this.currencySymbols = null;
        this.datePatterns = null;
        this.dateTimeSymbols = null;
        this.numberPatterns = null;
        this.numberSymbols = null;
        this.timePatterns = null;
        this.typeFaces = null;
    }
}
class locale_set_LocaleSet extends XFAObject {
    constructor(e1){
        super(_o, "localeSet", !0);
        this.locale = new XFAObjectArray;
    }
}
class Meridiem extends StringObject {
    constructor(e1){
        super(_o, "meridiem");
    }
}
class MeridiemNames extends XFAObject {
    constructor(e1){
        super(_o, "meridiemNames", !0);
        this.meridiem = new XFAObjectArray(2);
    }
}
class Month extends StringObject {
    constructor(e1){
        super(_o, "month");
    }
}
class MonthNames extends XFAObject {
    constructor(e1){
        super(_o, "monthNames", !0);
        this.abbr = getInteger({
            data: e1.abbr,
            defaultValue: 0,
            validate: (e1)=>1 === e1
        });
        this.month = new XFAObjectArray(12);
    }
}
class NumberPattern extends StringObject {
    constructor(e1){
        super(_o, "numberPattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class NumberPatterns extends XFAObject {
    constructor(e1){
        super(_o, "numberPatterns", !0);
        this.numberPattern = new XFAObjectArray(4);
    }
}
class NumberSymbol extends StringObject {
    constructor(e1){
        super(_o, "numberSymbol");
        this.name = getStringOption(e1.name, [
            "decimal",
            "grouping",
            "percent",
            "minus",
            "zero"
        ]);
    }
}
class NumberSymbols extends XFAObject {
    constructor(e1){
        super(_o, "numberSymbols", !0);
        this.numberSymbol = new XFAObjectArray(5);
    }
}
class TimePattern extends StringObject {
    constructor(e1){
        super(_o, "timePattern");
        this.name = getStringOption(e1.name, [
            "full",
            "long",
            "med",
            "short"
        ]);
    }
}
class TimePatterns extends XFAObject {
    constructor(e1){
        super(_o, "timePatterns", !0);
        this.timePattern = new XFAObjectArray(4);
    }
}
class TypeFace extends XFAObject {
    constructor(e1){
        super(_o, "typeFace", !0);
        this.name = "" | e1.name;
    }
}
class TypeFaces extends XFAObject {
    constructor(e1){
        super(_o, "typeFaces", !0);
        this.typeFace = new XFAObjectArray;
    }
}
class LocaleSetNamespace {
    static [Ks](e1, t) {
        if (LocaleSetNamespace.hasOwnProperty(e1)) return LocaleSetNamespace[e1](t);
    }
    static calendarSymbols(e1) {
        return new CalendarSymbols(e1);
    }
    static currencySymbol(e1) {
        return new CurrencySymbol(e1);
    }
    static currencySymbols(e1) {
        return new CurrencySymbols(e1);
    }
    static datePattern(e1) {
        return new DatePattern(e1);
    }
    static datePatterns(e1) {
        return new DatePatterns(e1);
    }
    static dateTimeSymbols(e1) {
        return new DateTimeSymbols(e1);
    }
    static day(e1) {
        return new Day(e1);
    }
    static dayNames(e1) {
        return new DayNames(e1);
    }
    static era(e1) {
        return new Era(e1);
    }
    static eraNames(e1) {
        return new EraNames(e1);
    }
    static locale(e1) {
        return new locale_set_Locale(e1);
    }
    static localeSet(e1) {
        return new locale_set_LocaleSet(e1);
    }
    static meridiem(e1) {
        return new Meridiem(e1);
    }
    static meridiemNames(e1) {
        return new MeridiemNames(e1);
    }
    static month(e1) {
        return new Month(e1);
    }
    static monthNames(e1) {
        return new MonthNames(e1);
    }
    static numberPattern(e1) {
        return new NumberPattern(e1);
    }
    static numberPatterns(e1) {
        return new NumberPatterns(e1);
    }
    static numberSymbol(e1) {
        return new NumberSymbol(e1);
    }
    static numberSymbols(e1) {
        return new NumberSymbols(e1);
    }
    static timePattern(e1) {
        return new TimePattern(e1);
    }
    static timePatterns(e1) {
        return new TimePatterns(e1);
    }
    static typeFace(e1) {
        return new TypeFace(e1);
    }
    static typeFaces(e1) {
        return new TypeFaces(e1);
    }
}
const Uo = Js.signature.id;
class signature_Signature extends XFAObject {
    constructor(e1){
        super(Uo, "signature", !0);
    }
}
class SignatureNamespace {
    static [Ks](e1, t) {
        if (SignatureNamespace.hasOwnProperty(e1)) return SignatureNamespace[e1](t);
    }
    static signature(e1) {
        return new signature_Signature(e1);
    }
}
const Xo = Js.stylesheet.id;
class Stylesheet extends XFAObject {
    constructor(e1){
        super(Xo, "stylesheet", !0);
    }
}
class StylesheetNamespace {
    static [Ks](e1, t) {
        if (StylesheetNamespace.hasOwnProperty(e1)) return StylesheetNamespace[e1](t);
    }
    static stylesheet(e1) {
        return new Stylesheet(e1);
    }
}
const qo = Js.xdp.id;
class xdp_Xdp extends XFAObject {
    constructor(e1){
        super(qo, "xdp", !0);
        this.uuid = e1.uuid || "";
        this.timeStamp = e1.timeStamp || "";
        this.config = null;
        this.connectionSet = null;
        this.datasets = null;
        this.localeSet = null;
        this.stylesheet = new XFAObjectArray;
        this.template = null;
    }
    [Os](e1) {
        const t = Js[e1[Fs]];
        return t && e1[vs] === t.id;
    }
}
class XdpNamespace {
    static [Ks](e1, t) {
        if (XdpNamespace.hasOwnProperty(e1)) return XdpNamespace[e1](t);
    }
    static xdp(e1) {
        return new xdp_Xdp(e1);
    }
}
const Ho = Js.xhtml.id, Wo = Symbol(), zo = new Set([
    "color",
    "font",
    "font-family",
    "font-size",
    "font-stretch",
    "font-style",
    "font-weight",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "letter-spacing",
    "line-height",
    "orphans",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "tab-interval",
    "tab-stop",
    "text-align",
    "text-decoration",
    "text-indent",
    "vertical-align",
    "widows",
    "kerning-mode",
    "xfa-font-horizontal-scale",
    "xfa-font-vertical-scale",
    "xfa-spacerun",
    "xfa-tab-stops"
]), $o = new Map([
    [
        "page-break-after",
        "breakAfter"
    ],
    [
        "page-break-before",
        "breakBefore"
    ],
    [
        "page-break-inside",
        "breakInside"
    ],
    [
        "kerning-mode",
        (e1)=>"none" === e1 ? "none" : "normal"
    ],
    [
        "xfa-font-horizontal-scale",
        (e1)=>`scaleX(${Math.max(0, parseInt(e1) / 100).toFixed(2)})`
    ],
    [
        "xfa-font-vertical-scale",
        (e1)=>`scaleY(${Math.max(0, parseInt(e1) / 100).toFixed(2)})`
    ],
    [
        "xfa-spacerun",
        ""
    ],
    [
        "xfa-tab-stops",
        ""
    ],
    [
        "font-size",
        (e1, t)=>measureToString(.99 * (e1 = t.fontSize = Math.abs(getMeasurement(e1))))
    ],
    [
        "letter-spacing",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "line-height",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-bottom",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-left",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-right",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "margin-top",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "text-indent",
        (e1)=>measureToString(getMeasurement(e1))
    ],
    [
        "font-family",
        (e1)=>e1
    ],
    [
        "vertical-align",
        (e1)=>measureToString(getMeasurement(e1))
    ]
]), Go = /\s+/g, Vo = /[\r\n]+/g, Ko = /\r\n?/g;
function mapStyle(e1, t, a) {
    const r = Object.create(null);
    if (!e1) return r;
    const i = Object.create(null);
    for (const [t, a] of e1.split(";").map((e1)=>e1.split(":", 2))){
        const e1 = $o.get(t);
        if ("" === e1) continue;
        let n = a;
        e1 && (n = "string" == typeof e1 ? e1 : e1(a, i));
        t.endsWith("scale") ? r.transform = r.transform ? `${r[t]} ${n}` : n : r[t.replaceAll(/-([a-zA-Z])/g, (e1, t)=>t.toUpperCase())] = n;
    }
    r.fontFamily && setFontFamily({
        typeface: r.fontFamily,
        weight: r.fontWeight || "normal",
        posture: r.fontStyle || "normal",
        size: i.fontSize || 0
    }, t, t[hs].fontFinder, r);
    if (a && r.verticalAlign && "0px" !== r.verticalAlign && r.fontSize) {
        const e1 = .583, t = .333, a = getMeasurement(r.fontSize);
        r.fontSize = measureToString(a * e1);
        r.verticalAlign = measureToString(Math.sign(getMeasurement(r.verticalAlign)) * a * t);
    }
    a && r.fontSize && (r.fontSize = `calc(${r.fontSize} * var(--total-scale-factor))`);
    fixTextIndent(r);
    return r;
}
const Jo = new Set([
    "body",
    "html"
]);
class XhtmlObject extends XmlObject {
    constructor(e1, t){
        super(Ho, t);
        this[Wo] = !1;
        this.style = e1.style || "";
    }
    [jn](e1) {
        super[jn](e1);
        this.style = function checkStyle(e1) {
            return e1.style ? e1.style.split(";").filter((e1)=>!!e1.trim()).map((e1)=>e1.split(":", 2).map((e1)=>e1.trim())).filter(([t, a])=>{
                "font-family" === t && e1[hs].usedTypefaces.add(a);
                return zo.has(t);
            }).map((e1)=>e1.join(":")).join(";") : "";
        }(this);
    }
    [Nn]() {
        return !Jo.has(this[Fs]);
    }
    [Ms](e1, t = !1) {
        if (t) this[Wo] = !0;
        else {
            e1 = e1.replaceAll(Vo, "");
            this.style.includes("xfa-spacerun:yes") || (e1 = e1.replaceAll(Go, " "));
        }
        e1 && (this[Hn] += e1);
    }
    [Ds](e1, t = !0) {
        const a = Object.create(null), r = {
            top: NaN,
            bottom: NaN,
            left: NaN,
            right: NaN
        };
        let i = null;
        for (const [e1, t] of this.style.split(";").map((e1)=>e1.split(":", 2)))switch(e1){
            case "font-family":
                a.typeface = stripQuotes(t);
                break;
            case "font-size":
                a.size = getMeasurement(t);
                break;
            case "font-weight":
                a.weight = t;
                break;
            case "font-style":
                a.posture = t;
                break;
            case "letter-spacing":
                a.letterSpacing = getMeasurement(t);
                break;
            case "margin":
                const e2 = t.split(/ \t/).map((e1)=>getMeasurement(e1));
                switch(e2.length){
                    case 1:
                        r.top = r.bottom = r.left = r.right = e2[0];
                        break;
                    case 2:
                        r.top = r.bottom = e2[0];
                        r.left = r.right = e2[1];
                        break;
                    case 3:
                        r.top = e2[0];
                        r.bottom = e2[2];
                        r.left = r.right = e2[1];
                        break;
                    case 4:
                        r.top = e2[0];
                        r.left = e2[1];
                        r.bottom = e2[2];
                        r.right = e2[3];
                }
                break;
            case "margin-top":
                r.top = getMeasurement(t);
                break;
            case "margin-bottom":
                r.bottom = getMeasurement(t);
                break;
            case "margin-left":
                r.left = getMeasurement(t);
                break;
            case "margin-right":
                r.right = getMeasurement(t);
                break;
            case "line-height":
                i = getMeasurement(t);
        }
        e1.pushData(a, r, i);
        if (this[Hn]) e1.addString(this[Hn]);
        else for (const t of this[is]())"#text" !== t[Fs] ? t[Ds](e1) : e1.addString(t[Hn]);
        t && e1.popFont();
    }
    [zs](e1) {
        const t = [];
        this[$n] = {
            children: t
        };
        this[Ln]({});
        if (0 === t.length && !this[Hn]) return HTMLResult.EMPTY;
        let a;
        a = this[Wo] ? this[Hn] ? this[Hn].replaceAll(Ko, "\n") : void 0 : this[Hn] || void 0;
        return HTMLResult.success({
            name: this[Fs],
            attributes: {
                href: this.href,
                style: mapStyle(this.style, this, this[Wo])
            },
            children: t,
            value: a
        });
    }
}
class A extends XhtmlObject {
    constructor(e1){
        super(e1, "a");
        this.href = fixURL(e1.href) || "";
    }
}
class B extends XhtmlObject {
    constructor(e1){
        super(e1, "b");
    }
    [Ds](e1) {
        e1.pushFont({
            weight: "bold"
        });
        super[Ds](e1);
        e1.popFont();
    }
}
class Body extends XhtmlObject {
    constructor(e1){
        super(e1, "body");
    }
    [zs](e1) {
        const t = super[zs](e1), { html: a } = t;
        if (!a) return HTMLResult.EMPTY;
        a.name = "div";
        a.attributes.class = [
            "xfaRich"
        ];
        return t;
    }
}
class Br extends XhtmlObject {
    constructor(e1){
        super(e1, "br");
    }
    [Hs]() {
        return "\n";
    }
    [Ds](e1) {
        e1.addString("\n");
    }
    [zs](e1) {
        return HTMLResult.success({
            name: "br"
        });
    }
}
class Html extends XhtmlObject {
    constructor(e1){
        super(e1, "html");
    }
    [zs](e1) {
        const t = [];
        this[$n] = {
            children: t
        };
        this[Ln]({});
        if (0 === t.length) return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            value: this[Hn] || ""
        });
        if (1 === t.length) {
            const e1 = t[0];
            if (e1.attributes?.class.includes("xfaRich")) return HTMLResult.success(e1);
        }
        return HTMLResult.success({
            name: "div",
            attributes: {
                class: [
                    "xfaRich"
                ],
                style: {}
            },
            children: t
        });
    }
}
class I extends XhtmlObject {
    constructor(e1){
        super(e1, "i");
    }
    [Ds](e1) {
        e1.pushFont({
            posture: "italic"
        });
        super[Ds](e1);
        e1.popFont();
    }
}
class Li extends XhtmlObject {
    constructor(e1){
        super(e1, "li");
    }
}
class Ol extends XhtmlObject {
    constructor(e1){
        super(e1, "ol");
    }
}
class P extends XhtmlObject {
    constructor(e1){
        super(e1, "p");
    }
    [Ds](e1) {
        super[Ds](e1, !1);
        e1.addString("\n");
        e1.addPara();
        e1.popFont();
    }
    [Hs]() {
        return this[cs]()[is]().at(-1) === this ? super[Hs]() : super[Hs]() + "\n";
    }
}
class Span extends XhtmlObject {
    constructor(e1){
        super(e1, "span");
    }
}
class Sub extends XhtmlObject {
    constructor(e1){
        super(e1, "sub");
    }
}
class Sup extends XhtmlObject {
    constructor(e1){
        super(e1, "sup");
    }
}
class Ul extends XhtmlObject {
    constructor(e1){
        super(e1, "ul");
    }
}
class XhtmlNamespace {
    static [Ks](e1, t) {
        if (XhtmlNamespace.hasOwnProperty(e1)) return XhtmlNamespace[e1](t);
    }
    static a(e1) {
        return new A(e1);
    }
    static b(e1) {
        return new B(e1);
    }
    static body(e1) {
        return new Body(e1);
    }
    static br(e1) {
        return new Br(e1);
    }
    static html(e1) {
        return new Html(e1);
    }
    static i(e1) {
        return new I(e1);
    }
    static li(e1) {
        return new Li(e1);
    }
    static ol(e1) {
        return new Ol(e1);
    }
    static p(e1) {
        return new P(e1);
    }
    static span(e1) {
        return new Span(e1);
    }
    static sub(e1) {
        return new Sub(e1);
    }
    static sup(e1) {
        return new Sup(e1);
    }
    static ul(e1) {
        return new Ul(e1);
    }
}
const Yo = {
    config: ConfigNamespace,
    connection: ConnectionSetNamespace,
    datasets: DatasetsNamespace,
    localeSet: LocaleSetNamespace,
    signature: SignatureNamespace,
    stylesheet: StylesheetNamespace,
    template: TemplateNamespace,
    xdp: XdpNamespace,
    xhtml: XhtmlNamespace
};
class UnknownNamespace {
    constructor(e1){
        this.namespaceId = e1;
    }
    [Ks](e1, t) {
        return new XmlObject(this.namespaceId, e1, t);
    }
}
class Root extends XFAObject {
    constructor(e1){
        super(-1, "root", Object.create(null));
        this.element = null;
        this[ds] = e1;
    }
    [Ts](e1) {
        this.element = e1;
        return !0;
    }
    [Gn]() {
        super[Gn]();
        if (this.element.template instanceof Template) {
            this[ds].set(Es, this.element);
            this.element.template[Ls](this[ds]);
            this.element.template[ds] = this[ds];
        }
    }
}
class Empty extends XFAObject {
    constructor(){
        super(-1, "", Object.create(null));
    }
    [Ts](e1) {
        return !1;
    }
}
class Builder {
    constructor(e1 = null){
        this._namespaceStack = [];
        this._nsAgnosticLevel = 0;
        this._namespacePrefixes = new Map;
        this._namespaces = new Map;
        this._nextNsId = Math.max(...Object.values(Js).map(({ id: e1 })=>e1));
        this._currentNamespace = e1 || new UnknownNamespace(++this._nextNsId);
    }
    buildRoot(e1) {
        return new Root(e1);
    }
    build({ nsPrefix: e1, name: t, attributes: a, namespace: r, prefixes: i }) {
        const n = null !== r;
        if (n) {
            this._namespaceStack.push(this._currentNamespace);
            this._currentNamespace = this._searchNamespace(r);
        }
        i && this._addNamespacePrefix(i);
        if (a.hasOwnProperty(Is)) {
            const e1 = Yo.datasets, t = a[Is];
            let r = null;
            for (const [a, i] of Object.entries(t)){
                if (this._getNamespaceToUse(a) === e1) {
                    r = {
                        xfa: i
                    };
                    break;
                }
            }
            r ? a[Is] = r : delete a[Is];
        }
        const s = this._getNamespaceToUse(e1), o = s?.[Ks](t, a) || new Empty;
        o[ws]() && this._nsAgnosticLevel++;
        (n || i || o[ws]()) && (o[Un] = {
            hasNamespace: n,
            prefixes: i,
            nsAgnostic: o[ws]()
        });
        return o;
    }
    isNsAgnostic() {
        return this._nsAgnosticLevel > 0;
    }
    _searchNamespace(e1) {
        let t = this._namespaces.get(e1);
        if (t) return t;
        for (const [a, { check: r }] of Object.entries(Js))if (r(e1)) {
            t = Yo[a];
            if (t) {
                this._namespaces.set(e1, t);
                return t;
            }
            break;
        }
        t = new UnknownNamespace(++this._nextNsId);
        this._namespaces.set(e1, t);
        return t;
    }
    _addNamespacePrefix(e1) {
        for (const { prefix: t, value: a } of e1){
            const e1 = this._searchNamespace(a);
            let r = this._namespacePrefixes.get(t);
            if (!r) {
                r = [];
                this._namespacePrefixes.set(t, r);
            }
            r.push(e1);
        }
    }
    _getNamespaceToUse(e1) {
        if (!e1) return this._currentNamespace;
        const t = this._namespacePrefixes.get(e1);
        if (t?.length > 0) return t.at(-1);
        warn(`Unknown namespace prefix: ${e1}.`);
        return null;
    }
    clean(e1) {
        const { hasNamespace: t, prefixes: a, nsAgnostic: r } = e1;
        t && (this._currentNamespace = this._namespaceStack.pop());
        a && a.forEach(({ prefix: e1 })=>{
            this._namespacePrefixes.get(e1).pop();
        });
        r && this._nsAgnosticLevel--;
    }
}
class XFAParser extends XMLParserBase {
    constructor(e1 = null, t = !1){
        super();
        this._builder = new Builder(e1);
        this._stack = [];
        this._globalData = {
            usedTypefaces: new Set
        };
        this._ids = new Map;
        this._current = this._builder.buildRoot(this._ids);
        this._errorCode = Sn;
        this._whiteRegex = /^\s+$/;
        this._nbsps = /\xa0+/g;
        this._richText = t;
    }
    parse(e1) {
        this.parseXml(e1);
        if (this._errorCode === Sn) {
            this._current[Gn]();
            return this._current.element;
        }
    }
    onText(e1) {
        e1 = e1.replace(this._nbsps, (e1)=>e1.slice(1) + " ");
        this._richText || this._current[Nn]() ? this._current[Ms](e1, this._richText) : this._whiteRegex.test(e1) || this._current[Ms](e1.trim());
    }
    onCdata(e1) {
        this._current[Ms](e1);
    }
    _mkAttributes(e1, t) {
        let a = null, r = null;
        const i = Object.create({});
        for (const { name: n, value: s } of e1)if ("xmlns" === n) a ? warn(`XFA - multiple namespace definition in <${t}>`) : a = s;
        else if (n.startsWith("xmlns:")) {
            const e1 = n.substring(6);
            r ??= [];
            r.push({
                prefix: e1,
                value: s
            });
        } else {
            const e1 = n.indexOf(":");
            if (-1 === e1) i[n] = s;
            else {
                const t = i[Is] ??= Object.create(null), [a, r] = [
                    n.slice(0, e1),
                    n.slice(e1 + 1)
                ];
                (t[a] ||= Object.create(null))[r] = s;
            }
        }
        return [
            a,
            r,
            i
        ];
    }
    _getNameAndPrefix(e1, t) {
        const a = e1.indexOf(":");
        return -1 === a ? [
            e1,
            null
        ] : [
            e1.substring(a + 1),
            t ? "" : e1.substring(0, a)
        ];
    }
    onBeginElement(e1, t, a) {
        const [r, i, n] = this._mkAttributes(t, e1), [s, o] = this._getNameAndPrefix(e1, this._builder.isNsAgnostic()), c = this._builder.build({
            nsPrefix: o,
            name: s,
            attributes: n,
            namespace: r,
            prefixes: i
        });
        c[hs] = this._globalData;
        if (a) {
            c[Gn]();
            this._current[Ts](c) && c[_s](this._ids);
            c[jn](this._builder);
        } else {
            this._stack.push(this._current);
            this._current = c;
        }
    }
    onEndElement(e1) {
        const t = this._current;
        if (t[ps]() && "string" == typeof t[Hn]) {
            const e1 = new XFAParser;
            e1._globalData = this._globalData;
            const a = e1.parse(t[Hn]);
            t[Hn] = null;
            t[Ts](a);
        }
        t[Gn]();
        this._current = this._stack.pop();
        this._current[Ts](t) && t[_s](this._ids);
        t[jn](this._builder);
    }
    onError(e1) {
        this._errorCode = e1;
    }
}
class XFAFactory {
    constructor(e1){
        try {
            this.root = (new XFAParser).parse(XFAFactory._createDocument(e1));
            const t = new Binder(this.root);
            this.form = t.bind();
            this.dataHandler = new DataHandler(this.root, t.getData());
            this.form[hs].template = this.form;
        } catch (e1) {
            warn(`XFA - an error occurred during parsing and binding: ${e1}`);
        }
    }
    isValid() {
        return !(!this.root || !this.form);
    }
    _createPagesHelper() {
        const e1 = this.form[Ws]();
        return new Promise((t, a)=>{
            const nextIteration = ()=>{
                try {
                    const a = e1.next();
                    a.done ? t(a.value) : setTimeout(nextIteration, 0);
                } catch (e1) {
                    a(e1);
                }
            };
            setTimeout(nextIteration, 0);
        });
    }
    async _createPages() {
        try {
            this.pages = await this._createPagesHelper();
            this.dims = this.pages.children.map((e1)=>{
                const { width: t, height: a } = e1.attributes.style;
                return [
                    0,
                    0,
                    parseInt(t),
                    parseInt(a)
                ];
            });
        } catch (e1) {
            warn(`XFA - an error occurred during layout: ${e1}`);
        }
    }
    getBoundingBox(e1) {
        return this.dims[e1];
    }
    async getNumPages() {
        this.pages || await this._createPages();
        return this.dims.length;
    }
    setImages(e1) {
        this.form[hs].images = e1;
    }
    setFonts(e1) {
        this.form[hs].fontFinder = new FontFinder(e1);
        const t = [];
        for (let e1 of this.form[hs].usedTypefaces){
            e1 = stripQuotes(e1);
            this.form[hs].fontFinder.find(e1) || t.push(e1);
        }
        return t.length > 0 ? t : null;
    }
    appendFonts(e1, t) {
        this.form[hs].fontFinder.add(e1, t);
    }
    async getPages() {
        this.pages || await this._createPages();
        const e1 = this.pages;
        this.pages = null;
        return e1;
    }
    serializeData(e1) {
        return this.dataHandler.serialize(e1);
    }
    static _createDocument(e1) {
        return e1["/xdp:xdp"] ? Object.values(e1).join("") : e1["xdp:xdp"];
    }
    static getRichTextAsHtml(e1) {
        if (!e1 || "string" != typeof e1) return null;
        try {
            let t = new XFAParser(XhtmlNamespace, !0).parse(e1);
            if (![
                "body",
                "xhtml"
            ].includes(t[Fs])) {
                const e1 = XhtmlNamespace.body({});
                e1[Pn](t);
                t = e1;
            }
            const a = t[zs]();
            if (!a.success) return null;
            const { html: r } = a, { attributes: i } = r;
            if (i) {
                i.class && (i.class = i.class.filter((e1)=>!e1.startsWith("xfa")));
                i.dir = "auto";
            }
            return {
                html: r,
                str: t[Hs]()
            };
        } catch (e1) {
            warn(`XFA - an error occurred during parsing of rich text: ${e1}`);
        }
        return null;
    }
}
class AnnotationFactory {
    static createGlobals(e1) {
        return Promise.all([
            e1.ensureCatalog("acroForm"),
            e1.ensureDoc("xfaDatasets"),
            e1.ensureCatalog("structTreeRoot"),
            e1.ensureCatalog("baseUrl"),
            e1.ensureCatalog("attachments"),
            e1.ensureCatalog("globalColorSpaceCache")
        ]).then(([t, a, r, i, n, s])=>({
                pdfManager: e1,
                acroForm: t instanceof Dict ? t : Dict.empty,
                xfaDatasets: a,
                structTreeRoot: r,
                baseUrl: i,
                attachments: n,
                globalColorSpaceCache: s
            }), (e1)=>{
            warn(`createGlobals: "${e1}".`);
            return null;
        });
    }
    static async create(e1, t, a, r, i, n, s, o) {
        const c = i ? await this._getPageIndex(e1, t, a.pdfManager) : null;
        return a.pdfManager.ensure(this, "_create", [
            e1,
            t,
            a,
            r,
            i,
            n,
            s,
            c,
            o
        ]);
    }
    static _create(e1, t, a, r, i = !1, n = null, s = null, o = null, c = null) {
        const l = e1.fetchIfRef(t);
        if (!(l instanceof Dict)) return;
        let h = l.get("Subtype");
        h = h instanceof Name ? h.name : null;
        if (s && !s.has(F[h.toUpperCase()])) return null;
        const { acroForm: u, pdfManager: d } = a, f = t instanceof Ref ? t.toString() : `annot_${r.createObjId()}`, g = {
            xref: e1,
            ref: t,
            dict: l,
            subtype: h,
            id: f,
            annotationGlobals: a,
            collectFields: i,
            orphanFields: n,
            needAppearances: !i && !0 === u.get("NeedAppearances"),
            pageIndex: o,
            evaluatorOptions: d.evaluatorOptions,
            pageRef: c
        };
        switch(h){
            case "Link":
                return new LinkAnnotation(g);
            case "Text":
                return new TextAnnotation(g);
            case "Widget":
                let e2 = getInheritableProperty({
                    dict: l,
                    key: "FT"
                });
                e2 = e2 instanceof Name ? e2.name : null;
                switch(e2){
                    case "Tx":
                        return new TextWidgetAnnotation(g);
                    case "Btn":
                        return new ButtonWidgetAnnotation(g);
                    case "Ch":
                        return new ChoiceWidgetAnnotation(g);
                    case "Sig":
                        return new SignatureWidgetAnnotation(g);
                }
                warn(`Unimplemented widget field type "${e2}", falling back to base field type.`);
                return new WidgetAnnotation(g);
            case "Popup":
                return new PopupAnnotation(g);
            case "FreeText":
                return new FreeTextAnnotation(g);
            case "Line":
                return new LineAnnotation(g);
            case "Square":
                return new SquareAnnotation(g);
            case "Circle":
                return new CircleAnnotation(g);
            case "PolyLine":
                return new PolylineAnnotation(g);
            case "Polygon":
                return new PolygonAnnotation(g);
            case "Caret":
                return new CaretAnnotation(g);
            case "Ink":
                return new InkAnnotation(g);
            case "Highlight":
                return new HighlightAnnotation(g);
            case "Underline":
                return new UnderlineAnnotation(g);
            case "Squiggly":
                return new SquigglyAnnotation(g);
            case "StrikeOut":
                return new StrikeOutAnnotation(g);
            case "Stamp":
                return new StampAnnotation(g);
            case "FileAttachment":
                return new FileAttachmentAnnotation(g);
            default:
                i || warn(h ? `Unimplemented annotation type "${h}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
                return new Annotation(g);
        }
    }
    static async _getPageIndex(e1, t, a) {
        try {
            const r = await e1.fetchIfRefAsync(t);
            if (!(r instanceof Dict)) return -1;
            const i = r.getRaw("P");
            if (i instanceof Ref) try {
                return await a.ensureCatalog("getPageIndex", [
                    i
                ]);
            } catch (e1) {
                info(`_getPageIndex -- not a valid page reference: "${e1}".`);
            }
            if (r.has("Kids")) return -1;
            const n = await a.ensureDoc("numPages");
            for(let e1 = 0; e1 < n; e1++){
                const r = await a.getPage(e1), i = await a.ensure(r, "annotations");
                for (const a of i)if (a instanceof Ref && isRefsEqual(a, t)) return e1;
            }
        } catch (e1) {
            warn(`_getPageIndex: "${e1}".`);
        }
        return -1;
    }
    static generateImages(e1, t, a) {
        if (!a) {
            warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
            return null;
        }
        let r;
        for (const { bitmapId: a, bitmap: i } of e1)if (i) {
            r ||= new Map;
            r.set(a, StampAnnotation.createImage(i, t));
        }
        return r;
    }
    static async saveNewAnnotations(e1, t, a, r, i) {
        const n = e1.xref;
        let s;
        const o = [], { isOffscreenCanvasSupported: c } = e1.options;
        for (const l of a)if (!l.deleted) switch(l.annotationType){
            case g:
                if (!s) {
                    const e1 = new Dict(n);
                    e1.setIfName("BaseFont", "Helvetica");
                    e1.setIfName("Type", "Font");
                    e1.setIfName("Subtype", "Type1");
                    e1.setIfName("Encoding", "WinAnsiEncoding");
                    s = n.getNewTemporaryRef();
                    i.put(s, {
                        data: e1
                    });
                }
                o.push(FreeTextAnnotation.createNewAnnotation(n, l, i, {
                    evaluator: e1,
                    task: t,
                    baseFontRef: s
                }));
                break;
            case p:
                l.quadPoints ? o.push(HighlightAnnotation.createNewAnnotation(n, l, i)) : o.push(InkAnnotation.createNewAnnotation(n, l, i));
                break;
            case b:
                o.push(InkAnnotation.createNewAnnotation(n, l, i));
                break;
            case m:
                const a = c ? await r?.get(l.bitmapId) : null;
                if (a?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = a;
                    if (t) {
                        const a = n.getNewTemporaryRef();
                        i.put(a, {
                            data: t
                        });
                        e1.dict.set("SMask", a);
                    }
                    const r = a.imageRef = n.getNewTemporaryRef();
                    i.put(r, {
                        data: e1
                    });
                    a.imageStream = a.smaskStream = null;
                }
                o.push(StampAnnotation.createNewAnnotation(n, l, i, {
                    image: a
                }));
                break;
            case y:
                o.push(StampAnnotation.createNewAnnotation(n, l, i, {}));
        }
        return {
            annotations: (await Promise.all(o)).flat()
        };
    }
    static async printNewAnnotations(e1, t, a, r, i) {
        if (!r) return null;
        const { options: n, xref: s } = t, o = [];
        for (const c of r)if (!c.deleted) switch(c.annotationType){
            case g:
                o.push(FreeTextAnnotation.createNewPrintAnnotation(e1, s, c, {
                    evaluator: t,
                    task: a,
                    evaluatorOptions: n
                }));
                break;
            case p:
                c.quadPoints ? o.push(HighlightAnnotation.createNewPrintAnnotation(e1, s, c, {
                    evaluatorOptions: n
                })) : o.push(InkAnnotation.createNewPrintAnnotation(e1, s, c, {
                    evaluatorOptions: n
                }));
                break;
            case b:
                o.push(InkAnnotation.createNewPrintAnnotation(e1, s, c, {
                    evaluatorOptions: n
                }));
                break;
            case m:
                const r = n.isOffscreenCanvasSupported ? await i?.get(c.bitmapId) : null;
                if (r?.imageStream) {
                    const { imageStream: e1, smaskStream: t } = r;
                    t && e1.dict.set("SMask", t);
                    r.imageRef = new JpegStream(e1, e1.length);
                    r.imageStream = r.smaskStream = null;
                }
                o.push(StampAnnotation.createNewPrintAnnotation(e1, s, c, {
                    image: r,
                    evaluatorOptions: n
                }));
                break;
            case y:
                o.push(StampAnnotation.createNewPrintAnnotation(e1, s, c, {
                    evaluatorOptions: n
                }));
        }
        return Promise.all(o);
    }
}
function getRgbColor(e1, t = new Uint8ClampedArray(3)) {
    if (!Array.isArray(e1)) return t;
    const a = t || new Uint8ClampedArray(3);
    switch(e1.length){
        case 0:
            return null;
        case 1:
            ColorSpaceUtils.gray.getRgbItem(e1, 0, a, 0);
            return a;
        case 3:
            ColorSpaceUtils.rgb.getRgbItem(e1, 0, a, 0);
            return a;
        case 4:
            ColorSpaceUtils.cmyk.getRgbItem(e1, 0, a, 0);
            return a;
        default:
            return t;
    }
}
function getPdfColorArray(e1, t = null) {
    return e1 && Array.from(e1, (e1)=>e1 / 255) || t;
}
function getQuadPoints(e1, t) {
    const a = e1.getArray("QuadPoints");
    if (!isNumberArray(a, null) || 0 === a.length || a.length % 8 > 0) return null;
    const r = new Float32Array(a.length);
    for(let e1 = 0, i = a.length; e1 < i; e1 += 8){
        const [i, n, s, o, c, l, h, u] = a.slice(e1, e1 + 8), d = Math.min(i, s, c, h), f = Math.max(i, s, c, h), g = Math.min(n, o, l, u), p = Math.max(n, o, l, u);
        if (null !== t && (d < t[0] || f > t[2] || g < t[1] || p > t[3])) return null;
        r.set([
            d,
            p,
            f,
            p,
            d,
            g,
            f,
            g
        ], e1);
    }
    return r;
}
function getTransformMatrix(e1, t, a) {
    const r = new Float32Array([
        1 / 0,
        1 / 0,
        -1 / 0,
        -1 / 0
    ]);
    Util.axialAlignedBoundingBox(t, a, r);
    const [i, n, s, o] = r;
    if (i === s || n === o) return [
        1,
        0,
        0,
        1,
        e1[0],
        e1[1]
    ];
    const c = (e1[2] - e1[0]) / (s - i), l = (e1[3] - e1[1]) / (o - n);
    return [
        c,
        0,
        0,
        l,
        e1[0] - i * c,
        e1[1] - n * l
    ];
}
class Annotation {
    constructor(e1){
        const { dict: t, xref: a, annotationGlobals: r, ref: i, orphanFields: n } = e1, s = n?.get(i);
        s && t.set("Parent", s);
        this.setTitle(t.get("T"));
        this.setContents(t.get("Contents"));
        this.setModificationDate(t.get("M"));
        this.setFlags(t.get("F"));
        this.setRectangle(t.getArray("Rect"));
        this.setColor(t.getArray("C"));
        this.setBorderStyle(t);
        this.setAppearance(t);
        this.setOptionalContent(t);
        const o = t.get("MK");
        this.setBorderAndBackgroundColors(o);
        this.setRotation(o, t);
        this.ref = e1.ref instanceof Ref ? e1.ref : null;
        this._streams = [];
        this.appearance && this._streams.push(this.appearance);
        const c = !!(this.flags & L), l = !!(this.flags & j);
        this.data = {
            annotationFlags: this.flags,
            borderStyle: this.borderStyle,
            color: this.color,
            backgroundColor: this.backgroundColor,
            borderColor: this.borderColor,
            rotation: this.rotation,
            contentsObj: this._contents,
            hasAppearance: !!this.appearance,
            id: e1.id,
            modificationDate: this.modificationDate,
            rect: this.rectangle,
            subtype: e1.subtype,
            hasOwnCanvas: !1,
            noRotate: !!(this.flags & N),
            noHTML: c && l,
            isEditable: !1,
            structParent: -1
        };
        if (r.structTreeRoot) {
            let a = t.get("StructParent");
            this.data.structParent = a = Number.isInteger(a) && a >= 0 ? a : -1;
            r.structTreeRoot.addAnnotationIdToPage(e1.pageRef, a);
        }
        if (e1.collectFields) {
            const r = t.get("Kids");
            if (Array.isArray(r)) {
                const e1 = [];
                for (const t of r)t instanceof Ref && e1.push(t.toString());
                0 !== e1.length && (this.data.kidIds = e1);
            }
            this.data.actions = collectActions(a, t, te);
            this.data.fieldName = this._constructFieldName(t);
            this.data.pageIndex = e1.pageIndex;
        }
        const h = t.get("IT");
        h instanceof Name && (this.data.it = h.name);
        this._isOffscreenCanvasSupported = e1.evaluatorOptions.isOffscreenCanvasSupported;
        this._fallbackFontDict = null;
        this._needAppearances = !1;
    }
    _hasFlag(e1, t) {
        return !!(e1 & t);
    }
    _buildFlags(e1, t) {
        let { flags: a } = this;
        if (void 0 === e1) {
            if (void 0 === t) return;
            return t ? a & ~R : a & ~D | R;
        }
        if (e1) {
            a |= R;
            return t ? a & ~E | D : a & ~D | E;
        }
        a &= ~(D | E);
        return t ? a & ~R : a | R;
    }
    _isViewable(e1) {
        return !this._hasFlag(e1, M) && !this._hasFlag(e1, E);
    }
    _isPrintable(e1) {
        return this._hasFlag(e1, R) && !this._hasFlag(e1, D) && !this._hasFlag(e1, M);
    }
    mustBeViewed(e1, t) {
        const a = e1?.get(this.data.id)?.noView;
        return void 0 !== a ? !a : this.viewable && !this._hasFlag(this.flags, D);
    }
    mustBePrinted(e1) {
        const t = e1?.get(this.data.id)?.noPrint;
        return void 0 !== t ? !t : this.printable;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        return e1 ? !this.data.isEditable : !t?.has(this.data.id);
    }
    get viewable() {
        return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
    }
    get printable() {
        return null !== this.data.quadPoints && 0 !== this.flags && this._isPrintable(this.flags);
    }
    _parseStringHelper(e1) {
        const t = "string" == typeof e1 ? stringToPDFString(e1) : "";
        return {
            str: t,
            dir: t && "rtl" === bidi(t).dir ? "rtl" : "ltr"
        };
    }
    setDefaultAppearance(e1) {
        const { dict: t, annotationGlobals: a } = e1, r = getInheritableProperty({
            dict: t,
            key: "DA"
        }) || a.acroForm.get("DA");
        this._defaultAppearance = "string" == typeof r ? r : "";
        this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
    }
    setTitle(e1) {
        this._title = this._parseStringHelper(e1);
    }
    setContents(e1) {
        this._contents = this._parseStringHelper(e1);
    }
    setModificationDate(e1) {
        this.modificationDate = "string" == typeof e1 ? e1 : null;
    }
    setFlags(e1) {
        this.flags = Number.isInteger(e1) && e1 > 0 ? e1 : 0;
        this.flags & M && "Annotation" !== this.constructor.name && (this.flags ^= M);
    }
    hasFlag(e1) {
        return this._hasFlag(this.flags, e1);
    }
    setRectangle(e1) {
        this.rectangle = lookupNormalRect(e1, [
            0,
            0,
            0,
            0
        ]);
    }
    setColor(e1) {
        this.color = getRgbColor(e1);
    }
    setLineEndings(e1) {
        this.lineEndings = [
            "None",
            "None"
        ];
        if (Array.isArray(e1) && 2 === e1.length) for(let t = 0; t < 2; t++){
            const a = e1[t];
            if (a instanceof Name) switch(a.name){
                case "None":
                    continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                    this.lineEndings[t] = a.name;
                    continue;
            }
            warn(`Ignoring invalid lineEnding: ${a}`);
        }
    }
    setRotation(e1, t) {
        this.rotation = 0;
        let a = e1 instanceof Dict ? e1.get("R") || 0 : t.get("Rotate") || 0;
        if (Number.isInteger(a) && 0 !== a) {
            a %= 360;
            a < 0 && (a += 360);
            a % 90 == 0 && (this.rotation = a);
        }
    }
    setBorderAndBackgroundColors(e1) {
        if (e1 instanceof Dict) {
            this.borderColor = getRgbColor(e1.getArray("BC"), null);
            this.backgroundColor = getRgbColor(e1.getArray("BG"), null);
        } else this.borderColor = this.backgroundColor = null;
    }
    setBorderStyle(e1) {
        this.borderStyle = new AnnotationBorderStyle;
        if (e1 instanceof Dict) if (e1.has("BS")) {
            const t = e1.get("BS");
            if (t instanceof Dict) {
                const e1 = t.get("Type");
                if (!e1 || isName(e1, "Border")) {
                    this.borderStyle.setWidth(t.get("W"), this.rectangle);
                    this.borderStyle.setStyle(t.get("S"));
                    this.borderStyle.setDashArray(t.getArray("D"));
                }
            }
        } else if (e1.has("Border")) {
            const t = e1.getArray("Border");
            if (Array.isArray(t) && t.length >= 3) {
                this.borderStyle.setHorizontalCornerRadius(t[0]);
                this.borderStyle.setVerticalCornerRadius(t[1]);
                this.borderStyle.setWidth(t[2], this.rectangle);
                4 === t.length && this.borderStyle.setDashArray(t[3], !0);
            }
        } else this.borderStyle.setWidth(0);
    }
    setAppearance(e1) {
        this.appearance = null;
        const t = e1.get("AP");
        if (!(t instanceof Dict)) return;
        const a = t.get("N");
        if (a instanceof BaseStream) {
            this.appearance = a;
            return;
        }
        if (!(a instanceof Dict)) return;
        const r = e1.get("AS");
        if (!(r instanceof Name && a.has(r.name))) return;
        const i = a.get(r.name);
        i instanceof BaseStream && (this.appearance = i);
    }
    setOptionalContent(e1) {
        this.oc = null;
        const t = e1.get("OC");
        t instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t instanceof Dict && (this.oc = t);
    }
    async loadResources(e1, t) {
        const a = await t.dict.getAsync("Resources");
        a && await ObjectLoader.load(a, e1, a.xref);
        return a;
    }
    async getOperatorList(e1, t, a, r) {
        const { hasOwnCanvas: i, id: n, rect: o } = this.data;
        let c = this.appearance;
        const l = !!(i && a & s);
        if (l && (0 === this.width || 0 === this.height)) {
            this.data.hasOwnCanvas = !1;
            return {
                opList: new OperatorList,
                separateForm: !1,
                separateCanvas: !1
            };
        }
        if (!c) {
            if (!l) return {
                opList: new OperatorList,
                separateForm: !1,
                separateCanvas: !1
            };
            c = new StringStream("");
            c.dict = new Dict;
        }
        const h = c.dict, u = await this.loadResources(ha, c), d = lookupRect(h.getArray("BBox"), [
            0,
            0,
            1,
            1
        ]), f = lookupMatrix(h.getArray("Matrix"), la), g = getTransformMatrix(o, d, f), p = new OperatorList;
        let m;
        this.oc && (m = await e1.parseMarkedContentProps(this.oc, null));
        void 0 !== m && p.addOp(St, [
            "OC",
            m
        ]);
        p.addOp(Ot, [
            n,
            o,
            g,
            f,
            l
        ]);
        await e1.getOperatorList({
            stream: c,
            task: t,
            resources: u,
            operatorList: p,
            fallbackFontDict: this._fallbackFontDict
        });
        p.addOp(Mt, []);
        void 0 !== m && p.addOp(At, []);
        this.reset();
        return {
            opList: p,
            separateForm: !1,
            separateCanvas: l
        };
    }
    async save(e1, t, a, r) {
        return null;
    }
    get overlaysTextContent() {
        return !1;
    }
    get hasTextContent() {
        return !1;
    }
    async extractTextContent(e1, t, a) {
        if (!this.appearance) return;
        const r = await this.loadResources(ua, this.appearance), i = [], n = [];
        let s = null;
        const o = {
            desiredSize: Math.Infinity,
            ready: !0,
            enqueue (e1, t) {
                for (const t of e1.items)if (void 0 !== t.str) {
                    s ||= t.transform.slice(-2);
                    n.push(t.str);
                    if (t.hasEOL) {
                        i.push(n.join("").trimEnd());
                        n.length = 0;
                    }
                }
            }
        };
        await e1.getTextContent({
            stream: this.appearance,
            task: t,
            resources: r,
            includeMarkedContent: !0,
            keepWhiteSpace: !0,
            sink: o,
            viewBox: a
        });
        this.reset();
        n.length && i.push(n.join("").trimEnd());
        if (i.length > 1 || i[0]) {
            const e1 = this.appearance.dict, t = lookupRect(e1.getArray("BBox"), null), a = lookupMatrix(e1.getArray("Matrix"), null);
            this.data.textPosition = this._transformPoint(s, t, a);
            this.data.textContent = i;
        }
    }
    _transformPoint(e1, t, a) {
        const { rect: r } = this.data;
        t ||= [
            0,
            0,
            1,
            1
        ];
        a ||= [
            1,
            0,
            0,
            1,
            0,
            0
        ];
        const i = getTransformMatrix(r, t, a);
        i[4] -= r[0];
        i[5] -= r[1];
        const n = e1.slice();
        Util.applyTransform(n, i);
        Util.applyTransform(n, a);
        return n;
    }
    getFieldObject() {
        return this.data.kidIds ? {
            id: this.data.id,
            actions: this.data.actions,
            name: this.data.fieldName,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            type: "",
            kidIds: this.data.kidIds,
            page: this.data.pageIndex,
            rotation: this.rotation
        } : null;
    }
    reset() {
        for (const e1 of this._streams)e1.reset();
    }
    _constructFieldName(e1) {
        if (!e1.has("T") && !e1.has("Parent")) {
            warn("Unknown field name, falling back to empty field name.");
            return "";
        }
        if (!e1.has("Parent")) return stringToPDFString(e1.get("T"));
        const t = [];
        e1.has("T") && t.unshift(stringToPDFString(e1.get("T")));
        let a = e1;
        const r = new RefSet;
        e1.objId && r.put(e1.objId);
        for(; a.has("Parent");){
            a = a.get("Parent");
            if (!(a instanceof Dict) || a.objId && r.has(a.objId)) break;
            a.objId && r.put(a.objId);
            a.has("T") && t.unshift(stringToPDFString(a.get("T")));
        }
        return t.join(".");
    }
    get width() {
        return this.data.rect[2] - this.data.rect[0];
    }
    get height() {
        return this.data.rect[3] - this.data.rect[1];
    }
}
class AnnotationBorderStyle {
    constructor(){
        this.width = 1;
        this.rawWidth = 1;
        this.style = J;
        this.dashArray = [
            3
        ];
        this.horizontalCornerRadius = 0;
        this.verticalCornerRadius = 0;
    }
    setWidth(e1, t = [
        0,
        0,
        0,
        0
    ]) {
        if (e1 instanceof Name) this.width = 0;
        else if ("number" == typeof e1) {
            if (e1 > 0) {
                this.rawWidth = e1;
                const a = (t[2] - t[0]) / 2, r = (t[3] - t[1]) / 2;
                if (a > 0 && r > 0 && (e1 > a || e1 > r)) {
                    warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e1}`);
                    e1 = 1;
                }
            }
            this.width = e1;
        }
    }
    setStyle(e1) {
        if (e1 instanceof Name) switch(e1.name){
            case "S":
                this.style = J;
                break;
            case "D":
                this.style = Y;
                break;
            case "B":
                this.style = Z;
                break;
            case "I":
                this.style = Q;
                break;
            case "U":
                this.style = ee;
        }
    }
    setDashArray(e1, t = !1) {
        if (Array.isArray(e1)) {
            let a = !0, r = !0;
            for (const t of e1){
                if (!(+t >= 0)) {
                    a = !1;
                    break;
                }
                t > 0 && (r = !1);
            }
            if (0 === e1.length || a && !r) {
                this.dashArray = e1;
                t && this.setStyle(Name.get("D"));
            } else this.width = 0;
        } else e1 && (this.width = 0);
    }
    setHorizontalCornerRadius(e1) {
        Number.isInteger(e1) && (this.horizontalCornerRadius = e1);
    }
    setVerticalCornerRadius(e1) {
        Number.isInteger(e1) && (this.verticalCornerRadius = e1);
    }
}
class MarkupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        if (t.has("IRT")) {
            const e1 = t.getRaw("IRT");
            this.data.inReplyTo = e1 instanceof Ref ? e1.toString() : null;
            const a = t.get("RT");
            this.data.replyType = a instanceof Name ? a.name : O;
        }
        let a = null;
        if (this.data.replyType === T) {
            const e1 = t.get("IRT");
            this.setTitle(e1.get("T"));
            this.data.titleObj = this._title;
            this.setContents(e1.get("Contents"));
            this.data.contentsObj = this._contents;
            if (e1.has("CreationDate")) {
                this.setCreationDate(e1.get("CreationDate"));
                this.data.creationDate = this.creationDate;
            } else this.data.creationDate = null;
            if (e1.has("M")) {
                this.setModificationDate(e1.get("M"));
                this.data.modificationDate = this.modificationDate;
            } else this.data.modificationDate = null;
            a = e1.getRaw("Popup");
            if (e1.has("C")) {
                this.setColor(e1.getArray("C"));
                this.data.color = this.color;
            } else this.data.color = null;
        } else {
            this.data.titleObj = this._title;
            this.setCreationDate(t.get("CreationDate"));
            this.data.creationDate = this.creationDate;
            a = t.getRaw("Popup");
            t.has("C") || (this.data.color = null);
        }
        this.data.popupRef = a instanceof Ref ? a.toString() : null;
        t.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t.get("RC")));
    }
    setCreationDate(e1) {
        this.creationDate = "string" == typeof e1 ? e1 : null;
    }
    _setDefaultAppearance({ xref: e1, extra: t, strokeColor: a, fillColor: r, blendMode: i, strokeAlpha: n, fillAlpha: s, pointsCallback: o }) {
        const c = this.data.rect = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
        ], l = [
            "q"
        ];
        t && l.push(t);
        a && l.push(`${a[0]} ${a[1]} ${a[2]} RG`);
        r && l.push(`${r[0]} ${r[1]} ${r[2]} rg`);
        const h = this.data.quadPoints || Float32Array.from([
            this.rectangle[0],
            this.rectangle[3],
            this.rectangle[2],
            this.rectangle[3],
            this.rectangle[0],
            this.rectangle[1],
            this.rectangle[2],
            this.rectangle[1]
        ]);
        for(let e1 = 0, t = h.length; e1 < t; e1 += 8){
            const t = o(l, h.subarray(e1, e1 + 8));
            Util.rectBoundingBox(...t, c);
        }
        l.push("Q");
        const u = new Dict(e1), d = new Dict(e1);
        d.setIfName("Subtype", "Form");
        const f = new StringStream(l.join(" "));
        f.dict = d;
        u.set("Fm0", f);
        const g = new Dict(e1);
        i && g.setIfName("BM", i);
        g.setIfNumber("CA", n);
        g.setIfNumber("ca", s);
        const p = new Dict(e1);
        p.set("GS0", g);
        const m = new Dict(e1);
        m.set("ExtGState", p);
        m.set("XObject", u);
        const b = new Dict(e1);
        b.set("Resources", m);
        b.set("BBox", c);
        this.appearance = new StringStream("/GS0 gs /Fm0 Do");
        this.appearance.dict = b;
        this._streams.push(this.appearance, f);
    }
    static async createNewAnnotation(e1, t, a, r) {
        const i = t.ref ||= e1.getNewTemporaryRef(), n = await this.createNewAppearanceStream(t, e1, r);
        let s;
        if (n) {
            const r = e1.getNewTemporaryRef();
            s = this.createNewDict(t, e1, {
                apRef: r
            });
            a.put(r, {
                data: n
            });
        } else s = this.createNewDict(t, e1, {});
        Number.isInteger(t.parentTreeId) && s.set("StructParent", t.parentTreeId);
        a.put(i, {
            data: s
        });
        const o = {
            ref: i
        };
        if (t.popup) {
            const r = t.popup;
            if (r.deleted) {
                s.delete("Popup");
                s.delete("Contents");
                s.delete("RC");
                return o;
            }
            const n = r.ref ||= e1.getNewTemporaryRef();
            r.parent = i;
            const c = PopupAnnotation.createNewDict(r, e1);
            a.put(n, {
                data: c
            });
            s.setIfDefined("Contents", stringToAsciiOrUTF16BE(r.contents));
            s.set("Popup", n);
            return [
                o,
                {
                    ref: n
                }
            ];
        }
        return o;
    }
    static async createNewPrintAnnotation(e1, t, a, r) {
        const i = await this.createNewAppearanceStream(a, t, r), n = this.createNewDict(a, t, i ? {
            ap: i
        } : {}), s = new this.prototype.constructor({
            dict: n,
            xref: t,
            annotationGlobals: e1,
            evaluatorOptions: r.evaluatorOptions
        });
        a.ref && (s.ref = s.refToReplace = a.ref);
        return s;
    }
}
class WidgetAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a, annotationGlobals: r } = e1, i = this.data;
        this._needAppearances = e1.needAppearances;
        i.annotationType = F.WIDGET;
        void 0 === i.fieldName && (i.fieldName = this._constructFieldName(t));
        void 0 === i.actions && (i.actions = collectActions(a, t, te));
        let n = getInheritableProperty({
            dict: t,
            key: "V",
            getArray: !0
        });
        i.fieldValue = this._decodeFormValue(n);
        const s = getInheritableProperty({
            dict: t,
            key: "DV",
            getArray: !0
        });
        i.defaultFieldValue = this._decodeFormValue(s);
        if (void 0 === n && r.xfaDatasets) {
            const e1 = this._title.str;
            if (e1) {
                this._hasValueFromXFA = !0;
                i.fieldValue = n = r.xfaDatasets.getValue(e1);
            }
        }
        void 0 === n && null !== i.defaultFieldValue && (i.fieldValue = i.defaultFieldValue);
        i.alternativeText = stringToPDFString(t.get("TU") || "");
        this.setDefaultAppearance(e1);
        i.hasAppearance ||= this._needAppearances && void 0 !== i.fieldValue && null !== i.fieldValue;
        const o = getInheritableProperty({
            dict: t,
            key: "FT"
        });
        i.fieldType = o instanceof Name ? o.name : null;
        const c = getInheritableProperty({
            dict: t,
            key: "DR"
        }), l = r.acroForm.get("DR"), h = this.appearance?.dict.get("Resources");
        this._fieldResources = {
            localResources: c,
            acroFormResources: l,
            appearanceResources: h,
            mergedResources: Dict.merge({
                xref: a,
                dictArray: [
                    c,
                    h,
                    l
                ],
                mergeSubDicts: !0
            })
        };
        i.fieldFlags = getInheritableProperty({
            dict: t,
            key: "Ff"
        });
        (!Number.isInteger(i.fieldFlags) || i.fieldFlags < 0) && (i.fieldFlags = 0);
        i.password = this.hasFieldFlag(q);
        i.readOnly = this.hasFieldFlag(_);
        i.required = this.hasFieldFlag(U);
        i.hidden = this._hasFlag(i.annotationFlags, D) || this._hasFlag(i.annotationFlags, E);
    }
    _decodeFormValue(e1) {
        return Array.isArray(e1) ? e1.filter((e1)=>"string" == typeof e1).map((e1)=>stringToPDFString(e1)) : e1 instanceof Name ? stringToPDFString(e1.name) : "string" == typeof e1 ? stringToPDFString(e1) : null;
    }
    hasFieldFlag(e1) {
        return !!(this.data.fieldFlags & e1);
    }
    _isViewable(e1) {
        return !0;
    }
    mustBeViewed(e1, t) {
        return t ? this.viewable : super.mustBeViewed(e1, t) && !this._hasFlag(this.flags, E);
    }
    getRotationMatrix(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        void 0 === t && (t = this.rotation);
        return 0 === t ? la : getRotationMatrix(t, this.width, this.height);
    }
    getBorderAndBackgroundAppearances(e1) {
        let t = e1?.get(this.data.id)?.rotation;
        void 0 === t && (t = this.rotation);
        if (!this.backgroundColor && !this.borderColor) return "";
        const a = 0 === t || 180 === t ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
        let r = "";
        this.backgroundColor && (r = `${getPdfColor(this.backgroundColor, !0)} ${a} f `);
        if (this.borderColor) {
            r += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, !1)} ${a} S `;
        }
        return r;
    }
    async getOperatorList(e1, t, a, r) {
        if (a & l && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return {
            opList: new OperatorList,
            separateForm: !0,
            separateCanvas: !1
        };
        if (!this._hasText) return super.getOperatorList(e1, t, a, r);
        const i = await this._getAppearance(e1, t, a, r);
        if (this.appearance && null === i) return super.getOperatorList(e1, t, a, r);
        const n = new OperatorList;
        if (!this._defaultAppearance || null === i) return {
            opList: n,
            separateForm: !1,
            separateCanvas: !1
        };
        const o = !!(this.data.hasOwnCanvas && a & s), c = [
            0,
            0,
            this.width,
            this.height
        ], h = getTransformMatrix(this.data.rect, c, [
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        let u;
        this.oc && (u = await e1.parseMarkedContentProps(this.oc, null));
        void 0 !== u && n.addOp(St, [
            "OC",
            u
        ]);
        n.addOp(Ot, [
            this.data.id,
            this.data.rect,
            h,
            this.getRotationMatrix(r),
            o
        ]);
        const d = new StringStream(i);
        await e1.getOperatorList({
            stream: d,
            task: t,
            resources: this._fieldResources.mergedResources,
            operatorList: n
        });
        n.addOp(Mt, []);
        void 0 !== u && n.addOp(At, []);
        return {
            opList: n,
            separateForm: !1,
            separateCanvas: o
        };
    }
    _getMKDict(e1) {
        const t = new Dict(null);
        e1 && t.set("R", e1);
        t.setIfArray("BC", getPdfColorArray(this.borderColor));
        t.setIfArray("BG", getPdfColorArray(this.backgroundColor));
        return t.size > 0 ? t : null;
    }
    amendSavedDict(e1, t) {}
    setValue(e1, t, a, r) {
        const { dict: i, ref: n } = function getParentToUpdate(e1, t, a) {
            const r = new RefSet, i = e1, n = {
                dict: null,
                ref: null
            };
            for(; e1 instanceof Dict && !r.has(t);){
                r.put(t);
                if (e1.has("T")) break;
                if (!((t = e1.getRaw("Parent")) instanceof Ref)) return n;
                e1 = a.fetch(t);
            }
            if (e1 instanceof Dict && e1 !== i) {
                n.dict = e1;
                n.ref = t;
            }
            return n;
        }(e1, this.ref, a);
        if (i) {
            if (!r.has(n)) {
                const e1 = i.clone();
                e1.set("V", t);
                r.put(n, {
                    data: e1
                });
                return e1;
            }
        } else e1.set("V", t);
        return null;
    }
    async save(e1, t, a, r) {
        const i = a?.get(this.data.id), n = this._buildFlags(i?.noView, i?.noPrint);
        let s = i?.value, o = i?.rotation;
        if (s === this.data.fieldValue || void 0 === s) {
            if (!this._hasValueFromXFA && void 0 === o && void 0 === n) return;
            s ||= this.data.fieldValue;
        }
        if (void 0 === o && !this._hasValueFromXFA && Array.isArray(s) && Array.isArray(this.data.fieldValue) && isArrayEqual(s, this.data.fieldValue) && void 0 === n) return;
        void 0 === o && (o = this.rotation);
        let l = null;
        if (!this._needAppearances) {
            l = await this._getAppearance(e1, t, c, a);
            if (null === l && void 0 === n) return;
        }
        let h = !1;
        if (l?.needAppearances) {
            h = !0;
            l = null;
        }
        const { xref: u } = e1, d = u.fetchIfRef(this.ref);
        if (!(d instanceof Dict)) return;
        const f = new Dict(u);
        for (const e1 of d.getKeys())"AP" !== e1 && f.set(e1, d.getRaw(e1));
        if (void 0 !== n) {
            f.set("F", n);
            if (null === l && !h) {
                const e1 = d.getRaw("AP");
                e1 && f.set("AP", e1);
            }
        }
        const g = {
            path: this.data.fieldName,
            value: s
        }, p = this.setValue(f, Array.isArray(s) ? s.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(s), u, r);
        this.amendSavedDict(a, p || f);
        const m = this._getMKDict(o);
        m && f.set("MK", m);
        r.put(this.ref, {
            data: f,
            xfa: g,
            needAppearances: h
        });
        if (null !== l) {
            const e1 = u.getNewTemporaryRef(), t = new Dict(u);
            f.set("AP", t);
            t.set("N", e1);
            const i = this._getSaveFieldResources(u), n = new StringStream(l), s = n.dict = new Dict(u);
            s.setIfName("Subtype", "Form");
            s.set("Resources", i);
            const c = o % 180 == 0 ? [
                0,
                0,
                this.width,
                this.height
            ] : [
                0,
                0,
                this.height,
                this.width
            ];
            s.set("BBox", c);
            const h = this.getRotationMatrix(a);
            h !== la && s.set("Matrix", h);
            r.put(e1, {
                data: n,
                xfa: null,
                needAppearances: !1
            });
        }
        f.set("M", `D:${getModificationDate()}`);
    }
    async _getAppearance(e1, t, a, r) {
        if (this.data.password) return null;
        const n = r?.get(this.data.id);
        let s, o;
        if (n) {
            s = n.formattedValue || n.value;
            o = n.rotation;
        }
        if (void 0 === o && void 0 === s && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
        const l = this.getBorderAndBackgroundAppearances(r);
        if (void 0 === s) {
            s = this.data.fieldValue;
            if (!s) return `/Tx BMC q ${l}Q EMC`;
        }
        Array.isArray(s) && 1 === s.length && (s = s[0]);
        assert("string" == typeof s, "Expected `value` to be a string.");
        s = s.trimEnd();
        if (this.data.combo) {
            const e1 = this.data.options.find(({ exportValue: e1 })=>s === e1);
            s = e1?.displayValue || s;
        }
        if ("" === s) return `/Tx BMC q ${l}Q EMC`;
        void 0 === o && (o = this.rotation);
        let h, u = -1;
        if (this.data.multiLine) {
            h = s.split(/\r\n?|\n/).map((e1)=>e1.normalize("NFC"));
            u = h.length;
        } else h = [
            s.replace(/\r\n?|\n/, "").normalize("NFC")
        ];
        let { width: d, height: f } = this;
        90 !== o && 270 !== o || ([d, f] = [
            f,
            d
        ]);
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        let g, p, m, b = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        const y = [];
        let w = !1;
        for (const e1 of h){
            const t = b.encodeString(e1);
            t.length > 1 && (w = !0);
            y.push(t.join(""));
        }
        if (w && a & c) return {
            needAppearances: !0
        };
        if (w && this._isOffscreenCanvasSupported) {
            const a = this.data.comb ? "monospace" : "sans-serif", r = new FakeUnicodeFont(e1.xref, a), i = r.createFontResources(h.join("")), n = i.getRaw("Font");
            if (this._fieldResources.mergedResources.has("Font")) {
                const e1 = this._fieldResources.mergedResources.get("Font");
                for (const t of n.getKeys())e1.set(t, n.getRaw(t));
            } else this._fieldResources.mergedResources.set("Font", n);
            const o = r.fontName.name;
            b = await WidgetAnnotation._getFontData(e1, t, {
                fontName: o,
                fontSize: 0
            }, i);
            for(let e1 = 0, t = y.length; e1 < t; e1++)y[e1] = stringToUTF16String(h[e1]);
            const c = Object.assign(Object.create(null), this.data.defaultAppearanceData);
            this.data.defaultAppearanceData.fontSize = 0;
            this.data.defaultAppearanceData.fontName = o;
            [g, p, m] = this._computeFontSize(f - 2, d - 4, s, b, u);
            this.data.defaultAppearanceData = c;
        } else {
            this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
            [g, p, m] = this._computeFontSize(f - 2, d - 4, s, b, u);
        }
        let x = b.descent;
        x = isNaN(x) ? i * m : Math.max(i * m, Math.abs(x) * p);
        const S = Math.min(Math.floor((f - p) / 2), 1), k = this.data.textAlignment;
        if (this.data.multiLine) return this._getMultilineAppearance(g, y, b, p, d, f, k, 2, S, x, m, r);
        if (this.data.comb) return this._getCombAppearance(g, b, y[0], p, d, f, 2, S, x, m, r);
        const C = S + x;
        if (0 === k || k > 2) return `/Tx BMC q ${l}BT ` + g + ` 1 0 0 1 ${numberToString(2)} ${numberToString(C)} Tm (${escapeString(y[0])}) Tj ET Q EMC`;
        return `/Tx BMC q ${l}BT ` + g + ` 1 0 0 1 0 0 Tm ${this._renderText(y[0], b, p, d, k, {
            shift: 0
        }, 2, C)} ET Q EMC`;
    }
    static async _getFontData(e1, t, a, r) {
        const i = new OperatorList, n = {
            font: null,
            clone () {
                return this;
            }
        }, { fontName: s, fontSize: o } = a;
        await e1.handleSetFont(r, [
            s && Name.get(s),
            o
        ], null, i, t, n, null);
        return n.font;
    }
    _getTextWidth(e1, t) {
        return Math.sumPrecise(t.charsToGlyphs(e1).map((e1)=>e1.width)) / 1e3;
    }
    _computeFontSize(e1, t, r, i, n) {
        let { fontSize: s } = this.data.defaultAppearanceData, o = (s || 12) * a, c = Math.round(e1 / o);
        if (!s) {
            const roundWithTwoDigits = (e1)=>Math.floor(100 * e1) / 100;
            if (-1 === n) {
                const n = this._getTextWidth(r, i);
                s = roundWithTwoDigits(Math.min(e1 / a, t / n));
                c = 1;
            } else {
                const l = r.split(/\r\n?|\n/), h = [];
                for (const e1 of l){
                    const t = i.encodeString(e1).join(""), a = i.charsToGlyphs(t), r = i.getCharPositions(t);
                    h.push({
                        line: t,
                        glyphs: a,
                        positions: r
                    });
                }
                const isTooBig = (a)=>{
                    let r = 0;
                    for (const n of h){
                        r += this._splitLine(null, i, a, t, n).length * a;
                        if (r > e1) return !0;
                    }
                    return !1;
                };
                c = Math.max(c, n);
                for(;;){
                    o = e1 / c;
                    s = roundWithTwoDigits(o / a);
                    if (!isTooBig(s)) break;
                    c++;
                }
            }
            const { fontName: l, fontColor: h } = this.data.defaultAppearanceData;
            this._defaultAppearance = function createDefaultAppearance({ fontSize: e1, fontName: t, fontColor: a }) {
                return `/${escapePDFName(t)} ${e1} Tf ${getPdfColor(a, !0)}`;
            }({
                fontSize: s,
                fontName: l,
                fontColor: h
            });
        }
        return [
            this._defaultAppearance,
            s,
            e1 / c
        ];
    }
    _renderText(e1, t, a, r, i, n, s, o) {
        let c;
        if (1 === i) {
            c = (r - this._getTextWidth(e1, t) * a) / 2;
        } else if (2 === i) {
            c = r - this._getTextWidth(e1, t) * a - s;
        } else c = s;
        const l = numberToString(c - n.shift);
        n.shift = c;
        return `${l} ${o = numberToString(o)} Td (${escapeString(e1)}) Tj`;
    }
    _getSaveFieldResources(e1) {
        const { localResources: t, appearanceResources: a, acroFormResources: r } = this._fieldResources, i = this.data.defaultAppearanceData?.fontName;
        if (!i) return t || Dict.empty;
        for (const e1 of [
            t,
            a
        ])if (e1 instanceof Dict) {
            const t = e1.get("Font");
            if (t instanceof Dict && t.has(i)) return e1;
        }
        if (r instanceof Dict) {
            const a = r.get("Font");
            if (a instanceof Dict && a.has(i)) {
                const r = new Dict(e1);
                r.set(i, a.getRaw(i));
                const n = new Dict(e1);
                n.set("Font", r);
                return Dict.merge({
                    xref: e1,
                    dictArray: [
                        n,
                        t
                    ],
                    mergeSubDicts: !0
                });
            }
        }
        return t || Dict.empty;
    }
    getFieldObject() {
        return null;
    }
}
class TextWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        if (t.has("PMD")) {
            this.flags |= D;
            this.data.hidden = !0;
            warn("Barcodes are not supported");
        }
        this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
        this._hasText = !0;
        "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
        let a = getInheritableProperty({
            dict: t,
            key: "Q"
        });
        (!Number.isInteger(a) || a < 0 || a > 2) && (a = null);
        this.data.textAlignment = a;
        let r = getInheritableProperty({
            dict: t,
            key: "MaxLen"
        });
        (!Number.isInteger(r) || r < 0) && (r = 0);
        this.data.maxLen = r;
        this.data.multiLine = this.hasFieldFlag(X);
        this.data.comb = this.hasFieldFlag(K) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag($) && 0 !== this.data.maxLen;
        this.data.doNotScroll = this.hasFieldFlag(V);
        const { data: { actions: i } } = this;
        if (!i) return;
        const n = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
        let s = !1;
        (1 === i.Format?.length && 1 === i.Keystroke?.length && n.test(i.Format[0]) && n.test(i.Keystroke[0]) || 0 === i.Format?.length && 1 === i.Keystroke?.length && n.test(i.Keystroke[0]) || 0 === i.Keystroke?.length && 1 === i.Format?.length && n.test(i.Format[0])) && (s = !0);
        const o = [];
        i.Format && o.push(...i.Format);
        i.Keystroke && o.push(...i.Keystroke);
        if (s) {
            delete i.Keystroke;
            i.Format = o;
        }
        for (const e1 of o){
            const t = e1.match(n);
            if (!t) continue;
            const a = "Date" === t[1];
            let r = t[2];
            const i = parseInt(r, 10);
            isNaN(i) || Math.floor(Math.log10(i)) + 1 !== t[2].length || (r = (a ? wn : xn)[i] ?? r);
            this.data.datetimeFormat = r;
            if (!s) break;
            if (a) {
                if (/HH|MM|ss|h/.test(r)) {
                    this.data.datetimeType = "datetime-local";
                    this.data.timeStep = /ss/.test(r) ? 1 : 60;
                } else this.data.datetimeType = "date";
                break;
            }
            this.data.datetimeType = "time";
            this.data.timeStep = /ss/.test(r) ? 1 : 60;
            break;
        }
    }
    get hasTextContent() {
        return !!this.appearance && !this._needAppearances;
    }
    _getCombAppearance(e1, t, a, r, i, n, s, o, c, l, h) {
        const u = i / this.data.maxLen, d = this.getBorderAndBackgroundAppearances(h), f = [], g = t.getCharPositions(a);
        for (const [e1, t] of g)f.push(`(${escapeString(a.substring(e1, t))}) Tj`);
        const p = f.join(` ${numberToString(u)} 0 Td `);
        return `/Tx BMC q ${d}BT ` + e1 + ` 1 0 0 1 ${numberToString(s)} ${numberToString(o + c)} Tm ${p} ET Q EMC`;
    }
    _getMultilineAppearance(e1, t, a, r, i, n, s, o, c, l, h, u) {
        const d = [], f = i - 2 * o, g = {
            shift: 0
        };
        for(let e1 = 0, n = t.length; e1 < n; e1++){
            const n = t[e1], u = this._splitLine(n, a, r, f);
            for(let t = 0, n = u.length; t < n; t++){
                const n = u[t], f = 0 === e1 && 0 === t ? -c - (h - l) : -h;
                d.push(this._renderText(n, a, r, i, s, g, o, f));
            }
        }
        const p = this.getBorderAndBackgroundAppearances(u), m = d.join("\n");
        return `/Tx BMC q ${p}BT ` + e1 + ` 1 0 0 1 0 ${numberToString(n)} Tm ${m} ET Q EMC`;
    }
    _splitLine(e1, t, a, r, i = {}) {
        e1 = i.line || e1;
        const n = i.glyphs || t.charsToGlyphs(e1);
        if (n.length <= 1) return [
            e1
        ];
        const s = i.positions || t.getCharPositions(e1), o = a / 1e3, c = [];
        let l = -1, h = -1, u = -1, d = 0, f = 0;
        for(let t = 0, a = n.length; t < a; t++){
            const [a, i] = s[t], g = n[t], p = g.width * o;
            if (" " === g.unicode) if (f + p > r) {
                c.push(e1.substring(d, a));
                d = a;
                f = p;
                l = -1;
                u = -1;
            } else {
                f += p;
                l = a;
                h = i;
                u = t;
            }
            else if (f + p > r) if (-1 !== l) {
                c.push(e1.substring(d, h));
                d = h;
                t = u + 1;
                l = -1;
                f = 0;
            } else {
                c.push(e1.substring(d, a));
                d = a;
                f = p;
            }
            else f += p;
        }
        d < e1.length && c.push(e1.substring(d, e1.length));
        return c;
    }
    async extractTextContent(e1, t, a) {
        await super.extractTextContent(e1, t, a);
        const r = this.data.textContent;
        if (!r) return;
        const i = r.join("\n");
        if (i === this.data.fieldValue) return;
        const n = i.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e1, t)=>t ? `\\${t}` : "\\s+");
        new RegExp(`^\\s*${n}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: this.data.fieldValue,
            defaultValue: this.data.defaultFieldValue || "",
            multiline: this.data.multiLine,
            password: this.data.password,
            charLimit: this.data.maxLen,
            comb: this.data.comb,
            editable: !this.data.readOnly,
            hidden: this.data.hidden,
            name: this.data.fieldName,
            rect: this.data.rect,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            datetimeFormat: this.data.datetimeFormat,
            hasDatetimeHTML: !!this.data.datetimeType,
            type: "text"
        };
    }
}
class ButtonWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        this.checkedAppearance = null;
        this.uncheckedAppearance = null;
        const t = this.hasFieldFlag(H), a = this.hasFieldFlag(W);
        this.data.checkBox = !t && !a;
        this.data.radioButton = t && !a;
        this.data.pushButton = a;
        this.data.isTooltipOnly = !1;
        if (this.data.checkBox) this._processCheckBox(e1);
        else if (this.data.radioButton) this._processRadioButton(e1);
        else if (this.data.pushButton) {
            this.data.hasOwnCanvas = !0;
            this.data.noHTML = !1;
            this._processPushButton(e1);
        } else warn("Invalid field flags for button widget annotation");
    }
    async getOperatorList(e1, t, a, r) {
        if (this.data.pushButton) return super.getOperatorList(e1, t, a, !1, r);
        let i = null, n = null;
        if (r) {
            const e1 = r.get(this.data.id);
            i = e1 ? e1.value : null;
            n = e1 ? e1.rotation : null;
        }
        if (null === i && this.appearance) return super.getOperatorList(e1, t, a, r);
        null == i && (i = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
        const s = i ? this.checkedAppearance : this.uncheckedAppearance;
        if (s) {
            const i = this.appearance, o = lookupMatrix(s.dict.getArray("Matrix"), la);
            n && s.dict.set("Matrix", this.getRotationMatrix(r));
            this.appearance = s;
            const c = super.getOperatorList(e1, t, a, r);
            this.appearance = i;
            s.dict.set("Matrix", o);
            return c;
        }
        return {
            opList: new OperatorList,
            separateForm: !1,
            separateCanvas: !1
        };
    }
    async save(e1, t, a, r) {
        this.data.checkBox ? this._saveCheckbox(e1, t, a, r) : this.data.radioButton && this._saveRadioButton(e1, t, a, r);
    }
    async _saveCheckbox(e1, t, a, r) {
        if (!a) return;
        const i = a.get(this.data.id), n = this._buildFlags(i?.noView, i?.noPrint);
        let s = i?.rotation, o = i?.value;
        if (void 0 === s && void 0 === n) {
            if (void 0 === o) return;
            if (this.data.fieldValue === this.data.exportValue === o) return;
        }
        let c = e1.xref.fetchIfRef(this.ref);
        if (!(c instanceof Dict)) return;
        c = c.clone();
        void 0 === s && (s = this.rotation);
        void 0 === o && (o = this.data.fieldValue === this.data.exportValue);
        const l = {
            path: this.data.fieldName,
            value: o ? this.data.exportValue : ""
        }, h = Name.get(o ? this.data.exportValue : "Off");
        this.setValue(c, h, e1.xref, r);
        c.set("AS", h);
        c.set("M", `D:${getModificationDate()}`);
        void 0 !== n && c.set("F", n);
        const u = this._getMKDict(s);
        u && c.set("MK", u);
        r.put(this.ref, {
            data: c,
            xfa: l,
            needAppearances: !1
        });
    }
    async _saveRadioButton(e1, t, a, r) {
        if (!a) return;
        const i = a.get(this.data.id), n = this._buildFlags(i?.noView, i?.noPrint);
        let s = i?.rotation, o = i?.value;
        if (void 0 === s && void 0 === n) {
            if (void 0 === o) return;
            if (this.data.fieldValue === this.data.buttonValue === o) return;
        }
        let c = e1.xref.fetchIfRef(this.ref);
        if (!(c instanceof Dict)) return;
        c = c.clone();
        void 0 === o && (o = this.data.fieldValue === this.data.buttonValue);
        void 0 === s && (s = this.rotation);
        const l = {
            path: this.data.fieldName,
            value: o ? this.data.buttonValue : ""
        }, h = Name.get(o ? this.data.buttonValue : "Off");
        o && this.setValue(c, h, e1.xref, r);
        c.set("AS", h);
        c.set("M", `D:${getModificationDate()}`);
        void 0 !== n && c.set("F", n);
        const u = this._getMKDict(s);
        u && c.set("MK", u);
        r.put(this.ref, {
            data: c,
            xfa: l,
            needAppearances: !1
        });
    }
    _getDefaultCheckedAppearance(e1, t) {
        const { width: a, height: r } = this, i = [
            0,
            0,
            a,
            r
        ], n = .8 * Math.min(a, r);
        let s, o;
        if ("check" === t) {
            s = {
                width: .755 * n,
                height: .705 * n
            };
            o = "3";
        } else if ("disc" === t) {
            s = {
                width: .791 * n,
                height: .705 * n
            };
            o = "l";
        } else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t}`);
        const c = `q BT /PdfJsZaDb ${n} Tf 0 g ${numberToString((a - s.width) / 2)} ${numberToString((r - s.height) / 2)} Td (${o}) Tj ET Q`, l = new Dict(e1.xref);
        l.set("FormType", 1);
        l.setIfName("Subtype", "Form");
        l.setIfName("Type", "XObject");
        l.set("BBox", i);
        l.set("Matrix", [
            1,
            0,
            0,
            1,
            0,
            0
        ]);
        l.set("Length", c.length);
        const h = new Dict(e1.xref), u = new Dict(e1.xref);
        u.set("PdfJsZaDb", this.fallbackFontDict);
        h.set("Font", u);
        l.set("Resources", h);
        this.checkedAppearance = new StringStream(c);
        this.checkedAppearance.dict = l;
        this._streams.push(this.checkedAppearance);
    }
    _processCheckBox(e1) {
        const t = e1.dict.get("AP");
        if (!(t instanceof Dict)) return;
        const a = t.get("N");
        if (!(a instanceof Dict)) return;
        const r = this._decodeFormValue(e1.dict.get("AS"));
        "string" == typeof r && (this.data.fieldValue = r);
        const i = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", n = this._decodeFormValue(a.getKeys());
        if (0 === n.length) n.push("Off", i);
        else if (1 === n.length) "Off" === n[0] ? n.push(i) : n.unshift("Off");
        else if (n.includes(i)) {
            n.length = 0;
            n.push("Off", i);
        } else {
            const e1 = n.find((e1)=>"Off" !== e1);
            n.length = 0;
            n.push("Off", e1);
        }
        n.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
        this.data.exportValue = n[1];
        const s = a.get(this.data.exportValue);
        this.checkedAppearance = s instanceof BaseStream ? s : null;
        const o = a.get("Off");
        this.uncheckedAppearance = o instanceof BaseStream ? o : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "check");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processRadioButton(e1) {
        this.data.buttonValue = null;
        const t = e1.dict.get("Parent");
        if (t instanceof Dict) {
            this.parent = e1.dict.getRaw("Parent");
            const a = t.get("V");
            a instanceof Name && (this.data.fieldValue = this._decodeFormValue(a));
        }
        const a = e1.dict.get("AP");
        if (!(a instanceof Dict)) return;
        const r = a.get("N");
        if (!(r instanceof Dict)) return;
        for (const e1 of r.getKeys())if ("Off" !== e1) {
            this.data.buttonValue = this._decodeFormValue(e1);
            break;
        }
        const i = r.get(this.data.buttonValue);
        this.checkedAppearance = i instanceof BaseStream ? i : null;
        const n = r.get("Off");
        this.uncheckedAppearance = n instanceof BaseStream ? n : null;
        this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e1, "disc");
        this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
        this._fallbackFontDict = this.fallbackFontDict;
        null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processPushButton(e1) {
        const { dict: t, annotationGlobals: a } = e1;
        if (t.has("A") || t.has("AA") || this.data.alternativeText) {
            this.data.isTooltipOnly = !t.has("A") && !t.has("AA");
            Catalog.parseDestDictionary({
                destDict: t,
                resultObj: this.data,
                docBaseUrl: a.baseUrl,
                docAttachments: a.attachments
            });
        } else warn("Push buttons without action dictionaries are not supported");
    }
    getFieldObject() {
        let e1, t = "button";
        if (this.data.checkBox) {
            t = "checkbox";
            e1 = this.data.exportValue;
        } else if (this.data.radioButton) {
            t = "radiobutton";
            e1 = this.data.buttonValue;
        }
        return {
            id: this.data.id,
            value: this.data.fieldValue || "Off",
            defaultValue: this.data.defaultFieldValue,
            exportValues: e1,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: t
        };
    }
    get fallbackFontDict() {
        const e1 = new Dict;
        e1.setIfName("BaseFont", "ZapfDingbats");
        e1.setIfName("Type", "FallbackType");
        e1.setIfName("Subtype", "FallbackType");
        e1.setIfName("Encoding", "ZapfDingbatsEncoding");
        return shadow(this, "fallbackFontDict", e1);
    }
}
class ChoiceWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.indices = t.getArray("I");
        this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
        this.data.options = [];
        const r = getInheritableProperty({
            dict: t,
            key: "Opt"
        });
        if (Array.isArray(r)) for(let e1 = 0, t = r.length; e1 < t; e1++){
            const t = a.fetchIfRef(r[e1]), i = Array.isArray(t);
            this.data.options[e1] = {
                exportValue: this._decodeFormValue(i ? a.fetchIfRef(t[0]) : t),
                displayValue: this._decodeFormValue(i ? a.fetchIfRef(t[1]) : t)
            };
        }
        if (this.hasIndices) {
            this.data.fieldValue = [];
            const e1 = this.data.options.length;
            for (const t of this.indices)Number.isInteger(t) && t >= 0 && t < e1 && this.data.fieldValue.push(this.data.options[t].exportValue);
        } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [
            this.data.fieldValue
        ] : this.data.fieldValue ||= [];
        0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((e1)=>({
                exportValue: e1,
                displayValue: e1
            })));
        this.data.combo = this.hasFieldFlag(z);
        this.data.multiSelect = this.hasFieldFlag(G);
        this._hasText = !0;
    }
    getFieldObject() {
        const e1 = this.data.combo ? "combobox" : "listbox", t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
        return {
            id: this.data.id,
            value: t,
            defaultValue: this.data.defaultFieldValue,
            editable: !this.data.readOnly,
            name: this.data.fieldName,
            rect: this.data.rect,
            numItems: this.data.fieldValue.length,
            multipleSelection: this.data.multiSelect,
            hidden: this.data.hidden,
            actions: this.data.actions,
            items: this.data.options,
            page: this.data.pageIndex,
            strokeColor: this.data.borderColor,
            fillColor: this.data.backgroundColor,
            rotation: this.rotation,
            type: e1
        };
    }
    amendSavedDict(e1, t) {
        if (!this.hasIndices) return;
        let a = e1?.get(this.data.id)?.value;
        Array.isArray(a) || (a = [
            a
        ]);
        const r = [], { options: i } = this.data;
        for(let e1 = 0, t = 0, n = i.length; e1 < n; e1++)if (i[e1].exportValue === a[t]) {
            r.push(e1);
            t += 1;
        }
        t.set("I", r);
    }
    async _getAppearance(e1, t, r, i) {
        if (this.data.combo) return super._getAppearance(e1, t, r, i);
        let n, s;
        const o = i?.get(this.data.id);
        if (o) {
            s = o.rotation;
            n = o.value;
        }
        if (void 0 === s && void 0 === n && !this._needAppearances) return null;
        void 0 === n ? n = this.data.fieldValue : Array.isArray(n) || (n = [
            n
        ]);
        let { width: c, height: l } = this;
        90 !== s && 270 !== s || ([c, l] = [
            l,
            c
        ]);
        const h = this.data.options.length, u = [];
        for(let e1 = 0; e1 < h; e1++){
            const { exportValue: t } = this.data.options[e1];
            n.includes(t) && u.push(e1);
        }
        this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
        const d = await WidgetAnnotation._getFontData(e1, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
        let f, { fontSize: g } = this.data.defaultAppearanceData;
        if (g) f = this._defaultAppearance;
        else {
            const e1 = (l - 1) / h;
            let t, a = -1;
            for (const { displayValue: e1 } of this.data.options){
                const r = this._getTextWidth(e1, d);
                if (r > a) {
                    a = r;
                    t = e1;
                }
            }
            [f, g] = this._computeFontSize(e1, c - 4, t, d, -1);
        }
        const p = g * a, m = (p - g) / 2, b = Math.floor(l / p);
        let y = 0;
        if (u.length > 0) {
            const e1 = Math.min(...u), t = Math.max(...u);
            y = Math.max(0, t - b + 1);
            y > e1 && (y = e1);
        }
        const w = Math.min(y + b + 1, h), x = [
            "/Tx BMC q",
            `1 1 ${c} ${l} re W n`
        ];
        if (u.length) {
            x.push("0.600006 0.756866 0.854904 rg");
            for (const e1 of u)y <= e1 && e1 < w && x.push(`1 ${l - (e1 - y + 1) * p} ${c} ${p} re f`);
        }
        x.push("BT", f, `1 0 0 1 0 ${l} Tm`);
        const S = {
            shift: 0
        };
        for(let e1 = y; e1 < w; e1++){
            const { displayValue: t } = this.data.options[e1], a = e1 === y ? m : 0;
            x.push(this._renderText(t, d, g, c, 0, S, 2, -p + a));
        }
        x.push("ET Q EMC");
        return x.join("\n");
    }
}
class SignatureWidgetAnnotation extends WidgetAnnotation {
    constructor(e1){
        super(e1);
        this.data.fieldValue = null;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !this.data.hasOwnCanvas;
    }
    getFieldObject() {
        return {
            id: this.data.id,
            value: null,
            page: this.data.pageIndex,
            type: "signature"
        };
    }
}
class TextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.noRotate = !0;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const { dict: t } = e1;
        this.data.annotationType = F.TEXT;
        if (this.data.hasAppearance) this.data.name = "NoIcon";
        else {
            this.data.rect[1] = this.data.rect[3] - 22;
            this.data.rect[2] = this.data.rect[0] + 22;
            this.data.name = t.has("Name") ? t.get("Name").name : "Note";
        }
        if (t.has("State")) {
            this.data.state = t.get("State") || null;
            this.data.stateModel = t.get("StateModel") || null;
        } else {
            this.data.state = null;
            this.data.stateModel = null;
        }
    }
}
class LinkAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t, annotationGlobals: a } = e1;
        this.data.annotationType = F.LINK;
        this.data.noHTML = !1;
        const r = getQuadPoints(t, this.rectangle);
        r && (this.data.quadPoints = r);
        this.data.borderColor ||= this.data.color;
        Catalog.parseDestDictionary({
            destDict: t,
            resultObj: this.data,
            docBaseUrl: a.baseUrl,
            docAttachments: a.attachments
        });
    }
    get overlaysTextContent() {
        return !0;
    }
}
class PopupAnnotation extends Annotation {
    constructor(e1){
        super(e1);
        const { dict: t } = e1;
        this.data.annotationType = F.POPUP;
        this.data.noHTML = !1;
        0 !== this.width && 0 !== this.height || (this.data.rect = null);
        let a = t.get("Parent");
        if (!a) {
            warn("Popup annotation has a missing or invalid parent annotation.");
            return;
        }
        this.data.parentRect = lookupNormalRect(a.getArray("Rect"), null);
        this.data.creationDate = a.get("CreationDate") || "";
        isName(a.get("RT"), T) && (a = a.get("IRT"));
        if (a.has("M")) {
            this.setModificationDate(a.get("M"));
            this.data.modificationDate = this.modificationDate;
        } else this.data.modificationDate = null;
        if (a.has("C")) {
            this.setColor(a.getArray("C"));
            this.data.color = this.color;
        } else this.data.color = null;
        if (!this.viewable) {
            const e1 = a.get("F");
            this._isViewable(e1) && this.setFlags(e1);
        }
        this.setTitle(a.get("T"));
        this.data.titleObj = this._title;
        this.setContents(a.get("Contents"));
        this.data.contentsObj = this._contents;
        a.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(a.get("RC")));
        this.data.open = !!t.get("Open");
    }
    static createNewDict(e1, t, a) {
        const { oldAnnotation: r, rect: i, parent: n } = e1, s = r || new Dict(t);
        s.setIfNotExists("Type", Name.get("Annot"));
        s.setIfNotExists("Subtype", Name.get("Popup"));
        s.setIfNotExists("Open", !1);
        s.setIfArray("Rect", i);
        s.set("Parent", n);
        return s;
    }
    static async createNewAppearanceStream(e1, t, a) {
        return null;
    }
}
class FreeTextAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        const { annotationGlobals: t, evaluatorOptions: a, xref: r } = e1;
        this.data.annotationType = F.FREETEXT;
        this.setDefaultAppearance(e1);
        this._hasAppearance = !!this.appearance;
        if (this._hasAppearance) {
            const { fontColor: e1, fontSize: i } = function parseAppearanceStream(e1, t, a, r) {
                return new AppearanceStreamEvaluator(e1, t, a, r).parse();
            }(this.appearance, a, r, t.globalColorSpaceCache);
            this.data.defaultAppearanceData.fontColor = e1;
            this.data.defaultAppearanceData.fontSize = i || 10;
        } else {
            this.data.defaultAppearanceData.fontSize ||= 10;
            const { fontColor: t, fontSize: a } = this.data.defaultAppearanceData;
            if (this._contents.str) {
                this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e1)=>e1.trimEnd());
                const { coords: e1, bbox: t, matrix: r } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a);
                this.data.textPosition = this._transformPoint(e1, t, r);
            }
            if (this._isOffscreenCanvasSupported) {
                const i = e1.dict.get("CA"), n = new FakeUnicodeFont(r, "sans-serif");
                this.appearance = n.createAppearance(this._contents.str, this.rectangle, this.rotation, a, t, i);
                this._streams.push(this.appearance);
            } else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
        }
    }
    get hasTextContent() {
        return this._hasAppearance;
    }
    static createNewDict(e1, t, { apRef: a, ap: r }) {
        const { color: i, date: n, fontSize: s, oldAnnotation: o, rect: c, rotation: l, user: h, value: u } = e1, d = o || new Dict(t);
        d.setIfNotExists("Type", Name.get("Annot"));
        d.setIfNotExists("Subtype", Name.get("FreeText"));
        d.set(o ? "M" : "CreationDate", `D:${getModificationDate(n)}`);
        o && d.delete("RC");
        d.setIfArray("Rect", c);
        const f = `/Helv ${s} Tf ${getPdfColor(i, !0)}`;
        d.set("DA", f);
        d.setIfDefined("Contents", stringToAsciiOrUTF16BE(u));
        d.setIfNotExists("F", 4);
        d.setIfNotExists("Border", [
            0,
            0,
            0
        ]);
        d.setIfNumber("Rotate", l);
        d.setIfDefined("T", stringToAsciiOrUTF16BE(h));
        if (a || r) {
            const e1 = new Dict(t);
            d.set("AP", e1);
            e1.set("N", a || r);
        }
        return d;
    }
    static async createNewAppearanceStream(e1, t, r) {
        const { baseFontRef: i, evaluator: n, task: s } = r, { color: o, fontSize: c, rect: l, rotation: h, value: u } = e1;
        if (!o) return null;
        const d = new Dict(t), f = new Dict(t);
        if (i) f.set("Helv", i);
        else {
            const e1 = new Dict(t);
            e1.setIfName("BaseFont", "Helvetica");
            e1.setIfName("Type", "Font");
            e1.setIfName("Subtype", "Type1");
            e1.setIfName("Encoding", "WinAnsiEncoding");
            f.set("Helv", e1);
        }
        d.set("Font", f);
        const g = await WidgetAnnotation._getFontData(n, s, {
            fontName: "Helv",
            fontSize: c
        }, d), [p, m, b, y] = l;
        let w = b - p, x = y - m;
        h % 180 != 0 && ([w, x] = [
            x,
            w
        ]);
        const S = u.split("\n"), k = c / 1e3;
        let C = -1 / 0;
        const v = [];
        for (let e1 of S){
            const t = g.encodeString(e1);
            if (t.length > 1) return null;
            e1 = t.join("");
            v.push(e1);
            let a = 0;
            const r = g.charsToGlyphs(e1);
            for (const e1 of r)a += e1.width * k;
            C = Math.max(C, a);
        }
        let F = 1;
        C > w && (F = w / C);
        let T = 1;
        const O = a * c, M = 1 * c, D = O * S.length;
        D > x && (T = x / D);
        const R = c * Math.min(F, T);
        let N, E, L;
        switch(h){
            case 0:
                L = [
                    1,
                    0,
                    0,
                    1
                ];
                E = [
                    l[0],
                    l[1],
                    w,
                    x
                ];
                N = [
                    l[0],
                    l[3] - M
                ];
                break;
            case 90:
                L = [
                    0,
                    1,
                    -1,
                    0
                ];
                E = [
                    l[1],
                    -l[2],
                    w,
                    x
                ];
                N = [
                    l[1],
                    -l[0] - M
                ];
                break;
            case 180:
                L = [
                    -1,
                    0,
                    0,
                    -1
                ];
                E = [
                    -l[2],
                    -l[3],
                    w,
                    x
                ];
                N = [
                    -l[2],
                    -l[1] - M
                ];
                break;
            case 270:
                L = [
                    0,
                    -1,
                    1,
                    0
                ];
                E = [
                    -l[3],
                    l[0],
                    w,
                    x
                ];
                N = [
                    -l[3],
                    l[2] - M
                ];
        }
        const j = [
            "q",
            `${L.join(" ")} 0 0 cm`,
            `${E.join(" ")} re W n`,
            "BT",
            `${getPdfColor(o, !0)}`,
            `0 Tc /Helv ${numberToString(R)} Tf`
        ];
        j.push(`${N.join(" ")} Td (${escapeString(v[0])}) Tj`);
        const _ = numberToString(O);
        for(let e1 = 1, t = v.length; e1 < t; e1++){
            const t = v[e1];
            j.push(`0 -${_} Td (${escapeString(t)}) Tj`);
        }
        j.push("ET", "Q");
        const U = j.join("\n"), X = new Dict(t);
        X.set("FormType", 1);
        X.setIfName("Subtype", "Form");
        X.setIfName("Type", "XObject");
        X.set("BBox", l);
        X.set("Resources", d);
        X.set("Matrix", [
            1,
            0,
            0,
            1,
            -l[0],
            -l[1]
        ]);
        const q = new StringStream(U);
        q.dict = X;
        return q;
    }
}
class LineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.LINE;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const r = lookupRect(t.getArray("L"), [
            0,
            0,
            0,
            0
        ]);
        this.data.lineCoordinates = Util.normalizeRect(r);
        this.setLineEndings(t.getArray("LE"));
        this.data.lineEndings = this.lineEndings;
        if (!this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), i = t.get("CA"), n = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), s = n ? i : null, o = this.borderStyle.width || 1, c = 2 * o, l = [
                this.data.lineCoordinates[0] - c,
                this.data.lineCoordinates[1] - c,
                this.data.lineCoordinates[2] + c,
                this.data.lineCoordinates[3] + c
            ];
            Util.intersect(this.rectangle, l) || (this.rectangle = l);
            this._setDefaultAppearance({
                xref: a,
                extra: `${o} w`,
                strokeColor: e1,
                fillColor: n,
                strokeAlpha: i,
                fillAlpha: s,
                pointsCallback: (e1, t)=>{
                    e1.push(`${r[0]} ${r[1]} m`, `${r[2]} ${r[3]} l`, "S");
                    return [
                        t[0] - o,
                        t[7] - o,
                        t[2] + o,
                        t[3] + o
                    ];
                }
            });
        }
    }
}
class SquareAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.SQUARE;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        if (!this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), r = t.get("CA"), i = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), n = i ? r : null;
            if (0 === this.borderStyle.width && !i) return;
            this._setDefaultAppearance({
                xref: a,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: i,
                strokeAlpha: r,
                fillAlpha: n,
                pointsCallback: (e1, t)=>{
                    const a = t[4] + this.borderStyle.width / 2, r = t[5] + this.borderStyle.width / 2, n = t[6] - t[4] - this.borderStyle.width, s = t[3] - t[7] - this.borderStyle.width;
                    e1.push(`${a} ${r} ${n} ${s} re`);
                    i ? e1.push("B") : e1.push("S");
                    return [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class CircleAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.CIRCLE;
        if (!this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), r = t.get("CA"), i = getPdfColorArray(getRgbColor(t.getArray("IC"), null)), n = i ? r : null;
            if (0 === this.borderStyle.width && !i) return;
            const s = 4 / 3 * Math.tan(Math.PI / 8);
            this._setDefaultAppearance({
                xref: a,
                extra: `${this.borderStyle.width} w`,
                strokeColor: e1,
                fillColor: i,
                strokeAlpha: r,
                fillAlpha: n,
                pointsCallback: (e1, t)=>{
                    const a = t[0] + this.borderStyle.width / 2, r = t[1] - this.borderStyle.width / 2, n = t[6] - this.borderStyle.width / 2, o = t[7] + this.borderStyle.width / 2, c = a + (n - a) / 2, l = r + (o - r) / 2, h = (n - a) / 2 * s, u = (o - r) / 2 * s;
                    e1.push(`${c} ${o} m`, `${c + h} ${o} ${n} ${l + u} ${n} ${l} c`, `${n} ${l - u} ${c + h} ${r} ${c} ${r} c`, `${c - h} ${r} ${a} ${l - u} ${a} ${l} c`, `${a} ${l + u} ${c - h} ${o} ${c} ${o} c`, "h");
                    i ? e1.push("B") : e1.push("S");
                    return [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolylineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.POLYLINE;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        this.data.vertices = null;
        if (!(this instanceof PolygonAnnotation)) {
            this.setLineEndings(t.getArray("LE"));
            this.data.lineEndings = this.lineEndings;
        }
        const r = t.getArray("Vertices");
        if (!isNumberArray(r, null)) return;
        const i = this.data.vertices = Float32Array.from(r);
        if (!this.appearance) {
            const e1 = getPdfColorArray(this.color, [
                0,
                0,
                0
            ]), r = t.get("CA");
            let n, s = getRgbColor(t.getArray("IC"), null);
            s && (s = getPdfColorArray(s));
            n = s ? this.color ? s.every((t, a)=>t === e1[a]) ? "f" : "B" : "f" : "S";
            const o = this.borderStyle.width || 1, c = 2 * o, l = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let e1 = 0, t = i.length; e1 < t; e1 += 2)Util.rectBoundingBox(i[e1] - c, i[e1 + 1] - c, i[e1] + c, i[e1 + 1] + c, l);
            Util.intersect(this.rectangle, l) || (this.rectangle = l);
            this._setDefaultAppearance({
                xref: a,
                extra: `${o} w`,
                strokeColor: e1,
                strokeAlpha: r,
                fillColor: s,
                fillAlpha: s ? r : null,
                pointsCallback: (e1, t)=>{
                    for(let t = 0, a = i.length; t < a; t += 2)e1.push(`${i[t]} ${i[t + 1]} ${0 === t ? "m" : "l"}`);
                    e1.push(n);
                    return [
                        t[0],
                        t[7],
                        t[2],
                        t[3]
                    ];
                }
            });
        }
    }
}
class PolygonAnnotation extends PolylineAnnotation {
    constructor(e1){
        super(e1);
        this.data.annotationType = F.POLYGON;
    }
}
class CaretAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.annotationType = F.CARET;
    }
}
class InkAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.INK;
        this.data.inkLists = [];
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        this.data.opacity = t.get("CA") || 1;
        const r = t.getArray("InkList");
        if (Array.isArray(r)) {
            for(let e1 = 0, t = r.length; e1 < t; ++e1){
                if (!Array.isArray(r[e1])) continue;
                const t = new Float32Array(r[e1].length);
                this.data.inkLists.push(t);
                for(let i = 0, n = r[e1].length; i < n; i += 2){
                    const n = a.fetchIfRef(r[e1][i]), s = a.fetchIfRef(r[e1][i + 1]);
                    if ("number" == typeof n && "number" == typeof s) {
                        t[i] = n;
                        t[i + 1] = s;
                    }
                }
            }
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), r = t.get("CA"), i = this.borderStyle.width || 1, n = 2 * i, s = [
                    1 / 0,
                    1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const e1 of this.data.inkLists)for(let t = 0, a = e1.length; t < a; t += 2)Util.rectBoundingBox(e1[t] - n, e1[t + 1] - n, e1[t] + n, e1[t + 1] + n, s);
                Util.intersect(this.rectangle, s) || (this.rectangle = s);
                this._setDefaultAppearance({
                    xref: a,
                    extra: `${i} w`,
                    strokeColor: e1,
                    strokeAlpha: r,
                    pointsCallback: (e1, t)=>{
                        for (const t of this.data.inkLists){
                            for(let a = 0, r = t.length; a < r; a += 2)e1.push(`${t[a]} ${t[a + 1]} ${0 === a ? "m" : "l"}`);
                            e1.push("S");
                        }
                        return [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ];
                    }
                });
            }
        }
    }
    static createNewDict(e1, t, { apRef: a, ap: r }) {
        const { oldAnnotation: i, color: n, date: s, opacity: o, paths: c, outlines: l, rect: h, rotation: u, thickness: d, user: f } = e1, g = i || new Dict(t);
        g.setIfNotExists("Type", Name.get("Annot"));
        g.setIfNotExists("Subtype", Name.get("Ink"));
        g.set(i ? "M" : "CreationDate", `D:${getModificationDate(s)}`);
        g.setIfArray("Rect", h);
        g.setIfArray("InkList", l?.points || c?.points);
        g.setIfNotExists("F", 4);
        g.setIfNumber("Rotate", u);
        g.setIfDefined("T", stringToAsciiOrUTF16BE(f));
        l && g.setIfName("IT", "InkHighlight");
        if (d > 0) {
            const e1 = new Dict(t);
            g.set("BS", e1);
            e1.set("W", d);
        }
        g.setIfArray("C", getPdfColorArray(n));
        g.setIfNumber("CA", o);
        if (r || a) {
            const e1 = new Dict(t);
            g.set("AP", e1);
            e1.set("N", a || r);
        }
        return g;
    }
    static async createNewAppearanceStream(e1, t, a) {
        if (e1.outlines) return this.createNewAppearanceStreamForHighlight(e1, t, a);
        const { color: r, rect: i, paths: n, thickness: s, opacity: o } = e1;
        if (!r) return null;
        const c = [
            `${s} w 1 J 1 j`,
            `${getPdfColor(r, !1)}`
        ];
        1 !== o && c.push("/R0 gs");
        for (const e1 of n.lines){
            c.push(`${numberToString(e1[4])} ${numberToString(e1[5])} m`);
            for(let t = 6, a = e1.length; t < a; t += 6)if (isNaN(e1[t])) c.push(`${numberToString(e1[t + 4])} ${numberToString(e1[t + 5])} l`);
            else {
                const [a, r, i, n, s, o] = e1.slice(t, t + 6);
                c.push([
                    a,
                    r,
                    i,
                    n,
                    s,
                    o
                ].map(numberToString).join(" ") + " c");
            }
            6 === e1.length && c.push(`${numberToString(e1[4])} ${numberToString(e1[5])} l`);
        }
        c.push("S");
        const l = c.join("\n"), h = new Dict(t);
        h.set("FormType", 1);
        h.setIfName("Subtype", "Form");
        h.setIfName("Type", "XObject");
        h.set("BBox", i);
        h.set("Length", l.length);
        if (1 !== o) {
            const e1 = new Dict(t), a = new Dict(t), r = new Dict(t);
            r.set("CA", o);
            r.setIfName("Type", "ExtGState");
            a.set("R0", r);
            e1.set("ExtGState", a);
            h.set("Resources", e1);
        }
        const u = new StringStream(l);
        u.dict = h;
        return u;
    }
    static async createNewAppearanceStreamForHighlight(e1, t, a) {
        const { color: r, rect: i, outlines: { outline: n }, opacity: s } = e1;
        if (!r) return null;
        const o = [
            `${getPdfColor(r, !0)}`,
            "/R0 gs"
        ];
        o.push(`${numberToString(n[4])} ${numberToString(n[5])} m`);
        for(let e1 = 6, t = n.length; e1 < t; e1 += 6)if (isNaN(n[e1])) o.push(`${numberToString(n[e1 + 4])} ${numberToString(n[e1 + 5])} l`);
        else {
            const [t, a, r, i, s, c] = n.slice(e1, e1 + 6);
            o.push([
                t,
                a,
                r,
                i,
                s,
                c
            ].map(numberToString).join(" ") + " c");
        }
        o.push("h f");
        const c = o.join("\n"), l = new Dict(t);
        l.set("FormType", 1);
        l.setIfName("Subtype", "Form");
        l.setIfName("Type", "XObject");
        l.set("BBox", i);
        l.set("Length", c.length);
        const h = new Dict(t), u = new Dict(t);
        h.set("ExtGState", u);
        l.set("Resources", h);
        const d = new Dict(t);
        u.set("R0", d);
        d.setIfName("BM", "Multiply");
        if (1 !== s) {
            d.set("ca", s);
            d.setIfName("Type", "ExtGState");
        }
        const f = new StringStream(c);
        f.dict = l;
        return f;
    }
}
class HighlightAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.HIGHLIGHT;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
        this.data.opacity = t.get("CA") || 1;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            const e1 = this.appearance?.dict.get("Resources");
            if (!this.appearance || !e1?.has("ExtGState")) {
                this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
                const e1 = getPdfColorArray(this.color, [
                    1,
                    1,
                    0
                ]), r = t.get("CA");
                this._setDefaultAppearance({
                    xref: a,
                    fillColor: e1,
                    blendMode: "Multiply",
                    fillAlpha: r,
                    pointsCallback: (e1, t)=>{
                        e1.push(`${t[0]} ${t[1]} m`, `${t[2]} ${t[3]} l`, `${t[6]} ${t[7]} l`, `${t[4]} ${t[5]} l`, "f");
                        return [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
    static createNewDict(e1, t, { apRef: a, ap: r }) {
        const { color: i, date: n, oldAnnotation: s, opacity: o, rect: c, rotation: l, user: h, quadPoints: u } = e1, d = s || new Dict(t);
        d.setIfNotExists("Type", Name.get("Annot"));
        d.setIfNotExists("Subtype", Name.get("Highlight"));
        d.set(s ? "M" : "CreationDate", `D:${getModificationDate(n)}`);
        d.setIfArray("Rect", c);
        d.setIfNotExists("F", 4);
        d.setIfNotExists("Border", [
            0,
            0,
            0
        ]);
        d.setIfNumber("Rotate", l);
        d.setIfArray("QuadPoints", u);
        d.setIfArray("C", getPdfColorArray(i));
        d.setIfNumber("CA", o);
        d.setIfDefined("T", stringToAsciiOrUTF16BE(h));
        if (a || r) {
            const e1 = new Dict(t);
            d.set("AP", e1);
            e1.set("N", a || r);
        }
        return d;
    }
    static async createNewAppearanceStream(e1, t, a) {
        const { color: r, rect: i, outlines: n, opacity: s } = e1;
        if (!r) return null;
        const o = [
            `${getPdfColor(r, !0)}`,
            "/R0 gs"
        ], c = [];
        for (const e1 of n){
            c.length = 0;
            c.push(`${numberToString(e1[0])} ${numberToString(e1[1])} m`);
            for(let t = 2, a = e1.length; t < a; t += 2)c.push(`${numberToString(e1[t])} ${numberToString(e1[t + 1])} l`);
            c.push("h");
            o.push(c.join("\n"));
        }
        o.push("f*");
        const l = o.join("\n"), h = new Dict(t);
        h.set("FormType", 1);
        h.setIfName("Subtype", "Form");
        h.setIfName("Type", "XObject");
        h.set("BBox", i);
        h.set("Length", l.length);
        const u = new Dict(t), d = new Dict(t);
        u.set("ExtGState", d);
        h.set("Resources", u);
        const f = new Dict(t);
        d.set("R0", f);
        f.setIfName("BM", "Multiply");
        if (1 !== s) {
            f.set("ca", s);
            f.setIfName("Type", "ExtGState");
        }
        const g = new StringStream(l);
        g.dict = h;
        return g;
    }
}
class UnderlineAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.UNDERLINE;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), r = t.get("CA");
                this._setDefaultAppearance({
                    xref: a,
                    extra: "[] 0 d 0.571 w",
                    strokeColor: e1,
                    strokeAlpha: r,
                    pointsCallback: (e1, t)=>{
                        e1.push(`${t[4]} ${t[5] + 1.3} m`, `${t[6]} ${t[7] + 1.3} l`, "S");
                        return [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class SquigglyAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.SQUIGGLY;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), r = t.get("CA");
                this._setDefaultAppearance({
                    xref: a,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: r,
                    pointsCallback: (e1, t)=>{
                        const a = (t[1] - t[5]) / 6;
                        let r = a, i = t[4];
                        const n = t[5], s = t[6];
                        e1.push(`${i} ${n + r} m`);
                        do {
                            i += 2;
                            r = 0 === r ? a : 0;
                            e1.push(`${i} ${n + r} l`);
                        }while (i < s)
                        e1.push("S");
                        return [
                            t[4],
                            n - 2 * a,
                            s,
                            n + 2 * a
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class StrikeOutAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1;
        this.data.annotationType = F.STRIKEOUT;
        if (this.data.quadPoints = getQuadPoints(t, null)) {
            if (!this.appearance) {
                const e1 = getPdfColorArray(this.color, [
                    0,
                    0,
                    0
                ]), r = t.get("CA");
                this._setDefaultAppearance({
                    xref: a,
                    extra: "[] 0 d 1 w",
                    strokeColor: e1,
                    strokeAlpha: r,
                    pointsCallback: (e1, t)=>{
                        e1.push((t[0] + t[4]) / 2 + " " + (t[1] + t[5]) / 2 + " m", (t[2] + t[6]) / 2 + " " + (t[3] + t[7]) / 2 + " l", "S");
                        return [
                            t[0],
                            t[7],
                            t[2],
                            t[3]
                        ];
                    }
                });
            }
        } else this.data.popupRef = null;
    }
    get overlaysTextContent() {
        return !0;
    }
}
class StampAnnotation extends MarkupAnnotation {
    #pe = null;
    constructor(e1){
        super(e1);
        this.data.annotationType = F.STAMP;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.isEditable = !this.data.noHTML;
        this.data.noHTML = !1;
    }
    mustBeViewedWhenEditing(e1, t = null) {
        if (e1) {
            if (!this.data.isEditable) return !0;
            this.#pe ??= this.data.hasOwnCanvas;
            this.data.hasOwnCanvas = !0;
            return !0;
        }
        if (null !== this.#pe) {
            this.data.hasOwnCanvas = this.#pe;
            this.#pe = null;
        }
        return !t?.has(this.data.id);
    }
    static async createImage(e1, t) {
        const { width: a, height: r } = e1, i = new OffscreenCanvas(a, r), n = i.getContext("2d", {
            alpha: !0
        });
        n.drawImage(e1, 0, 0);
        const s = n.getImageData(0, 0, a, r).data, o = new Uint32Array(s.buffer), c = o.some(FeatureTest.isLittleEndian ? (e1)=>e1 >>> 24 != 255 : (e1)=>!!(255 & ~e1));
        if (c) {
            n.fillStyle = "white";
            n.fillRect(0, 0, a, r);
            n.drawImage(e1, 0, 0);
        }
        const l = i.convertToBlob({
            type: "image/jpeg",
            quality: 1
        }).then((e1)=>e1.arrayBuffer()), h = Name.get("XObject"), u = Name.get("Image"), d = new Dict(t);
        d.set("Type", h);
        d.set("Subtype", u);
        d.set("BitsPerComponent", 8);
        d.setIfName("ColorSpace", "DeviceRGB");
        d.setIfName("Filter", "DCTDecode");
        d.set("BBox", [
            0,
            0,
            a,
            r
        ]);
        d.set("Width", a);
        d.set("Height", r);
        let f = null;
        if (c) {
            const e1 = new Uint8Array(o.length);
            if (FeatureTest.isLittleEndian) for(let t = 0, a = o.length; t < a; t++)e1[t] = o[t] >>> 24;
            else for(let t = 0, a = o.length; t < a; t++)e1[t] = 255 & o[t];
            const i = new Dict(t);
            i.set("Type", h);
            i.set("Subtype", u);
            i.set("BitsPerComponent", 8);
            i.setIfName("ColorSpace", "DeviceGray");
            i.set("Width", a);
            i.set("Height", r);
            f = new Stream(e1, 0, 0, i);
        }
        return {
            imageStream: new Stream(await l, 0, 0, d),
            smaskStream: f,
            width: a,
            height: r
        };
    }
    static createNewDict(e1, t, { apRef: a, ap: r }) {
        const { date: i, oldAnnotation: n, rect: s, rotation: o, user: c } = e1, l = n || new Dict(t);
        l.setIfNotExists("Type", Name.get("Annot"));
        l.setIfNotExists("Subtype", Name.get("Stamp"));
        l.set(n ? "M" : "CreationDate", `D:${getModificationDate(i)}`);
        l.setIfArray("Rect", s);
        l.setIfNotExists("F", 4);
        l.setIfNotExists("Border", [
            0,
            0,
            0
        ]);
        l.setIfNumber("Rotate", o);
        l.setIfDefined("T", stringToAsciiOrUTF16BE(c));
        if (a || r) {
            const e1 = new Dict(t);
            l.set("AP", e1);
            e1.set("N", a || r);
        }
        return l;
    }
    static async #me(e1, t) {
        const { areContours: a, color: r, rect: i, lines: n, thickness: s } = e1;
        if (!r) return null;
        const o = [
            `${s} w 1 J 1 j`,
            `${getPdfColor(r, a)}`
        ];
        for (const e1 of n){
            o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} m`);
            for(let t = 6, a = e1.length; t < a; t += 6)if (isNaN(e1[t])) o.push(`${numberToString(e1[t + 4])} ${numberToString(e1[t + 5])} l`);
            else {
                const [a, r, i, n, s, c] = e1.slice(t, t + 6);
                o.push([
                    a,
                    r,
                    i,
                    n,
                    s,
                    c
                ].map(numberToString).join(" ") + " c");
            }
            6 === e1.length && o.push(`${numberToString(e1[4])} ${numberToString(e1[5])} l`);
        }
        o.push(a ? "F" : "S");
        const c = o.join("\n"), l = new Dict(t);
        l.set("FormType", 1);
        l.setIfName("Subtype", "Form");
        l.setIfName("Type", "XObject");
        l.set("BBox", i);
        l.set("Length", c.length);
        const h = new StringStream(c);
        h.dict = l;
        return h;
    }
    static async createNewAppearanceStream(e1, t, a) {
        if (e1.oldAnnotation) return null;
        if (e1.isSignature) return this.#me(e1, t);
        const { rotation: r } = e1, { imageRef: i, width: n, height: s } = a.image, o = new Dict(t), c = new Dict(t);
        o.set("XObject", c);
        c.set("Im0", i);
        const l = `q ${n} 0 0 ${s} 0 0 cm /Im0 Do Q`, h = new Dict(t);
        h.set("FormType", 1);
        h.setIfName("Subtype", "Form");
        h.setIfName("Type", "XObject");
        h.set("BBox", [
            0,
            0,
            n,
            s
        ]);
        h.set("Resources", o);
        if (r) {
            const e1 = getRotationMatrix(r, n, s);
            h.set("Matrix", e1);
        }
        const u = new StringStream(l);
        u.dict = h;
        return u;
    }
}
class FileAttachmentAnnotation extends MarkupAnnotation {
    constructor(e1){
        super(e1);
        const { dict: t, xref: a } = e1, r = new FileSpec(t.get("FS"), a);
        this.data.annotationType = F.FILEATTACHMENT;
        this.data.hasOwnCanvas = this.data.noRotate;
        this.data.noHTML = !1;
        this.data.file = r.serializable;
        const i = t.get("Name");
        this.data.name = i instanceof Name ? stringToPDFString(i.name) : "PushPin";
        const n = t.get("ca");
        this.data.fillAlpha = "number" == typeof n && n >= 0 && n <= 1 ? n : null;
    }
}
const Zo = {
    get r () {
        return shadow(this, "r", new Uint8Array([
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
        ]));
    },
    get k () {
        return shadow(this, "k", new Int32Array([
            -680876936,
            -389564586,
            606105819,
            -1044525330,
            -176418897,
            1200080426,
            -1473231341,
            -45705983,
            1770035416,
            -1958414417,
            -42063,
            -1990404162,
            1804603682,
            -40341101,
            -1502002290,
            1236535329,
            -165796510,
            -1069501632,
            643717713,
            -373897302,
            -701558691,
            38016083,
            -660478335,
            -405537848,
            568446438,
            -1019803690,
            -187363961,
            1163531501,
            -1444681467,
            -51403784,
            1735328473,
            -1926607734,
            -378558,
            -2022574463,
            1839030562,
            -35309556,
            -1530992060,
            1272893353,
            -155497632,
            -1094730640,
            681279174,
            -358537222,
            -722521979,
            76029189,
            -640364487,
            -421815835,
            530742520,
            -995338651,
            -198630844,
            1126891415,
            -1416354905,
            -57434055,
            1700485571,
            -1894986606,
            -1051523,
            -2054922799,
            1873313359,
            -30611744,
            -1560198380,
            1309151649,
            -145523070,
            -1120210379,
            718787259,
            -343485551
        ]));
    }
};
function calculateMD5(e1, t, a) {
    let r = 1732584193, i = -271733879, n = -1732584194, s = 271733878;
    const o = a + 72 & -64, c = new Uint8Array(o);
    let l, h;
    for(l = 0; l < a; ++l)c[l] = e1[t++];
    c[l++] = 128;
    const u = o - 8;
    l < u && (l = u);
    c[l++] = a << 3 & 255;
    c[l++] = a >> 5 & 255;
    c[l++] = a >> 13 & 255;
    c[l++] = a >> 21 & 255;
    c[l++] = a >>> 29 & 255;
    l += 3;
    const d = new Int32Array(16), { k: f, r: g } = Zo;
    for(l = 0; l < o;){
        for(h = 0; h < 16; ++h, l += 4)d[h] = c[l] | c[l + 1] << 8 | c[l + 2] << 16 | c[l + 3] << 24;
        let e1, t, a = r, o = i, u = n, p = s;
        for(h = 0; h < 64; ++h){
            if (h < 16) {
                e1 = o & u | ~o & p;
                t = h;
            } else if (h < 32) {
                e1 = p & o | ~p & u;
                t = 5 * h + 1 & 15;
            } else if (h < 48) {
                e1 = o ^ u ^ p;
                t = 3 * h + 5 & 15;
            } else {
                e1 = u ^ (o | ~p);
                t = 7 * h & 15;
            }
            const r = p, i = a + e1 + f[h] + d[t] | 0, n = g[h];
            p = u;
            u = o;
            o = o + (i << n | i >>> 32 - n) | 0;
            a = r;
        }
        r = r + a | 0;
        i = i + o | 0;
        n = n + u | 0;
        s = s + p | 0;
    }
    return new Uint8Array([
        255 & r,
        r >> 8 & 255,
        r >> 16 & 255,
        r >>> 24 & 255,
        255 & i,
        i >> 8 & 255,
        i >> 16 & 255,
        i >>> 24 & 255,
        255 & n,
        n >> 8 & 255,
        n >> 16 & 255,
        n >>> 24 & 255,
        255 & s,
        s >> 8 & 255,
        s >> 16 & 255,
        s >>> 24 & 255
    ]);
}
function decodeString(e1) {
    try {
        return stringToUTF8String(e1);
    } catch (t) {
        warn(`UTF-8 decoding failed: "${t}".`);
        return e1;
    }
}
class DatasetXMLParser extends SimpleXMLParser {
    constructor(e1){
        super(e1);
        this.node = null;
    }
    onEndElement(e1) {
        const t = super.onEndElement(e1);
        if (t && "xfa:datasets" === e1) {
            this.node = t;
            throw new Error("Aborting DatasetXMLParser.");
        }
    }
}
class DatasetReader {
    constructor(e1){
        if (e1.datasets) this.node = new SimpleXMLParser({
            hasAttributes: !0
        }).parseFromString(e1.datasets).documentElement;
        else {
            const t = new DatasetXMLParser({
                hasAttributes: !0
            });
            try {
                t.parseFromString(e1["xdp:xdp"]);
            } catch  {}
            this.node = t.node;
        }
    }
    getValue(e1) {
        if (!this.node || !e1) return "";
        const t = this.node.searchNode(parseXFAPath(e1), 0);
        if (!t) return "";
        const a = t.firstChild;
        return "value" === a?.nodeName ? t.children.map((e1)=>decodeString(e1.textContent)) : decodeString(t.textContent);
    }
}
class SingleIntersector {
    #be;
    #ye = 1 / 0;
    #we = 1 / 0;
    #xe = -1 / 0;
    #Se = -1 / 0;
    #Ae = null;
    #ke = [];
    #Ce = [];
    #ve = -1;
    #Fe = !1;
    constructor(e1){
        this.#be = e1;
        const t = e1.data.quadPoints;
        if (t) {
            for(let e1 = 0, a = t.length; e1 < a; e1 += 8){
                this.#ye = Math.min(this.#ye, t[e1]);
                this.#xe = Math.max(this.#xe, t[e1 + 2]);
                this.#we = Math.min(this.#we, t[e1 + 5]);
                this.#Se = Math.max(this.#Se, t[e1 + 1]);
            }
            t.length > 8 && (this.#Ae = t);
        } else [this.#ye, this.#we, this.#xe, this.#Se] = e1.data.rect;
    }
    overlaps(e1) {
        return !(this.#ye >= e1.#xe || this.#xe <= e1.#ye || this.#we >= e1.#Se || this.#Se <= e1.#we);
    }
    #Ie(e1, t) {
        if (this.#ye >= e1 || this.#xe <= e1 || this.#we >= t || this.#Se <= t) return !1;
        const a = this.#Ae;
        if (!a) return !0;
        if (this.#ve >= 0) {
            const r = this.#ve;
            if (!(a[r] >= e1 || a[r + 2] <= e1 || a[r + 5] >= t || a[r + 1] <= t)) return !0;
            this.#ve = -1;
        }
        for(let r = 0, i = a.length; r < i; r += 8)if (!(a[r] >= e1 || a[r + 2] <= e1 || a[r + 5] >= t || a[r + 1] <= t)) {
            this.#ve = r;
            return !0;
        }
        return !1;
    }
    addGlyph(e1, t, a) {
        if (!this.#Ie(e1, t)) {
            this.disableExtraChars();
            return !1;
        }
        if (this.#Ce.length > 0) {
            this.#ke.push(this.#Ce.join(""));
            this.#Ce.length = 0;
        }
        this.#ke.push(a);
        this.#Fe = !0;
        return !0;
    }
    addExtraChar(e1) {
        this.#Fe && this.#Ce.push(e1);
    }
    disableExtraChars() {
        if (this.#Fe) {
            this.#Fe = !1;
            this.#Ce.length = 0;
        }
    }
    setText() {
        this.#be.data.overlaidText = this.#ke.join("");
    }
}
class Intersector {
    #Te = new Map;
    constructor(e1){
        for (const t of e1){
            if (!t.data.quadPoints && !t.data.rect) continue;
            const e1 = new SingleIntersector(t);
            for (const [t, a] of this.#Te)t.overlaps(e1) && (a ? a.add(e1) : this.#Te.set(t, new Set([
                e1
            ])));
            this.#Te.set(e1, null);
        }
    }
    addGlyph(e1, t, a, r) {
        const i = e1[4] + t / 2, n = e1[5] + a / 2;
        let s;
        for (const [e1, t] of this.#Te)s ? s.has(e1) ? e1.addGlyph(i, n, r) : e1.disableExtraChars() : e1.addGlyph(i, n, r) && (s = t);
    }
    addExtraChar(e1) {
        for (const t of this.#Te.keys())t.addExtraChar(e1);
    }
    setText() {
        for (const e1 of this.#Te.keys())e1.setText();
    }
}
class Word64 {
    constructor(e1, t){
        this.high = 0 | e1;
        this.low = 0 | t;
    }
    and(e1) {
        this.high &= e1.high;
        this.low &= e1.low;
    }
    xor(e1) {
        this.high ^= e1.high;
        this.low ^= e1.low;
    }
    shiftRight(e1) {
        if (e1 >= 32) {
            this.low = this.high >>> e1 - 32 | 0;
            this.high = 0;
        } else {
            this.low = this.low >>> e1 | this.high << 32 - e1;
            this.high = this.high >>> e1 | 0;
        }
    }
    rotateRight(e1) {
        let t, a;
        if (32 & e1) {
            a = this.low;
            t = this.high;
        } else {
            t = this.low;
            a = this.high;
        }
        e1 &= 31;
        this.low = t >>> e1 | a << 32 - e1;
        this.high = a >>> e1 | t << 32 - e1;
    }
    not() {
        this.high = ~this.high;
        this.low = ~this.low;
    }
    add(e1) {
        const t = (this.low >>> 0) + (e1.low >>> 0);
        let a = (this.high >>> 0) + (e1.high >>> 0);
        t > 4294967295 && (a += 1);
        this.low = 0 | t;
        this.high = 0 | a;
    }
    copyTo(e1, t) {
        e1[t] = this.high >>> 24 & 255;
        e1[t + 1] = this.high >> 16 & 255;
        e1[t + 2] = this.high >> 8 & 255;
        e1[t + 3] = 255 & this.high;
        e1[t + 4] = this.low >>> 24 & 255;
        e1[t + 5] = this.low >> 16 & 255;
        e1[t + 6] = this.low >> 8 & 255;
        e1[t + 7] = 255 & this.low;
    }
    assign(e1) {
        this.high = e1.high;
        this.low = e1.low;
    }
}
const Qo = {
    get k () {
        return shadow(this, "k", [
            new Word64(1116352408, 3609767458),
            new Word64(1899447441, 602891725),
            new Word64(3049323471, 3964484399),
            new Word64(3921009573, 2173295548),
            new Word64(961987163, 4081628472),
            new Word64(1508970993, 3053834265),
            new Word64(2453635748, 2937671579),
            new Word64(2870763221, 3664609560),
            new Word64(3624381080, 2734883394),
            new Word64(310598401, 1164996542),
            new Word64(607225278, 1323610764),
            new Word64(1426881987, 3590304994),
            new Word64(1925078388, 4068182383),
            new Word64(2162078206, 991336113),
            new Word64(2614888103, 633803317),
            new Word64(3248222580, 3479774868),
            new Word64(3835390401, 2666613458),
            new Word64(4022224774, 944711139),
            new Word64(264347078, 2341262773),
            new Word64(604807628, 2007800933),
            new Word64(770255983, 1495990901),
            new Word64(1249150122, 1856431235),
            new Word64(1555081692, 3175218132),
            new Word64(1996064986, 2198950837),
            new Word64(2554220882, 3999719339),
            new Word64(2821834349, 766784016),
            new Word64(2952996808, 2566594879),
            new Word64(3210313671, 3203337956),
            new Word64(3336571891, 1034457026),
            new Word64(3584528711, 2466948901),
            new Word64(113926993, 3758326383),
            new Word64(338241895, 168717936),
            new Word64(666307205, 1188179964),
            new Word64(773529912, 1546045734),
            new Word64(1294757372, 1522805485),
            new Word64(1396182291, 2643833823),
            new Word64(1695183700, 2343527390),
            new Word64(1986661051, 1014477480),
            new Word64(2177026350, 1206759142),
            new Word64(2456956037, 344077627),
            new Word64(2730485921, 1290863460),
            new Word64(2820302411, 3158454273),
            new Word64(3259730800, 3505952657),
            new Word64(3345764771, 106217008),
            new Word64(3516065817, 3606008344),
            new Word64(3600352804, 1432725776),
            new Word64(4094571909, 1467031594),
            new Word64(275423344, 851169720),
            new Word64(430227734, 3100823752),
            new Word64(506948616, 1363258195),
            new Word64(659060556, 3750685593),
            new Word64(883997877, 3785050280),
            new Word64(958139571, 3318307427),
            new Word64(1322822218, 3812723403),
            new Word64(1537002063, 2003034995),
            new Word64(1747873779, 3602036899),
            new Word64(1955562222, 1575990012),
            new Word64(2024104815, 1125592928),
            new Word64(2227730452, 2716904306),
            new Word64(2361852424, 442776044),
            new Word64(2428436474, 593698344),
            new Word64(2756734187, 3733110249),
            new Word64(3204031479, 2999351573),
            new Word64(3329325298, 3815920427),
            new Word64(3391569614, 3928383900),
            new Word64(3515267271, 566280711),
            new Word64(3940187606, 3454069534),
            new Word64(4118630271, 4000239992),
            new Word64(116418474, 1914138554),
            new Word64(174292421, 2731055270),
            new Word64(289380356, 3203993006),
            new Word64(460393269, 320620315),
            new Word64(685471733, 587496836),
            new Word64(852142971, 1086792851),
            new Word64(1017036298, 365543100),
            new Word64(1126000580, 2618297676),
            new Word64(1288033470, 3409855158),
            new Word64(1501505948, 4234509866),
            new Word64(1607167915, 987167468),
            new Word64(1816402316, 1246189591)
        ]);
    }
};
function ch(e1, t, a, r, i) {
    e1.assign(t);
    e1.and(a);
    i.assign(t);
    i.not();
    i.and(r);
    e1.xor(i);
}
function maj(e1, t, a, r, i) {
    e1.assign(t);
    e1.and(a);
    i.assign(t);
    i.and(r);
    e1.xor(i);
    i.assign(a);
    i.and(r);
    e1.xor(i);
}
function sigma(e1, t, a) {
    e1.assign(t);
    e1.rotateRight(28);
    a.assign(t);
    a.rotateRight(34);
    e1.xor(a);
    a.assign(t);
    a.rotateRight(39);
    e1.xor(a);
}
function sigmaPrime(e1, t, a) {
    e1.assign(t);
    e1.rotateRight(14);
    a.assign(t);
    a.rotateRight(18);
    e1.xor(a);
    a.assign(t);
    a.rotateRight(41);
    e1.xor(a);
}
function littleSigma(e1, t, a) {
    e1.assign(t);
    e1.rotateRight(1);
    a.assign(t);
    a.rotateRight(8);
    e1.xor(a);
    a.assign(t);
    a.shiftRight(7);
    e1.xor(a);
}
function littleSigmaPrime(e1, t, a) {
    e1.assign(t);
    e1.rotateRight(19);
    a.assign(t);
    a.rotateRight(61);
    e1.xor(a);
    a.assign(t);
    a.shiftRight(6);
    e1.xor(a);
}
function calculateSHA512(e1, t, a, r = !1) {
    let i, n, s, o, c, l, h, u;
    if (r) {
        i = new Word64(3418070365, 3238371032);
        n = new Word64(1654270250, 914150663);
        s = new Word64(2438529370, 812702999);
        o = new Word64(355462360, 4144912697);
        c = new Word64(1731405415, 4290775857);
        l = new Word64(2394180231, 1750603025);
        h = new Word64(3675008525, 1694076839);
        u = new Word64(1203062813, 3204075428);
    } else {
        i = new Word64(1779033703, 4089235720);
        n = new Word64(3144134277, 2227873595);
        s = new Word64(1013904242, 4271175723);
        o = new Word64(2773480762, 1595750129);
        c = new Word64(1359893119, 2917565137);
        l = new Word64(2600822924, 725511199);
        h = new Word64(528734635, 4215389547);
        u = new Word64(1541459225, 327033209);
    }
    const d = 128 * Math.ceil((a + 17) / 128), f = new Uint8Array(d);
    let g, p;
    for(g = 0; g < a; ++g)f[g] = e1[t++];
    f[g++] = 128;
    const m = d - 16;
    g < m && (g = m);
    g += 11;
    f[g++] = a >>> 29 & 255;
    f[g++] = a >> 21 & 255;
    f[g++] = a >> 13 & 255;
    f[g++] = a >> 5 & 255;
    f[g++] = a << 3 & 255;
    const b = new Array(80);
    for(g = 0; g < 80; g++)b[g] = new Word64(0, 0);
    const { k: y } = Qo;
    let w = new Word64(0, 0), x = new Word64(0, 0), S = new Word64(0, 0), k = new Word64(0, 0), C = new Word64(0, 0), v = new Word64(0, 0), F = new Word64(0, 0), T = new Word64(0, 0);
    const O = new Word64(0, 0), M = new Word64(0, 0), D = new Word64(0, 0), R = new Word64(0, 0);
    let N, E;
    for(g = 0; g < d;){
        for(p = 0; p < 16; ++p){
            b[p].high = f[g] << 24 | f[g + 1] << 16 | f[g + 2] << 8 | f[g + 3];
            b[p].low = f[g + 4] << 24 | f[g + 5] << 16 | f[g + 6] << 8 | f[g + 7];
            g += 8;
        }
        for(p = 16; p < 80; ++p){
            N = b[p];
            littleSigmaPrime(N, b[p - 2], R);
            N.add(b[p - 7]);
            littleSigma(D, b[p - 15], R);
            N.add(D);
            N.add(b[p - 16]);
        }
        w.assign(i);
        x.assign(n);
        S.assign(s);
        k.assign(o);
        C.assign(c);
        v.assign(l);
        F.assign(h);
        T.assign(u);
        for(p = 0; p < 80; ++p){
            O.assign(T);
            sigmaPrime(D, C, R);
            O.add(D);
            ch(D, C, v, F, R);
            O.add(D);
            O.add(y[p]);
            O.add(b[p]);
            sigma(M, w, R);
            maj(D, w, x, S, R);
            M.add(D);
            N = T;
            T = F;
            F = v;
            v = C;
            k.add(O);
            C = k;
            k = S;
            S = x;
            x = w;
            N.assign(O);
            N.add(M);
            w = N;
        }
        i.add(w);
        n.add(x);
        s.add(S);
        o.add(k);
        c.add(C);
        l.add(v);
        h.add(F);
        u.add(T);
    }
    if (r) {
        E = new Uint8Array(48);
        i.copyTo(E, 0);
        n.copyTo(E, 8);
        s.copyTo(E, 16);
        o.copyTo(E, 24);
        c.copyTo(E, 32);
        l.copyTo(E, 40);
    } else {
        E = new Uint8Array(64);
        i.copyTo(E, 0);
        n.copyTo(E, 8);
        s.copyTo(E, 16);
        o.copyTo(E, 24);
        c.copyTo(E, 32);
        l.copyTo(E, 40);
        h.copyTo(E, 48);
        u.copyTo(E, 56);
    }
    return E;
}
const ec = {
    get k () {
        return shadow(this, "k", [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ]);
    }
};
function rotr(e1, t) {
    return e1 >>> t | e1 << 32 - t;
}
function calculate_sha256_ch(e1, t, a) {
    return e1 & t ^ ~e1 & a;
}
function calculate_sha256_maj(e1, t, a) {
    return e1 & t ^ e1 & a ^ t & a;
}
function calculate_sha256_sigma(e1) {
    return rotr(e1, 2) ^ rotr(e1, 13) ^ rotr(e1, 22);
}
function calculate_sha256_sigmaPrime(e1) {
    return rotr(e1, 6) ^ rotr(e1, 11) ^ rotr(e1, 25);
}
function calculate_sha256_littleSigma(e1) {
    return rotr(e1, 7) ^ rotr(e1, 18) ^ e1 >>> 3;
}
function calculateSHA256(e1, t, a) {
    let r = 1779033703, i = 3144134277, n = 1013904242, s = 2773480762, o = 1359893119, c = 2600822924, l = 528734635, h = 1541459225;
    const u = 64 * Math.ceil((a + 9) / 64), d = new Uint8Array(u);
    let f, g;
    for(f = 0; f < a; ++f)d[f] = e1[t++];
    d[f++] = 128;
    const p = u - 8;
    f < p && (f = p);
    f += 3;
    d[f++] = a >>> 29 & 255;
    d[f++] = a >> 21 & 255;
    d[f++] = a >> 13 & 255;
    d[f++] = a >> 5 & 255;
    d[f++] = a << 3 & 255;
    const m = new Uint32Array(64), { k: b } = ec;
    for(f = 0; f < u;){
        for(g = 0; g < 16; ++g){
            m[g] = d[f] << 24 | d[f + 1] << 16 | d[f + 2] << 8 | d[f + 3];
            f += 4;
        }
        for(g = 16; g < 64; ++g)m[g] = (rotr(y = m[g - 2], 17) ^ rotr(y, 19) ^ y >>> 10) + m[g - 7] + calculate_sha256_littleSigma(m[g - 15]) + m[g - 16] | 0;
        let e1, t, a = r, u = i, p = n, w = s, x = o, S = c, k = l, C = h;
        for(g = 0; g < 64; ++g){
            e1 = C + calculate_sha256_sigmaPrime(x) + calculate_sha256_ch(x, S, k) + b[g] + m[g];
            t = calculate_sha256_sigma(a) + calculate_sha256_maj(a, u, p);
            C = k;
            k = S;
            S = x;
            x = w + e1 | 0;
            w = p;
            p = u;
            u = a;
            a = e1 + t | 0;
        }
        r = r + a | 0;
        i = i + u | 0;
        n = n + p | 0;
        s = s + w | 0;
        o = o + x | 0;
        c = c + S | 0;
        l = l + k | 0;
        h = h + C | 0;
    }
    var y;
    return new Uint8Array([
        r >> 24 & 255,
        r >> 16 & 255,
        r >> 8 & 255,
        255 & r,
        i >> 24 & 255,
        i >> 16 & 255,
        i >> 8 & 255,
        255 & i,
        n >> 24 & 255,
        n >> 16 & 255,
        n >> 8 & 255,
        255 & n,
        s >> 24 & 255,
        s >> 16 & 255,
        s >> 8 & 255,
        255 & s,
        o >> 24 & 255,
        o >> 16 & 255,
        o >> 8 & 255,
        255 & o,
        c >> 24 & 255,
        c >> 16 & 255,
        c >> 8 & 255,
        255 & c,
        l >> 24 & 255,
        l >> 16 & 255,
        l >> 8 & 255,
        255 & l,
        h >> 24 & 255,
        h >> 16 & 255,
        h >> 8 & 255,
        255 & h
    ]);
}
class DecryptStream extends DecodeStream {
    constructor(e1, t, a){
        super(t);
        this.str = e1;
        this.dict = e1.dict;
        this.decrypt = a;
        this.nextChunk = null;
        this.initialized = !1;
    }
    readBlock() {
        let e1;
        if (this.initialized) e1 = this.nextChunk;
        else {
            e1 = this.str.getBytes(512);
            this.initialized = !0;
        }
        if (!e1?.length) {
            this.eof = !0;
            return;
        }
        this.nextChunk = this.str.getBytes(512);
        const t = this.nextChunk?.length > 0;
        e1 = (0, this.decrypt)(e1, !t);
        const a = this.bufferLength, r = a + e1.length;
        this.ensureBuffer(r).set(e1, a);
        this.bufferLength = r;
    }
}
class ARCFourCipher {
    constructor(e1){
        this.a = 0;
        this.b = 0;
        const t = new Uint8Array(256), a = e1.length;
        for(let e1 = 0; e1 < 256; ++e1)t[e1] = e1;
        for(let r = 0, i = 0; r < 256; ++r){
            const n = t[r];
            i = i + n + e1[r % a] & 255;
            t[r] = t[i];
            t[i] = n;
        }
        this.s = t;
    }
    encryptBlock(e1) {
        let t = this.a, a = this.b;
        const r = this.s, i = e1.length, n = new Uint8Array(i);
        for(let s = 0; s < i; ++s){
            t = t + 1 & 255;
            const i = r[t];
            a = a + i & 255;
            const o = r[a];
            r[t] = o;
            r[a] = i;
            n[s] = e1[s] ^ r[i + o & 255];
        }
        this.a = t;
        this.b = a;
        return n;
    }
    decryptBlock(e1) {
        return this.encryptBlock(e1);
    }
    encrypt(e1) {
        return this.encryptBlock(e1);
    }
}
class NullCipher {
    decryptBlock(e1) {
        return e1;
    }
    encrypt(e1) {
        return e1;
    }
}
class AESBaseCipher {
    _s = new Uint8Array([
        99,
        124,
        119,
        123,
        242,
        107,
        111,
        197,
        48,
        1,
        103,
        43,
        254,
        215,
        171,
        118,
        202,
        130,
        201,
        125,
        250,
        89,
        71,
        240,
        173,
        212,
        162,
        175,
        156,
        164,
        114,
        192,
        183,
        253,
        147,
        38,
        54,
        63,
        247,
        204,
        52,
        165,
        229,
        241,
        113,
        216,
        49,
        21,
        4,
        199,
        35,
        195,
        24,
        150,
        5,
        154,
        7,
        18,
        128,
        226,
        235,
        39,
        178,
        117,
        9,
        131,
        44,
        26,
        27,
        110,
        90,
        160,
        82,
        59,
        214,
        179,
        41,
        227,
        47,
        132,
        83,
        209,
        0,
        237,
        32,
        252,
        177,
        91,
        106,
        203,
        190,
        57,
        74,
        76,
        88,
        207,
        208,
        239,
        170,
        251,
        67,
        77,
        51,
        133,
        69,
        249,
        2,
        127,
        80,
        60,
        159,
        168,
        81,
        163,
        64,
        143,
        146,
        157,
        56,
        245,
        188,
        182,
        218,
        33,
        16,
        255,
        243,
        210,
        205,
        12,
        19,
        236,
        95,
        151,
        68,
        23,
        196,
        167,
        126,
        61,
        100,
        93,
        25,
        115,
        96,
        129,
        79,
        220,
        34,
        42,
        144,
        136,
        70,
        238,
        184,
        20,
        222,
        94,
        11,
        219,
        224,
        50,
        58,
        10,
        73,
        6,
        36,
        92,
        194,
        211,
        172,
        98,
        145,
        149,
        228,
        121,
        231,
        200,
        55,
        109,
        141,
        213,
        78,
        169,
        108,
        86,
        244,
        234,
        101,
        122,
        174,
        8,
        186,
        120,
        37,
        46,
        28,
        166,
        180,
        198,
        232,
        221,
        116,
        31,
        75,
        189,
        139,
        138,
        112,
        62,
        181,
        102,
        72,
        3,
        246,
        14,
        97,
        53,
        87,
        185,
        134,
        193,
        29,
        158,
        225,
        248,
        152,
        17,
        105,
        217,
        142,
        148,
        155,
        30,
        135,
        233,
        206,
        85,
        40,
        223,
        140,
        161,
        137,
        13,
        191,
        230,
        66,
        104,
        65,
        153,
        45,
        15,
        176,
        84,
        187,
        22
    ]);
    _inv_s = new Uint8Array([
        82,
        9,
        106,
        213,
        48,
        54,
        165,
        56,
        191,
        64,
        163,
        158,
        129,
        243,
        215,
        251,
        124,
        227,
        57,
        130,
        155,
        47,
        255,
        135,
        52,
        142,
        67,
        68,
        196,
        222,
        233,
        203,
        84,
        123,
        148,
        50,
        166,
        194,
        35,
        61,
        238,
        76,
        149,
        11,
        66,
        250,
        195,
        78,
        8,
        46,
        161,
        102,
        40,
        217,
        36,
        178,
        118,
        91,
        162,
        73,
        109,
        139,
        209,
        37,
        114,
        248,
        246,
        100,
        134,
        104,
        152,
        22,
        212,
        164,
        92,
        204,
        93,
        101,
        182,
        146,
        108,
        112,
        72,
        80,
        253,
        237,
        185,
        218,
        94,
        21,
        70,
        87,
        167,
        141,
        157,
        132,
        144,
        216,
        171,
        0,
        140,
        188,
        211,
        10,
        247,
        228,
        88,
        5,
        184,
        179,
        69,
        6,
        208,
        44,
        30,
        143,
        202,
        63,
        15,
        2,
        193,
        175,
        189,
        3,
        1,
        19,
        138,
        107,
        58,
        145,
        17,
        65,
        79,
        103,
        220,
        234,
        151,
        242,
        207,
        206,
        240,
        180,
        230,
        115,
        150,
        172,
        116,
        34,
        231,
        173,
        53,
        133,
        226,
        249,
        55,
        232,
        28,
        117,
        223,
        110,
        71,
        241,
        26,
        113,
        29,
        41,
        197,
        137,
        111,
        183,
        98,
        14,
        170,
        24,
        190,
        27,
        252,
        86,
        62,
        75,
        198,
        210,
        121,
        32,
        154,
        219,
        192,
        254,
        120,
        205,
        90,
        244,
        31,
        221,
        168,
        51,
        136,
        7,
        199,
        49,
        177,
        18,
        16,
        89,
        39,
        128,
        236,
        95,
        96,
        81,
        127,
        169,
        25,
        181,
        74,
        13,
        45,
        229,
        122,
        159,
        147,
        201,
        156,
        239,
        160,
        224,
        59,
        77,
        174,
        42,
        245,
        176,
        200,
        235,
        187,
        60,
        131,
        83,
        153,
        97,
        23,
        43,
        4,
        126,
        186,
        119,
        214,
        38,
        225,
        105,
        20,
        99,
        85,
        33,
        12,
        125
    ]);
    _mix = new Uint32Array([
        0,
        235474187,
        470948374,
        303765277,
        941896748,
        908933415,
        607530554,
        708780849,
        1883793496,
        2118214995,
        1817866830,
        1649639237,
        1215061108,
        1181045119,
        1417561698,
        1517767529,
        3767586992,
        4003061179,
        4236429990,
        4069246893,
        3635733660,
        3602770327,
        3299278474,
        3400528769,
        2430122216,
        2664543715,
        2362090238,
        2193862645,
        2835123396,
        2801107407,
        3035535058,
        3135740889,
        3678124923,
        3576870512,
        3341394285,
        3374361702,
        3810496343,
        3977675356,
        4279080257,
        4043610186,
        2876494627,
        2776292904,
        3076639029,
        3110650942,
        2472011535,
        2640243204,
        2403728665,
        2169303058,
        1001089995,
        899835584,
        666464733,
        699432150,
        59727847,
        226906860,
        530400753,
        294930682,
        1273168787,
        1172967064,
        1475418501,
        1509430414,
        1942435775,
        2110667444,
        1876241833,
        1641816226,
        2910219766,
        2743034109,
        2976151520,
        3211623147,
        2505202138,
        2606453969,
        2302690252,
        2269728455,
        3711829422,
        3543599269,
        3240894392,
        3475313331,
        3843699074,
        3943906441,
        4178062228,
        4144047775,
        1306967366,
        1139781709,
        1374988112,
        1610459739,
        1975683434,
        2076935265,
        1775276924,
        1742315127,
        1034867998,
        866637845,
        566021896,
        800440835,
        92987698,
        193195065,
        429456164,
        395441711,
        1984812685,
        2017778566,
        1784663195,
        1683407248,
        1315562145,
        1080094634,
        1383856311,
        1551037884,
        101039829,
        135050206,
        437757123,
        337553864,
        1042385657,
        807962610,
        573804783,
        742039012,
        2531067453,
        2564033334,
        2328828971,
        2227573024,
        2935566865,
        2700099354,
        3001755655,
        3168937228,
        3868552805,
        3902563182,
        4203181171,
        4102977912,
        3736164937,
        3501741890,
        3265478751,
        3433712980,
        1106041591,
        1340463100,
        1576976609,
        1408749034,
        2043211483,
        2009195472,
        1708848333,
        1809054150,
        832877231,
        1068351396,
        766945465,
        599762354,
        159417987,
        126454664,
        361929877,
        463180190,
        2709260871,
        2943682380,
        3178106961,
        3009879386,
        2572697195,
        2538681184,
        2236228733,
        2336434550,
        3509871135,
        3745345300,
        3441850377,
        3274667266,
        3910161971,
        3877198648,
        4110568485,
        4211818798,
        2597806476,
        2497604743,
        2261089178,
        2295101073,
        2733856160,
        2902087851,
        3202437046,
        2968011453,
        3936291284,
        3835036895,
        4136440770,
        4169408201,
        3535486456,
        3702665459,
        3467192302,
        3231722213,
        2051518780,
        1951317047,
        1716890410,
        1750902305,
        1113818384,
        1282050075,
        1584504582,
        1350078989,
        168810852,
        67556463,
        371049330,
        404016761,
        841739592,
        1008918595,
        775550814,
        540080725,
        3969562369,
        3801332234,
        4035489047,
        4269907996,
        3569255213,
        3669462566,
        3366754619,
        3332740144,
        2631065433,
        2463879762,
        2160117071,
        2395588676,
        2767645557,
        2868897406,
        3102011747,
        3069049960,
        202008497,
        33778362,
        270040487,
        504459436,
        875451293,
        975658646,
        675039627,
        641025152,
        2084704233,
        1917518562,
        1615861247,
        1851332852,
        1147550661,
        1248802510,
        1484005843,
        1451044056,
        933301370,
        967311729,
        733156972,
        632953703,
        260388950,
        25965917,
        328671808,
        496906059,
        1206477858,
        1239443753,
        1543208500,
        1441952575,
        2144161806,
        1908694277,
        1675577880,
        1842759443,
        3610369226,
        3644379585,
        3408119516,
        3307916247,
        4011190502,
        3776767469,
        4077384432,
        4245618683,
        2809771154,
        2842737049,
        3144396420,
        3043140495,
        2673705150,
        2438237621,
        2203032232,
        2370213795
    ]);
    _mixCol = new Uint8Array(256).map((e1, t)=>t < 128 ? t << 1 : t << 1 ^ 27);
    constructor(){
        this.buffer = new Uint8Array(16);
        this.bufferPosition = 0;
    }
    _expandKey(e1) {
        unreachable("Cannot call `_expandKey` on the base class");
    }
    _decrypt(e1, t) {
        let a, r, i;
        const n = new Uint8Array(16);
        n.set(e1);
        for(let e1 = 0, a = this._keySize; e1 < 16; ++e1, ++a)n[e1] ^= t[a];
        for(let e1 = this._cyclesOfRepetition - 1; e1 >= 1; --e1){
            a = n[13];
            n[13] = n[9];
            n[9] = n[5];
            n[5] = n[1];
            n[1] = a;
            a = n[14];
            r = n[10];
            n[14] = n[6];
            n[10] = n[2];
            n[6] = a;
            n[2] = r;
            a = n[15];
            r = n[11];
            i = n[7];
            n[15] = n[3];
            n[11] = a;
            n[7] = r;
            n[3] = i;
            for(let e1 = 0; e1 < 16; ++e1)n[e1] = this._inv_s[n[e1]];
            for(let a = 0, r = 16 * e1; a < 16; ++a, ++r)n[a] ^= t[r];
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = this._mix[n[e1]], r = this._mix[n[e1 + 1]], i = this._mix[n[e1 + 2]], s = this._mix[n[e1 + 3]];
                a = t ^ r >>> 8 ^ r << 24 ^ i >>> 16 ^ i << 16 ^ s >>> 24 ^ s << 8;
                n[e1] = a >>> 24 & 255;
                n[e1 + 1] = a >> 16 & 255;
                n[e1 + 2] = a >> 8 & 255;
                n[e1 + 3] = 255 & a;
            }
        }
        a = n[13];
        n[13] = n[9];
        n[9] = n[5];
        n[5] = n[1];
        n[1] = a;
        a = n[14];
        r = n[10];
        n[14] = n[6];
        n[10] = n[2];
        n[6] = a;
        n[2] = r;
        a = n[15];
        r = n[11];
        i = n[7];
        n[15] = n[3];
        n[11] = a;
        n[7] = r;
        n[3] = i;
        for(let e1 = 0; e1 < 16; ++e1){
            n[e1] = this._inv_s[n[e1]];
            n[e1] ^= t[e1];
        }
        return n;
    }
    _encrypt(e1, t) {
        const a = this._s;
        let r, i, n;
        const s = new Uint8Array(16);
        s.set(e1);
        for(let e1 = 0; e1 < 16; ++e1)s[e1] ^= t[e1];
        for(let e1 = 1; e1 < this._cyclesOfRepetition; e1++){
            for(let e1 = 0; e1 < 16; ++e1)s[e1] = a[s[e1]];
            n = s[1];
            s[1] = s[5];
            s[5] = s[9];
            s[9] = s[13];
            s[13] = n;
            n = s[2];
            i = s[6];
            s[2] = s[10];
            s[6] = s[14];
            s[10] = n;
            s[14] = i;
            n = s[3];
            i = s[7];
            r = s[11];
            s[3] = s[15];
            s[7] = n;
            s[11] = i;
            s[15] = r;
            for(let e1 = 0; e1 < 16; e1 += 4){
                const t = s[e1], a = s[e1 + 1], i = s[e1 + 2], n = s[e1 + 3];
                r = t ^ a ^ i ^ n;
                s[e1] ^= r ^ this._mixCol[t ^ a];
                s[e1 + 1] ^= r ^ this._mixCol[a ^ i];
                s[e1 + 2] ^= r ^ this._mixCol[i ^ n];
                s[e1 + 3] ^= r ^ this._mixCol[n ^ t];
            }
            for(let a = 0, r = 16 * e1; a < 16; ++a, ++r)s[a] ^= t[r];
        }
        for(let e1 = 0; e1 < 16; ++e1)s[e1] = a[s[e1]];
        n = s[1];
        s[1] = s[5];
        s[5] = s[9];
        s[9] = s[13];
        s[13] = n;
        n = s[2];
        i = s[6];
        s[2] = s[10];
        s[6] = s[14];
        s[10] = n;
        s[14] = i;
        n = s[3];
        i = s[7];
        r = s[11];
        s[3] = s[15];
        s[7] = n;
        s[11] = i;
        s[15] = r;
        for(let e1 = 0, a = this._keySize; e1 < 16; ++e1, ++a)s[e1] ^= t[a];
        return s;
    }
    _decryptBlock2(e1, t) {
        const a = e1.length;
        let r = this.buffer, i = this.bufferPosition;
        const n = [];
        let s = this.iv;
        for(let t = 0; t < a; ++t){
            r[i] = e1[t];
            ++i;
            if (i < 16) continue;
            const a = this._decrypt(r, this._key);
            for(let e1 = 0; e1 < 16; ++e1)a[e1] ^= s[e1];
            s = r;
            n.push(a);
            r = new Uint8Array(16);
            i = 0;
        }
        this.buffer = r;
        this.bufferLength = i;
        this.iv = s;
        if (0 === n.length) return new Uint8Array(0);
        let o = 16 * n.length;
        if (t) {
            const e1 = n.at(-1);
            let t = e1[15];
            if (t <= 16) {
                for(let a = 15, r = 16 - t; a >= r; --a)if (e1[a] !== t) {
                    t = 0;
                    break;
                }
                o -= t;
                n[n.length - 1] = e1.subarray(0, 16 - t);
            }
        }
        const c = new Uint8Array(o);
        for(let e1 = 0, t = 0, a = n.length; e1 < a; ++e1, t += 16)c.set(n[e1], t);
        return c;
    }
    decryptBlock(e1, t, a = null) {
        const r = e1.length, i = this.buffer;
        let n = this.bufferPosition;
        if (a) this.iv = a;
        else {
            for(let t = 0; n < 16 && t < r; ++t, ++n)i[n] = e1[t];
            if (n < 16) {
                this.bufferLength = n;
                return new Uint8Array(0);
            }
            this.iv = i;
            e1 = e1.subarray(16);
        }
        this.buffer = new Uint8Array(16);
        this.bufferLength = 0;
        this.decryptBlock = this._decryptBlock2;
        return this.decryptBlock(e1, t);
    }
    encrypt(e1, t) {
        const a = e1.length;
        let r = this.buffer, i = this.bufferPosition;
        const n = [];
        t ||= new Uint8Array(16);
        for(let s = 0; s < a; ++s){
            r[i] = e1[s];
            ++i;
            if (i < 16) continue;
            for(let e1 = 0; e1 < 16; ++e1)r[e1] ^= t[e1];
            const a = this._encrypt(r, this._key);
            t = a;
            n.push(a);
            r = new Uint8Array(16);
            i = 0;
        }
        this.buffer = r;
        this.bufferLength = i;
        this.iv = t;
        if (0 === n.length) return new Uint8Array(0);
        const s = 16 * n.length, o = new Uint8Array(s);
        for(let e1 = 0, t = 0, a = n.length; e1 < a; ++e1, t += 16)o.set(n[e1], t);
        return o;
    }
}
class AES128Cipher extends AESBaseCipher {
    _rcon = new Uint8Array([
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141
    ]);
    constructor(e1){
        super();
        this._cyclesOfRepetition = 10;
        this._keySize = 160;
        this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, a = this._rcon, r = new Uint8Array(176);
        r.set(e1);
        for(let e1 = 16, i = 1; e1 < 176; ++i){
            let n = r[e1 - 3], s = r[e1 - 2], o = r[e1 - 1], c = r[e1 - 4];
            n = t[n];
            s = t[s];
            o = t[o];
            c = t[c];
            n ^= a[i];
            for(let t = 0; t < 4; ++t){
                r[e1] = n ^= r[e1 - 16];
                e1++;
                r[e1] = s ^= r[e1 - 16];
                e1++;
                r[e1] = o ^= r[e1 - 16];
                e1++;
                r[e1] = c ^= r[e1 - 16];
                e1++;
            }
        }
        return r;
    }
}
class AES256Cipher extends AESBaseCipher {
    constructor(e1){
        super();
        this._cyclesOfRepetition = 14;
        this._keySize = 224;
        this._key = this._expandKey(e1);
    }
    _expandKey(e1) {
        const t = this._s, a = new Uint8Array(240);
        a.set(e1);
        let r, i, n, s, o = 1;
        for(let e1 = 32, c = 1; e1 < 240; ++c){
            if (e1 % 32 == 16) {
                r = t[r];
                i = t[i];
                n = t[n];
                s = t[s];
            } else if (e1 % 32 == 0) {
                r = a[e1 - 3];
                i = a[e1 - 2];
                n = a[e1 - 1];
                s = a[e1 - 4];
                r = t[r];
                i = t[i];
                n = t[n];
                s = t[s];
                r ^= o;
                (o <<= 1) >= 256 && (o = 255 & (27 ^ o));
            }
            for(let t = 0; t < 4; ++t){
                a[e1] = r ^= a[e1 - 32];
                e1++;
                a[e1] = i ^= a[e1 - 32];
                e1++;
                a[e1] = n ^= a[e1 - 32];
                e1++;
                a[e1] = s ^= a[e1 - 32];
                e1++;
            }
        }
        return a;
    }
}
class PDFBase {
    _hash(e1, t, a) {
        unreachable("Abstract method `_hash` called");
    }
    checkOwnerPassword(e1, t, a, r) {
        const i = new Uint8Array(e1.length + 56);
        i.set(e1, 0);
        i.set(t, e1.length);
        i.set(a, e1.length + t.length);
        return isArrayEqual(this._hash(e1, i, a), r);
    }
    checkUserPassword(e1, t, a) {
        const r = new Uint8Array(e1.length + 8);
        r.set(e1, 0);
        r.set(t, e1.length);
        return isArrayEqual(this._hash(e1, r, []), a);
    }
    getOwnerKey(e1, t, a, r) {
        const i = new Uint8Array(e1.length + 56);
        i.set(e1, 0);
        i.set(t, e1.length);
        i.set(a, e1.length + t.length);
        const n = this._hash(e1, i, a);
        return new AES256Cipher(n).decryptBlock(r, !1, new Uint8Array(16));
    }
    getUserKey(e1, t, a) {
        const r = new Uint8Array(e1.length + 8);
        r.set(e1, 0);
        r.set(t, e1.length);
        const i = this._hash(e1, r, []);
        return new AES256Cipher(i).decryptBlock(a, !1, new Uint8Array(16));
    }
}
class PDF17 extends PDFBase {
    _hash(e1, t, a) {
        return calculateSHA256(t, 0, t.length);
    }
}
class PDF20 extends PDFBase {
    _hash(e1, t, a) {
        let r = calculateSHA256(t, 0, t.length).subarray(0, 32), i = [
            0
        ], n = 0;
        for(; n < 64 || i.at(-1) > n - 32;){
            const t = e1.length + r.length + a.length, l = new Uint8Array(t);
            let h = 0;
            l.set(e1, h);
            h += e1.length;
            l.set(r, h);
            h += r.length;
            l.set(a, h);
            const u = new Uint8Array(64 * t);
            for(let e1 = 0, a = 0; e1 < 64; e1++, a += t)u.set(l, a);
            i = new AES128Cipher(r.subarray(0, 16)).encrypt(u, r.subarray(16, 32));
            const d = Math.sumPrecise(i.slice(0, 16)) % 3;
            0 === d ? r = calculateSHA256(i, 0, i.length) : 1 === d ? r = (s = i, o = 0, c = i.length, calculateSHA512(s, o, c, !0)) : 2 === d && (r = calculateSHA512(i, 0, i.length));
            n++;
        }
        var s, o, c;
        return r.subarray(0, 32);
    }
}
class CipherTransform {
    constructor(e1, t){
        this.StringCipherConstructor = e1;
        this.StreamCipherConstructor = t;
    }
    createStream(e1, t) {
        const a = new this.StreamCipherConstructor;
        return new DecryptStream(e1, t, function cipherTransformDecryptStream(e1, t) {
            return a.decryptBlock(e1, t);
        });
    }
    decryptString(e1) {
        const t = new this.StringCipherConstructor;
        let a = stringToBytes(e1);
        a = t.decryptBlock(a, !0);
        return bytesToString(a);
    }
    encryptString(e1) {
        const t = new this.StringCipherConstructor;
        if (t instanceof AESBaseCipher) {
            const a = 16 - e1.length % 16;
            e1 += String.fromCharCode(a).repeat(a);
            const r = new Uint8Array(16);
            crypto.getRandomValues(r);
            let i = stringToBytes(e1);
            i = t.encrypt(i, r);
            const n = new Uint8Array(16 + i.length);
            n.set(r);
            n.set(i, 16);
            return bytesToString(n);
        }
        let a = stringToBytes(e1);
        a = t.encrypt(a);
        return bytesToString(a);
    }
}
class CipherTransformFactory {
    static get _defaultPasswordBytes() {
        return shadow(this, "_defaultPasswordBytes", new Uint8Array([
            40,
            191,
            78,
            94,
            78,
            117,
            138,
            65,
            100,
            0,
            78,
            86,
            255,
            250,
            1,
            8,
            46,
            46,
            0,
            182,
            208,
            104,
            62,
            128,
            47,
            12,
            169,
            254,
            100,
            83,
            105,
            122
        ]));
    }
    #Oe(e1, t, a, r, i, n, s, o, c, l, h, u) {
        if (t) {
            const e1 = Math.min(127, t.length);
            t = t.subarray(0, e1);
        } else t = [];
        const d = 6 === e1 ? new PDF20 : new PDF17;
        return d.checkUserPassword(t, o, s) ? d.getUserKey(t, c, h) : t.length && d.checkOwnerPassword(t, r, n, a) ? d.getOwnerKey(t, i, n, l) : null;
    }
    #Me(e1, t, a, r, i, n, s, o) {
        const c = 40 + a.length + e1.length, l = new Uint8Array(c);
        let h, u, d = 0;
        if (t) {
            u = Math.min(32, t.length);
            for(; d < u; ++d)l[d] = t[d];
        }
        h = 0;
        for(; d < 32;)l[d++] = CipherTransformFactory._defaultPasswordBytes[h++];
        l.set(a, d);
        d += a.length;
        l[d++] = 255 & i;
        l[d++] = i >> 8 & 255;
        l[d++] = i >> 16 & 255;
        l[d++] = i >>> 24 & 255;
        l.set(e1, d);
        d += e1.length;
        if (n >= 4 && !o) {
            l.fill(255, d, d + 4);
            d += 4;
        }
        let f = calculateMD5(l, 0, d);
        const g = s >> 3;
        if (n >= 3) for(h = 0; h < 50; ++h)f = calculateMD5(f, 0, g);
        const p = f.subarray(0, g);
        let m, b;
        if (n >= 3) {
            d = 0;
            l.set(CipherTransformFactory._defaultPasswordBytes, d);
            d += 32;
            l.set(e1, d);
            d += e1.length;
            m = new ARCFourCipher(p);
            b = m.encryptBlock(calculateMD5(l, 0, d));
            u = p.length;
            const t = new Uint8Array(u);
            for(h = 1; h <= 19; ++h){
                for(let e1 = 0; e1 < u; ++e1)t[e1] = p[e1] ^ h;
                m = new ARCFourCipher(t);
                b = m.encryptBlock(b);
            }
        } else {
            m = new ARCFourCipher(p);
            b = m.encryptBlock(CipherTransformFactory._defaultPasswordBytes);
        }
        return b.every((e1, t)=>r[t] === e1) ? p : null;
    }
    #De(e1, t, a, r) {
        const i = new Uint8Array(32);
        let n = 0;
        const s = Math.min(32, e1.length);
        for(; n < s; ++n)i[n] = e1[n];
        let o = 0;
        for(; n < 32;)i[n++] = CipherTransformFactory._defaultPasswordBytes[o++];
        let c = calculateMD5(i, 0, n);
        const l = r >> 3;
        if (a >= 3) for(o = 0; o < 50; ++o)c = calculateMD5(c, 0, c.length);
        let h, u;
        if (a >= 3) {
            u = t;
            const e1 = new Uint8Array(l);
            for(o = 19; o >= 0; o--){
                for(let t = 0; t < l; ++t)e1[t] = c[t] ^ o;
                h = new ARCFourCipher(e1);
                u = h.encryptBlock(u);
            }
        } else {
            h = new ARCFourCipher(c.subarray(0, l));
            u = h.encryptBlock(t);
        }
        return u;
    }
    #Be(e1, t, a, r = !1) {
        const i = a.length, n = new Uint8Array(i + 9);
        n.set(a);
        let s = i;
        n[s++] = 255 & e1;
        n[s++] = e1 >> 8 & 255;
        n[s++] = e1 >> 16 & 255;
        n[s++] = 255 & t;
        n[s++] = t >> 8 & 255;
        if (r) {
            n[s++] = 115;
            n[s++] = 65;
            n[s++] = 108;
            n[s++] = 84;
        }
        return calculateMD5(n, 0, s).subarray(0, Math.min(i + 5, 16));
    }
    #Re(e1, t, a, r, i) {
        if (!(t instanceof Name)) throw new FormatError("Invalid crypt filter name.");
        const n = this, s = e1.get(t.name), o = s?.get("CFM");
        if (!o || "None" === o.name) return function() {
            return new NullCipher;
        };
        if ("V2" === o.name) return function() {
            return new ARCFourCipher(n.#Be(a, r, i, !1));
        };
        if ("AESV2" === o.name) return function() {
            return new AES128Cipher(n.#Be(a, r, i, !0));
        };
        if ("AESV3" === o.name) return function() {
            return new AES256Cipher(i);
        };
        throw new FormatError("Unknown crypto method");
    }
    constructor(e1, t, a){
        const r = e1.get("Filter");
        if (!isName(r, "Standard")) throw new FormatError("unknown encryption method");
        this.filterName = r.name;
        this.dict = e1;
        const i = e1.get("V");
        if (!Number.isInteger(i) || 1 !== i && 2 !== i && 4 !== i && 5 !== i) throw new FormatError("unsupported encryption algorithm");
        this.algorithm = i;
        let n = e1.get("Length");
        if (!n) if (i <= 3) n = 40;
        else {
            const t = e1.get("CF"), a = e1.get("StmF");
            if (t instanceof Dict && a instanceof Name) {
                t.suppressEncryption = !0;
                const e1 = t.get(a.name);
                n = e1?.get("Length") || 128;
                n < 40 && (n <<= 3);
            }
        }
        if (!Number.isInteger(n) || n < 40 || n % 8 != 0) throw new FormatError("invalid key length");
        const s = stringToBytes(e1.get("O")), o = stringToBytes(e1.get("U")), c = s.subarray(0, 32), l = o.subarray(0, 32), h = e1.get("P"), u = e1.get("R"), d = (4 === i || 5 === i) && !1 !== e1.get("EncryptMetadata");
        this.encryptMetadata = d;
        const f = stringToBytes(t);
        let g, p;
        if (a) {
            if (6 === u) try {
                a = utf8StringToString(a);
            } catch  {
                warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
            }
            g = stringToBytes(a);
        }
        if (5 !== i) p = this.#Me(f, g, c, l, h, u, n, d);
        else {
            const t = s.subarray(32, 40), a = s.subarray(40, 48), r = o.subarray(0, 48), i = o.subarray(32, 40), n = o.subarray(40, 48), h = stringToBytes(e1.get("OE")), d = stringToBytes(e1.get("UE")), f = stringToBytes(e1.get("Perms"));
            p = this.#Oe(u, g, c, t, a, r, l, i, n, h, d, f);
        }
        if (!p) {
            if (!a) throw new PasswordException("No password given", Gt);
            const e1 = this.#De(g, c, u, n);
            p = this.#Me(f, e1, c, l, h, u, n, d);
        }
        if (!p) throw new PasswordException("Incorrect Password", Vt);
        if (4 === i && p.length < 16) {
            this.encryptionKey = new Uint8Array(16);
            this.encryptionKey.set(p);
        } else this.encryptionKey = p;
        if (i >= 4) {
            const t = e1.get("CF");
            t instanceof Dict && (t.suppressEncryption = !0);
            this.cf = t;
            this.stmf = e1.get("StmF") || Name.get("Identity");
            this.strf = e1.get("StrF") || Name.get("Identity");
            this.eff = e1.get("EFF") || this.stmf;
        }
    }
    createCipherTransform(e1, t) {
        if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#Re(this.cf, this.strf, e1, t, this.encryptionKey), this.#Re(this.cf, this.stmf, e1, t, this.encryptionKey));
        const a = this.#Be(e1, t, this.encryptionKey, !1), cipherConstructor = function() {
            return new ARCFourCipher(a);
        };
        return new CipherTransform(cipherConstructor, cipherConstructor);
    }
}
class XRef {
    #Ne = null;
    constructor(e1, t){
        this.stream = e1;
        this.pdfManager = t;
        this.entries = [];
        this._xrefStms = new Set;
        this._cacheMap = new Map;
        this._pendingRefs = new RefSet;
        this._newPersistentRefNum = null;
        this._newTemporaryRefNum = null;
        this._persistentRefsCache = null;
    }
    getNewPersistentRef(e1) {
        null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
        const t = this._newPersistentRefNum++;
        this._cacheMap.set(t, e1);
        return Ref.get(t, 0);
    }
    getNewTemporaryRef() {
        if (null === this._newTemporaryRefNum) {
            this._newTemporaryRefNum = this.entries.length || 1;
            if (this._newPersistentRefNum) {
                this._persistentRefsCache = new Map;
                for(let e1 = this._newTemporaryRefNum; e1 < this._newPersistentRefNum; e1++){
                    this._persistentRefsCache.set(e1, this._cacheMap.get(e1));
                    this._cacheMap.delete(e1);
                }
            }
        }
        return Ref.get(this._newTemporaryRefNum++, 0);
    }
    resetNewTemporaryRef() {
        this._newTemporaryRefNum = null;
        if (this._persistentRefsCache) for (const [e1, t] of this._persistentRefsCache)this._cacheMap.set(e1, t);
        this._persistentRefsCache = null;
    }
    setStartXRef(e1) {
        this.startXRefQueue = [
            e1
        ];
    }
    parse(e1 = !1) {
        let t, a, r;
        if (e1) {
            warn("Indexing all PDF objects");
            t = this.indexObjects();
        } else t = this.readXRef();
        t.assignXref(this);
        this.trailer = t;
        try {
            a = t.get("Encrypt");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Encrypt" reference: "${e1}".`);
        }
        if (a instanceof Dict) {
            const e1 = t.get("ID"), r = e1?.length ? e1[0] : "";
            a.suppressEncryption = !0;
            this.encrypt = new CipherTransformFactory(a, r, this.pdfManager.password);
        }
        try {
            r = t.get("Root");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Root" reference: "${e1}".`);
        }
        if (r instanceof Dict) try {
            if (r.get("Pages") instanceof Dict) {
                this.root = r;
                return;
            }
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`XRef.parse - Invalid "Pages" reference: "${e1}".`);
        }
        if (!e1) throw new XRefParseException;
        throw new InvalidPDFException("Invalid Root reference.");
    }
    processXRefTable(e1) {
        "tableState" in this || (this.tableState = {
            entryNum: 0,
            streamPos: e1.lexer.stream.pos,
            parserBuf1: e1.buf1,
            parserBuf2: e1.buf2
        });
        if (!isCmd(this.readXRefTable(e1), "trailer")) throw new FormatError("Invalid XRef table: could not find trailer dictionary");
        let t = e1.getObj();
        t instanceof Dict || !t.dict || (t = t.dict);
        if (!(t instanceof Dict)) throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
        delete this.tableState;
        return t;
    }
    readXRefTable(e1) {
        const t = e1.lexer.stream, a = this.tableState;
        t.pos = a.streamPos;
        e1.buf1 = a.parserBuf1;
        e1.buf2 = a.parserBuf2;
        let r;
        for(;;){
            if (!("firstEntryNum" in a) || !("entryCount" in a)) {
                if (isCmd(r = e1.getObj(), "trailer")) break;
                a.firstEntryNum = r;
                a.entryCount = e1.getObj();
            }
            let i = a.firstEntryNum;
            const n = a.entryCount;
            if (!Number.isInteger(i) || !Number.isInteger(n)) throw new FormatError("Invalid XRef table: wrong types in subsection header");
            for(let r = a.entryNum; r < n; r++){
                a.streamPos = t.pos;
                a.entryNum = r;
                a.parserBuf1 = e1.buf1;
                a.parserBuf2 = e1.buf2;
                const s = {};
                s.offset = e1.getObj();
                s.gen = e1.getObj();
                const o = e1.getObj();
                if (o instanceof Cmd) switch(o.cmd){
                    case "f":
                        s.free = !0;
                        break;
                    case "n":
                        s.uncompressed = !0;
                }
                if (!Number.isInteger(s.offset) || !Number.isInteger(s.gen) || !s.free && !s.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${i}, ${n}`);
                0 === r && s.free && 1 === i && (i = 0);
                this.entries[r + i] || (this.entries[r + i] = s);
            }
            a.entryNum = 0;
            a.streamPos = t.pos;
            a.parserBuf1 = e1.buf1;
            a.parserBuf2 = e1.buf2;
            delete a.firstEntryNum;
            delete a.entryCount;
        }
        if (this.entries[0] && !this.entries[0].free) throw new FormatError("Invalid XRef table: unexpected first object");
        return r;
    }
    processXRefStream(e1) {
        if (!("streamState" in this)) {
            const { dict: t, pos: a } = e1, r = t.get("W"), i = t.get("Index") || [
                0,
                t.get("Size")
            ];
            this.streamState = {
                entryRanges: i,
                byteWidths: r,
                entryNum: 0,
                streamPos: a
            };
        }
        this.readXRefStream(e1);
        delete this.streamState;
        return e1.dict;
    }
    readXRefStream(e1) {
        const t = this.streamState;
        e1.pos = t.streamPos;
        const [a, r, i] = t.byteWidths, n = t.entryRanges;
        for(; n.length > 0;){
            const [s, o] = n;
            if (!Number.isInteger(s) || !Number.isInteger(o)) throw new FormatError(`Invalid XRef range fields: ${s}, ${o}`);
            if (!Number.isInteger(a) || !Number.isInteger(r) || !Number.isInteger(i)) throw new FormatError(`Invalid XRef entry fields length: ${s}, ${o}`);
            for(let n = t.entryNum; n < o; ++n){
                t.entryNum = n;
                t.streamPos = e1.pos;
                let o = 0, c = 0, l = 0;
                for(let t = 0; t < a; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'type'.");
                    o = o << 8 | t;
                }
                0 === a && (o = 1);
                for(let t = 0; t < r; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'offset'.");
                    c = c << 8 | t;
                }
                for(let t = 0; t < i; ++t){
                    const t = e1.getByte();
                    if (-1 === t) throw new FormatError("Invalid XRef byteWidths 'generation'.");
                    l = l << 8 | t;
                }
                const h = {};
                h.offset = c;
                h.gen = l;
                switch(o){
                    case 0:
                        h.free = !0;
                        break;
                    case 1:
                        h.uncompressed = !0;
                        break;
                    case 2:
                        break;
                    default:
                        throw new FormatError(`Invalid XRef entry type: ${o}`);
                }
                this.entries[s + n] || (this.entries[s + n] = h);
            }
            t.entryNum = 0;
            t.streamPos = e1.pos;
            n.splice(0, 2);
        }
    }
    indexObjects() {
        function readToken(e1, t) {
            let a = "", r = e1[t];
            for(; 10 !== r && 13 !== r && 60 !== r && !(++t >= e1.length);){
                a += String.fromCharCode(r);
                r = e1[t];
            }
            return a;
        }
        function skipUntil(e1, t, a) {
            const r = a.length, i = e1.length;
            let n = 0;
            for(; t < i;){
                let i = 0;
                for(; i < r && e1[t + i] === a[i];)++i;
                if (i >= r) break;
                t++;
                n++;
            }
            return n;
        }
        const e1 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t = /\b(startxref|\d+\s+\d+\s+obj)\b/g, a = /^(\d+)\s+(\d+)\s+obj\b/, r = new Uint8Array([
            116,
            114,
            97,
            105,
            108,
            101,
            114
        ]), i = new Uint8Array([
            115,
            116,
            97,
            114,
            116,
            120,
            114,
            101,
            102
        ]), n = new Uint8Array([
            47,
            88,
            82,
            101,
            102
        ]);
        this.entries.length = 0;
        this._cacheMap.clear();
        const s = this.stream;
        s.pos = 0;
        const o = s.getBytes(), c = bytesToString(o), l = o.length;
        let h = s.start;
        const u = [], d = [];
        for(; h < l;){
            let f = o[h];
            if (9 === f || 10 === f || 13 === f || 32 === f) {
                ++h;
                continue;
            }
            if (37 === f) {
                do {
                    ++h;
                    if (h >= l) break;
                    f = o[h];
                }while (10 !== f && 13 !== f)
                continue;
            }
            const g = readToken(o, h);
            let p;
            if (g.startsWith("xref") && (4 === g.length || /\s/.test(g[4]))) {
                h += skipUntil(o, h, r);
                u.push(h);
                h += skipUntil(o, h, i);
            } else if (p = a.exec(g)) {
                const t = 0 | p[1], a = 0 | p[2], r = h + g.length;
                let i, u = !1;
                if (this.entries[t]) {
                    if (this.entries[t].gen === a) try {
                        new Parser({
                            lexer: new Lexer(s.makeSubStream(r))
                        }).getObj();
                        u = !0;
                    } catch (e1) {
                        e1 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${g}): "${e1}".`) : u = !0;
                    }
                } else u = !0;
                u && (this.entries[t] = {
                    offset: h - s.start,
                    gen: a,
                    uncompressed: !0
                });
                e1.lastIndex = r;
                const f = e1.exec(c);
                if (f) {
                    i = e1.lastIndex + 1 - h;
                    if ("endobj" !== f[1]) {
                        warn(`indexObjects: Found "${f[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
                        i -= f[1].length + 1;
                    }
                } else i = l - h;
                const m = o.subarray(h, h + i), b = skipUntil(m, 0, n);
                if (b < i && m[b + 5] < 64) {
                    d.push(h - s.start);
                    this._xrefStms.add(h - s.start);
                }
                h += i;
            } else if (g.startsWith("trailer") && (7 === g.length || /\s/.test(g[7]))) {
                u.push(h);
                const e1 = h + g.length;
                let a;
                t.lastIndex = e1;
                const r = t.exec(c);
                if (r) {
                    a = t.lastIndex + 1 - h;
                    if ("startxref" !== r[1]) {
                        warn(`indexObjects: Found "${r[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
                        a -= r[1].length + 1;
                    }
                } else a = l - h;
                h += a;
            } else h += g.length + 1;
        }
        for (const e1 of d){
            this.startXRefQueue.push(e1);
            this.readXRef(!0);
        }
        const f = [];
        let g, p, m = !1;
        for (const e1 of u){
            s.pos = e1;
            const t = new Parser({
                lexer: new Lexer(s),
                xref: this,
                allowStreams: !0,
                recoveryMode: !0
            });
            if (!isCmd(t.getObj(), "trailer")) continue;
            const a = t.getObj();
            if (a instanceof Dict) {
                f.push(a);
                a.has("Encrypt") && (m = !0);
            }
        }
        for (const e1 of [
            ...f,
            "genFallback",
            ...f
        ]){
            if ("genFallback" === e1) {
                if (!p) break;
                this._generationFallback = !0;
                continue;
            }
            let t = !1;
            try {
                const a = e1.get("Root");
                if (!(a instanceof Dict)) continue;
                const r = a.get("Pages");
                if (!(r instanceof Dict)) continue;
                const i = r.get("Count");
                Number.isInteger(i) && (t = !0);
            } catch (e1) {
                p = e1;
                continue;
            }
            if (t && (!m || e1.has("Encrypt")) && e1.has("ID")) return e1;
            g = e1;
        }
        if (g) return g;
        if (this.topDict) return this.topDict;
        if (!f.length) for(const e1 in this.entries){
            if (!Object.hasOwn(this.entries, e1)) continue;
            const t = this.entries[e1], a = Ref.get(parseInt(e1), t.gen);
            let r;
            try {
                r = this.fetch(a);
            } catch  {
                continue;
            }
            r instanceof BaseStream && (r = r.dict);
            if (r instanceof Dict && r.has("Root")) return r;
        }
        throw new InvalidPDFException("Invalid PDF structure.");
    }
    readXRef(e1 = !1) {
        const t = this.stream, a = new Set;
        for(; this.startXRefQueue.length;){
            try {
                const e1 = this.startXRefQueue[0];
                if (a.has(e1)) {
                    warn("readXRef - skipping XRef table since it was already parsed.");
                    this.startXRefQueue.shift();
                    continue;
                }
                a.add(e1);
                t.pos = e1 + t.start;
                const r = new Parser({
                    lexer: new Lexer(t),
                    xref: this,
                    allowStreams: !0
                });
                let i, n = r.getObj();
                if (isCmd(n, "xref")) {
                    i = this.processXRefTable(r);
                    this.topDict || (this.topDict = i);
                    n = i.get("XRefStm");
                    if (Number.isInteger(n) && !this._xrefStms.has(n)) {
                        this._xrefStms.add(n);
                        this.startXRefQueue.push(n);
                        this.#Ne ??= n;
                    }
                } else {
                    if (!Number.isInteger(n)) throw new FormatError("Invalid XRef stream header");
                    if (!(Number.isInteger(r.getObj()) && isCmd(r.getObj(), "obj") && (n = r.getObj()) instanceof BaseStream)) throw new FormatError("Invalid XRef stream");
                    i = this.processXRefStream(n);
                    this.topDict || (this.topDict = i);
                    if (!i) throw new FormatError("Failed to read XRef stream");
                }
                n = i.get("Prev");
                Number.isInteger(n) ? this.startXRefQueue.push(n) : n instanceof Ref && this.startXRefQueue.push(n.num);
            } catch (e1) {
                if (e1 instanceof MissingDataException) throw e1;
                info("(while reading XRef): " + e1);
            }
            this.startXRefQueue.shift();
        }
        if (this.topDict) return this.topDict;
        if (!e1) throw new XRefParseException;
    }
    get lastXRefStreamPos() {
        return this.#Ne ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
    }
    getEntry(e1) {
        const t = this.entries[e1];
        return t && !t.free && t.offset ? t : null;
    }
    fetchIfRef(e1, t = !1) {
        return e1 instanceof Ref ? this.fetch(e1, t) : e1;
    }
    fetch(e1, t = !1) {
        if (!(e1 instanceof Ref)) throw new Error("ref object is not a reference");
        const a = e1.num, r = this._cacheMap.get(a);
        if (void 0 !== r) {
            r instanceof Dict && !r.objId && (r.objId = e1.toString());
            return r;
        }
        let i = this.getEntry(a);
        if (null === i) return i;
        if (this._pendingRefs.has(e1)) {
            this._pendingRefs.remove(e1);
            warn(`Ignoring circular reference: ${e1}.`);
            return ta;
        }
        this._pendingRefs.put(e1);
        try {
            i = i.uncompressed ? this.fetchUncompressed(e1, i, t) : this.fetchCompressed(e1, i, t);
            this._pendingRefs.remove(e1);
        } catch (t) {
            this._pendingRefs.remove(e1);
            throw t;
        }
        i instanceof Dict ? i.objId = e1.toString() : i instanceof BaseStream && (i.dict.objId = e1.toString());
        return i;
    }
    fetchUncompressed(e1, t, a = !1) {
        const r = e1.gen;
        let i = e1.num;
        if (t.gen !== r) {
            const n = `Inconsistent generation in XRef: ${e1}`;
            if (this._generationFallback && t.gen < r) {
                warn(n);
                return this.fetchUncompressed(Ref.get(i, t.gen), t, a);
            }
            throw new XRefEntryException(n);
        }
        const n = this.stream.makeSubStream(t.offset + this.stream.start), s = new Parser({
            lexer: new Lexer(n),
            xref: this,
            allowStreams: !0
        }), o = s.getObj(), c = s.getObj(), l = s.getObj();
        if (o !== i || c !== r || !(l instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        if ("obj" !== l.cmd) {
            if (l.cmd.startsWith("obj")) {
                i = parseInt(l.cmd.substring(3), 10);
                if (!Number.isNaN(i)) return i;
            }
            throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e1}`);
        }
        (t = this.encrypt && !a ? s.getObj(this.encrypt.createCipherTransform(i, r)) : s.getObj()) instanceof BaseStream || this._cacheMap.set(i, t);
        return t;
    }
    fetchCompressed(e1, t, a = !1) {
        const r = t.offset, i = this.fetch(Ref.get(r, 0));
        if (!(i instanceof BaseStream)) throw new FormatError("bad ObjStm stream");
        const n = i.dict.get("First"), s = i.dict.get("N");
        if (!Number.isInteger(n) || !Number.isInteger(s)) throw new FormatError("invalid first and n parameters for ObjStm stream");
        let o = new Parser({
            lexer: new Lexer(i),
            xref: this,
            allowStreams: !0
        });
        const c = new Array(s), l = new Array(s);
        for(let e1 = 0; e1 < s; ++e1){
            const t = o.getObj();
            if (!Number.isInteger(t)) throw new FormatError(`invalid object number in the ObjStm stream: ${t}`);
            const a = o.getObj();
            if (!Number.isInteger(a)) throw new FormatError(`invalid object offset in the ObjStm stream: ${a}`);
            c[e1] = t;
            const i = this.getEntry(t);
            i?.offset === r && i.gen !== e1 && (i.gen = e1);
            l[e1] = a;
        }
        const h = (i.start || 0) + n, u = new Array(s);
        for(let e1 = 0; e1 < s; ++e1){
            const t = e1 < s - 1 ? l[e1 + 1] - l[e1] : void 0;
            if (t < 0) throw new FormatError("Invalid offset in the ObjStm stream.");
            o = new Parser({
                lexer: new Lexer(i.makeSubStream(h + l[e1], t, i.dict)),
                xref: this,
                allowStreams: !0
            });
            const a = o.getObj();
            u[e1] = a;
            if (a instanceof BaseStream) continue;
            const n = c[e1], d = this.entries[n];
            d && d.offset === r && d.gen === e1 && this._cacheMap.set(n, a);
        }
        if (void 0 === (t = u[t.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e1}`);
        return t;
    }
    async fetchIfRefAsync(e1, t) {
        return e1 instanceof Ref ? this.fetchAsync(e1, t) : e1;
    }
    async fetchAsync(e1, t) {
        try {
            return this.fetch(e1, t);
        } catch (a) {
            if (!(a instanceof MissingDataException)) throw a;
            await this.pdfManager.requestRange(a.begin, a.end);
            return this.fetchAsync(e1, t);
        }
    }
    getCatalogObj() {
        return this.root;
    }
}
const tc = [
    0,
    0,
    612,
    792
];
class Page {
    #Ee = !1;
    #Pe = null;
    constructor({ pdfManager: e1, xref: t, pageIndex: a, pageDict: r, ref: i, globalIdFactory: n, fontCache: s, builtInCMapCache: o, standardFontDataCache: c, globalColorSpaceCache: l, globalImageCache: h, systemFontCache: u, nonBlendModesSet: d, xfaFactory: f }){
        this.pdfManager = e1;
        this.pageIndex = a;
        this.pageDict = r;
        this.xref = t;
        this.ref = i;
        this.fontCache = s;
        this.builtInCMapCache = o;
        this.standardFontDataCache = c;
        this.globalColorSpaceCache = l;
        this.globalImageCache = h;
        this.systemFontCache = u;
        this.nonBlendModesSet = d;
        this.evaluatorOptions = e1.evaluatorOptions;
        this.xfaFactory = f;
        const g = {
            obj: 0
        };
        this._localIdFactory = class extends n {
            static createObjId() {
                return `p${a}_${++g.obj}`;
            }
            static getPageObjId() {
                return `p${i.toString()}`;
            }
        };
    }
    #Le(e1) {
        return new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalColorSpaceCache: this.globalColorSpaceCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
        });
    }
    #je(e1, t = !1) {
        const a = getInheritableProperty({
            dict: this.pageDict,
            key: e1,
            getArray: t,
            stopWhenFound: !1
        });
        return Array.isArray(a) ? 1 !== a.length && a[0] instanceof Dict ? Dict.merge({
            xref: this.xref,
            dictArray: a
        }) : a[0] : a;
    }
    get content() {
        return this.pageDict.getArray("Contents");
    }
    get resources() {
        const e1 = this.#je("Resources");
        return shadow(this, "resources", e1 instanceof Dict ? e1 : Dict.empty);
    }
    #_e(e1) {
        if (this.xfaData) return this.xfaData.bbox;
        const t = lookupNormalRect(this.#je(e1, !0), null);
        if (t) {
            if (t[2] - t[0] > 0 && t[3] - t[1] > 0) return t;
            warn(`Empty, or invalid, /${e1} entry.`);
        }
        return null;
    }
    get mediaBox() {
        return shadow(this, "mediaBox", this.#_e("MediaBox") || tc);
    }
    get cropBox() {
        return shadow(this, "cropBox", this.#_e("CropBox") || this.mediaBox);
    }
    get userUnit() {
        const e1 = this.pageDict.get("UserUnit");
        return shadow(this, "userUnit", "number" == typeof e1 && e1 > 0 ? e1 : 1);
    }
    get view() {
        const { cropBox: e1, mediaBox: t } = this;
        if (e1 !== t && !isArrayEqual(e1, t)) {
            const a = Util.intersect(e1, t);
            if (a && a[2] - a[0] > 0 && a[3] - a[1] > 0) return shadow(this, "view", a);
            warn("Empty /CropBox and /MediaBox intersection.");
        }
        return shadow(this, "view", t);
    }
    get rotate() {
        let e1 = this.#je("Rotate") || 0;
        e1 % 90 != 0 ? e1 = 0 : e1 >= 360 ? e1 %= 360 : e1 < 0 && (e1 = (e1 % 360 + 360) % 360);
        return shadow(this, "rotate", e1);
    }
    #Ue(e1, t) {
        if (!this.evaluatorOptions.ignoreErrors) throw e1;
        warn(`getContentStream - ignoring sub-stream (${t}): "${e1}".`);
    }
    async getContentStream() {
        const e1 = await this.pdfManager.ensure(this, "content");
        return e1 instanceof BaseStream ? e1 : Array.isArray(e1) ? new StreamsSequenceStream(e1, this.#Ue.bind(this)) : new NullStream;
    }
    get xfaData() {
        return shadow(this, "xfaData", this.xfaFactory ? {
            bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
        } : null);
    }
    async #Xe(e1, t, a) {
        const r = [];
        for (const i of e1)if (i.id) {
            const e1 = Ref.fromString(i.id);
            if (!e1) {
                warn(`A non-linked annotation cannot be modified: ${i.id}`);
                continue;
            }
            if (i.deleted) {
                t.put(e1, e1);
                if (i.popupRef) {
                    const e1 = Ref.fromString(i.popupRef);
                    e1 && t.put(e1, e1);
                }
                continue;
            }
            if (i.popup?.deleted) {
                const e1 = Ref.fromString(i.popupRef);
                e1 && t.put(e1, e1);
            }
            a?.put(e1);
            i.ref = e1;
            r.push(this.xref.fetchAsync(e1).then((e1)=>{
                e1 instanceof Dict && (i.oldAnnotation = e1.clone());
            }, ()=>{
                warn(`Cannot fetch \`oldAnnotation\` for: ${e1}.`);
            }));
            delete i.id;
        }
        await Promise.all(r);
    }
    async saveNewAnnotations(e1, t, a, r, i) {
        if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
        const n = this.#Le(e1), s = new RefSetCache, o = new RefSet;
        await this.#Xe(a, s, o);
        const c = this.pageDict, l = this.annotations.filter((e1)=>!(e1 instanceof Ref && s.has(e1))), h = await AnnotationFactory.saveNewAnnotations(n, t, a, r, i);
        for (const { ref: e1 } of h.annotations)e1 instanceof Ref && !o.has(e1) && l.push(e1);
        const u = c.clone();
        u.set("Annots", l);
        i.put(this.ref, {
            data: u
        });
        for (const e1 of s)i.put(e1, {
            data: null
        });
    }
    async save(e1, t, a, r) {
        const i = this.#Le(e1), n = await this._parsedAnnotations, s = [];
        for (const e1 of n)s.push(e1.save(i, t, a, r).catch(function(e1) {
            warn(`save - ignoring annotation data during "${t.name}" task: "${e1}".`);
            return null;
        }));
        return Promise.all(s);
    }
    async loadResources(e1) {
        await (this.#Pe ??= this.pdfManager.ensure(this, "resources"));
        await ObjectLoader.load(this.resources, e1, this.xref);
    }
    async #qe(e1, t) {
        const a = e1?.get("Resources");
        if (!(a instanceof Dict && a.size)) return this.resources;
        await ObjectLoader.load(a, t, this.xref);
        return Dict.merge({
            xref: this.xref,
            dictArray: [
                a,
                this.resources
            ],
            mergeSubDicts: !0
        });
    }
    async getOperatorList({ handler: e1, sink: t, task: a, intent: r, cacheKey: i, annotationStorage: c = null, modifiedIds: d = null }) {
        const g = this.getContentStream(), p = this.loadResources(ha), m = this.#Le(e1), b = this.xfaFactory ? null : getNewAnnotationsMap(c), y = b?.get(this.pageIndex);
        let w = Promise.resolve(null), x = null;
        if (y) {
            const e1 = this.pdfManager.ensureDoc("annotationGlobals");
            let t;
            const r = new Set;
            for (const { bitmapId: e1, bitmap: t } of y)!e1 || t || r.has(e1) || r.add(e1);
            const { isOffscreenCanvasSupported: i } = this.evaluatorOptions;
            if (r.size > 0) {
                const e1 = y.slice();
                for (const [t, a] of c)t.startsWith(f) && a.bitmap && r.has(a.bitmapId) && e1.push(a);
                t = AnnotationFactory.generateImages(e1, this.xref, i);
            } else t = AnnotationFactory.generateImages(y, this.xref, i);
            x = new RefSet;
            w = Promise.all([
                e1,
                this.#Xe(y, x, null)
            ]).then(([e1])=>e1 ? AnnotationFactory.printNewAnnotations(e1, m, a, y, t) : null);
        }
        const S = Promise.all([
            g,
            p
        ]).then(async ([n])=>{
            const s = await this.#qe(n.dict, ha), o = new OperatorList(r, t);
            e1.send("StartRenderPage", {
                transparency: m.hasBlendModes(s, this.nonBlendModesSet),
                pageIndex: this.pageIndex,
                cacheKey: i
            });
            await m.getOperatorList({
                stream: n,
                task: a,
                resources: s,
                operatorList: o
            });
            return o;
        });
        let [k, C, v] = await Promise.all([
            S,
            this._parsedAnnotations,
            w
        ]);
        if (v) {
            C = C.filter((e1)=>!(e1.ref && x.has(e1.ref)));
            for(let e1 = 0, t = v.length; e1 < t; e1++){
                const a = v[e1];
                if (a.refToReplace) {
                    const r = C.findIndex((e1)=>e1.ref && isRefsEqual(e1.ref, a.refToReplace));
                    if (r >= 0) {
                        C.splice(r, 1, a);
                        v.splice(e1--, 1);
                        t--;
                    }
                }
            }
            C = C.concat(v);
        }
        if (0 === C.length || r & h) {
            k.flush(!0);
            return {
                length: k.totalLength
            };
        }
        const F = !!(r & l), T = !!(r & u), O = !!(r & n), M = !!(r & s), D = !!(r & o), R = [];
        for (const e1 of C)(O || M && e1.mustBeViewed(c, F) && e1.mustBeViewedWhenEditing(T, d) || D && e1.mustBePrinted(c)) && R.push(e1.getOperatorList(m, a, r, c).catch(function(e1) {
            warn(`getOperatorList - ignoring annotation data during "${a.name}" task: "${e1}".`);
            return {
                opList: null,
                separateForm: !1,
                separateCanvas: !1
            };
        }));
        const N = await Promise.all(R);
        let E = !1, L = !1;
        for (const { opList: e1, separateForm: t, separateCanvas: a } of N){
            k.addOpList(e1);
            E ||= t;
            L ||= a;
        }
        k.flush(!0, {
            form: E,
            canvas: L
        });
        return {
            length: k.totalLength
        };
    }
    async extractTextContent({ handler: e1, task: t, includeMarkedContent: a, disableNormalization: r, sink: i, intersector: n = null }) {
        const s = this.getContentStream(), o = this.loadResources(ua), c = this.pdfManager.ensureCatalog("lang"), [l, , h] = await Promise.all([
            s,
            o,
            c
        ]), u = await this.#qe(l.dict, ua);
        return this.#Le(e1).getTextContent({
            stream: l,
            task: t,
            resources: u,
            includeMarkedContent: a,
            disableNormalization: r,
            sink: i,
            viewBox: this.view,
            lang: h,
            intersector: n
        });
    }
    async getStructTree() {
        const e1 = await this.pdfManager.ensureCatalog("structTreeRoot");
        if (!e1) return null;
        await this._parsedAnnotations;
        try {
            const t = await this.pdfManager.ensure(this, "_parseStructTree", [
                e1
            ]);
            return await this.pdfManager.ensure(t, "serializable");
        } catch (e1) {
            warn(`getStructTree: "${e1}".`);
            return null;
        }
    }
    _parseStructTree(e1) {
        const t = new StructTreePage(e1, this.pageDict);
        t.parse(this.ref);
        return t;
    }
    async getAnnotationsData(e1, t, a) {
        const r = await this._parsedAnnotations;
        if (0 === r.length) return r;
        const i = [], c = [];
        let l;
        const h = !!(a & n), u = !!(a & s), d = !!(a & o), f = [];
        for (const a of r){
            const r = h || u && a.viewable;
            (r || d && a.printable) && i.push(a.data);
            if (a.hasTextContent && r) {
                l ??= this.#Le(e1);
                c.push(a.extractTextContent(l, t, [
                    -1 / 0,
                    -1 / 0,
                    1 / 0,
                    1 / 0
                ]).catch(function(e1) {
                    warn(`getAnnotationsData - ignoring textContent during "${t.name}" task: "${e1}".`);
                }));
            } else a.overlaysTextContent && r && f.push(a);
        }
        if (f.length > 0) {
            const a = new Intersector(f);
            c.push(this.extractTextContent({
                handler: e1,
                task: t,
                includeMarkedContent: !1,
                disableNormalization: !1,
                sink: null,
                viewBox: this.view,
                lang: null,
                intersector: a
            }).then(()=>{
                a.setText();
            }));
        }
        await Promise.all(c);
        return i;
    }
    get annotations() {
        const e1 = this.#je("Annots");
        return shadow(this, "annotations", Array.isArray(e1) ? e1 : []);
    }
    get _parsedAnnotations() {
        const e1 = this.pdfManager.ensure(this, "annotations").then(async (e1)=>{
            if (0 === e1.length) return e1;
            const [t, a] = await Promise.all([
                this.pdfManager.ensureDoc("annotationGlobals"),
                this.pdfManager.ensureDoc("fieldObjects")
            ]);
            if (!t) return [];
            const r = a?.orphanFields, i = [];
            for (const a of e1)i.push(AnnotationFactory.create(this.xref, a, t, this._localIdFactory, !1, r, null, this.ref).catch(function(e1) {
                warn(`_parsedAnnotations: "${e1}".`);
                return null;
            }));
            const n = [];
            let s, o;
            for (const e1 of (await Promise.all(i)))e1 && (e1 instanceof WidgetAnnotation ? (o ||= []).push(e1) : e1 instanceof PopupAnnotation ? (s ||= []).push(e1) : n.push(e1));
            o && n.push(...o);
            s && n.push(...s);
            return n;
        });
        this.#Ee = !0;
        return shadow(this, "_parsedAnnotations", e1);
    }
    get jsActions() {
        return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, re));
    }
    async collectAnnotationsByType(e1, t, a, r, i) {
        const { pageIndex: n } = this;
        if (this.#Ee) {
            const e1 = await this._parsedAnnotations;
            for (const { data: t } of e1)if (!a || a.has(t.annotationType)) {
                t.pageIndex = n;
                r.push(Promise.resolve(t));
            }
            return;
        }
        const s = await this.pdfManager.ensure(this, "annotations");
        for (const o of s)r.push(AnnotationFactory.create(this.xref, o, i, this._localIdFactory, !1, null, a, this.ref).then(async (a)=>{
            if (!a) return null;
            a.data.pageIndex = n;
            if (a.hasTextContent && a.viewable) {
                const r = this.#Le(e1);
                await a.extractTextContent(r, t, [
                    -1 / 0,
                    -1 / 0,
                    1 / 0,
                    1 / 0
                ]);
            }
            return a.data;
        }).catch(function(e1) {
            warn(`collectAnnotationsByType: "${e1}".`);
            return null;
        }));
    }
}
const ac = new Uint8Array([
    37,
    80,
    68,
    70,
    45
]), rc = new Uint8Array([
    115,
    116,
    97,
    114,
    116,
    120,
    114,
    101,
    102
]), ic = new Uint8Array([
    101,
    110,
    100,
    111,
    98,
    106
]);
function find(e1, t, a = 1024, r = !1) {
    const i = t.length, n = e1.peekBytes(a), s = n.length - i;
    if (s <= 0) return !1;
    if (r) {
        const a = i - 1;
        let r = n.length - 1;
        for(; r >= a;){
            let s = 0;
            for(; s < i && n[r - s] === t[a - s];)s++;
            if (s >= i) {
                e1.pos += r - a;
                return !0;
            }
            r--;
        }
    } else {
        let a = 0;
        for(; a <= s;){
            let r = 0;
            for(; r < i && n[a + r] === t[r];)r++;
            if (r >= i) {
                e1.pos += a;
                return !0;
            }
            a++;
        }
    }
    return !1;
}
class PDFDocument {
    #He = new Map;
    #We = null;
    constructor(e1, t){
        if (t.length <= 0) throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
        this.pdfManager = e1;
        this.stream = t;
        this.xref = new XRef(t, e1);
        const a = {
            font: 0
        };
        this._globalIdFactory = class {
            static getDocId() {
                return `g_${e1.docId}`;
            }
            static createFontId() {
                return "f" + ++a.font;
            }
            static createObjId() {
                unreachable("Abstract method `createObjId` called.");
            }
            static getPageObjId() {
                unreachable("Abstract method `getPageObjId` called.");
            }
        };
    }
    parse(e1) {
        this.xref.parse(e1);
        this.catalog = new Catalog(this.pdfManager, this.xref);
    }
    get linearization() {
        let e1 = null;
        try {
            e1 = Linearization.create(this.stream);
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info(e1);
        }
        return shadow(this, "linearization", e1);
    }
    get startXRef() {
        const e1 = this.stream;
        let t = 0;
        if (this.linearization) {
            e1.reset();
            if (find(e1, ic)) {
                e1.skip(6);
                let a = e1.peekByte();
                for(; isWhiteSpace(a);){
                    e1.pos++;
                    a = e1.peekByte();
                }
                t = e1.pos - e1.start;
            }
        } else {
            const a = 1024, r = rc.length;
            let i = !1, n = e1.end;
            for(; !i && n > 0;){
                n -= a - r;
                n < 0 && (n = 0);
                e1.pos = n;
                i = find(e1, rc, a, !0);
            }
            if (i) {
                e1.skip(9);
                let a;
                do {
                    a = e1.getByte();
                }while (isWhiteSpace(a))
                let r = "";
                for(; a >= 32 && a <= 57;){
                    r += String.fromCharCode(a);
                    a = e1.getByte();
                }
                t = parseInt(r, 10);
                isNaN(t) && (t = 0);
            }
        }
        return shadow(this, "startXRef", t);
    }
    checkHeader() {
        const e1 = this.stream;
        e1.reset();
        if (!find(e1, ac)) return;
        e1.moveStart();
        e1.skip(ac.length);
        let t, a = "";
        for(; (t = e1.getByte()) > 32 && a.length < 7;)a += String.fromCharCode(t);
        oa.test(a) ? this.#We = a : warn(`Invalid PDF header version: ${a}`);
    }
    parseStartXRef() {
        this.xref.setStartXRef(this.startXRef);
    }
    get numPages() {
        let e1 = 0;
        e1 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
        return shadow(this, "numPages", e1);
    }
    #ze(e1, t = 0) {
        return !!Array.isArray(e1) && e1.every((e1)=>{
            if (!((e1 = this.xref.fetchIfRef(e1)) instanceof Dict)) return !1;
            if (e1.has("Kids")) {
                if (++t > 10) {
                    warn("#hasOnlyDocumentSignatures: maximum recursion depth reached");
                    return !1;
                }
                return this.#ze(e1.get("Kids"), t);
            }
            const a = isName(e1.get("FT"), "Sig"), r = e1.get("Rect"), i = Array.isArray(r) && r.every((e1)=>0 === e1);
            return a && i;
        });
    }
    #$e(e1, t, a = new RefSet) {
        if (Array.isArray(e1)) for (let r of e1){
            if (r instanceof Ref) {
                if (a.has(r)) continue;
                a.put(r);
            }
            r = this.xref.fetchIfRef(r);
            if (!(r instanceof Dict)) continue;
            if (r.has("Kids")) {
                this.#$e(r.get("Kids"), t, a);
                continue;
            }
            if (!isName(r.get("FT"), "Sig")) continue;
            const e1 = r.get("V");
            if (!(e1 instanceof Dict)) continue;
            const i = e1.get("SubFilter");
            i instanceof Name && t.add(i.name);
        }
    }
    get _xfaStreams() {
        const { acroForm: e1 } = this.catalog;
        if (!e1) return null;
        const t = e1.get("XFA"), a = new Map([
            "xdp:xdp",
            "template",
            "datasets",
            "config",
            "connectionSet",
            "localeSet",
            "stylesheet",
            "/xdp:xdp"
        ].map((e1)=>[
                e1,
                null
            ]));
        if (t instanceof BaseStream && !t.isEmpty) {
            a.set("xdp:xdp", t);
            return a;
        }
        if (!Array.isArray(t) || 0 === t.length) return null;
        for(let e1 = 0, r = t.length; e1 < r; e1 += 2){
            let i;
            i = 0 === e1 ? "xdp:xdp" : e1 === r - 2 ? "/xdp:xdp" : t[e1];
            if (!a.has(i)) continue;
            const n = this.xref.fetchIfRef(t[e1 + 1]);
            n instanceof BaseStream && !n.isEmpty && a.set(i, n);
        }
        return a;
    }
    get xfaDatasets() {
        const e1 = this._xfaStreams;
        if (!e1) return shadow(this, "xfaDatasets", null);
        for (const t of [
            "datasets",
            "xdp:xdp"
        ]){
            const a = e1.get(t);
            if (a) try {
                const e1 = stringToUTF8String(a.getString());
                return shadow(this, "xfaDatasets", new DatasetReader({
                    [t]: e1
                }));
            } catch  {
                warn("XFA - Invalid utf-8 string.");
                break;
            }
        }
        return shadow(this, "xfaDatasets", null);
    }
    get xfaData() {
        const e1 = this._xfaStreams;
        if (!e1) return null;
        const t = Object.create(null);
        for (const [a, r] of e1)if (r) try {
            t[a] = stringToUTF8String(r.getString());
        } catch  {
            warn("XFA - Invalid utf-8 string.");
            return null;
        }
        return t;
    }
    get xfaFactory() {
        let e1;
        this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e1 = this.xfaData);
        return shadow(this, "xfaFactory", e1 ? new XFAFactory(e1) : null);
    }
    get isPureXfa() {
        return !!this.xfaFactory && this.xfaFactory.isValid();
    }
    get htmlForXfa() {
        return this.xfaFactory ? this.xfaFactory.getPages() : null;
    }
    async #Ge() {
        const e1 = await this.pdfManager.ensureCatalog("xfaImages");
        e1 && this.xfaFactory.setImages(e1);
    }
    async #Ve(e1, t) {
        const a = await this.pdfManager.ensureCatalog("acroForm");
        if (!a) return;
        const r = await a.getAsync("DR");
        if (!(r instanceof Dict)) return;
        await ObjectLoader.load(r, [
            "Font"
        ], this.xref);
        const i = r.get("Font");
        if (!(i instanceof Dict)) return;
        const n = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions, {
            useSystemFonts: !1
        }), { builtInCMapCache: s, fontCache: o, standardFontDataCache: c } = this.catalog, l = new PartialEvaluator({
            xref: this.xref,
            handler: e1,
            pageIndex: -1,
            idFactory: this._globalIdFactory,
            fontCache: o,
            builtInCMapCache: s,
            standardFontDataCache: c,
            options: n
        }), h = new OperatorList, u = [], d = {
            get font () {
                return u.at(-1);
            },
            set font (e){
                u.push(e);
            },
            clone () {
                return this;
            }
        }, parseFont = (e1, a, i)=>l.handleSetFont(r, [
                Name.get(e1),
                1
            ], null, h, t, d, a, i).catch((e1)=>{
                warn(`loadXfaFonts: "${e1}".`);
                return null;
            }), f = [];
        for (const [e1, t] of i){
            const a = t.get("FontDescriptor");
            if (!(a instanceof Dict)) continue;
            let r = a.get("FontFamily");
            r = r.replaceAll(/[ ]+(\d)/g, "$1");
            const i = {
                fontFamily: r,
                fontWeight: a.get("FontWeight"),
                italicAngle: -a.get("ItalicAngle")
            };
            validateCSSFont(i) && f.push(parseFont(e1, null, i));
        }
        await Promise.all(f);
        const g = this.xfaFactory.setFonts(u);
        if (!g) return;
        n.ignoreErrors = !0;
        f.length = 0;
        u.length = 0;
        const p = new Set;
        for (const e1 of g)getXfaFontName(`${e1}-Regular`) || p.add(e1);
        p.size && g.push("PdfJS-Fallback");
        for (const e1 of g)if (!p.has(e1)) for (const t of [
            {
                name: "Regular",
                fontWeight: 400,
                italicAngle: 0
            },
            {
                name: "Bold",
                fontWeight: 700,
                italicAngle: 0
            },
            {
                name: "Italic",
                fontWeight: 400,
                italicAngle: 12
            },
            {
                name: "BoldItalic",
                fontWeight: 700,
                italicAngle: 12
            }
        ]){
            const a = `${e1}-${t.name}`;
            f.push(parseFont(a, getXfaFontDict(a), {
                fontFamily: e1,
                fontWeight: t.fontWeight,
                italicAngle: t.italicAngle
            }));
        }
        await Promise.all(f);
        this.xfaFactory.appendFonts(u, p);
    }
    loadXfaResources(e1, t) {
        return Promise.all([
            this.#Ve(e1, t).catch(()=>{}),
            this.#Ge()
        ]);
    }
    serializeXfaData(e1) {
        return this.xfaFactory ? this.xfaFactory.serializeData(e1) : null;
    }
    get version() {
        return this.catalog.version || this.#We;
    }
    get formInfo() {
        const e1 = {
            hasFields: !1,
            hasAcroForm: !1,
            hasXfa: !1,
            hasSignatures: !1
        }, { acroForm: t } = this.catalog;
        if (!t) return shadow(this, "formInfo", e1);
        try {
            const a = t.get("Fields"), r = Array.isArray(a) && a.length > 0;
            e1.hasFields = r;
            const i = t.get("XFA");
            e1.hasXfa = Array.isArray(i) && i.length > 0 || i instanceof BaseStream && !i.isEmpty;
            const n = !!(1 & t.get("SigFlags")), s = n && this.#ze(a);
            e1.hasAcroForm = r && !s;
            e1.hasSignatures = n;
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            warn(`Cannot fetch form information: "${e1}".`);
        }
        return shadow(this, "formInfo", e1);
    }
    get documentInfo() {
        const { catalog: e1, formInfo: t, xref: a } = this, r = {
            PDFFormatVersion: this.version,
            Language: e1.lang,
            EncryptFilterName: a.encrypt?.filterName ?? null,
            IsLinearized: !!this.linearization,
            IsAcroFormPresent: t.hasAcroForm,
            IsXFAPresent: t.hasXfa,
            IsCollectionPresent: !!e1.collection,
            IsSignaturesPresent: t.hasSignatures
        };
        let i;
        try {
            i = a.trailer.get("Info");
        } catch (e1) {
            if (e1 instanceof MissingDataException) throw e1;
            info("The document information dictionary is invalid.");
        }
        if (!(i instanceof Dict)) return shadow(this, "documentInfo", r);
        for (const [e1, t] of i){
            switch(e1){
                case "Title":
                case "Author":
                case "Subject":
                case "Keywords":
                case "Creator":
                case "Producer":
                case "CreationDate":
                case "ModDate":
                    if ("string" == typeof t) {
                        r[e1] = stringToPDFString(t);
                        continue;
                    }
                    break;
                case "Trapped":
                    if (t instanceof Name) {
                        r[e1] = t;
                        continue;
                    }
                    break;
                default:
                    let a;
                    switch(typeof t){
                        case "string":
                            a = stringToPDFString(t);
                            break;
                        case "number":
                        case "boolean":
                            a = t;
                            break;
                        default:
                            t instanceof Name && (a = t);
                    }
                    if (void 0 === a) {
                        warn(`Bad value, for custom key "${e1}", in Info: ${t}.`);
                        continue;
                    }
                    r.Custom ??= Object.create(null);
                    r.Custom[e1] = a;
                    continue;
            }
            warn(`Bad value, for key "${e1}", in Info: ${t}.`);
        }
        return shadow(this, "documentInfo", r);
    }
    get fingerprints() {
        const e1 = "\0".repeat(16);
        function validate(t) {
            return "string" == typeof t && 16 === t.length && t !== e1;
        }
        const t = this.xref.trailer.get("ID");
        let a, r;
        if (Array.isArray(t) && validate(t[0])) {
            a = stringToBytes(t[0]);
            t[1] !== t[0] && validate(t[1]) && (r = stringToBytes(t[1]));
        } else a = calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024);
        return shadow(this, "fingerprints", [
            toHexUtil(a),
            r ? toHexUtil(r) : null
        ]);
    }
    async #Ke(e1) {
        const { catalog: t, linearization: a, xref: r } = this, i = Ref.get(a.objectNumberFirst, 0);
        try {
            const e1 = await r.fetchAsync(i);
            if (e1 instanceof Dict) {
                let a = e1.getRaw("Type");
                a instanceof Ref && (a = await r.fetchAsync(a));
                if (isName(a, "Page") || !e1.has("Type") && !e1.has("Kids") && e1.has("Contents")) {
                    t.pageKidsCountCache.has(i) || t.pageKidsCountCache.put(i, 1);
                    t.pageIndexCache.has(i) || t.pageIndexCache.put(i, 0);
                    return [
                        e1,
                        i
                    ];
                }
            }
            throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
        } catch (a) {
            warn(`_getLinearizationPage: "${a.message}".`);
            return t.getPageDict(e1);
        }
    }
    getPage(e1) {
        const t = this.#He.get(e1);
        if (t) return t;
        const { catalog: a, linearization: r, xfaFactory: i } = this;
        let n;
        n = i ? Promise.resolve([
            Dict.empty,
            null
        ]) : r?.pageFirst === e1 ? this.#Ke(e1) : a.getPageDict(e1);
        n = n.then(([t, r])=>new Page({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: e1,
                pageDict: t,
                ref: r,
                globalIdFactory: this._globalIdFactory,
                fontCache: a.fontCache,
                builtInCMapCache: a.builtInCMapCache,
                standardFontDataCache: a.standardFontDataCache,
                globalColorSpaceCache: a.globalColorSpaceCache,
                globalImageCache: a.globalImageCache,
                systemFontCache: a.systemFontCache,
                nonBlendModesSet: a.nonBlendModesSet,
                xfaFactory: i
            }));
        this.#He.set(e1, n);
        return n;
    }
    async checkFirstPage(e1 = !1) {
        if (!e1) try {
            await this.getPage(0);
        } catch (e1) {
            if (e1 instanceof XRefEntryException) {
                this.#He.delete(0);
                await this.cleanup();
                throw new XRefParseException;
            }
        }
    }
    async checkLastPage(e1 = !1) {
        const { catalog: t, pdfManager: a } = this;
        t.setActualNumPages();
        let r;
        try {
            await Promise.all([
                a.ensureDoc("xfaFactory"),
                a.ensureDoc("linearization"),
                a.ensureCatalog("numPages")
            ]);
            if (this.xfaFactory) return;
            r = this.linearization ? this.linearization.numPages : t.numPages;
            if (!Number.isInteger(r)) throw new FormatError("Page count is not an integer.");
            if (r <= 1) return;
            await this.getPage(r - 1);
        } catch (i) {
            this.#He.delete(r - 1);
            await this.cleanup();
            if (i instanceof XRefEntryException && !e1) throw new XRefParseException;
            warn(`checkLastPage - invalid /Pages tree /Count: ${r}.`);
            let n;
            try {
                n = await t.getAllPageDicts(e1);
            } catch (a) {
                if (a instanceof XRefEntryException && !e1) throw new XRefParseException;
                t.setActualNumPages(1);
                return;
            }
            for (const [e1, [r, i]] of n){
                let n;
                if (r instanceof Error) {
                    n = Promise.reject(r);
                    n.catch(()=>{});
                } else n = Promise.resolve(new Page({
                    pdfManager: a,
                    xref: this.xref,
                    pageIndex: e1,
                    pageDict: r,
                    ref: i,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: t.fontCache,
                    builtInCMapCache: t.builtInCMapCache,
                    standardFontDataCache: t.standardFontDataCache,
                    globalColorSpaceCache: this.globalColorSpaceCache,
                    globalImageCache: t.globalImageCache,
                    systemFontCache: t.systemFontCache,
                    nonBlendModesSet: t.nonBlendModesSet,
                    xfaFactory: null
                }));
                this.#He.set(e1, n);
            }
            t.setActualNumPages(n.size);
        }
    }
    async fontFallback(e1, t) {
        const { catalog: a, pdfManager: r } = this;
        for (const i of (await Promise.all(a.fontCache)))if (i.loadedName === e1) {
            i.fallback(t, r.evaluatorOptions);
            return;
        }
    }
    async cleanup(e1 = !1) {
        return this.catalog ? this.catalog.cleanup(e1) : clearGlobalCaches();
    }
    async #Je(e1, t, a, r, i, n, s) {
        const { xref: o } = this;
        if (!(a instanceof Ref) || n.has(a)) return;
        n.put(a);
        const c = await o.fetchAsync(a);
        if (!(c instanceof Dict)) return;
        let l = await c.getAsync("Subtype");
        l = l instanceof Name ? l.name : null;
        if ("Link" === l) return;
        if (c.has("T")) {
            const t = stringToPDFString(await c.getAsync("T"));
            e1 = "" === e1 ? t : `${e1}.${t}`;
        } else {
            let a = c;
            for(;;){
                a = a.getRaw("Parent") || t;
                if (a instanceof Ref) {
                    if (n.has(a)) break;
                    a = await o.fetchAsync(a);
                }
                if (!(a instanceof Dict)) break;
                if (a.has("T")) {
                    const t = stringToPDFString(await a.getAsync("T"));
                    e1 = "" === e1 ? t : `${e1}.${t}`;
                    break;
                }
            }
        }
        t && !c.has("Parent") && isName(c.get("Subtype"), "Widget") && s.put(a, t);
        r.has(e1) || r.set(e1, []);
        r.get(e1).push(AnnotationFactory.create(o, a, i, null, !0, s, null, null).then((e1)=>e1?.getFieldObject()).catch(function(e1) {
            warn(`#collectFieldObjects: "${e1}".`);
            return null;
        }));
        if (!c.has("Kids")) return;
        const h = await c.getAsync("Kids");
        if (Array.isArray(h)) for (const t of h)await this.#Je(e1, a, t, r, i, n, s);
    }
    get fieldObjects() {
        return shadow(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e1)=>{
            if (!e1.hasFields) return null;
            const t = await this.annotationGlobals;
            if (!t) return null;
            const { acroForm: a } = t, r = new RefSet, i = Object.create(null), n = new Map, s = new RefSetCache;
            for (const e1 of a.get("Fields"))await this.#Je("", null, e1, n, t, r, s);
            const o = [];
            for (const [e1, t] of n)o.push(Promise.all(t).then((t)=>{
                (t = t.filter((e1)=>!!e1)).length > 0 && (i[e1] = t);
            }));
            await Promise.all(o);
            return {
                allFields: objectSize(i) > 0 ? i : null,
                orphanFields: s
            };
        }));
    }
    get hasJSActions() {
        return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
    }
    async _parseHasJSActions() {
        const [e1, t] = await Promise.all([
            this.pdfManager.ensureCatalog("jsActions"),
            this.pdfManager.ensureDoc("fieldObjects")
        ]);
        return !!e1 || !!t?.allFields && Object.values(t.allFields).some((e1)=>e1.some((e1)=>null !== e1.actions));
    }
    get calculationOrderIds() {
        const e1 = this.catalog.acroForm?.get("CO");
        if (!Array.isArray(e1) || 0 === e1.length) return shadow(this, "calculationOrderIds", null);
        const t = [];
        for (const a of e1)a instanceof Ref && t.push(a.toString());
        return shadow(this, "calculationOrderIds", t.length ? t : null);
    }
    get annotationGlobals() {
        return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
    }
}
class BasePdfManager {
    constructor({ docBaseUrl: e1, docId: t, enableXfa: a, evaluatorOptions: r, handler: i, password: n }){
        this._docBaseUrl = function parseDocBaseUrl(e1) {
            if (e1) {
                const t = createValidAbsoluteUrl(e1);
                if (t) return t.href;
                warn(`Invalid absolute docBaseUrl: "${e1}".`);
            }
            return null;
        }(e1);
        this._docId = t;
        this._password = n;
        this.enableXfa = a;
        r.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported;
        r.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported;
        this.evaluatorOptions = Object.freeze(r);
        ImageResizer.setOptions(r);
        JpegStream.setOptions(r);
        OperatorList.setOptions(r);
        const s = {
            ...r,
            handler: i
        };
        JpxImage.setOptions(s);
        IccColorSpace.setOptions(s);
        CmykICCBasedCS.setOptions(s);
    }
    get docId() {
        return this._docId;
    }
    get password() {
        return this._password;
    }
    get docBaseUrl() {
        return this._docBaseUrl;
    }
    ensureDoc(e1, t) {
        return this.ensure(this.pdfDocument, e1, t);
    }
    ensureXRef(e1, t) {
        return this.ensure(this.pdfDocument.xref, e1, t);
    }
    ensureCatalog(e1, t) {
        return this.ensure(this.pdfDocument.catalog, e1, t);
    }
    getPage(e1) {
        return this.pdfDocument.getPage(e1);
    }
    fontFallback(e1, t) {
        return this.pdfDocument.fontFallback(e1, t);
    }
    cleanup(e1 = !1) {
        return this.pdfDocument.cleanup(e1);
    }
    async ensure(e1, t, a) {
        unreachable("Abstract method `ensure` called");
    }
    requestRange(e1, t) {
        unreachable("Abstract method `requestRange` called");
    }
    requestLoadedStream(e1 = !1) {
        unreachable("Abstract method `requestLoadedStream` called");
    }
    sendProgressiveData(e1) {
        unreachable("Abstract method `sendProgressiveData` called");
    }
    updatePassword(e1) {
        this._password = e1;
    }
    terminate(e1) {
        unreachable("Abstract method `terminate` called");
    }
}
class LocalPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1);
        const t = new Stream(e1.source);
        this.pdfDocument = new PDFDocument(this, t);
        this._loadedStreamPromise = Promise.resolve(t);
    }
    async ensure(e1, t, a) {
        const r = e1[t];
        return "function" == typeof r ? r.apply(e1, a) : r;
    }
    requestRange(e1, t) {
        return Promise.resolve();
    }
    requestLoadedStream(e1 = !1) {
        return this._loadedStreamPromise;
    }
    terminate(e1) {}
}
class NetworkPdfManager extends BasePdfManager {
    constructor(e1){
        super(e1);
        this.streamManager = new ChunkedStreamManager(e1.source, {
            msgHandler: e1.handler,
            length: e1.length,
            disableAutoFetch: e1.disableAutoFetch,
            rangeChunkSize: e1.rangeChunkSize
        });
        this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
    }
    async ensure(e1, t, a) {
        try {
            const r = e1[t];
            return "function" == typeof r ? r.apply(e1, a) : r;
        } catch (r) {
            if (!(r instanceof MissingDataException)) throw r;
            await this.requestRange(r.begin, r.end);
            return this.ensure(e1, t, a);
        }
    }
    requestRange(e1, t) {
        return this.streamManager.requestRange(e1, t);
    }
    requestLoadedStream(e1 = !1) {
        return this.streamManager.requestAllChunks(e1);
    }
    sendProgressiveData(e1) {
        this.streamManager.onReceiveData({
            chunk: e1
        });
    }
    terminate(e1) {
        this.streamManager.abort(e1);
    }
}
const nc = 1, sc = 2, oc = 1, cc = 2, lc = 3, hc = 4, uc = 5, dc = 6, fc = 7, gc = 8;
function onFn() {}
function wrapReason(e1) {
    if (e1 instanceof AbortException || e1 instanceof InvalidPDFException || e1 instanceof PasswordException || e1 instanceof ResponseException || e1 instanceof UnknownErrorException) return e1;
    e1 instanceof Error || "object" == typeof e1 && null !== e1 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    switch(e1.name){
        case "AbortException":
            return new AbortException(e1.message);
        case "InvalidPDFException":
            return new InvalidPDFException(e1.message);
        case "PasswordException":
            return new PasswordException(e1.message, e1.code);
        case "ResponseException":
            return new ResponseException(e1.message, e1.status, e1.missing);
        case "UnknownErrorException":
            return new UnknownErrorException(e1.message, e1.details);
    }
    return new UnknownErrorException(e1.message, e1.toString());
}
class MessageHandler {
    #Ye = new AbortController;
    constructor(e1, t, a){
        this.sourceName = e1;
        this.targetName = t;
        this.comObj = a;
        this.callbackId = 1;
        this.streamId = 1;
        this.streamSinks = Object.create(null);
        this.streamControllers = Object.create(null);
        this.callbackCapabilities = Object.create(null);
        this.actionHandler = Object.create(null);
        a.addEventListener("message", this.#Ze.bind(this), {
            signal: this.#Ye.signal
        });
    }
    #Ze({ data: e1 }) {
        if (e1.targetName !== this.sourceName) return;
        if (e1.stream) {
            this.#Qe(e1);
            return;
        }
        if (e1.callback) {
            const t = e1.callbackId, a = this.callbackCapabilities[t];
            if (!a) throw new Error(`Cannot resolve callback ${t}`);
            delete this.callbackCapabilities[t];
            if (e1.callback === nc) a.resolve(e1.data);
            else {
                if (e1.callback !== sc) throw new Error("Unexpected callback case");
                a.reject(wrapReason(e1.reason));
            }
            return;
        }
        const t = this.actionHandler[e1.action];
        if (!t) throw new Error(`Unknown action from worker: ${e1.action}`);
        if (e1.callbackId) {
            const a = this.sourceName, r = e1.sourceName, i = this.comObj;
            Promise.try(t, e1.data).then(function(t) {
                i.postMessage({
                    sourceName: a,
                    targetName: r,
                    callback: nc,
                    callbackId: e1.callbackId,
                    data: t
                });
            }, function(t) {
                i.postMessage({
                    sourceName: a,
                    targetName: r,
                    callback: sc,
                    callbackId: e1.callbackId,
                    reason: wrapReason(t)
                });
            });
        } else e1.streamId ? this.#et(e1) : t(e1.data);
    }
    on(e1, t) {
        const a = this.actionHandler;
        if (a[e1]) throw new Error(`There is already an actionName called "${e1}"`);
        a[e1] = t;
    }
    send(e1, t, a) {
        this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: e1,
            data: t
        }, a);
    }
    sendWithPromise(e1, t, a) {
        const r = this.callbackId++, i = Promise.withResolvers();
        this.callbackCapabilities[r] = i;
        try {
            this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: e1,
                callbackId: r,
                data: t
            }, a);
        } catch (e1) {
            i.reject(e1);
        }
        return i.promise;
    }
    sendWithStream(e1, t, a, r) {
        const i = this.streamId++, n = this.sourceName, s = this.targetName, o = this.comObj;
        return new ReadableStream({
            start: (a)=>{
                const c = Promise.withResolvers();
                this.streamControllers[i] = {
                    controller: a,
                    startCall: c,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                };
                o.postMessage({
                    sourceName: n,
                    targetName: s,
                    action: e1,
                    streamId: i,
                    data: t,
                    desiredSize: a.desiredSize
                }, r);
                return c.promise;
            },
            pull: (e1)=>{
                const t = Promise.withResolvers();
                this.streamControllers[i].pullCall = t;
                o.postMessage({
                    sourceName: n,
                    targetName: s,
                    stream: dc,
                    streamId: i,
                    desiredSize: e1.desiredSize
                });
                return t.promise;
            },
            cancel: (e1)=>{
                assert(e1 instanceof Error, "cancel must have a valid reason");
                const t = Promise.withResolvers();
                this.streamControllers[i].cancelCall = t;
                this.streamControllers[i].isClosed = !0;
                o.postMessage({
                    sourceName: n,
                    targetName: s,
                    stream: oc,
                    streamId: i,
                    reason: wrapReason(e1)
                });
                return t.promise;
            }
        }, a);
    }
    #et(e1) {
        const t = e1.streamId, a = this.sourceName, r = e1.sourceName, i = this.comObj, n = this, s = this.actionHandler[e1.action], o = {
            enqueue (e1, n = 1, s) {
                if (this.isCancelled) return;
                const o = this.desiredSize;
                this.desiredSize -= n;
                if (o > 0 && this.desiredSize <= 0) {
                    this.sinkCapability = Promise.withResolvers();
                    this.ready = this.sinkCapability.promise;
                }
                i.postMessage({
                    sourceName: a,
                    targetName: r,
                    stream: hc,
                    streamId: t,
                    chunk: e1
                }, s);
            },
            close () {
                if (!this.isCancelled) {
                    this.isCancelled = !0;
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: lc,
                        streamId: t
                    });
                    delete n.streamSinks[t];
                }
            },
            error (e1) {
                assert(e1 instanceof Error, "error must have a valid reason");
                if (!this.isCancelled) {
                    this.isCancelled = !0;
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: uc,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                }
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: e1.desiredSize,
            ready: null
        };
        o.sinkCapability.resolve();
        o.ready = o.sinkCapability.promise;
        this.streamSinks[t] = o;
        Promise.try(s, e1.data, o).then(function() {
            i.postMessage({
                sourceName: a,
                targetName: r,
                stream: gc,
                streamId: t,
                success: !0
            });
        }, function(e1) {
            i.postMessage({
                sourceName: a,
                targetName: r,
                stream: gc,
                streamId: t,
                reason: wrapReason(e1)
            });
        });
    }
    #Qe(e1) {
        const t = e1.streamId, a = this.sourceName, r = e1.sourceName, i = this.comObj, n = this.streamControllers[t], s = this.streamSinks[t];
        switch(e1.stream){
            case gc:
                e1.success ? n.startCall.resolve() : n.startCall.reject(wrapReason(e1.reason));
                break;
            case fc:
                e1.success ? n.pullCall.resolve() : n.pullCall.reject(wrapReason(e1.reason));
                break;
            case dc:
                if (!s) {
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: fc,
                        streamId: t,
                        success: !0
                    });
                    break;
                }
                s.desiredSize <= 0 && e1.desiredSize > 0 && s.sinkCapability.resolve();
                s.desiredSize = e1.desiredSize;
                Promise.try(s.onPull || onFn).then(function() {
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: fc,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: fc,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                });
                break;
            case hc:
                assert(n, "enqueue should have stream controller");
                if (n.isClosed) break;
                n.controller.enqueue(e1.chunk);
                break;
            case lc:
                assert(n, "close should have stream controller");
                if (n.isClosed) break;
                n.isClosed = !0;
                n.controller.close();
                this.#tt(n, t);
                break;
            case uc:
                assert(n, "error should have stream controller");
                n.controller.error(wrapReason(e1.reason));
                this.#tt(n, t);
                break;
            case cc:
                e1.success ? n.cancelCall.resolve() : n.cancelCall.reject(wrapReason(e1.reason));
                this.#tt(n, t);
                break;
            case oc:
                if (!s) break;
                const o = wrapReason(e1.reason);
                Promise.try(s.onCancel || onFn, o).then(function() {
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: cc,
                        streamId: t,
                        success: !0
                    });
                }, function(e1) {
                    i.postMessage({
                        sourceName: a,
                        targetName: r,
                        stream: cc,
                        streamId: t,
                        reason: wrapReason(e1)
                    });
                });
                s.sinkCapability.reject(o);
                s.isCancelled = !0;
                delete this.streamSinks[t];
                break;
            default:
                throw new Error("Unexpected stream case");
        }
    }
    async #tt(e1, t) {
        await Promise.allSettled([
            e1.startCall?.promise,
            e1.pullCall?.promise,
            e1.cancelCall?.promise
        ]);
        delete this.streamControllers[t];
    }
    destroy() {
        this.#Ye?.abort();
        this.#Ye = null;
    }
}
async function writeObject(e1, t, a, { encrypt: r = null }) {
    const i = r?.createCipherTransform(e1.num, e1.gen);
    a.push(`${e1.num} ${e1.gen} obj\n`);
    t instanceof Dict ? await writeDict(t, a, i) : t instanceof BaseStream ? await writeStream(t, a, i) : (Array.isArray(t) || ArrayBuffer.isView(t)) && await writeArray(t, a, i);
    a.push("\nendobj\n");
}
async function writeDict(e1, t, a) {
    t.push("<<");
    for (const r of e1.getKeys()){
        t.push(` /${escapePDFName(r)} `);
        await writeValue(e1.getRaw(r), t, a);
    }
    t.push(">>");
}
async function writeStream(e1, t, a) {
    let r = e1.getBytes();
    const { dict: i } = e1, [n, s] = await Promise.all([
        i.getAsync("Filter"),
        i.getAsync("DecodeParms")
    ]), o = isName(Array.isArray(n) ? await i.xref.fetchIfRefAsync(n[0]) : n, "FlateDecode");
    if (r.length >= 256 || o) try {
        const e1 = new CompressionStream("deflate"), t = e1.writable.getWriter();
        await t.ready;
        t.write(r).then(async ()=>{
            await t.ready;
            await t.close();
        }).catch(()=>{});
        const a = await new Response(e1.readable).arrayBuffer();
        r = new Uint8Array(a);
        let c, l;
        if (n) {
            if (!o) {
                c = Array.isArray(n) ? [
                    Name.get("FlateDecode"),
                    ...n
                ] : [
                    Name.get("FlateDecode"),
                    n
                ];
                s && (l = Array.isArray(s) ? [
                    null,
                    ...s
                ] : [
                    null,
                    s
                ]);
            }
        } else c = Name.get("FlateDecode");
        c && i.set("Filter", c);
        l && i.set("DecodeParms", l);
    } catch (e1) {
        info(`writeStream - cannot compress data: "${e1}".`);
    }
    let c = bytesToString(r);
    a && (c = a.encryptString(c));
    i.set("Length", c.length);
    await writeDict(i, t, a);
    t.push(" stream\n", c, "\nendstream");
}
async function writeArray(e1, t, a) {
    t.push("[");
    let r = !0;
    for (const i of e1){
        r ? r = !1 : t.push(" ");
        await writeValue(i, t, a);
    }
    t.push("]");
}
async function writeValue(e1, t, a) {
    if (e1 instanceof Name) t.push(`/${escapePDFName(e1.name)}`);
    else if (e1 instanceof Ref) t.push(`${e1.num} ${e1.gen} R`);
    else if (Array.isArray(e1) || ArrayBuffer.isView(e1)) await writeArray(e1, t, a);
    else if ("string" == typeof e1) {
        a && (e1 = a.encryptString(e1));
        t.push(`(${escapeString(e1)})`);
    } else "number" == typeof e1 ? t.push(numberToString(e1)) : "boolean" == typeof e1 ? t.push(e1.toString()) : e1 instanceof Dict ? await writeDict(e1, t, a) : e1 instanceof BaseStream ? await writeStream(e1, t, a) : null === e1 ? t.push("null") : warn(`Unhandled value in writer: ${typeof e1}, please file a bug.`);
}
function writeInt(e1, t, a, r) {
    for(let i = t + a - 1; i > a - 1; i--){
        r[i] = 255 & e1;
        e1 >>= 8;
    }
    return a + t;
}
function writeString(e1, t, a) {
    const r = e1.length;
    for(let i = 0; i < r; i++)a[t + i] = 255 & e1.charCodeAt(i);
    return t + r;
}
function updateXFA({ xfaData: e1, xfaDatasetsRef: t, changes: a, xref: r }) {
    if (null === e1) {
        e1 = function writeXFADataForAcroform(e1, t) {
            const a = new SimpleXMLParser({
                hasAttributes: !0
            }).parseFromString(e1);
            for (const { xfa: e1 } of t){
                if (!e1) continue;
                const { path: t, value: r } = e1;
                if (!t) continue;
                const i = parseXFAPath(t);
                let n = a.documentElement.searchNode(i, 0);
                !n && i.length > 1 && (n = a.documentElement.searchNode([
                    i.at(-1)
                ], 0));
                n ? n.childNodes = Array.isArray(r) ? r.map((e1)=>new SimpleDOMNode("value", e1)) : [
                    new SimpleDOMNode("#text", r)
                ] : warn(`Node not found for path: ${t}`);
            }
            const r = [];
            a.documentElement.dump(r);
            return r.join("");
        }(r.fetchIfRef(t).getString(), a);
    }
    const i = new StringStream(e1);
    i.dict = new Dict(r);
    i.dict.setIfName("Type", "EmbeddedFile");
    a.put(t, {
        data: i
    });
}
function getIndexes(e1) {
    const t = [];
    for (const { ref: a } of e1)a.num === t.at(-2) + t.at(-1) ? t[t.length - 1] += 1 : t.push(a.num, 1);
    return t;
}
function computeIDs(e1, t, a) {
    if (Array.isArray(t.fileIds) && t.fileIds.length > 0) {
        const r = function computeMD5(e1, t) {
            const a = Math.floor(Date.now() / 1e3), r = t.filename || "", i = [
                a.toString(),
                r,
                e1.toString(),
                ...t.infoMap.values()
            ], n = Math.sumPrecise(i.map((e1)=>e1.length)), s = new Uint8Array(n);
            let o = 0;
            for (const e1 of i)o = writeString(e1, o, s);
            return bytesToString(calculateMD5(s, 0, s.length));
        }(e1, t);
        a.set("ID", [
            t.fileIds[0],
            r
        ]);
    }
}
async function incrementalUpdate({ originalData: e1, xrefInfo: t, changes: a, xref: r = null, hasXfa: i = !1, xfaDatasetsRef: n = null, hasXfaDatasetsEntry: s = !1, needAppearances: o, acroFormRef: c = null, acroForm: l = null, xfaData: h = null, useXrefStream: u = !1 }) {
    await async function updateAcroform({ xref: e1, acroForm: t, acroFormRef: a, hasXfa: r, hasXfaDatasetsEntry: i, xfaDatasetsRef: n, needAppearances: s, changes: o }) {
        !r || i || n || warn("XFA - Cannot save it");
        if (!s && (!r || !n || i)) return;
        const c = t.clone();
        if (r && !i) {
            const e1 = t.get("XFA").slice();
            e1.splice(2, 0, "datasets");
            e1.splice(3, 0, n);
            c.set("XFA", e1);
        }
        s && c.set("NeedAppearances", !0);
        o.put(a, {
            data: c
        });
    }({
        xref: r,
        acroForm: l,
        acroFormRef: c,
        hasXfa: i,
        hasXfaDatasetsEntry: s,
        xfaDatasetsRef: n,
        needAppearances: o,
        changes: a
    });
    i && updateXFA({
        xfaData: h,
        xfaDatasetsRef: n,
        changes: a,
        xref: r
    });
    const d = function getTrailerDict(e1, t, a) {
        const r = new Dict(null);
        r.set("Prev", e1.startXRef);
        const i = e1.newRef;
        if (a) {
            t.put(i, {
                data: ""
            });
            r.set("Size", i.num + 1);
            r.setIfName("Type", "XRef");
        } else r.set("Size", i.num);
        null !== e1.rootRef && r.set("Root", e1.rootRef);
        null !== e1.infoRef && r.set("Info", e1.infoRef);
        null !== e1.encryptRef && r.set("Encrypt", e1.encryptRef);
        return r;
    }(t, a, u), f = [], g = await async function writeChanges(e1, t, a = []) {
        const r = [];
        for (const [i, { data: n }] of e1.items())if (null !== n && "string" != typeof n) {
            await writeObject(i, n, a, t);
            r.push({
                ref: i,
                data: a.join("")
            });
            a.length = 0;
        } else r.push({
            ref: i,
            data: n
        });
        return r.sort((e1, t)=>e1.ref.num - t.ref.num);
    }(a, r, f);
    let p = e1.length;
    const m = e1.at(-1);
    if (10 !== m && 13 !== m) {
        f.push("\n");
        p += 1;
    }
    for (const { data: e1 } of g)null !== e1 && f.push(e1);
    await (u ? async function getXRefStreamTable(e1, t, a, r, i) {
        const n = [];
        let s = 0, o = 0;
        for (const { ref: e1, data: r } of a){
            let a;
            s = Math.max(s, t);
            if (null !== r) {
                a = Math.min(e1.gen, 65535);
                n.push([
                    1,
                    t,
                    a
                ]);
                t += r.length;
            } else {
                a = Math.min(e1.gen + 1, 65535);
                n.push([
                    0,
                    0,
                    a
                ]);
            }
            o = Math.max(o, a);
        }
        r.set("Index", getIndexes(a));
        const c = [
            1,
            getSizeInBytes(s),
            getSizeInBytes(o)
        ];
        r.set("W", c);
        computeIDs(t, e1, r);
        const l = Math.sumPrecise(c), h = new Uint8Array(l * n.length), u = new Stream(h);
        u.dict = r;
        let d = 0;
        for (const [e1, t, a] of n){
            d = writeInt(e1, c[0], d, h);
            d = writeInt(t, c[1], d, h);
            d = writeInt(a, c[2], d, h);
        }
        await writeObject(e1.newRef, u, i, {});
        i.push("startxref\n", t.toString(), "\n%%EOF\n");
    }(t, p, g, d, f) : async function getXRefTable(e1, t, a, r, i) {
        i.push("xref\n");
        const n = getIndexes(a);
        let s = 0;
        for (const { ref: e1, data: r } of a){
            if (e1.num === n[s]) {
                i.push(`${n[s]} ${n[s + 1]}\n`);
                s += 2;
            }
            if (null !== r) {
                i.push(`${t.toString().padStart(10, "0")} ${Math.min(e1.gen, 65535).toString().padStart(5, "0")} n\r\n`);
                t += r.length;
            } else i.push(`0000000000 ${Math.min(e1.gen + 1, 65535).toString().padStart(5, "0")} f\r\n`);
        }
        computeIDs(t, e1, r);
        i.push("trailer\n");
        await writeDict(r, i);
        i.push("\nstartxref\n", t.toString(), "\n%%EOF\n");
    }(t, p, g, d, f));
    const b = e1.length + Math.sumPrecise(f.map((e1)=>e1.length)), y = new Uint8Array(b);
    y.set(e1);
    let w = e1.length;
    for (const e1 of f)w = writeString(e1, w, y);
    return y;
}
class PDFWorkerStream {
    constructor(e1){
        this._msgHandler = e1;
        this._contentLength = null;
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
    }
    getFullReader() {
        assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
        return this._fullRequestReader;
    }
    getRangeReader(e1, t) {
        const a = new PDFWorkerStreamRangeReader(e1, t, this._msgHandler);
        this._rangeRequestReaders.push(a);
        return a;
    }
    cancelAllRequests(e1) {
        this._fullRequestReader?.cancel(e1);
        for (const t of this._rangeRequestReaders.slice(0))t.cancel(e1);
    }
}
class PDFWorkerStreamReader {
    constructor(e1){
        this._msgHandler = e1;
        this.onProgress = null;
        this._contentLength = null;
        this._isRangeSupported = !1;
        this._isStreamingSupported = !1;
        const t = this._msgHandler.sendWithStream("GetReader");
        this._reader = t.getReader();
        this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e1)=>{
            this._isStreamingSupported = e1.isStreamingSupported;
            this._isRangeSupported = e1.isRangeSupported;
            this._contentLength = e1.contentLength;
        });
    }
    get headersReady() {
        return this._headersReady;
    }
    get contentLength() {
        return this._contentLength;
    }
    get isStreamingSupported() {
        return this._isStreamingSupported;
    }
    get isRangeSupported() {
        return this._isRangeSupported;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class PDFWorkerStreamRangeReader {
    constructor(e1, t, a){
        this._msgHandler = a;
        this.onProgress = null;
        const r = this._msgHandler.sendWithStream("GetRangeReader", {
            begin: e1,
            end: t
        });
        this._reader = r.getReader();
    }
    get isStreamingSupported() {
        return !1;
    }
    async read() {
        const { value: e1, done: t } = await this._reader.read();
        return t ? {
            value: void 0,
            done: !0
        } : {
            value: e1.buffer,
            done: !1
        };
    }
    cancel(e1) {
        this._reader.cancel(e1);
    }
}
class WorkerTask {
    constructor(e1){
        this.name = e1;
        this.terminated = !1;
        this._capability = Promise.withResolvers();
    }
    get finished() {
        return this._capability.promise;
    }
    finish() {
        this._capability.resolve();
    }
    terminate() {
        this.terminated = !0;
    }
    ensureNotTerminated() {
        if (this.terminated) throw new Error("Worker task was terminated");
    }
}
class WorkerMessageHandler {
    static{
        "undefined" == "undefined" && !e1 && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && this.initializeFromPort(self);
    }
    static setup(e1, t) {
        let a = !1;
        e1.on("test", (t)=>{
            if (!a) {
                a = !0;
                e1.send("test", t instanceof Uint8Array);
            }
        });
        e1.on("configure", (e1)=>{
            !function setVerbosityLevel(e1) {
                Number.isInteger(e1) && (Kt = e1);
            }(e1.verbosity);
        });
        e1.on("GetDocRequest", (e1)=>this.createDocumentHandler(e1, t));
    }
    static createDocumentHandler(e1, t) {
        let a, r = !1, i = null;
        const n = new Set, s = getVerbosityLevel(), { docId: o, apiVersion: c } = e1, l = "5.4.149";
        if (c !== l) throw new Error(`The API version "${c}" does not match the Worker version "${l}".`);
        const buildMsg = (e1, t)=>`The \`${e1}.prototype\` contains unexpected enumerable property "${t}", thus breaking e.g. \`for...in\` iteration of ${e1}s.`;
        for(const e1 in {})throw new Error(buildMsg("Object", e1));
        for(const e1 in [])throw new Error(buildMsg("Array", e1));
        const h = o + "_worker";
        let u = new MessageHandler(h, o, t);
        function ensureNotTerminated() {
            if (r) throw new Error("Worker was terminated");
        }
        function startWorkerTask(e1) {
            n.add(e1);
        }
        function finishWorkerTask(e1) {
            e1.finish();
            n.delete(e1);
        }
        async function loadDocument(e1) {
            await a.ensureDoc("checkHeader");
            await a.ensureDoc("parseStartXRef");
            await a.ensureDoc("parse", [
                e1
            ]);
            await a.ensureDoc("checkFirstPage", [
                e1
            ]);
            await a.ensureDoc("checkLastPage", [
                e1
            ]);
            const t = await a.ensureDoc("isPureXfa");
            if (t) {
                const e1 = new WorkerTask("loadXfaResources");
                startWorkerTask(e1);
                await a.ensureDoc("loadXfaResources", [
                    u,
                    e1
                ]);
                finishWorkerTask(e1);
            }
            const [r, i] = await Promise.all([
                a.ensureDoc("numPages"),
                a.ensureDoc("fingerprints")
            ]);
            return {
                numPages: r,
                fingerprints: i,
                htmlForXfa: t ? await a.ensureDoc("htmlForXfa") : null
            };
        }
        function setupDoc(e1) {
            function onSuccess(e1) {
                ensureNotTerminated();
                u.send("GetDoc", {
                    pdfInfo: e1
                });
            }
            function onFailure(e1) {
                ensureNotTerminated();
                if (e1 instanceof PasswordException) {
                    const t = new WorkerTask(`PasswordException: response ${e1.code}`);
                    startWorkerTask(t);
                    u.sendWithPromise("PasswordRequest", e1).then(function({ password: e1 }) {
                        finishWorkerTask(t);
                        a.updatePassword(e1);
                        pdfManagerReady();
                    }).catch(function() {
                        finishWorkerTask(t);
                        u.send("DocException", e1);
                    });
                } else u.send("DocException", wrapReason(e1));
            }
            function pdfManagerReady() {
                ensureNotTerminated();
                loadDocument(!1).then(onSuccess, function(e1) {
                    ensureNotTerminated();
                    e1 instanceof XRefParseException ? a.requestLoadedStream().then(function() {
                        ensureNotTerminated();
                        loadDocument(!0).then(onSuccess, onFailure);
                    }) : onFailure(e1);
                });
            }
            ensureNotTerminated();
            (async function getPdfManager({ data: e1, password: t, disableAutoFetch: a, rangeChunkSize: r, length: n, docBaseUrl: s, enableXfa: c, evaluatorOptions: l }) {
                const h = {
                    source: null,
                    disableAutoFetch: a,
                    docBaseUrl: s,
                    docId: o,
                    enableXfa: c,
                    evaluatorOptions: l,
                    handler: u,
                    length: n,
                    password: t,
                    rangeChunkSize: r
                };
                if (e1) {
                    h.source = e1;
                    return new LocalPdfManager(h);
                }
                const d = new PDFWorkerStream(u), f = d.getFullReader(), g = Promise.withResolvers();
                let p, m = [], b = 0;
                f.headersReady.then(function() {
                    if (f.isRangeSupported) {
                        h.source = d;
                        h.length = f.contentLength;
                        h.disableAutoFetch ||= f.isStreamingSupported;
                        p = new NetworkPdfManager(h);
                        for (const e1 of m)p.sendProgressiveData(e1);
                        m = [];
                        g.resolve(p);
                        i = null;
                    }
                }).catch(function(e1) {
                    g.reject(e1);
                    i = null;
                });
                new Promise(function(e1, t) {
                    const readChunk = function({ value: e1, done: a }) {
                        try {
                            ensureNotTerminated();
                            if (a) {
                                if (!p) {
                                    const e1 = arrayBuffersToBytes(m);
                                    m = [];
                                    n && e1.length !== n && warn("reported HTTP length is different from actual");
                                    h.source = e1;
                                    p = new LocalPdfManager(h);
                                    g.resolve(p);
                                }
                                i = null;
                                return;
                            }
                            b += e1.byteLength;
                            f.isStreamingSupported || u.send("DocProgress", {
                                loaded: b,
                                total: Math.max(b, f.contentLength || 0)
                            });
                            p ? p.sendProgressiveData(e1) : m.push(e1);
                            f.read().then(readChunk, t);
                        } catch (e1) {
                            t(e1);
                        }
                    };
                    f.read().then(readChunk, t);
                }).catch(function(e1) {
                    g.reject(e1);
                    i = null;
                });
                i = (e1)=>{
                    d.cancelAllRequests(e1);
                };
                return g.promise;
            })(e1).then(function(e1) {
                if (r) {
                    e1.terminate(new AbortException("Worker was terminated."));
                    throw new Error("Worker was terminated");
                }
                a = e1;
                a.requestLoadedStream(!0).then((e1)=>{
                    u.send("DataLoaded", {
                        length: e1.bytes.byteLength
                    });
                });
            }).then(pdfManagerReady, onFailure);
        }
        u.on("GetPage", function(e1) {
            return a.getPage(e1.pageIndex).then(function(e1) {
                return Promise.all([
                    a.ensure(e1, "rotate"),
                    a.ensure(e1, "ref"),
                    a.ensure(e1, "userUnit"),
                    a.ensure(e1, "view")
                ]).then(function([e1, t, a, r]) {
                    return {
                        rotate: e1,
                        ref: t,
                        refStr: t?.toString() ?? null,
                        userUnit: a,
                        view: r
                    };
                });
            });
        });
        u.on("GetPageIndex", function(e1) {
            const t = Ref.get(e1.num, e1.gen);
            return a.ensureCatalog("getPageIndex", [
                t
            ]);
        });
        u.on("GetDestinations", function(e1) {
            return a.ensureCatalog("destinations");
        });
        u.on("GetDestination", function(e1) {
            return a.ensureCatalog("getDestination", [
                e1.id
            ]);
        });
        u.on("GetPageLabels", function(e1) {
            return a.ensureCatalog("pageLabels");
        });
        u.on("GetPageLayout", function(e1) {
            return a.ensureCatalog("pageLayout");
        });
        u.on("GetPageMode", function(e1) {
            return a.ensureCatalog("pageMode");
        });
        u.on("GetViewerPreferences", function(e1) {
            return a.ensureCatalog("viewerPreferences");
        });
        u.on("GetOpenAction", function(e1) {
            return a.ensureCatalog("openAction");
        });
        u.on("GetAttachments", function(e1) {
            return a.ensureCatalog("attachments");
        });
        u.on("GetDocJSActions", function(e1) {
            return a.ensureCatalog("jsActions");
        });
        u.on("GetPageJSActions", function({ pageIndex: e1 }) {
            return a.getPage(e1).then((e1)=>a.ensure(e1, "jsActions"));
        });
        u.on("GetAnnotationsByType", async function({ types: e1, pageIndexesToSkip: t }) {
            const [r, i] = await Promise.all([
                a.ensureDoc("numPages"),
                a.ensureDoc("annotationGlobals")
            ]);
            if (!i) return null;
            const n = [], s = [];
            let o = null;
            try {
                for(let c = 0, l = r; c < l; c++)if (!t?.has(c)) {
                    if (!o) {
                        o = new WorkerTask("GetAnnotationsByType");
                        startWorkerTask(o);
                    }
                    n.push(a.getPage(c).then(async (t)=>t && t.collectAnnotationsByType(u, o, e1, s, i) || []));
                }
                await Promise.all(n);
                return (await Promise.all(s)).filter((e1)=>!!e1);
            } finally{
                o && finishWorkerTask(o);
            }
        });
        u.on("GetOutline", function(e1) {
            return a.ensureCatalog("documentOutline");
        });
        u.on("GetOptionalContentConfig", function(e1) {
            return a.ensureCatalog("optionalContentConfig");
        });
        u.on("GetPermissions", function(e1) {
            return a.ensureCatalog("permissions");
        });
        u.on("GetMetadata", function(e1) {
            return Promise.all([
                a.ensureDoc("documentInfo"),
                a.ensureCatalog("metadata")
            ]);
        });
        u.on("GetMarkInfo", function(e1) {
            return a.ensureCatalog("markInfo");
        });
        u.on("GetData", function(e1) {
            return a.requestLoadedStream().then((e1)=>e1.bytes);
        });
        u.on("GetAnnotations", function({ pageIndex: e1, intent: t }) {
            return a.getPage(e1).then(function(a) {
                const r = new WorkerTask(`GetAnnotations: page ${e1}`);
                startWorkerTask(r);
                return a.getAnnotationsData(u, r, t).then((e1)=>{
                    finishWorkerTask(r);
                    return e1;
                }, (e1)=>{
                    finishWorkerTask(r);
                    throw e1;
                });
            });
        });
        u.on("GetFieldObjects", function(e1) {
            return a.ensureDoc("fieldObjects").then((e1)=>e1?.allFields || null);
        });
        u.on("HasJSActions", function(e1) {
            return a.ensureDoc("hasJSActions");
        });
        u.on("GetCalculationOrderIds", function(e1) {
            return a.ensureDoc("calculationOrderIds");
        });
        u.on("SaveDocument", async function({ isPureXfa: e1, numPages: t, annotationStorage: r, filename: i }) {
            const n = [
                a.requestLoadedStream(),
                a.ensureCatalog("acroForm"),
                a.ensureCatalog("acroFormRef"),
                a.ensureDoc("startXRef"),
                a.ensureDoc("xref"),
                a.ensureDoc("linearization"),
                a.ensureCatalog("structTreeRoot")
            ], s = new RefSetCache, o = [], c = e1 ? null : getNewAnnotationsMap(r), [l, h, d, f, g, p, m] = await Promise.all(n), b = g.trailer.getRaw("Root") || null;
            let y;
            if (c) {
                m ? await m.canUpdateStructTree({
                    pdfManager: a,
                    newAnnotationsByPage: c
                }) && (y = m) : await StructTreeRoot.canCreateStructureTree({
                    catalogRef: b,
                    pdfManager: a,
                    newAnnotationsByPage: c
                }) && (y = null);
                const e1 = AnnotationFactory.generateImages(r.values(), g, a.evaluatorOptions.isOffscreenCanvasSupported), t = void 0 === y ? o : [];
                for (const [r, i] of c)t.push(a.getPage(r).then((t)=>{
                    const a = new WorkerTask(`Save (editor): page ${r}`);
                    startWorkerTask(a);
                    return t.saveNewAnnotations(u, a, i, e1, s).finally(function() {
                        finishWorkerTask(a);
                    });
                }));
                null === y ? o.push(Promise.all(t).then(async ()=>{
                    await StructTreeRoot.createStructureTree({
                        newAnnotationsByPage: c,
                        xref: g,
                        catalogRef: b,
                        pdfManager: a,
                        changes: s
                    });
                })) : y && o.push(Promise.all(t).then(async ()=>{
                    await y.updateStructureTree({
                        newAnnotationsByPage: c,
                        pdfManager: a,
                        changes: s
                    });
                }));
            }
            if (e1) o.push(a.ensureDoc("serializeXfaData", [
                r
            ]));
            else for(let e1 = 0; e1 < t; e1++)o.push(a.getPage(e1).then(function(t) {
                const a = new WorkerTask(`Save: page ${e1}`);
                startWorkerTask(a);
                return t.save(u, a, r, s).finally(function() {
                    finishWorkerTask(a);
                });
            }));
            const w = await Promise.all(o);
            let x = null;
            if (e1) {
                x = w[0];
                if (!x) return l.bytes;
            } else if (0 === s.size) return l.bytes;
            const S = d && h instanceof Dict && s.values().some((e1)=>e1.needAppearances), k = h instanceof Dict && h.get("XFA") || null;
            let C = null, v = !1;
            if (Array.isArray(k)) {
                for(let e1 = 0, t = k.length; e1 < t; e1 += 2)if ("datasets" === k[e1]) {
                    C = k[e1 + 1];
                    v = !0;
                }
                null === C && (C = g.getNewTemporaryRef());
            } else k && warn("Unsupported XFA type.");
            let F = Object.create(null);
            if (g.trailer) {
                const e1 = new Map, t = g.trailer.get("Info") || null;
                if (t instanceof Dict) for (const [a, r] of t)"string" == typeof r && e1.set(a, stringToPDFString(r));
                F = {
                    rootRef: b,
                    encryptRef: g.trailer.getRaw("Encrypt") || null,
                    newRef: g.getNewTemporaryRef(),
                    infoRef: g.trailer.getRaw("Info") || null,
                    infoMap: e1,
                    fileIds: g.trailer.get("ID") || null,
                    startXRef: p ? f : g.lastXRefStreamPos ?? f,
                    filename: i
                };
            }
            return incrementalUpdate({
                originalData: l.bytes,
                xrefInfo: F,
                changes: s,
                xref: g,
                hasXfa: !!k,
                xfaDatasetsRef: C,
                hasXfaDatasetsEntry: v,
                needAppearances: S,
                acroFormRef: d,
                acroForm: h,
                xfaData: x,
                useXrefStream: isDict(g.topDict, "XRef")
            }).finally(()=>{
                g.resetNewTemporaryRef();
            });
        });
        u.on("GetOperatorList", function(e1, t) {
            const r = e1.pageIndex;
            a.getPage(r).then(function(a) {
                const i = new WorkerTask(`GetOperatorList: page ${r}`);
                startWorkerTask(i);
                const n = s >= ne ? Date.now() : 0;
                a.getOperatorList({
                    handler: u,
                    sink: t,
                    task: i,
                    intent: e1.intent,
                    cacheKey: e1.cacheKey,
                    annotationStorage: e1.annotationStorage,
                    modifiedIds: e1.modifiedIds
                }).then(function(e1) {
                    finishWorkerTask(i);
                    n && info(`page=${r + 1} - getOperatorList: time=${Date.now() - n}ms, len=${e1.length}`);
                    t.close();
                }, function(e1) {
                    finishWorkerTask(i);
                    i.terminated || t.error(e1);
                });
            });
        });
        u.on("GetTextContent", function(e1, t) {
            const { pageIndex: r, includeMarkedContent: i, disableNormalization: n } = e1;
            a.getPage(r).then(function(e1) {
                const a = new WorkerTask("GetTextContent: page " + r);
                startWorkerTask(a);
                const o = s >= ne ? Date.now() : 0;
                e1.extractTextContent({
                    handler: u,
                    task: a,
                    sink: t,
                    includeMarkedContent: i,
                    disableNormalization: n
                }).then(function() {
                    finishWorkerTask(a);
                    o && info(`page=${r + 1} - getTextContent: time=` + (Date.now() - o) + "ms");
                    t.close();
                }, function(e1) {
                    finishWorkerTask(a);
                    a.terminated || t.error(e1);
                });
            });
        });
        u.on("GetStructTree", function(e1) {
            return a.getPage(e1.pageIndex).then((e1)=>a.ensure(e1, "getStructTree"));
        });
        u.on("FontFallback", function(e1) {
            return a.fontFallback(e1.id, u);
        });
        u.on("Cleanup", function(e1) {
            return a.cleanup(!0);
        });
        u.on("Terminate", function(e1) {
            r = !0;
            const t = [];
            if (a) {
                a.terminate(new AbortException("Worker was terminated."));
                const e1 = a.cleanup();
                t.push(e1);
                a = null;
            } else clearGlobalCaches();
            i?.(new AbortException("Worker was terminated."));
            for (const e1 of n){
                t.push(e1.finished);
                e1.terminate();
            }
            return Promise.all(t).then(function() {
                u.destroy();
                u = null;
            });
        });
        u.on("Ready", function(t) {
            setupDoc(e1);
            e1 = null;
        });
        return h;
    }
    static initializeFromPort(e1) {
        const t = new MessageHandler("worker", "main", e1);
        this.setup(t, e1);
        t.send("ready", null);
    }
}
globalThis.pdfjsWorker = {
    WorkerMessageHandler
};
;
}),
];

//# sourceMappingURL=node_modules_pdfjs-dist_build_pdf_worker_min_mjs_5810138d._.js.map